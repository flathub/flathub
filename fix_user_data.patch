diff --git a/Common.mak b/Common.mak
index 4212d2aad..cb554f9ac 100644
--- a/Common.mak
+++ b/Common.mak
@@ -536,7 +536,7 @@ else ifeq ($(SUBPLATFORM),LINUX)
 endif
 ASFLAGS += -f $(ASFORMAT)
 
-COMPILERFLAGS += -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0
+COMPILERFLAGS += -D_FORTIFY_SOURCE=2
 
 
 ##### Optimizations
diff --git a/GNUmakefile b/GNUmakefile
index 577b795f9..20652137a 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -664,6 +664,7 @@ endif
 #### Includes
 
 COMPILERFLAGS += \
+    -std=c++20 \
     -I$(engine_inc) \
     -I$(mact_inc) \
     -I$(audiolib_inc) \
diff --git a/source/build/include/smmalloc.h b/source/build/include/smmalloc.h
index 4fa90d268..802967edf 100644
--- a/source/build/include/smmalloc.h
+++ b/source/build/include/smmalloc.h
@@ -685,7 +685,9 @@ struct TlsPoolBucket
     }
 };
 
-static_assert(std::is_pod<TlsPoolBucket>::value == true, "TlsPoolBucket must be POD type, stored in TLS");
+// Remove excessive warning spam on builds so actual errors don't get buried
+static_assert(std::is_standard_layout<TlsPoolBucket>::value == true, "TlsPoolBucket must be POD type, stored in TLS");
+static_assert(std::is_trivial<TlsPoolBucket>::value == true, "TlsPoolBucket must be POD type, stored in TLS");
 static_assert(sizeof(TlsPoolBucket) <= 64, "TlsPoolBucket sizeof must be less than CPU cache line");
 } // namespace internal
 
diff --git a/source/build/include/texcache.h b/source/build/include/texcache.h
index a548cd18b..4ae5a3ab1 100644
--- a/source/build/include/texcache.h
+++ b/source/build/include/texcache.h
@@ -57,7 +57,7 @@ typedef struct {
 
 extern globaltexcache texcache;
 
-extern char TEXCACHEFILE[BMAX_PATH];
+extern std::string TEXCACHEFILE;
 
 extern int32_t texcache_enabled(void);
 extern void texcache_freeptrs(void);
diff --git a/source/build/include/vfs.h b/source/build/include/vfs.h
index 4862820b9..b2082edcb 100644
--- a/source/build/include/vfs.h
+++ b/source/build/include/vfs.h
@@ -320,4 +320,11 @@ void dfwrite_LZ4(const void *buffer, int dasizeof, int count, buildvfs_FILE fil)
 }
 #endif
 
+#include <filesystem>
+extern std::filesystem::path redirect_to_user_data(std::string path);
+extern void create_parent_directory(std::string path);
+extern std::string get_writable_filename_subdir(std::string filename, std::string subdir);
+extern std::string get_writable_filename(std::string filename);
+extern std::string get_numbered_writable_filename(std::string filename, std::string extension);
+
 #endif // vfs_h_
diff --git a/source/build/src/build.cpp b/source/build/src/build.cpp
index 253bcac3c..a6e873c32 100644
--- a/source/build/src/build.cpp
+++ b/source/build/src/build.cpp
@@ -625,10 +625,9 @@ void editorMaybeLockMouse(int lock)
 
 int app_main(int argc, char const* const* argv)
 {
-    Bstrcpy(tempbuf, AppTechnicalName);
-    Bstrcat(tempbuf, ".log");
-
-    engineSetLogFile(tempbuf);
+    std::string logfile = get_writable_filename("amcsquad.log");
+    printf("Logging to %s\n", logfile.c_str());
+    engineSetLogFile(logfile.c_str());
 
 #ifdef STARTUP_SETUP_WINDOW
     char cmdsetup = 0;
diff --git a/source/build/src/config.cpp b/source/build/src/config.cpp
index bbcb42a33..a81e776b3 100644
--- a/source/build/src/config.cpp
+++ b/source/build/src/config.cpp
@@ -113,7 +113,7 @@ int32_t loadsetup(const char *fn)
 
     editorgridextent = 131072;
 
-    if ((fp = buildvfs_fopen_read(fn)) == NULL) return -1;
+    if ((fp = buildvfs_fopen_read(get_writable_filename(fn).c_str())) == NULL) return -1;
 
     if (readconfig(fp, "usecwd", val, VL) > 0) g_useCwd = (atoi_safe(val) != 0);
     if (readconfig(fp, "forcesetup", val, VL) > 0) forcesetup = (atoi_safe(val) != 0);
@@ -323,7 +323,7 @@ void writesettings(void) // save binds and aliases to <cfgname>_m32_settings.cfg
         Bsprintf(tempbuf, "m32_settings.cfg");
     else Bsprintf(tempbuf, "%s_m32_settings.cfg", strtok(ptr, "."));
 
-    fp = buildvfs_fopen_write(tempbuf);
+    fp = buildvfs_fopen_write(get_writable_filename(tempbuf).c_str());
 
     if (fp)
     {
@@ -354,7 +354,7 @@ int32_t writesetup(const char *fn)
     buildvfs_FILE fp;
     int32_t i,j,first=1;
 
-    fp = buildvfs_fopen_write(fn);
+    fp = buildvfs_fopen_write(get_writable_filename(fn).c_str());
     if (!fp) return -1;
 
     Bfprintf(fp,
diff --git a/source/build/src/engine.cpp b/source/build/src/engine.cpp
index 18a0aa67a..6769b5b2c 100644
--- a/source/build/src/engine.cpp
+++ b/source/build/src/engine.cpp
@@ -13400,7 +13400,8 @@ int32_t krd_print(const char *filename)
     if (!krd_enabled) return 1;
     krd_enabled = 0;
 
-    fp = buildvfs_fopen_write(filename);
+    LOG_F(INFO, "engine::krd_print: %s\n", filename)
+    fp = buildvfs_fopen_write(get_writable_filename(filename).c_str());
     if (!fp) { OSD_Printf("krd_print (2): fopen"); return 1; }
 
     for (i=0; i<krd_numcalls; i++)
diff --git a/source/build/src/screenshot.cpp b/source/build/src/screenshot.cpp
index 9003e94db..d3adf693c 100644
--- a/source/build/src/screenshot.cpp
+++ b/source/build/src/screenshot.cpp
@@ -97,8 +97,8 @@ static char* getScreenshotPath(const char* filename)
 
 int videoCaptureScreen(const char *filename, char inverseit)
 {
-    char* fn = getScreenshotPath(filename);
-    buildvfs_FILE fp = capturecounter.opennextfile_withext(fn, "png");
+    char* fn = const_cast<char*>(get_numbered_writable_filename(get_writable_filename_subdir(filename, "screenshots"), "png").c_str());
+    buildvfs_FILE fp = buildvfs_fopen_write(fn);
 
     if (fp == nullptr)
     {
@@ -177,9 +177,9 @@ int videoCaptureScreenTGA(const char *filename, char inverseit)
     int32_t i;
     char head[18] = { 0,1,1,0,0,0,1,24,0,0,0,0,0/*wlo*/,0/*whi*/,0/*hlo*/,0/*hhi*/,8,0 };
     //char palette[4*256];
-    char* fn = getScreenshotPath(filename);
+    char* fn = const_cast<char*>(get_numbered_writable_filename(get_writable_filename_subdir(filename, "screenshots"), "tga").c_str());
 
-    buildvfs_FILE fil = capturecounter.opennextfile_withext(fn, "tga");
+    buildvfs_FILE fil = buildvfs_fopen_write(fn);
     if (fil == nullptr)
     {
         Xfree(fn);
diff --git a/source/build/src/texcache.cpp b/source/build/src/texcache.cpp
index e4aad2f0f..0b0026a1c 100644
--- a/source/build/src/texcache.cpp
+++ b/source/build/src/texcache.cpp
@@ -35,7 +35,8 @@
 
 globaltexcache texcache;
 
-char TEXCACHEFILE[BMAX_PATH] = "texturecache";
+std::string TEXCACHEFILE(get_writable_filename("texturecache").c_str());
+std::string TEXCACHE_INDEX(get_writable_filename("texturecache.index").c_str());
 
 static const char *texcache_errors[TEXCACHEERRORS] = {
     "no error",
@@ -306,10 +307,8 @@ static void texcache_deletefiles(void)
 {
     Bassert(!texcache.indexFilePtr && !texcache.dataFilePtr);
 
-    unlink(TEXCACHEFILE);
-    Bstrcpy(ptempbuf, TEXCACHEFILE);
-    Bstrcat(ptempbuf, ".index");
-    unlink(ptempbuf);
+    unlink(TEXCACHEFILE.c_str());
+    unlink(TEXCACHE_INDEX.c_str());
 }
 
 int32_t texcache_enabled(void)
@@ -334,17 +333,14 @@ void texcache_openfiles(void)
 {
     Bassert(!texcache.indexFilePtr && !texcache.dataFilePtr);
 
-    Bstrcpy(ptempbuf, TEXCACHEFILE);
-    Bstrcat(ptempbuf, ".index");
+    bool const texcache_exists = buildvfs_exists(TEXCACHE_INDEX.c_str());
 
-    bool const texcache_exists = buildvfs_exists(ptempbuf);
-
-    texcache.indexFilePtr = buildvfs_fopen_append(ptempbuf);
-    texcache.dataFilePtr  = buildvfs_fopen_append(TEXCACHEFILE);
+    texcache.indexFilePtr = buildvfs_fopen_append(TEXCACHE_INDEX.c_str());
+    texcache.dataFilePtr  = buildvfs_fopen_append(TEXCACHEFILE.c_str());
 
     if (!texcache.indexFilePtr || !texcache.dataFilePtr)
     {
-        LOG_F(ERROR, "Unable to open cache file %s or %s: %s.", TEXCACHEFILE, ptempbuf, strerror(errno));
+        LOG_F(ERROR, "Unable to open cache file %s or %s: %s.", TEXCACHEFILE.c_str(), TEXCACHE_INDEX.c_str(), strerror(errno));
         texcache_closefiles();
         glusetexcache = 0;
         return;
@@ -355,7 +351,7 @@ void texcache_openfiles(void)
         buildvfs_fputstr(texcache.indexFilePtr, "// automatically generated by the engine, DO NOT MODIFY!\n");
     }
 
-    LOG_F(INFO, "Opened %s as cache file.", TEXCACHEFILE);
+    LOG_F(INFO, "Opened %s as cache file.", TEXCACHEFILE.c_str());
 }
 
 
@@ -396,9 +392,7 @@ void texcache_invalidate(void)
 
 int texcache_loadoffsets(void)
 {
-    Bstrcpy(ptempbuf, TEXCACHEFILE);
-    Bstrcat(ptempbuf, ".index");
-    scriptfile *script = scriptfile_fromfile(ptempbuf);
+    scriptfile *script = scriptfile_fromfile(TEXCACHE_INDEX.c_str());
 
     if (!script) return -1;
 
diff --git a/source/build/src/vfs.cpp b/source/build/src/vfs.cpp
index 44a9d212d..2790eecc0 100644
--- a/source/build/src/vfs.cpp
+++ b/source/build/src/vfs.cpp
@@ -14,6 +14,9 @@
 #include "pragmas.h"
 #include "vfs.h"
 #include "cache1d.h"
+#include <string>
+#include <filesystem>
+#include <format>
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,6 +61,63 @@ static intptr_t kzipopen(const char *filnam)
 
 #endif
 
+std::filesystem::path redirect_to_user_data(std::string path) {
+    std::string user_data_path(std::getenv("XDG_DATA_HOME"));
+    std::filesystem::path path_obj;
+    // Add user data prefix if needed
+    if (!path.starts_with(user_data_path)) {
+        path_obj /= user_data_path;
+    }
+    path_obj /= path;
+    // printf("Redirected %s to %s\n", path.c_str(), path_obj.lexically_normal().c_str());
+    return path_obj;
+}
+
+void create_parent_directory(std::string filename)
+{
+    std::filesystem::path path_obj = redirect_to_user_data(filename).remove_filename();
+    // printf("create_parent_directory \"%s\"\n", path_obj.lexically_normal().c_str());
+    if (! buildvfs_isdir(path_obj.lexically_normal().c_str()) && buildvfs_mkdir(path_obj.lexically_normal().c_str(), S_IRWXU) != 0)
+    {
+        printf("^10^S0Failed to create directory \"%s\"!\n", path_obj.lexically_normal().c_str());
+    }
+}
+
+std::string get_writable_filename_subdir(std::string filename, std::string subdir)
+{
+    std::filesystem::path path_obj = redirect_to_user_data(subdir);
+    path_obj /= filename;
+    create_parent_directory(filename);
+    // printf("get_writable_filename_subdir \"%s\"\n", path_obj.lexically_normal().c_str());
+    return path_obj.lexically_normal().string();
+}
+
+std::string get_writable_filename(std::string filename)
+{
+    std::filesystem::path path_obj = redirect_to_user_data(filename);
+    create_parent_directory(filename);
+    // printf("get_writable_filename \"%s\"\n", path_obj.lexically_normal().c_str());
+    return path_obj.lexically_normal().string();
+}
+
+std::string get_numbered_writable_filename(std::string filename, std::string extension)
+{
+    if (!extension.starts_with(".")) { extension = std::format(".{}", extension); }
+
+    std::string final_filename;
+    int counter = 0;
+    do
+    {
+        if (counter > 9999) { 
+            printf(std::format("^10^S0Too many files using filename {0}{1}\n", filename, extension).c_str());
+            return nullptr;
+        }
+        final_filename = get_writable_filename(std::format("{0}{1:0>4}{2}", filename, counter, extension));
+        counter++;
+    } while (std::filesystem::exists(final_filename));
+    return final_filename;
+}
+
 char *kpzbuf = NULL;
 int32_t kpzbufsiz;
 
diff --git a/source/duke3d/src/astub.cpp b/source/duke3d/src/astub.cpp
index ea83b3c1a..938717149 100644
--- a/source/duke3d/src/astub.cpp
+++ b/source/duke3d/src/astub.cpp
@@ -10169,9 +10169,11 @@ int32_t ExtInit(void)
 
     {
         char *ptr = Xstrdup(setupfilename), *p = strtok(ptr,".");
+        char m32_settings_p[BMAX_PATH];
+        sprintf(m32_settings_p, "/%s_m32_settings.cfg", p);
         if (!Bstrcmp(setupfilename, SETUPFILENAME))
-            Bsprintf(tempbuf, "m32_settings.cfg");
-        else Bsprintf(tempbuf,"%s_m32_settings.cfg",p);
+            Bsprintf(tempbuf, get_writable_filename(std::string("m32_settings.cfg")).c_str());
+        else Bsprintf(tempbuf, get_writable_filename(std::string(m32_settings_p)).c_str());
         OSD_Exec(tempbuf);
         Xfree(ptr);
     }
diff --git a/source/duke3d/src/common.cpp b/source/duke3d/src/common.cpp
index 23ff2a81e..5f6d5ff4e 100644
--- a/source/duke3d/src/common.cpp
+++ b/source/duke3d/src/common.cpp
@@ -414,8 +414,8 @@ void G_LoadGroups(int32_t autoload)
         }
 
 #ifdef USE_OPENGL
-        Bsnprintf(path, sizeof(path), "%s/%s", g_modDir, TEXCACHEFILE);
-        Bstrcpy(TEXCACHEFILE, path);
+        Bsnprintf(path, sizeof(path), const_cast<char*>(TEXCACHEFILE.c_str()));
+        Bstrcpy(const_cast<char*>(TEXCACHEFILE.c_str()), path);
 #endif
     }
 
diff --git a/source/duke3d/src/config.cpp b/source/duke3d/src/config.cpp
index 1f25a2e6b..7e31bfd2c 100644
--- a/source/duke3d/src/config.cpp
+++ b/source/duke3d/src/config.cpp
@@ -700,31 +700,33 @@ int CONFIG_ReadSetup(void)
 
     ud.config.setupread = 1;
     pathsearchmode = 1;
+    std::string WRITABLE_SETUPFILENAME(get_writable_filename(std::string(SETUPFILENAME)));
+    std::string WRITABLE_BACKUP_SETUPFILENAME(get_writable_filename(std::string(BACKUP_SETUPFILENAME)));
 
     if (ud.config.scripthandle < 0)
     {
-        if (buildvfs_exists(g_setupFileName))  // JBF 20031211
-            ud.config.scripthandle = SCRIPT_Load(g_setupFileName);
+        if (buildvfs_exists(WRITABLE_SETUPFILENAME.c_str()))  // JBF 20031211
+            ud.config.scripthandle = SCRIPT_Load(WRITABLE_SETUPFILENAME.c_str());
 #if !defined(EDUKE32_TOUCH_DEVICES) && !defined(EDUKE32_STANDALONE)
-        else if (buildvfs_exists(SETUPFILENAME))
+        else if (buildvfs_exists(WRITABLE_SETUPFILENAME.c_str()))
         {
             int const i = wm_ynbox("Import Configuration Settings",
                                    "Configuration file %s not found. "
                                    "Import configuration data from %s?",
-                                   g_setupFileName, SETUPFILENAME);
+                                   g_setupFileName, WRITABLE_SETUPFILENAME.c_str());
             if (i)
-                ud.config.scripthandle = SCRIPT_Load(SETUPFILENAME);
+                ud.config.scripthandle = SCRIPT_Load(WRITABLE_SETUPFILENAME.c_str());
         }
 #endif
 #ifdef BACKUP_SETUPFILENAME
-        else if (buildvfs_exists(BACKUP_SETUPFILENAME))
+        else if (buildvfs_exists(WRITABLE_BACKUP_SETUPFILENAME.c_str()))
         {
             int const i = wm_ynbox("Import Configuration Settings",
                                    "Configuration file %s not found. "
                                    "Import configuration data from %s?",
-                                   g_setupFileName, BACKUP_SETUPFILENAME);
+                                   g_setupFileName, WRITABLE_BACKUP_SETUPFILENAME.c_str());
             if (i)
-                ud.config.scripthandle = SCRIPT_Load(BACKUP_SETUPFILENAME);
+                ud.config.scripthandle = SCRIPT_Load(WRITABLE_BACKUP_SETUPFILENAME.c_str());
         }
 #endif
     }
@@ -841,7 +843,7 @@ void CONFIG_ReadSettings(void)
 
     Xfree(setupFileName);
 
-    OSD_Exec(tempbuf);
+    OSD_Exec(get_writable_filename(tempbuf).c_str());
 
     ud.config.setupread = 2;
 
@@ -859,7 +861,7 @@ void CONFIG_WriteSettings(void) // save binds and aliases to <cfgname>_settings.
     else
         Bsprintf(filename, "%s_settings.cfg", strtok(g_setupFileName, "."));
 
-    buildvfs_FILE fp = buildvfs_fopen_write(filename);
+    buildvfs_FILE fp = buildvfs_fopen_write(get_writable_filename(filename).c_str());
 
     if (fp)
     {
diff --git a/source/duke3d/src/demo.cpp b/source/duke3d/src/demo.cpp
index 3169ab92b..bd19baacd 100644
--- a/source/duke3d/src/demo.cpp
+++ b/source/duke3d/src/demo.cpp
@@ -81,6 +81,7 @@ static int32_t G_OpenDemoRead(int32_t g_whichDemo) // 0 = mine
     int32_t i;
     savehead_t saveh;
 
+    char demodir[6] = "demos";
     char demofn[14];
     const char *demofnptr;
 
@@ -94,7 +95,8 @@ static int32_t G_OpenDemoRead(int32_t g_whichDemo) // 0 = mine
         demofnptr = demofn;
     }
 
-    g_demo_recFilePtr = kopen4loadfrommod(demofnptr, g_loadFromGroupOnly);
+    std::string full_demofn(get_writable_filename_subdir(demofnptr, demodir));
+    g_demo_recFilePtr = kopen4loadfrommod(full_demofn.c_str(), g_loadFromGroupOnly);
     if (g_demo_recFilePtr == buildvfs_kfd_invalid)
         return 0;
 
@@ -135,6 +137,7 @@ extern int32_t krd_print(const char *filename);
 
 void G_OpenDemoWrite(void)
 {
+    char demodir[6] = "demos";
     char demofn[BMAX_PATH];
     int32_t i, demonum=1;
 
@@ -174,15 +177,14 @@ void G_OpenDemoWrite(void)
         if (demonum == MAXDEMOS)
             return;
 
-        if (G_ModDirSnprintf(demofn, sizeof(demofn), DEMOFN_FMT, demonum))
-        {
-            LOG_F(ERROR, "Couldn't start demo writing: INTERNAL ERROR: file name too long");
-            goto error_wopen_demo;
-        }
+        // if (G_ModDirSnprintf(demofn, sizeof(demofn), DEMOFN_FMT, demonum))
+        // {
+        //     LOG_F(ERROR, "Couldn't start demo writing: INTERNAL ERROR: file name too long");
+        //     goto error_wopen_demo;
+        // }
 
         demonum++;
-
-        g_demo_filePtr = buildvfs_fopen_read(demofn);
+        g_demo_filePtr = buildvfs_fopen_read(get_writable_filename_subdir(demofn, demodir).c_str());
         if (g_demo_filePtr == NULL)
             break;
 
@@ -190,7 +192,8 @@ void G_OpenDemoWrite(void)
     }
     while (1);
 
-    g_demo_filePtr = buildvfs_fopen_write(demofn);
+    create_parent_directory(get_writable_filename_subdir(demofn, demodir));
+    g_demo_filePtr = buildvfs_fopen_write(get_writable_filename_subdir(demofn, demodir).c_str());
     if (g_demo_filePtr == NULL)
         return;
 
diff --git a/source/duke3d/src/game.cpp b/source/duke3d/src/game.cpp
index 29760de9c..5941bb76d 100644
--- a/source/duke3d/src/game.cpp
+++ b/source/duke3d/src/game.cpp
@@ -6768,7 +6768,9 @@ static const char* dukeVerbosityCallback(loguru::Verbosity verbosity)
 
 int app_main(int argc, char const* const* argv)
 {
-    engineSetLogFile(APPBASENAME ".log", LOG_GAME_MAX);
+    std::string logfile_name(get_writable_filename("amcsquad.log"));
+    printf("Logging to %s\n", logfile_name.c_str());
+    engineSetLogFile(logfile_name.c_str(), LOG_GAME_MAX);
     engineSetLogVerbosityCallback(dukeVerbosityCallback);
 
 #ifndef NETCODE_DISABLE
diff --git a/source/duke3d/src/gamedef.cpp b/source/duke3d/src/gamedef.cpp
index 32adb1a49..99dbcefc0 100644
--- a/source/duke3d/src/gamedef.cpp
+++ b/source/duke3d/src/gamedef.cpp
@@ -2468,7 +2468,7 @@ static void C_SetCfgName(const char *cfgname)
     CONFIG_WriteSetup(1);
 
     if (g_modDir[0] != '/')
-        Bsnprintf(g_setupFileName, sizeof(g_setupFileName), "%s/%s", g_modDir, temp);
+        Bsnprintf(g_setupFileName, sizeof(g_setupFileName), get_writable_filename(temp).c_str());
     else
         Bstrncpyz(g_setupFileName, temp, sizeof(g_setupFileName));
 
diff --git a/source/duke3d/src/gameexec.cpp b/source/duke3d/src/gameexec.cpp
index c19ce1d2b..5a52ea3ec 100644
--- a/source/duke3d/src/gameexec.cpp
+++ b/source/duke3d/src/gameexec.cpp
@@ -5928,13 +5928,13 @@ badindex:
                     int const quoteDirname = *insptr++;
 
                     VM_ABORT_IF(bad_quote(quoteDirname), "invalid quote %d", quoteDirname);
-                    char temp[BMAX_PATH];
+                    char temp[BMAX_PATH] = { *get_writable_filename(apStrings[quoteDirname]).c_str() };
 
-                    if (EDUKE32_PREDICT_FALSE(G_ModDirSnprintf(temp, sizeof(temp), "%s", apStrings[quoteDirname])))
-                    {
-                        CON_ERRPRINTF("directory name in quote %d too long\n", quoteDirname);
-                        abort_after_error();
-                    }
+                    // if (EDUKE32_PREDICT_FALSE(G_ModDirSnprintf(temp, sizeof(temp), "%s", apStrings[quoteDirname])))
+                    // {
+                    //     CON_ERRPRINTF("directory name in quote %d too long\n", quoteDirname);
+                    //     abort_after_error();
+                    // }
 
                     if (!buildvfs_isdir(temp))
                     {
@@ -5999,7 +5999,7 @@ badindex:
 
                     VM_ABORT_IF(bad_quote(quoteFilename), "invalid quote %d", quoteFilename);
 
-                    buildvfs_kfd kFile = kopen4loadfrommod(apStrings[quoteFilename], 0);
+                    buildvfs_kfd kFile = kopen4loadfrommod(get_writable_filename(apStrings[quoteFilename]).c_str(), 0);
 
                     if (kFile == buildvfs_kfd_invalid)
                         dispatch();
@@ -6068,19 +6068,20 @@ badindex:
 
                     VM_ABORT_IF(bad_quote(quoteFilename), "invalid quote %d", quoteFilename);
 
-                    char temp[BMAX_PATH];
+                    std::string temp(get_writable_filename(apStrings[quoteFilename]));
 
-                    if (EDUKE32_PREDICT_FALSE(G_ModDirSnprintf(temp, sizeof(temp), "%s", apStrings[quoteFilename])))
-                    {
-                        LOG_F(ERROR, "Unable to save array to %s: resulting filename is too long.", apStrings[quoteFilename]);
-                        abort_after_error();
-                    }
+                    // if (EDUKE32_PREDICT_FALSE(G_ModDirSnprintf(temp, sizeof(temp), "%s", apStrings[quoteFilename])))
+                    // {
+                    //     LOG_F(ERROR, "Unable to save array to %s: resulting filename is too long.", apStrings[quoteFilename]);
+                    //     abort_after_error();
+                    // }
 
-                    buildvfs_FILE const fil = buildvfs_fopen_write(temp);
+                    create_parent_directory(temp);
+                    buildvfs_FILE const fil = buildvfs_fopen_write(temp.c_str());
 
                     if (EDUKE32_PREDICT_FALSE(fil == NULL))
                     {
-                        LOG_F(ERROR, "Unable to save array to %s: unknown error.", temp);
+                        LOG_F(ERROR, "Unable to save array to %s: unknown error.", temp.c_str());
                         abort_after_error();
                     }
 
diff --git a/source/duke3d/src/grpscan.cpp b/source/duke3d/src/grpscan.cpp
index 8b5133efe..3258c30ce 100644
--- a/source/duke3d/src/grpscan.cpp
+++ b/source/duke3d/src/grpscan.cpp
@@ -265,8 +265,7 @@ static void FreeGameList(void)
     }
 }
 
-
-#define GRPCACHEFILE "grpfiles.cache"
+#define GRPCACHEFILE get_writable_filename("grpfiles.cache").c_str()
 static struct grpcache
 {
     struct grpcache *next;
diff --git a/source/duke3d/src/menus.cpp b/source/duke3d/src/menus.cpp
index 4a558dd2b..f1da62831 100644
--- a/source/duke3d/src/menus.cpp
+++ b/source/duke3d/src/menus.cpp
@@ -37,6 +37,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #include "music.h"
 #include "sbar.h"
 #include "joystick.h"
+#include "vfs.h"
 
 #ifndef __ANDROID__
 droidinput_t droidinput;
@@ -1658,11 +1659,11 @@ static MenuTextForm_t M_CHEAT_SKILL = { NULL, "Enter Skill #:", 2, 0 };
 #define MAKE_MENUFILESELECT(a, dir, b, c, d) { a, { &MMF_FileSelectLeft, &MMF_FileSelectRight }, { &MF_Minifont, &MF_Minifont }, dir, b, c, d, { NULL, NULL }, { 0, 0 }, { 3<<16, 3<<16 }, FNLIST_INITIALIZER, 0 }
 
 static char lastuserdir[BMAX_PATH];
-static MenuFileSelect_t M_USERMAP = MAKE_MENUFILESELECT( "Select A User Map", "/usermaps/", "*.map", boardfilename, lastuserdir);
+static MenuFileSelect_t M_USERMAP = MAKE_MENUFILESELECT( "Select A User Map", redirect_to_user_data("usermaps/").c_str(), "*.map", boardfilename, lastuserdir);
 
 #ifndef EDUKE32_RETAIL_MENU
 static char lastsfdir[BMAX_PATH];
-static MenuFileSelect_t M_SOUND_SF2 = MAKE_MENUFILESELECT( "Select Sound Bank", "/", "*.sf2", sf2bankfile, lastsfdir);
+static MenuFileSelect_t M_SOUND_SF2 = MAKE_MENUFILESELECT( "Select Sound Bank", redirect_to_user_data("/").c_str(), "*.sf2", sf2bankfile, lastsfdir);
 #endif
 
 // MUST be in ascending order of MenuID enum values due to binary search
diff --git a/source/duke3d/src/player.cpp b/source/duke3d/src/player.cpp
index 48b78cb4f..38db20483 100644
--- a/source/duke3d/src/player.cpp
+++ b/source/duke3d/src/player.cpp
@@ -5943,12 +5943,12 @@ int portableBackupSave(const char * path, const char * name, int volume, int lev
     if (!FURY)
         return 0;
 
-    char fn[BMAX_PATH];
+    char fn[BMAX_PATH] = { *const_cast<char*>(get_writable_filename(path).c_str()) };
 
-    if (G_ModDirSnprintf(fn, sizeof(fn), "%s.ext", path))
-    {
-        return 1;
-    }
+    // if (G_ModDirSnprintf(fn, sizeof(fn), "%s.ext", path))
+    // {
+    //     return 1;
+    // }
 
     sjson_context * ctx = sjson_create_context(0, 0, NULL);
     if (!ctx)
diff --git a/source/duke3d/src/savegame.cpp b/source/duke3d/src/savegame.cpp
index ce29653e5..a6036fc84 100644
--- a/source/duke3d/src/savegame.cpp
+++ b/source/duke3d/src/savegame.cpp
@@ -209,12 +209,23 @@ static int countcache1dfind(BUILDVFS_FIND_REC *f)
 
 static void ReadSaveGameHeaders_Internal(void)
 {
-    static char const DefaultPath[] = "/", SavePattern[] = "*.esv";
+    BUILDVFS_FIND_REC *findfiles_default;
 
-    BUILDVFS_FIND_REC *findfiles_default = klistpath(DefaultPath, SavePattern, BUILDVFS_FIND_FILE);
+    for (auto const& dir_entry : std::filesystem::directory_iterator{redirect_to_user_data("saves").lexically_normal()})
+    {
+        printf("Checking %s\n", dir_entry.path().lexically_normal().c_str());
+        if (! std::filesystem::is_directory(dir_entry.path()) &&
+            dir_entry.path().has_extension() &&
+            dir_entry.path().extension() == ".esv")
+        {
+            printf("Adding %s to savegame list!\n", dir_entry.path().lexically_normal().c_str());
+            klistaddentry(&findfiles_default, dir_entry.path().filename().c_str(), 1, 1);
+        }
+    }
 
     // potentially overallocating but programmatically simple
     int const numfiles = countcache1dfind(findfiles_default);
+    printf("Found %s savegames\n", numfiles);
     size_t const internalsavesize = sizeof(menusave_t) * numfiles;
 
     g_internalsaves = (menusave_t *)Xrealloc(g_internalsaves, internalsavesize);
@@ -325,13 +336,13 @@ int32_t G_LoadSaveHeaderNew(char const *fn, savehead_t *saveh)
 
 #if 0
         // debug code to dump the screenshot
-        char scrbuf[BMAX_PATH];
-        if (G_ModDirSnprintf(scrbuf, sizeof(scrbuf), "%s.raw", fn) == 0)
-        {
-            buildvfs_FILE scrfil = buildvfs_fopen_write(scrbuf);
-            buildvfs_fwrite((char *)waloff[TILE_LOADSHOT], 320, 200, scrfil);
-            buildvfs_fclose(scrfil);
-        }
+        char scrbuf[BMAX_PATH] = { get_writable_filename(fn).c_str() };
+        // if (G_ModDirSnprintf(scrbuf, sizeof(scrbuf), "%s.raw", fn) == 0)
+        // {
+        buildvfs_FILE scrfil = buildvfs_fopen_write(scrbuf);
+        buildvfs_fwrite((char *)waloff[TILE_LOADSHOT], 320, 200, scrfil);
+        buildvfs_fclose(scrfil);
+        // }
 #endif
     }
     else
@@ -784,11 +795,11 @@ void G_DeleteSave(savebrief_t const & sv)
 
     char temp[BMAX_PATH];
 
-    if (G_ModDirSnprintf(temp, sizeof(temp), "%s", sv.path))
-    {
-        LOG_F(ERROR, "Unable to remove %s: unknown fatal error.", sv.path);
-        return;
-    }
+    // if (G_ModDirSnprintf(temp, sizeof(temp), "%s", sv.path))
+    // {
+    //     LOG_F(ERROR, "Unable to remove %s: unknown fatal error.", sv.path);
+    //     return;
+    // }
 
     buildvfs_unlink(temp);
     Bstrcat(temp, ".ext");
@@ -833,40 +844,42 @@ int32_t G_SavePlayer(savebrief_t & sv, bool isAutoSave)
     Net_WaitForServer();
     ready2send = 0;
 
-    char fn[BMAX_PATH];
+    char fn[BMAX_PATH] = "save";
 
     errno = 0;
     buildvfs_FILE fil;
+    std::string savefilename;
 
     if (sv.isValid())
     {
-        if (G_ModDirSnprintf(fn, sizeof(fn), "%s", sv.path))
-        {
-            LOG_F(ERROR, "Unable to save %s: unknown fatal error.", sv.path);
-            goto saveproblem;
-        }
-        fil = buildvfs_fopen_write(fn);
+        // if (G_ModDirSnprintf(fn, sizeof(fn), "%s", sv.path))
+        // {
+        //     LOG_F(ERROR, "Unable to save %s: unknown fatal error.", sv.path);
+        //     goto saveproblem;
+        // }
+        savefilename = get_writable_filename_subdir(sv.path, "saves");
+        printf("sv.isvalid, filename %s\n", savefilename.c_str());
+        fil = buildvfs_fopen_write(savefilename.c_str());
     }
     else
     {
-        static char const SaveName[] = "save0000.esv";
-        int const len = G_ModDirSnprintfLite(fn, ARRAY_SIZE(fn), SaveName);
-        if (len >= ARRAY_SSIZE(fn)-1)
-        {
-            LOG_F(ERROR, "Resulting save filename is too long.");
-            goto saveproblem;
-        }
-        char * zeros = fn + (len-8);
-        fil = savecounter.opennextfile(fn, zeros);
-        savecounter.count++;
+        // int const len = G_ModDirSnprintf(fn, ARRAY_SIZE(fn), SaveName);
+        // if (len >= ARRAY_SSIZE(fn)-1)
+        // {
+        //     LOG_F(ERROR, "Resulting save filename is too long.");
+        //     goto saveproblem;
+        // }
+
+        savefilename = get_numbered_writable_filename(get_writable_filename_subdir(fn, "saves"), ".esv");
+        printf("sv.isvalid false, filename %s\n", savefilename.c_str());
+        fil = buildvfs_fopen_write(savefilename.c_str());
         // don't copy the mod dir into sv.path
-        Bstrcpy(sv.path, fn + (len-(ARRAY_SIZE(SaveName)-1)));
+        Bstrcpy(sv.path, fn + 4);
     }
 
     if (!fil)
     {
-        LOG_F(ERROR, "Unable to open %s for writing: %s.",
-                   fn, strerror(errno));
+        LOG_F(ERROR, "Unable to open %s for writing: %s.", savefilename.c_str(), strerror(errno));
         goto saveproblem;
     }
 
@@ -891,7 +904,7 @@ int32_t G_SavePlayer(savebrief_t & sv, bool isAutoSave)
 
     if (!g_netServer && ud.multimode < 2)
     {
-        OSD_Printf("Saved: %s\n", fn);
+        OSD_Printf("Saved: %s\n", savefilename.c_str());
 #ifndef AMC_BUILD
         Bstrcpy(apStrings[QUOTE_RESERVED4], "Game Saved");
         P_DoQuote(QUOTE_RESERVED4, g_player[myconnectindex].ps);
diff --git a/source/mact/src/scriplib.cpp b/source/mact/src/scriplib.cpp
index 4a9dd6cb2..f7b9eb34a 100644
--- a/source/mact/src/scriplib.cpp
+++ b/source/mact/src/scriplib.cpp
@@ -481,7 +481,7 @@ void SCRIPT_Save(int32_t scripthandle, char const * filename)
     if (!filename) return;
     if (!SC(scripthandle)) return;
 
-    fp = buildvfs_fopen_write_text(filename);
+    fp = buildvfs_fopen_write_text(get_writable_filename(filename).c_str());
     if (!fp) return;
 
     numsect = SCRIPT_NumberSections(scripthandle);
