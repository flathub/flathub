From 80ce5dc3ed8380b7c360509fab2b8ab3d7123739 Mon Sep 17 00:00:00 2001
From: Michal Rostecki <michal@kinvolk.io>
Date: Fri, 30 Dec 2016 11:09:49 +0100
Subject: [PATCH] Make sure that system libs will be used

---
 CMakeLists.txt                             |    4 -
 thirdparty/CMakeLists.txt                  |  114 -
 thirdparty/include/zconf.h                 |  428 ---
 thirdparty/include/zconf.h.cmake.msvc      |  430 ---
 thirdparty/include/zlib.h                  | 1613 ---------
 thirdparty/liblcms2/CMakeLists.txt         |   20 -
 thirdparty/liblcms2/COPYING                |    8 -
 thirdparty/liblcms2/include/lcms2.h        | 1737 ----------
 thirdparty/liblcms2/include/lcms2_plugin.h |  535 ---
 thirdparty/liblcms2/src/cmscam02.c         |  483 ---
 thirdparty/liblcms2/src/cmscgats.c         | 2655 ---------------
 thirdparty/liblcms2/src/cmscnvrt.c         | 1039 ------
 thirdparty/liblcms2/src/cmserr.c           |  428 ---
 thirdparty/liblcms2/src/cmsgamma.c         | 1138 -------
 thirdparty/liblcms2/src/cmsgmt.c           |  591 ----
 thirdparty/liblcms2/src/cmsintrp.c         | 1463 --------
 thirdparty/liblcms2/src/cmsio0.c           | 1720 ----------
 thirdparty/liblcms2/src/cmsio1.c           |  760 -----
 thirdparty/liblcms2/src/cmslut.c           | 1665 ----------
 thirdparty/liblcms2/src/cmsmd5.c           |  317 --
 thirdparty/liblcms2/src/cmsmtrx.c          |  176 -
 thirdparty/liblcms2/src/cmsnamed.c         |  750 -----
 thirdparty/liblcms2/src/cmsopt.c           | 1631 ---------
 thirdparty/liblcms2/src/cmspack.c          | 2558 --------------
 thirdparty/liblcms2/src/cmspcs.c           |  926 ------
 thirdparty/liblcms2/src/cmsplugin.c        |  612 ----
 thirdparty/liblcms2/src/cmsps2.c           | 1595 ---------
 thirdparty/liblcms2/src/cmssamp.c          |  266 --
 thirdparty/liblcms2/src/cmssm.c            |  734 ----
 thirdparty/liblcms2/src/cmstypes.c         | 4955 ----------------------------
 thirdparty/liblcms2/src/cmsvirt.c          | 1148 -------
 thirdparty/liblcms2/src/cmswtpnt.c         |  351 --
 thirdparty/liblcms2/src/cmsxform.c         |  809 -----
 thirdparty/liblcms2/src/lcms2.def          |  300 --
 thirdparty/liblcms2/src/lcms2_internal.h   |  652 ----
 thirdparty/libpng/CMakeLists.txt           |   29 -
 thirdparty/libpng/LICENSE                  |  111 -
 thirdparty/libpng/example.c                |  838 -----
 thirdparty/libpng/png.c                    |  918 ------
 thirdparty/libpng/png.h                    | 2699 ---------------
 thirdparty/libpng/pngconf.h                | 1540 ---------
 thirdparty/libpng/pngerror.c               |  402 ---
 thirdparty/libpng/pngget.c                 |  925 ------
 thirdparty/libpng/pngmem.c                 |  611 ----
 thirdparty/libpng/pngpread.c               | 1765 ----------
 thirdparty/libpng/pngpriv.h                |  954 ------
 thirdparty/libpng/pngread.c                | 1361 --------
 thirdparty/libpng/pngrio.c                 |  163 -
 thirdparty/libpng/pngrtran.c               | 4203 -----------------------
 thirdparty/libpng/pngrutil.c               | 3379 -------------------
 thirdparty/libpng/pngset.c                 | 1167 -------
 thirdparty/libpng/pngtest.c                | 1632 ---------
 thirdparty/libpng/pngtrans.c               |  677 ----
 thirdparty/libpng/pngwio.c                 |  241 --
 thirdparty/libpng/pngwrite.c               | 1457 --------
 thirdparty/libpng/pngwtran.c               |  566 ----
 thirdparty/libpng/pngwutil.c               | 2786 ----------------
 thirdparty/libtiff/CMakeLists.txt          |   78 -
 thirdparty/libtiff/t4.h                    |  292 --
 thirdparty/libtiff/tif_apple.c             |  281 --
 thirdparty/libtiff/tif_aux.c               |  290 --
 thirdparty/libtiff/tif_close.c             |  126 -
 thirdparty/libtiff/tif_codec.c             |  160 -
 thirdparty/libtiff/tif_color.c             |  282 --
 thirdparty/libtiff/tif_compress.c          |  295 --
 thirdparty/libtiff/tif_config.h            |   70 -
 thirdparty/libtiff/tif_dir.c               | 1389 --------
 thirdparty/libtiff/tif_dir.h               |  211 --
 thirdparty/libtiff/tif_dirinfo.c           |  904 -----
 thirdparty/libtiff/tif_dirread.c           | 2081 ------------
 thirdparty/libtiff/tif_dirwrite.c          | 1414 --------
 thirdparty/libtiff/tif_dumpmode.c          |  126 -
 thirdparty/libtiff/tif_error.c             |   80 -
 thirdparty/libtiff/tif_extension.c         |  118 -
 thirdparty/libtiff/tif_fax3.c              | 1626 ---------
 thirdparty/libtiff/tif_fax3.h              |  532 ---
 thirdparty/libtiff/tif_fax3sm.c            | 1260 -------
 thirdparty/libtiff/tif_flush.c             |   74 -
 thirdparty/libtiff/tif_getimage.c          | 2676 ---------------
 thirdparty/libtiff/tif_jbig.c              |  385 ---
 thirdparty/libtiff/tif_jpeg.c              | 2065 ------------
 thirdparty/libtiff/tif_luv.c               | 1629 ---------
 thirdparty/libtiff/tif_lzw.c               | 1129 -------
 thirdparty/libtiff/tif_next.c              |  154 -
 thirdparty/libtiff/tif_ojpeg.c             | 2438 --------------
 thirdparty/libtiff/tif_open.c              |  695 ----
 thirdparty/libtiff/tif_packbits.c          |  300 --
 thirdparty/libtiff/tif_pixarlog.c          | 1371 --------
 thirdparty/libtiff/tif_predict.c           |  736 -----
 thirdparty/libtiff/tif_predict.h           |   77 -
 thirdparty/libtiff/tif_print.c             |  646 ----
 thirdparty/libtiff/tif_read.c              |  750 -----
 thirdparty/libtiff/tif_stream.cxx          |  295 --
 thirdparty/libtiff/tif_strip.c             |  370 ---
 thirdparty/libtiff/tif_swab.c              |  242 --
 thirdparty/libtiff/tif_thunder.c           |  165 -
 thirdparty/libtiff/tif_tile.c              |  280 --
 thirdparty/libtiff/tif_unix.c              |  296 --
 thirdparty/libtiff/tif_version.c           |   40 -
 thirdparty/libtiff/tif_warning.c           |   81 -
 thirdparty/libtiff/tif_win32.c             |  408 ---
 thirdparty/libtiff/tif_write.c             |  718 ----
 thirdparty/libtiff/tif_zip.c               |  419 ---
 thirdparty/libtiff/tiff.h                  |  654 ----
 thirdparty/libtiff/tiffconf.h              |  124 -
 thirdparty/libtiff/tiffio.h                |  526 ---
 thirdparty/libtiff/tiffio.hxx              |   49 -
 thirdparty/libtiff/tiffiop.h               |  350 --
 thirdparty/libtiff/tiffvers.h              |    9 -
 thirdparty/libtiff/uvcode.h                |  180 -
 thirdparty/libz/CMakeLists.txt             |  102 -
 thirdparty/libz/adler32.c                  |  169 -
 thirdparty/libz/compress.c                 |   80 -
 thirdparty/libz/crc32.c                    |  442 ---
 thirdparty/libz/crc32.h                    |  441 ---
 thirdparty/libz/deflate.c                  | 1834 ----------
 thirdparty/libz/deflate.h                  |  342 --
 thirdparty/libz/example.c                  |  565 ----
 thirdparty/libz/gzclose.c                  |   25 -
 thirdparty/libz/gzguts.h                   |  132 -
 thirdparty/libz/gzlib.c                    |  537 ---
 thirdparty/libz/gzread.c                   |  653 ----
 thirdparty/libz/gzwrite.c                  |  531 ---
 thirdparty/libz/infback.c                  |  632 ----
 thirdparty/libz/inffast.c                  |  340 --
 thirdparty/libz/inffast.h                  |   11 -
 thirdparty/libz/inffixed.h                 |   94 -
 thirdparty/libz/inflate.c                  | 1480 ---------
 thirdparty/libz/inflate.h                  |  122 -
 thirdparty/libz/inftrees.c                 |  330 --
 thirdparty/libz/inftrees.h                 |   62 -
 thirdparty/libz/minigzip.c                 |  440 ---
 thirdparty/libz/trees.c                    | 1244 -------
 thirdparty/libz/trees.h                    |  128 -
 thirdparty/libz/uncompr.c                  |   59 -
 thirdparty/libz/zlib.h                     | 1613 ---------
 thirdparty/libz/zutil.c                    |  318 --
 thirdparty/libz/zutil.h                    |  274 --
 138 files changed, 107981 deletions(-)
 delete mode 100644 thirdparty/CMakeLists.txt
 delete mode 100644 thirdparty/include/zconf.h
 delete mode 100644 thirdparty/include/zconf.h.cmake.msvc
 delete mode 100644 thirdparty/include/zlib.h
 delete mode 100644 thirdparty/liblcms2/CMakeLists.txt
 delete mode 100644 thirdparty/liblcms2/COPYING
 delete mode 100644 thirdparty/liblcms2/include/lcms2.h
 delete mode 100644 thirdparty/liblcms2/include/lcms2_plugin.h
 delete mode 100644 thirdparty/liblcms2/src/cmscam02.c
 delete mode 100644 thirdparty/liblcms2/src/cmscgats.c
 delete mode 100644 thirdparty/liblcms2/src/cmscnvrt.c
 delete mode 100644 thirdparty/liblcms2/src/cmserr.c
 delete mode 100644 thirdparty/liblcms2/src/cmsgamma.c
 delete mode 100644 thirdparty/liblcms2/src/cmsgmt.c
 delete mode 100644 thirdparty/liblcms2/src/cmsintrp.c
 delete mode 100644 thirdparty/liblcms2/src/cmsio0.c
 delete mode 100644 thirdparty/liblcms2/src/cmsio1.c
 delete mode 100644 thirdparty/liblcms2/src/cmslut.c
 delete mode 100644 thirdparty/liblcms2/src/cmsmd5.c
 delete mode 100644 thirdparty/liblcms2/src/cmsmtrx.c
 delete mode 100644 thirdparty/liblcms2/src/cmsnamed.c
 delete mode 100644 thirdparty/liblcms2/src/cmsopt.c
 delete mode 100644 thirdparty/liblcms2/src/cmspack.c
 delete mode 100644 thirdparty/liblcms2/src/cmspcs.c
 delete mode 100644 thirdparty/liblcms2/src/cmsplugin.c
 delete mode 100644 thirdparty/liblcms2/src/cmsps2.c
 delete mode 100644 thirdparty/liblcms2/src/cmssamp.c
 delete mode 100644 thirdparty/liblcms2/src/cmssm.c
 delete mode 100644 thirdparty/liblcms2/src/cmstypes.c
 delete mode 100644 thirdparty/liblcms2/src/cmsvirt.c
 delete mode 100644 thirdparty/liblcms2/src/cmswtpnt.c
 delete mode 100644 thirdparty/liblcms2/src/cmsxform.c
 delete mode 100644 thirdparty/liblcms2/src/lcms2.def
 delete mode 100644 thirdparty/liblcms2/src/lcms2_internal.h
 delete mode 100644 thirdparty/libpng/CMakeLists.txt
 delete mode 100644 thirdparty/libpng/LICENSE
 delete mode 100644 thirdparty/libpng/example.c
 delete mode 100644 thirdparty/libpng/png.c
 delete mode 100644 thirdparty/libpng/png.h
 delete mode 100644 thirdparty/libpng/pngconf.h
 delete mode 100644 thirdparty/libpng/pngerror.c
 delete mode 100644 thirdparty/libpng/pngget.c
 delete mode 100644 thirdparty/libpng/pngmem.c
 delete mode 100644 thirdparty/libpng/pngpread.c
 delete mode 100644 thirdparty/libpng/pngpriv.h
 delete mode 100644 thirdparty/libpng/pngread.c
 delete mode 100644 thirdparty/libpng/pngrio.c
 delete mode 100644 thirdparty/libpng/pngrtran.c
 delete mode 100644 thirdparty/libpng/pngrutil.c
 delete mode 100644 thirdparty/libpng/pngset.c
 delete mode 100644 thirdparty/libpng/pngtest.c
 delete mode 100644 thirdparty/libpng/pngtrans.c
 delete mode 100644 thirdparty/libpng/pngwio.c
 delete mode 100644 thirdparty/libpng/pngwrite.c
 delete mode 100644 thirdparty/libpng/pngwtran.c
 delete mode 100644 thirdparty/libpng/pngwutil.c
 delete mode 100644 thirdparty/libtiff/CMakeLists.txt
 delete mode 100644 thirdparty/libtiff/t4.h
 delete mode 100644 thirdparty/libtiff/tif_apple.c
 delete mode 100644 thirdparty/libtiff/tif_aux.c
 delete mode 100644 thirdparty/libtiff/tif_close.c
 delete mode 100644 thirdparty/libtiff/tif_codec.c
 delete mode 100644 thirdparty/libtiff/tif_color.c
 delete mode 100644 thirdparty/libtiff/tif_compress.c
 delete mode 100644 thirdparty/libtiff/tif_config.h
 delete mode 100644 thirdparty/libtiff/tif_dir.c
 delete mode 100644 thirdparty/libtiff/tif_dir.h
 delete mode 100644 thirdparty/libtiff/tif_dirinfo.c
 delete mode 100644 thirdparty/libtiff/tif_dirread.c
 delete mode 100644 thirdparty/libtiff/tif_dirwrite.c
 delete mode 100644 thirdparty/libtiff/tif_dumpmode.c
 delete mode 100644 thirdparty/libtiff/tif_error.c
 delete mode 100644 thirdparty/libtiff/tif_extension.c
 delete mode 100644 thirdparty/libtiff/tif_fax3.c
 delete mode 100644 thirdparty/libtiff/tif_fax3.h
 delete mode 100644 thirdparty/libtiff/tif_fax3sm.c
 delete mode 100644 thirdparty/libtiff/tif_flush.c
 delete mode 100644 thirdparty/libtiff/tif_getimage.c
 delete mode 100644 thirdparty/libtiff/tif_jbig.c
 delete mode 100644 thirdparty/libtiff/tif_jpeg.c
 delete mode 100644 thirdparty/libtiff/tif_luv.c
 delete mode 100644 thirdparty/libtiff/tif_lzw.c
 delete mode 100644 thirdparty/libtiff/tif_next.c
 delete mode 100644 thirdparty/libtiff/tif_ojpeg.c
 delete mode 100644 thirdparty/libtiff/tif_open.c
 delete mode 100644 thirdparty/libtiff/tif_packbits.c
 delete mode 100644 thirdparty/libtiff/tif_pixarlog.c
 delete mode 100644 thirdparty/libtiff/tif_predict.c
 delete mode 100644 thirdparty/libtiff/tif_predict.h
 delete mode 100644 thirdparty/libtiff/tif_print.c
 delete mode 100644 thirdparty/libtiff/tif_read.c
 delete mode 100644 thirdparty/libtiff/tif_stream.cxx
 delete mode 100644 thirdparty/libtiff/tif_strip.c
 delete mode 100644 thirdparty/libtiff/tif_swab.c
 delete mode 100644 thirdparty/libtiff/tif_thunder.c
 delete mode 100644 thirdparty/libtiff/tif_tile.c
 delete mode 100644 thirdparty/libtiff/tif_unix.c
 delete mode 100644 thirdparty/libtiff/tif_version.c
 delete mode 100644 thirdparty/libtiff/tif_warning.c
 delete mode 100644 thirdparty/libtiff/tif_win32.c
 delete mode 100644 thirdparty/libtiff/tif_write.c
 delete mode 100644 thirdparty/libtiff/tif_zip.c
 delete mode 100644 thirdparty/libtiff/tiff.h
 delete mode 100644 thirdparty/libtiff/tiffconf.h
 delete mode 100644 thirdparty/libtiff/tiffio.h
 delete mode 100644 thirdparty/libtiff/tiffio.hxx
 delete mode 100644 thirdparty/libtiff/tiffiop.h
 delete mode 100644 thirdparty/libtiff/tiffvers.h
 delete mode 100644 thirdparty/libtiff/uvcode.h
 delete mode 100644 thirdparty/libz/CMakeLists.txt
 delete mode 100644 thirdparty/libz/adler32.c
 delete mode 100644 thirdparty/libz/compress.c
 delete mode 100644 thirdparty/libz/crc32.c
 delete mode 100644 thirdparty/libz/crc32.h
 delete mode 100644 thirdparty/libz/deflate.c
 delete mode 100644 thirdparty/libz/deflate.h
 delete mode 100644 thirdparty/libz/example.c
 delete mode 100644 thirdparty/libz/gzclose.c
 delete mode 100644 thirdparty/libz/gzguts.h
 delete mode 100644 thirdparty/libz/gzlib.c
 delete mode 100644 thirdparty/libz/gzread.c
 delete mode 100644 thirdparty/libz/gzwrite.c
 delete mode 100644 thirdparty/libz/infback.c
 delete mode 100644 thirdparty/libz/inffast.c
 delete mode 100644 thirdparty/libz/inffast.h
 delete mode 100644 thirdparty/libz/inffixed.h
 delete mode 100644 thirdparty/libz/inflate.c
 delete mode 100644 thirdparty/libz/inflate.h
 delete mode 100644 thirdparty/libz/inftrees.c
 delete mode 100644 thirdparty/libz/inftrees.h
 delete mode 100644 thirdparty/libz/minigzip.c
 delete mode 100644 thirdparty/libz/trees.c
 delete mode 100644 thirdparty/libz/trees.h
 delete mode 100644 thirdparty/libz/uncompr.c
 delete mode 100644 thirdparty/libz/zlib.h
 delete mode 100644 thirdparty/libz/zutil.c
 delete mode 100644 thirdparty/libz/zutil.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 253e46a..c8d3866 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -239,10 +239,6 @@ MARK_AS_ADVANCED(BUILD_VIEWER)
 MARK_AS_ADVANCED(BUILD_JAVA)
 
 IF(BUILD_CODEC OR BUILD_MJ2)
-  # OFF: It will only build 3rd party libs if they are not found on the system
-  # ON: 3rd party libs will ALWAYS be build, and used
-  OPTION(BUILD_THIRDPARTY "Build the thirdparty executables if it is needed" OFF)
-  ADD_SUBDIRECTORY(thirdparty)
   ADD_SUBDIRECTORY(applications)
 ENDIF (BUILD_CODEC OR BUILD_MJ2)
 
diff --git a/thirdparty/CMakeLists.txt b/thirdparty/CMakeLists.txt
deleted file mode 100644
index 7ab24ba..0000000
--- a/thirdparty/CMakeLists.txt
+++ /dev/null
@@ -1,114 +0,0 @@
-# 3rd party libs  
-
-#------------
-# Try to find lib Z
-IF(BUILD_THIRDPARTY)
-  # Try to build it
-  message(STATUS "We will build Z lib from thirdparty")
-  ADD_SUBDIRECTORY(libz)
-  SET(Z_LIBNAME z PARENT_SCOPE)
-  SET(Z_INCLUDE_DIRNAME ${OPENJPEG_SOURCE_DIR}/thirdparty/include PARENT_SCOPE)
-  SET(ZLIB_FOUND 1)
-ELSE (BUILD_THIRDPARTY)
-  # Try to find lib Z
-  FIND_PACKAGE(ZLIB)
-  IF(ZLIB_FOUND)
-    SET(Z_LIBNAME ${ZLIB_LIBRARIES} PARENT_SCOPE)
-    SET(Z_INCLUDE_DIRNAME ${ZLIB_INCLUDE_DIRS} PARENT_SCOPE) 
-    message(STATUS "Your system seems to have a Z lib available, we will use it to generate PNG lib")
-  ELSE (ZLIB_FOUND) # not found
-    message(STATUS "Z lib not found, activate BUILD_THIRDPARTY if you want build it (necessary to build libPNG)")
-  ENDIF(ZLIB_FOUND)
-ENDIF(BUILD_THIRDPARTY) 
-    
-
-#------------
-# Try to find lib PNG (which depends on zlib)
-IF(BUILD_THIRDPARTY)
-  # Try to build it
-  message(STATUS "We will build PNG lib from thirdparty")
-  ADD_SUBDIRECTORY(libpng)
-  SET(HAVE_PNG_H 1 PARENT_SCOPE)
-  SET(HAVE_LIBPNG 1 PARENT_SCOPE)
-  SET(PNG_LIBNAME png PARENT_SCOPE)
-  SET(PNG_INCLUDE_DIRNAME ${OPENJPEG_SOURCE_DIR}/thirdparty/libpng PARENT_SCOPE)
-ELSE (BUILD_THIRDPARTY)
-  IF (ZLIB_FOUND)
-    FIND_PACKAGE(PNG)
-    IF(PNG_FOUND)
-      message(STATUS "Your system seems to have a PNG lib available, we will use it")
-      SET(HAVE_PNG_H 1 PARENT_SCOPE)
-      SET(HAVE_LIBPNG 1 PARENT_SCOPE)
-      SET(PNG_LIBNAME ${PNG_LIBRARIES} PARENT_SCOPE)
-      SET(PNG_INCLUDE_DIRNAME ${PNG_PNG_INCLUDE_DIR} PARENT_SCOPE) 
-    ELSE(PNG_FOUND) # not found
-      SET(HAVE_PNG_H 0 PARENT_SCOPE)
-      SET(HAVE_LIBPNG 0 PARENT_SCOPE)
-      message(STATUS "PNG lib not found, activate BUILD_THIRDPARTY if you want build it")
-    ENDIF(PNG_FOUND)
-  ENDIF (ZLIB_FOUND)
-ENDIF(BUILD_THIRDPARTY) 
-
-#------------
-# Try to find lib TIFF
-  
-IF(BUILD_THIRDPARTY)
-  # Try to build it
-  message(STATUS "We will build TIFF lib from thirdparty")
-  ADD_SUBDIRECTORY(libtiff)
-  SET(TIFF_LIBNAME tiff PARENT_SCOPE)
-  SET(TIFF_INCLUDE_DIRNAME ${OPENJPEG_SOURCE_DIR}/thirdparty/libtiff PARENT_SCOPE)
-  SET(HAVE_TIFF_H 1 PARENT_SCOPE)
-  SET(HAVE_LIBTIFF 1 PARENT_SCOPE)
-ELSE (BUILD_THIRDPARTY)
-  FIND_PACKAGE(TIFF)
-  IF(TIFF_FOUND)
-    message(STATUS "Your system seems to have a TIFF lib available, we will use it")
-    SET(HAVE_TIFF_H 1 PARENT_SCOPE)
-    SET(HAVE_LIBTIFF 1 PARENT_SCOPE)
-    SET(TIFF_LIBNAME ${TIFF_LIBRARIES} PARENT_SCOPE)
-    SET(TIFF_INCLUDE_DIRNAME ${TIFF_INCLUDE_DIR} PARENT_SCOPE) 
-  ELSE (TIFF_FOUND) # not found
-    SET(HAVE_TIFF_H 0 PARENT_SCOPE)
-    SET(HAVE_LIBTIFF 0 PARENT_SCOPE)
-    message(STATUS "TIFF lib not found, activate BUILD_THIRDPARTY if you want build it")
-  ENDIF(TIFF_FOUND)
-ENDIF(BUILD_THIRDPARTY) 
-
-#------------
-# Try to find lib LCMS2 (or by default LCMS)
-SET(HAVE_LCMS_H 0 PARENT_SCOPE)
-SET(HAVE_LIBLCMS 0 PARENT_SCOPE)
-
-IF( BUILD_THIRDPARTY)
-  # Try to build lcms2
-  message(STATUS "We will build LCMS2 lib from thirdparty")
-  ADD_SUBDIRECTORY(liblcms2)
-  SET(LCMS_LIBNAME lcms2 PARENT_SCOPE)
-  SET(LCMS_INCLUDE_DIRNAME ${OPENJPEG_SOURCE_DIR}/thirdparty/liblcms2/include PARENT_SCOPE) #
-  SET(HAVE_LCMS2_H 1 PARENT_SCOPE)
-  SET(HAVE_LIBLCMS2 1 PARENT_SCOPE)
-ELSE (BUILD_THIRDPARTY)
-  FIND_PACKAGE(LCMS2)
-  IF(LCMS2_FOUND)
-    message(STATUS "Your system seems to have a LCMS2 lib available, we will use it")
-    SET(HAVE_LCMS2_H 1 PARENT_SCOPE)
-    SET(HAVE_LIBLCMS2 1 PARENT_SCOPE)
-    SET(LCMS_LIBNAME ${LCMS2_LIBRARIES} PARENT_SCOPE)
-    SET(LCMS_INCLUDE_DIRNAME ${LCMS2_INCLUDE_DIRS} PARENT_SCOPE) 
-  ELSE (LCMS2_FOUND) # not found lcms2
-    # try to find LCMS
-    FIND_PACKAGE(LCMS)  
-    IF(LCMS_FOUND)
-      message(STATUS "Your system seems to have a LCMS lib available, we will use it")
-      SET(HAVE_LCMS_H 1 PARENT_SCOPE)
-      SET(HAVE_LIBLCMS 1 PARENT_SCOPE)
-      SET(LCMS_LIBNAME ${LCMS_LIBRARIES} PARENT_SCOPE)
-      SET(LCMS_INCLUDE_DIRNAME ${LCMS_INCLUDE_DIRS} PARENT_SCOPE) 
-    ELSE (LCMS_FOUND) # not found lcms
-      SET(HAVE_LCMS2_H 0 PARENT_SCOPE)
-      SET(HAVE_LIBLCMS2 0 PARENT_SCOPE)
-      message(STATUS "LCMS2 or LCMS lib not found, activate BUILD_THIRDPARTY if you want build it")
-    ENDIF (LCMS_FOUND)
-  ENDIF(LCMS2_FOUND)
-ENDIF(BUILD_THIRDPARTY) 
diff --git a/thirdparty/include/zconf.h b/thirdparty/include/zconf.h
deleted file mode 100644
index 02ce56c..0000000
--- a/thirdparty/include/zconf.h
+++ /dev/null
@@ -1,428 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  define gz_error              z_gz_error
-#  define gz_intmax             z_gz_intmax
-#  define gz_strwinerror        z_gz_strwinerror
-#  define gzbuffer              z_gzbuffer
-#  define gzclearerr            z_gzclearerr
-#  define gzclose               z_gzclose
-#  define gzclose_r             z_gzclose_r
-#  define gzclose_w             z_gzclose_w
-#  define gzdirect              z_gzdirect
-#  define gzdopen               z_gzdopen
-#  define gzeof                 z_gzeof
-#  define gzerror               z_gzerror
-#  define gzflush               z_gzflush
-#  define gzgetc                z_gzgetc
-#  define gzgets                z_gzgets
-#  define gzoffset              z_gzoffset
-#  define gzoffset64            z_gzoffset64
-#  define gzopen                z_gzopen
-#  define gzopen64              z_gzopen64
-#  define gzprintf              z_gzprintf
-#  define gzputc                z_gzputc
-#  define gzputs                z_gzputs
-#  define gzread                z_gzread
-#  define gzrewind              z_gzrewind
-#  define gzseek                z_gzseek
-#  define gzseek64              z_gzseek64
-#  define gzsetparams           z_gzsetparams
-#  define gztell                z_gztell
-#  define gztell64              z_gztell64
-#  define gzungetc              z_gzungetc
-#  define gzwrite               z_gzwrite
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  define uncompress            z_uncompress
-#  define zError                z_zError
-#  define zcalloc               z_zcalloc
-#  define zcfree                z_zcfree
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  define gzFile                z_gzFile
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef STDC
-#  include <sys/types.h>    /* for off_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#  include <unistd.h>       /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>     /* for off_t */
-#  endif
-#  ifndef z_off_t
-#    define z_off_t off_t
-#  endif
-#endif
-
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define z_off64_t off64_t
-#else
-#  define z_off64_t z_off_t
-#endif
-
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff --git a/thirdparty/include/zconf.h.cmake.msvc b/thirdparty/include/zconf.h.cmake.msvc
deleted file mode 100644
index 57465e0..0000000
--- a/thirdparty/include/zconf.h.cmake.msvc
+++ /dev/null
@@ -1,430 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-/* #undef Z_PREFIX */
-/* #undef Z_HAVE_UNISTD_H */
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  define gz_error              z_gz_error
-#  define gz_intmax             z_gz_intmax
-#  define gz_strwinerror        z_gz_strwinerror
-#  define gzbuffer              z_gzbuffer
-#  define gzclearerr            z_gzclearerr
-#  define gzclose               z_gzclose
-#  define gzclose_r             z_gzclose_r
-#  define gzclose_w             z_gzclose_w
-#  define gzdirect              z_gzdirect
-#  define gzdopen               z_gzdopen
-#  define gzeof                 z_gzeof
-#  define gzerror               z_gzerror
-#  define gzflush               z_gzflush
-#  define gzgetc                z_gzgetc
-#  define gzgets                z_gzgets
-#  define gzoffset              z_gzoffset
-#  define gzoffset64            z_gzoffset64
-#  define gzopen                z_gzopen
-#  define gzopen64              z_gzopen64
-#  define gzprintf              z_gzprintf
-#  define gzputc                z_gzputc
-#  define gzputs                z_gzputs
-#  define gzread                z_gzread
-#  define gzrewind              z_gzrewind
-#  define gzseek                z_gzseek
-#  define gzseek64              z_gzseek64
-#  define gzsetparams           z_gzsetparams
-#  define gztell                z_gztell
-#  define gztell64              z_gztell64
-#  define gzungetc              z_gzungetc
-#  define gzwrite               z_gzwrite
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  define uncompress            z_uncompress
-#  define zError                z_zError
-#  define zcalloc               z_zcalloc
-#  define zcfree                z_zcfree
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  define gzFile                z_gzFile
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef STDC
-#  include <sys/types.h>    /* for off_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#  include <unistd.h>       /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>     /* for off_t */
-#  endif
-#  ifndef z_off_t
-#    define z_off_t off_t
-#  endif
-#endif
-
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define z_off64_t off64_t
-#else
-#  define z_off64_t z_off_t
-#endif
-
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff --git a/thirdparty/include/zlib.h b/thirdparty/include/zlib.h
deleted file mode 100644
index bfbba83..0000000
--- a/thirdparty/include/zlib.h
+++ /dev/null
@@ -1,1613 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.5, April 19th, 2010
-
-  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.5"
-#define ZLIB_VERNUM 0x1250
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 5
-#define ZLIB_VER_SUBREVISION 0
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip streams in memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use in the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field (though see inflate()) */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).  Some
-    output may be provided even if flush is not set.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed code
-  block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error.  After
-  deflate has returned Z_STREAM_END, the only possible operations on the stream
-  are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step.  In this case, avail_out must be at least the
-  value returned by deflateBound (see below).  If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
-  binary.  This field is only for information purposes and does not affect the
-  compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
-  fatal, and deflate() can be called again with more input and more output
-  space to continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
-   exact value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit() does not process any header information -- that is deferred
-   until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing will
-    resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all the uncompressed data.  (The size
-  of the uncompressed data may have been saved by the compressor for this
-  purpose.) The next operation on this stream must be inflateEnd to deallocate
-  the decompression state.  The use of Z_FINISH is never required, but can be
-  used to inform inflate that a faster approach may be used for the single
-  inflate() call.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the only effect of the flush parameter in this implementation
-  is on the return value of inflate(), as noted below, or when it returns early
-  because Z_BLOCK or Z_TREES is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the adler32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed adler32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained, so applications that need that information should
-  instead use raw inflate, see inflateInit2() below, or inflateBack() and
-  perform their own processing of the gzip header and trailer.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
-  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is desired.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent.  In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute an adler32 check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to 255 (unknown).  If a
-   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any call
-   of deflate.  The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   adler32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort).  deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.  The
-   stream will keep the same compression level and any other attributes that
-   may have been set by deflateInit2.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression level is changed, the input available so far is
-   compressed with the old level (and may be flushed); the new level will take
-   effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to be
-   compressed and flushed.  In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
-   strm->avail_out was zero.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().
-*/
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an adler32 or a crc32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   crc32 instead of an adler32.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called
-   immediately after inflateInit2() or inflateReset() and before any call of
-   inflate() to set the dictionary.  The application must insure that the
-   dictionary that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a full flush point (see above the
-   description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-   if no more input was provided, Z_DATA_ERROR if no flush point has been
-   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the
-   success case, the application may save the current current value of total_in
-   which indicates where valid compressed data was found.  In the error case,
-   the application may repeatedly call inflateSync, providing more input each
-   time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above or -1 << 16 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the normal
-   behavior of inflate(), which expects either a zlib or gzip header and
-   trailer around the deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero--buf is ignored in that
-   case--and inflateBack() will return a buffer error.  inflateBack() will call
-   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
-   should return zero on success, or non-zero on failure.  If out() returns
-   non-zero, inflateBack() will return with an error.  Neither in() nor out()
-   are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.) Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
-*/
-
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef voidp gzFile;       /* opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.) Also "a"
-   can be used instead of "w" to request that the gzip stream that will be
-   written be appended to the file.  "+" will result in an error, since reading
-   and writing to the same gzip file is not supported.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Two buffers are allocated, either both of the specified size when
-   writing, or one of the specified size and the other twice that size when
-   reading.  A larger buffer size of, for example, 64K or 128K bytes will
-   noticeably increase the speed of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.
-
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file was not in gzip format, gzread copies the given number of
-   bytes into the buffer.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream, or failing that, reading the rest
-   of the input file directly without decompression.  The entire input file
-   will be read if gzread is called until it returns less than the requested
-   len.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or 0 in case of error.  The number of
-   uncompressed bytes written is limited to 8191, or one less than the buffer
-   size given to gzbuffer().  The caller should assure that this limit is not
-   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
-   nothing written.  In this case, there may also be a buffer overflow with
-   unpredictable consequences, which is possible only if zlib was compiled with
-   the insecure functions sprintf() or vsprintf() because the secure snprintf()
-   or vsnprintf() functions were not available.  This can be determined using
-   zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatented gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.  This state can change from
-   false to true while reading the input file if the end of a gzip stream is
-   reached, but is followed by data that is not another gzip stream.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the for the crc.  Pre- and post-conditioning (one's
-   complement) is performed within this function so it shouldn't be done by the
-   application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-#define inflateBackInit(strm, windowBits, window) \
-        inflateBackInit_((strm), (windowBits), (window), \
-                                            ZLIB_VERSION, sizeof(z_stream))
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && _FILE_OFFSET_BITS-0 == 64 && _LFS64_LARGEFILE-0
-#  define gzopen gzopen64
-#  define gzseek gzseek64
-#  define gztell gztell64
-#  define gzoffset gzoffset64
-#  define adler32_combine adler32_combine64
-#  define crc32_combine crc32_combine64
-#  ifdef _LARGEFILE64_SOURCE
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-/* hack for buggy compilers */
-#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;};
-#endif
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
diff --git a/thirdparty/liblcms2/CMakeLists.txt b/thirdparty/liblcms2/CMakeLists.txt
deleted file mode 100644
index e05a42b..0000000
--- a/thirdparty/liblcms2/CMakeLists.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-PROJECT(liblcms2 C)
-#
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/include")
-#
-FILE(GLOB SRCS src/*.c)
-FILE(GLOB HDRS include/*.h)
-#
-SET(LIBTARGET "lcms2")
-#
-ADD_LIBRARY(${LIBTARGET} STATIC ${SRCS} ${HDRS})
-#
-IF(MSVC)
-  SET_TARGET_PROPERTIES(${LIBTARGET} PROPERTIES PREFIX "lib")
-ENDIF(MSVC)
-#
-SET_TARGET_PROPERTIES(${LIBTARGET}
-  PROPERTIES
-  OUTPUT_NAME "${LIBTARGET}"
-  ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/thirdparty/lib)
-#
diff --git a/thirdparty/liblcms2/COPYING b/thirdparty/liblcms2/COPYING
deleted file mode 100644
index b147b1b..0000000
--- a/thirdparty/liblcms2/COPYING
+++ /dev/null
@@ -1,8 +0,0 @@
-Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/thirdparty/liblcms2/include/lcms2.h b/thirdparty/liblcms2/include/lcms2.h
deleted file mode 100644
index ef121cb..0000000
--- a/thirdparty/liblcms2/include/lcms2.h
+++ /dev/null
@@ -1,1737 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the Software
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-// Version 2.1
-//
-
-#ifndef _lcms2_H
-
-// ********** Configuration toggles ****************************************
-
-// Uncomment this one if you are using big endian machines
-// #define CMS_USE_BIG_ENDIAN   1
-
-// Uncomment this one if your compiler/machine does NOT support the
-// "long long" type.
-// #define CMS_DONT_USE_INT64        1
-
-// Uncomment this if your compiler doesn't work with fast floor function
-// #define CMS_DONT_USE_FAST_FLOOR 1
-
-// Uncomment this line if your system does not support multithreading
-#define CMS_DONT_USE_PTHREADS    1
-
-// Uncomment this line if you want lcms to use the black point tag in profile,
-// if commented, lcms will compute the black point by its own.
-// It is safer to leave it commented out
-// #define CMS_USE_PROFILE_BLACK_POINT_TAG    1
-
-// Uncomment this line if you are compiling as C++ and want a C++ API
-// #define CMS_USE_CPP_API
-
-// Uncomment this line if you need strict CGATS syntax. Makes CGATS files to
-// require "KEYWORD" on undefined identifiers, keep it comented out unless needed
-// #define CMS_STRICT_CGATS  1
-
-// ********** End of configuration toggles ******************************
-
-// Needed for streams
-#include <stdio.h>
-
-// Needed for portability (C99 per 7.1.2)
-#include <limits.h>
-#include <time.h>
-#include <stddef.h>
-
-#ifndef CMS_USE_CPP_API
-#   ifdef __cplusplus
-extern "C" {
-#   endif
-#endif
-
-// Version/release
-#define LCMS_VERSION        2010
-
-// I will give the chance of redefining basic types for compilers that are not fully C99 compliant
-#ifndef CMS_BASIC_TYPES_ALREADY_DEFINED
-
-// Base types
-typedef unsigned char        cmsUInt8Number;   // That is guaranteed by the C99 spec
-typedef signed char          cmsInt8Number;    // That is guaranteed by the C99 spec
-
-// IEEE float storage numbers
-typedef float                cmsFloat32Number;
-typedef double               cmsFloat64Number;
-
-// 16-bit base types
-#if (USHRT_MAX == 65535U)
- typedef unsigned short      cmsUInt16Number;
-#elif (UINT_MAX == 65535U)
- typedef unsigned int        cmsUInt16Number;
-#else
-#  error "Unable to find 16 bits unsigned type, unsupported compiler"
-#endif
-
-#if (SHRT_MAX == 32767)
-  typedef  short             cmsInt16Number;
-#elif (INT_MAX == 32767)
-  typedef  int               cmsInt16Number;
-#else
-#  error "Unable to find 16 bits signed type, unsupported compiler"
-#endif
-
-// 32-bit base type
-#if (UINT_MAX == 4294967295U)
- typedef unsigned int        cmsUInt32Number;
-#elif (ULONG_MAX == 4294967295U)
- typedef unsigned long       cmsUInt32Number;
-#else
-#  error "Unable to find 32 bit unsigned type, unsupported compiler"
-#endif
-
-#if (INT_MAX == +2147483647)
- typedef  int                cmsInt32Number;
-#elif (LONG_MAX == +2147483647)
- typedef  long               cmsInt32Number;
-#else
-#  error "Unable to find 32 bit signed type, unsupported compiler"
-#endif
-
-// 64-bit base types
-#ifndef CMS_DONT_USE_INT64
-#  if (ULONG_MAX  == 18446744073709551615U)
-    typedef unsigned long   cmsUInt64Number;
-#  elif (ULLONG_MAX == 18446744073709551615U)
-      typedef unsigned long long   cmsUInt64Number;
-#  else
-#     define CMS_DONT_USE_INT64 1
-#  endif
-#  if (LONG_MAX == +9223372036854775807)
-      typedef  long          cmsInt64Number;
-#  elif (LLONG_MAX == +9223372036854775807)
-      typedef  long long     cmsInt64Number;
-#  else
-#     define CMS_DONT_USE_INT64 1
-#  endif
-#endif
-#endif
-
-// In the case 64 bit numbers are not supported by the compiler
-#ifdef CMS_DONT_USE_INT64
-    typedef cmsUInt32Number      cmsUInt64Number[2];
-    typedef cmsInt32Number       cmsInt64Number[2];
-#endif
-
-// Derivative types
-typedef cmsUInt32Number      cmsSignature;
-typedef cmsUInt16Number      cmsU8Fixed8Number;
-typedef cmsInt32Number       cmsS15Fixed16Number;
-typedef cmsUInt32Number      cmsU16Fixed16Number;
-
-// Boolean type, which will be using the native integer
-typedef int                  cmsBool;
-
-// Try to detect windows
-#if defined (_WIN32) || defined(_WIN64) || defined(WIN32) || defined(_WIN32_)
-#  define CMS_IS_WINDOWS_ 1
-#endif
-
-#ifdef _MSC_VER
-#  define CMS_IS_WINDOWS_ 1
-#endif
-
-#ifdef __BORLANDC__
-#  define CMS_IS_WINDOWS_ 1
-#endif
-
-// Try to detect big endian platforms. This list can be endless, so only some checks are performed over here.
-// you can pass this toggle to the compiler by using -DCMS_USE_BIG_ENDIAN or something similar
-
-#if defined(_HOST_BIG_ENDIAN) || defined(__BIG_ENDIAN__) || defined(WORDS_BIGENDIAN)
-#   define CMS_USE_BIG_ENDIAN      1
-#endif
-
-#if defined(__sgi__) || defined(__sgi) || defined(__powerpc__) || defined(sparc)
-#   define CMS_USE_BIG_ENDIAN      1
-#endif
-
-#if defined(__ppc__) || defined(__s390__) || defined(__s390x__)
-#   define CMS_USE_BIG_ENDIAN   1
-#endif
-
-#if TARGET_CPU_PPC
-#   define CMS_USE_BIG_ENDIAN   1
-#endif
-
-#ifdef macintosh
-# ifdef __BIG_ENDIAN__
-#   define CMS_USE_BIG_ENDIAN      1
-# endif
-#endif
-
-// Calling convention -- this is hardly platform and compiler dependent
-#ifdef CMS_IS_WINDOWS_
-#  if defined(CMS_DLL) || defined(CMS_DLL_BUILD)
-#     ifdef __BORLANDC__
-#        define CMSEXPORT       __stdcall _export
-#        define CMSAPI
-#     else
-#        define CMSEXPORT      _stdcall
-#        ifdef CMS_DLL_BUILD
-#            define CMSAPI    __declspec(dllexport)
-#        else
-#           define CMSAPI     __declspec(dllimport)
-#       endif
-#     endif
-#  else
-#       define CMSEXPORT
-#       define CMSAPI
-#  endif
-#else
-# define CMSEXPORT
-# define CMSAPI
-#endif
-
-// Some common definitions
-#define cmsMAX_PATH     256
-
-#ifndef FALSE
-#       define FALSE 0
-#endif
-#ifndef TRUE
-#       define TRUE  1
-#endif
-
-// D50 XYZ normalized to Y=1.0
-#define cmsD50X             0.9642
-#define cmsD50Y             1.0
-#define cmsD50Z             0.8249
-
-// V4 perceptual black
-#define cmsPERCEPTUAL_BLACK_X  0.00336
-#define cmsPERCEPTUAL_BLACK_Y  0.0034731
-#define cmsPERCEPTUAL_BLACK_Z  0.00287
-
-// Definitions in ICC spec
-#define cmsMagicNumber      0x61637370     // 'acsp'
-#define lcmsSignature       0x6c636d73     // 'lcms'
-
-
-// Base ICC type definitions
-typedef enum {
-    cmsSigChromaticityType                  = 0x6368726D,  // 'chrm'
-    cmsSigColorantOrderType                 = 0x636C726F,  // 'clro'
-    cmsSigColorantTableType                 = 0x636C7274,  // 'clrt'
-    cmsSigCrdInfoType                       = 0x63726469,  // 'crdi'
-    cmsSigCurveType                         = 0x63757276,  // 'curv'
-    cmsSigDataType                          = 0x64617461,  // 'data'
-    cmsSigDateTimeType                      = 0x6474696D,  // 'dtim'
-    cmsSigDeviceSettingsType                = 0x64657673,  // 'devs'
-    cmsSigLut16Type                         = 0x6d667432,  // 'mft2'
-    cmsSigLut8Type                          = 0x6d667431,  // 'mft1'
-    cmsSigLutAtoBType                       = 0x6d414220,  // 'mAB '
-    cmsSigLutBtoAType                       = 0x6d424120,  // 'mBA '
-    cmsSigMeasurementType                   = 0x6D656173,  // 'meas'
-    cmsSigMultiLocalizedUnicodeType         = 0x6D6C7563,  // 'mluc'
-    cmsSigMultiProcessElementType           = 0x6D706574,  // 'mpet'
-    cmsSigNamedColorType                    = 0x6E636f6C,  // 'ncol' -- DEPRECATED!
-    cmsSigNamedColor2Type                   = 0x6E636C32,  // 'ncl2'
-    cmsSigParametricCurveType               = 0x70617261,  // 'para'
-    cmsSigProfileSequenceDescType           = 0x70736571,  // 'pseq'
-    cmsSigProfileSequenceIdType             = 0x70736964,  // 'psid'
-    cmsSigResponseCurveSet16Type            = 0x72637332,  // 'rcs2'
-    cmsSigS15Fixed16ArrayType               = 0x73663332,  // 'sf32'
-    cmsSigScreeningType                     = 0x7363726E,  // 'scrn'
-    cmsSigSignatureType                     = 0x73696720,  // 'sig '
-    cmsSigTextType                          = 0x74657874,  // 'text'
-    cmsSigTextDescriptionType               = 0x64657363,  // 'desc'
-    cmsSigU16Fixed16ArrayType               = 0x75663332,  // 'uf32'
-    cmsSigUcrBgType                         = 0x62666420,  // 'bfd '
-    cmsSigUInt16ArrayType                   = 0x75693136,  // 'ui16'
-    cmsSigUInt32ArrayType                   = 0x75693332,  // 'ui32'
-    cmsSigUInt64ArrayType                   = 0x75693634,  // 'ui64'
-    cmsSigUInt8ArrayType                    = 0x75693038,  // 'ui08'
-    cmsSigViewingConditionsType             = 0x76696577,  // 'view'
-    cmsSigXYZType                           = 0x58595A20,  // 'XYZ '
-    cmsSigVcgtType                          = 0x76636774   // 'vcgt'
-
-} cmsTagTypeSignature;
-
-// Base ICC tag definitions
-typedef enum {
-    cmsSigAToB0Tag                          = 0x41324230,  // 'A2B0'
-    cmsSigAToB1Tag                          = 0x41324231,  // 'A2B1'
-    cmsSigAToB2Tag                          = 0x41324232,  // 'A2B2'
-    cmsSigBlueColorantTag                   = 0x6258595A,  // 'bXYZ'
-    cmsSigBlueMatrixColumnTag               = 0x6258595A,  // 'bXYZ'
-    cmsSigBlueTRCTag                        = 0x62545243,  // 'bTRC'
-    cmsSigBToA0Tag                          = 0x42324130,  // 'B2A0'
-    cmsSigBToA1Tag                          = 0x42324131,  // 'B2A1'
-    cmsSigBToA2Tag                          = 0x42324132,  // 'B2A2'
-    cmsSigCalibrationDateTimeTag            = 0x63616C74,  // 'calt'
-    cmsSigCharTargetTag                     = 0x74617267,  // 'targ'
-    cmsSigChromaticAdaptationTag            = 0x63686164,  // 'chad'
-    cmsSigChromaticityTag                   = 0x6368726D,  // 'chrm'
-    cmsSigColorantOrderTag                  = 0x636C726F,  // 'clro'
-    cmsSigColorantTableTag                  = 0x636C7274,  // 'clrt'
-    cmsSigColorantTableOutTag               = 0x636C6F74,  // 'clot'
-    cmsSigColorimetricIntentImageStateTag   = 0x63696973,  // 'ciis'
-    cmsSigCopyrightTag                      = 0x63707274,  // 'cprt'
-    cmsSigCrdInfoTag                        = 0x63726469,  // 'crdi'
-    cmsSigDataTag                           = 0x64617461,  // 'data'
-    cmsSigDateTimeTag                       = 0x6474696D,  // 'dtim'
-    cmsSigDeviceMfgDescTag                  = 0x646D6E64,  // 'dmnd'
-    cmsSigDeviceModelDescTag                = 0x646D6464,  // 'dmdd'
-    cmsSigDeviceSettingsTag                 = 0x64657673,  // 'devs'
-    cmsSigDToB0Tag                          = 0x44324230,  // 'D2B0'
-    cmsSigDToB1Tag                          = 0x44324231,  // 'D2B1'
-    cmsSigDToB2Tag                          = 0x44324232,  // 'D2B2'
-    cmsSigDToB3Tag                          = 0x44324233,  // 'D2B3'
-    cmsSigBToD0Tag                          = 0x42324430,  // 'B2D0'
-    cmsSigBToD1Tag                          = 0x42324431,  // 'B2D1'
-    cmsSigBToD2Tag                          = 0x42324432,  // 'B2D2'
-    cmsSigBToD3Tag                          = 0x42324433,  // 'B2D3'
-    cmsSigGamutTag                          = 0x67616D74,  // 'gamt'
-    cmsSigGrayTRCTag                        = 0x6b545243,  // 'kTRC'
-    cmsSigGreenColorantTag                  = 0x6758595A,  // 'gXYZ'
-    cmsSigGreenMatrixColumnTag              = 0x6758595A,  // 'gXYZ'
-    cmsSigGreenTRCTag                       = 0x67545243,  // 'gTRC'
-    cmsSigLuminanceTag                      = 0x6C756d69,  // 'lumi'
-    cmsSigMeasurementTag                    = 0x6D656173,  // 'meas'
-    cmsSigMediaBlackPointTag                = 0x626B7074,  // 'bkpt'
-    cmsSigMediaWhitePointTag                = 0x77747074,  // 'wtpt'
-    cmsSigNamedColorTag                     = 0x6E636f6C,  // 'ncol' // Deprecated by the ICC
-    cmsSigNamedColor2Tag                    = 0x6E636C32,  // 'ncl2'
-    cmsSigOutputResponseTag                 = 0x72657370,  // 'resp'
-    cmsSigPerceptualRenderingIntentGamutTag = 0x72696730,  // 'rig0'
-    cmsSigPreview0Tag                       = 0x70726530,  // 'pre0'
-    cmsSigPreview1Tag                       = 0x70726531,  // 'pre1'
-    cmsSigPreview2Tag                       = 0x70726532,  // 'pre2'
-    cmsSigProfileDescriptionTag             = 0x64657363,  // 'desc'
-    cmsSigProfileSequenceDescTag            = 0x70736571,  // 'pseq'
-    cmsSigProfileSequenceIdTag              = 0x70736964,  // 'psid'
-    cmsSigPs2CRD0Tag                        = 0x70736430,  // 'psd0'
-    cmsSigPs2CRD1Tag                        = 0x70736431,  // 'psd1'
-    cmsSigPs2CRD2Tag                        = 0x70736432,  // 'psd2'
-    cmsSigPs2CRD3Tag                        = 0x70736433,  // 'psd3'
-    cmsSigPs2CSATag                         = 0x70733273,  // 'ps2s'
-    cmsSigPs2RenderingIntentTag             = 0x70733269,  // 'ps2i'
-    cmsSigRedColorantTag                    = 0x7258595A,  // 'rXYZ'
-    cmsSigRedMatrixColumnTag                = 0x7258595A,  // 'rXYZ'
-    cmsSigRedTRCTag                         = 0x72545243,  // 'rTRC'
-    cmsSigSaturationRenderingIntentGamutTag = 0x72696732,  // 'rig2'
-    cmsSigScreeningDescTag                  = 0x73637264,  // 'scrd'
-    cmsSigScreeningTag                      = 0x7363726E,  // 'scrn'
-    cmsSigTechnologyTag                     = 0x74656368,  // 'tech'
-    cmsSigUcrBgTag                          = 0x62666420,  // 'bfd '
-    cmsSigViewingCondDescTag                = 0x76756564,  // 'vued'
-    cmsSigViewingConditionsTag              = 0x76696577,  // 'view'
-    cmsSigVcgtTag                           = 0x76636774   // 'vcgt'
-
-} cmsTagSignature;
-
-
-// ICC Technology tag
-typedef enum {
-    cmsSigDigitalCamera                     = 0x6463616D,  // 'dcam'
-    cmsSigFilmScanner                       = 0x6673636E,  // 'fscn'
-    cmsSigReflectiveScanner                 = 0x7273636E,  // 'rscn'
-    cmsSigInkJetPrinter                     = 0x696A6574,  // 'ijet'
-    cmsSigThermalWaxPrinter                 = 0x74776178,  // 'twax'
-    cmsSigElectrophotographicPrinter        = 0x6570686F,  // 'epho'
-    cmsSigElectrostaticPrinter              = 0x65737461,  // 'esta'
-    cmsSigDyeSublimationPrinter             = 0x64737562,  // 'dsub'
-    cmsSigPhotographicPaperPrinter          = 0x7270686F,  // 'rpho'
-    cmsSigFilmWriter                        = 0x6670726E,  // 'fprn'
-    cmsSigVideoMonitor                      = 0x7669646D,  // 'vidm'
-    cmsSigVideoCamera                       = 0x76696463,  // 'vidc'
-    cmsSigProjectionTelevision              = 0x706A7476,  // 'pjtv'
-    cmsSigCRTDisplay                        = 0x43525420,  // 'CRT '
-    cmsSigPMDisplay                         = 0x504D4420,  // 'PMD '
-    cmsSigAMDisplay                         = 0x414D4420,  // 'AMD '
-    cmsSigPhotoCD                           = 0x4B504344,  // 'KPCD'
-    cmsSigPhotoImageSetter                  = 0x696D6773,  // 'imgs'
-    cmsSigGravure                           = 0x67726176,  // 'grav'
-    cmsSigOffsetLithography                 = 0x6F666673,  // 'offs'
-    cmsSigSilkscreen                        = 0x73696C6B,  // 'silk'
-    cmsSigFlexography                       = 0x666C6578,  // 'flex'
-    cmsSigMotionPictureFilmScanner          = 0x6D706673,  // 'mpfs'
-    cmsSigMotionPictureFilmRecorder         = 0x6D706672,  // 'mpfr'
-    cmsSigDigitalMotionPictureCamera        = 0x646D7063,  // 'dmpc'
-    cmsSigDigitalCinemaProjector            = 0x64636A70   // 'dcpj'
-
-} cmsTechnologySignature;
-
-
-// ICC Color spaces
-typedef enum {
-    cmsSigXYZData                           = 0x58595A20,  // 'XYZ '
-    cmsSigLabData                           = 0x4C616220,  // 'Lab '
-    cmsSigLuvData                           = 0x4C757620,  // 'Luv '
-    cmsSigYCbCrData                         = 0x59436272,  // 'YCbr'
-    cmsSigYxyData                           = 0x59787920,  // 'Yxy '
-    cmsSigRgbData                           = 0x52474220,  // 'RGB '
-    cmsSigGrayData                          = 0x47524159,  // 'GRAY'
-    cmsSigHsvData                           = 0x48535620,  // 'HSV '
-    cmsSigHlsData                           = 0x484C5320,  // 'HLS '
-    cmsSigCmykData                          = 0x434D594B,  // 'CMYK'
-    cmsSigCmyData                           = 0x434D5920,  // 'CMY '
-    cmsSigMCH1Data                          = 0x4D434831,  // 'MCH1'
-    cmsSigMCH2Data                          = 0x4D434832,  // 'MCH2'
-    cmsSigMCH3Data                          = 0x4D434833,  // 'MCH3'
-    cmsSigMCH4Data                          = 0x4D434834,  // 'MCH4'
-    cmsSigMCH5Data                          = 0x4D434835,  // 'MCH5'
-    cmsSigMCH6Data                          = 0x4D434836,  // 'MCH6'
-    cmsSigMCH7Data                          = 0x4D434837,  // 'MCH7'
-    cmsSigMCH8Data                          = 0x4D434838,  // 'MCH8'
-    cmsSigMCH9Data                          = 0x4D434839,  // 'MCH9'
-    cmsSigMCHAData                          = 0x4D43483A,  // 'MCHA'
-    cmsSigMCHBData                          = 0x4D43483B,  // 'MCHB'
-    cmsSigMCHCData                          = 0x4D43483C,  // 'MCHC'
-    cmsSigMCHDData                          = 0x4D43483D,  // 'MCHD'
-    cmsSigMCHEData                          = 0x4D43483E,  // 'MCHE'
-    cmsSigMCHFData                          = 0x4D43483F,  // 'MCHF'
-    cmsSigNamedData                         = 0x6e6d636c,  // 'nmcl'
-    cmsSig1colorData                        = 0x31434C52,  // '1CLR'
-    cmsSig2colorData                        = 0x32434C52,  // '2CLR'
-    cmsSig3colorData                        = 0x33434C52,  // '3CLR'
-    cmsSig4colorData                        = 0x34434C52,  // '4CLR'
-    cmsSig5colorData                        = 0x35434C52,  // '5CLR'
-    cmsSig6colorData                        = 0x36434C52,  // '6CLR'
-    cmsSig7colorData                        = 0x37434C52,  // '7CLR'
-    cmsSig8colorData                        = 0x38434C52,  // '8CLR'
-    cmsSig9colorData                        = 0x39434C52,  // '9CLR'
-    cmsSig10colorData                       = 0x41434C52,  // 'ACLR'
-    cmsSig11colorData                       = 0x42434C52,  // 'BCLR'
-    cmsSig12colorData                       = 0x43434C52,  // 'CCLR'
-    cmsSig13colorData                       = 0x44434C52,  // 'DCLR'
-    cmsSig14colorData                       = 0x45434C52,  // 'ECLR'
-    cmsSig15colorData                       = 0x46434C52,  // 'FCLR'
-    cmsSigLuvKData                          = 0x4C75764B   // 'LuvK'
-
-} cmsColorSpaceSignature;
-
-// ICC Profile Class
-typedef enum {
-    cmsSigInputClass                        = 0x73636E72,  // 'scnr'
-    cmsSigDisplayClass                      = 0x6D6E7472,  // 'mntr'
-    cmsSigOutputClass                       = 0x70727472,  // 'prtr'
-    cmsSigLinkClass                         = 0x6C696E6B,  // 'link'
-    cmsSigAbstractClass                     = 0x61627374,  // 'abst'
-    cmsSigColorSpaceClass                   = 0x73706163,  // 'spac'
-    cmsSigNamedColorClass                   = 0x6e6d636c   // 'nmcl'
-
-} cmsProfileClassSignature;
-
-// ICC Platforms
-typedef enum {
-    cmsSigMacintosh                         = 0x4150504C,  // 'APPL'
-    cmsSigMicrosoft                         = 0x4D534654,  // 'MSFT'
-    cmsSigSolaris                           = 0x53554E57,  // 'SUNW'
-    cmsSigSGI                               = 0x53474920,  // 'SGI '
-    cmsSigTaligent                          = 0x54474E54,  // 'TGNT'
-    cmsSigUnices                            = 0x2A6E6978   // '*nix'   // From argyll -- Not official
-
-} cmsPlatformSignature;
-
-// Reference gamut
-#define  cmsSigPerceptualReferenceMediumGamut         0x70726d67  //'prmg'
-
-// For cmsSigColorimetricIntentImageStateTag
-#define  cmsSigSceneColorimetryEstimates              0x73636F65  //'scoe'
-#define  cmsSigSceneAppearanceEstimates               0x73617065  //'sape'
-#define  cmsSigFocalPlaneColorimetryEstimates         0x66706365  //'fpce'
-#define  cmsSigReflectionHardcopyOriginalColorimetry  0x72686F63  //'rhoc'
-#define  cmsSigReflectionPrintOutputColorimetry       0x72706F63  //'rpoc'
-
-// Multi process elements types
-typedef enum {
-    cmsSigCurveSetElemType              = 0x63767374,  //'cvst'
-    cmsSigMatrixElemType                = 0x6D617466,  //'matf'
-    cmsSigCLutElemType                  = 0x636C7574,  //'clut'
-
-    cmsSigBAcsElemType                  = 0x62414353,  // 'bACS'
-    cmsSigEAcsElemType                  = 0x65414353,  // 'eACS'
-
-    // Custom from here, not in the ICC Spec
-    cmsSigXYZ2LabElemType               = 0x6C327820,  // 'l2x '
-    cmsSigLab2XYZElemType               = 0x78326C20,  // 'x2l '
-    cmsSigNamedColorElemType            = 0x6E636C20,  // 'ncl '
-    cmsSigLabV2toV4                     = 0x32203420,  // '2 4 '
-    cmsSigLabV4toV2                     = 0x34203220,  // '4 2 '
-
-    // Identities
-    cmsSigIdentityElemType              = 0x69646E20   // 'idn '
-
-} cmsStageSignature;
-
-// Types of CurveElements
-typedef enum {
-
-    cmsSigFormulaCurveSeg               = 0x70617266, // 'parf'
-    cmsSigSampledCurveSeg               = 0x73616D66, // 'samf'
-    cmsSigSegmentedCurve                = 0x63757266  // 'curf'
-
-} cmsCurveSegSignature;
-
-// Used in ResponseCurveType
-#define  cmsSigStatusA                    0x53746141 //'StaA'
-#define  cmsSigStatusE                    0x53746145 //'StaE'
-#define  cmsSigStatusI                    0x53746149 //'StaI'
-#define  cmsSigStatusT                    0x53746154 //'StaT'
-#define  cmsSigStatusM                    0x5374614D //'StaM'
-#define  cmsSigDN                         0x444E2020 //'DN  '
-#define  cmsSigDNP                        0x444E2050 //'DN P'
-#define  cmsSigDNN                        0x444E4E20 //'DNN '
-#define  cmsSigDNNP                       0x444E4E50 //'DNNP'
-
-// Device attributes, currently defined values correspond to the low 4 bytes
-// of the 8 byte attribute quantity
-#define cmsReflective     0
-#define cmsTransparency   1
-#define cmsGlossy         0
-#define cmsMatte          2
-
-// Common structures in ICC tags
-typedef struct {
-    cmsUInt32Number len;
-    cmsUInt32Number flag;
-    cmsUInt8Number  data[1];
-
-} cmsICCData;
-
-// ICC date time
-typedef struct {
-    cmsUInt16Number      year;
-    cmsUInt16Number      month;
-    cmsUInt16Number      day;
-    cmsUInt16Number      hours;
-    cmsUInt16Number      minutes;
-    cmsUInt16Number      seconds;
-
-} cmsDateTimeNumber;
-
-// ICC XYZ
-typedef struct {
-    cmsS15Fixed16Number  X;
-    cmsS15Fixed16Number  Y;
-    cmsS15Fixed16Number  Z;
-
-} cmsEncodedXYZNumber;
-
-
-// Profile ID as computed by MD5 algorithm
-typedef union {
-    cmsUInt8Number       ID8[16];
-    cmsUInt16Number      ID16[8];
-    cmsUInt32Number      ID32[4];
-
-} cmsProfileID;
-
-
-// ----------------------------------------------------------------------------------------------
-// ICC profile internal base types. Strictly, shouldn't be declared in this header, but maybe
-// somebody want to use this info for accessing profile header directly, so here it is.
-
-// Profile header -- it is 32-bit aligned, so no issues are expected on alignment
-typedef struct {
-    cmsUInt32Number              size;           // Profile size in bytes
-    cmsSignature                 cmmId;          // CMM for this profile
-    cmsUInt32Number              version;        // Format version number
-    cmsProfileClassSignature     deviceClass;    // Type of profile
-    cmsColorSpaceSignature       colorSpace;     // Color space of data
-    cmsColorSpaceSignature       pcs;            // PCS, XYZ or Lab only
-    cmsDateTimeNumber            date;           // Date profile was created
-    cmsSignature                 magic;          // Magic Number to identify an ICC profile
-    cmsPlatformSignature         platform;       // Primary Platform
-    cmsUInt32Number              flags;          // Various bit settings
-    cmsSignature                 manufacturer;   // Device manufacturer
-    cmsUInt32Number              model;          // Device model number
-    cmsUInt64Number              attributes;     // Device attributes
-    cmsUInt32Number              renderingIntent;// Rendering intent
-    cmsEncodedXYZNumber          illuminant;     // Profile illuminant
-    cmsSignature                 creator;        // Profile creator
-    cmsProfileID                 profileID;      // Profile ID using MD5
-    cmsInt8Number                reserved[28];   // Reserved for future use
-
-} cmsICCHeader;
-
-// ICC base tag
-typedef struct {
-    cmsTagTypeSignature  sig;
-    cmsInt8Number        reserved[4];
-
-} cmsTagBase;
-
-// A tag entry in directory
-typedef struct {
-    cmsTagSignature      sig;            // The tag signature
-    cmsUInt32Number      offset;         // Start of tag
-    cmsUInt32Number      size;           // Size in bytes
-
-} cmsTagEntry;
-
-// ----------------------------------------------------------------------------------------------
-
-// Little CMS specific typedefs
-
-typedef void* cmsContext;              // Context identifier for multithreaded environments
-typedef void* cmsHANDLE ;              // Generic handle
-typedef void* cmsHPROFILE;             // Opaque typedefs to hide internals
-typedef void* cmsHTRANSFORM;
-
-#define cmsMAXCHANNELS  16                // Maximum number of channels in ICC profiles
-
-// Format of pixel is defined by one cmsUInt32Number, using bit fields as follows
-//
-//            A O TTTTT U Y F P X S EEE CCCC BBB
-//
-//            A: Floating point -- With this flag we can differentiate 16 bits as float and as int
-//            O: Optimized -- previous optimization already returns the final 8-bit value
-//            T: Pixeltype
-//            F: Flavor  0=MinIsBlack(Chocolate) 1=MinIsWhite(Vanilla)
-//            P: Planar? 0=Chunky, 1=Planar
-//            X: swap 16 bps endianess?
-//            S: Do swap? ie, BGR, KYMC
-//            E: Extra samples
-//            C: Channels (Samples per pixel)
-//            B: bytes per sample
-//            Y: Swap first - changes ABGR to BGRA and KCMY to CMYK
-
-#define FLOAT_SH(a)            ((a) << 22)
-#define OPTIMIZED_SH(s)        ((s) << 21)
-#define COLORSPACE_SH(s)       ((s) << 16)
-#define SWAPFIRST_SH(s)        ((s) << 14)
-#define FLAVOR_SH(s)           ((s) << 13)
-#define PLANAR_SH(p)           ((p) << 12)
-#define ENDIAN16_SH(e)         ((e) << 11)
-#define DOSWAP_SH(e)           ((e) << 10)
-#define EXTRA_SH(e)            ((e) << 7)
-#define CHANNELS_SH(c)         ((c) << 3)
-#define BYTES_SH(b)            (b)
-
-// These macros unpack format specifiers into integers
-#define T_FLOAT(a)            (((a)>>22)&1)
-#define T_OPTIMIZED(o)        (((o)>>21)&1)
-#define T_COLORSPACE(s)       (((s)>>16)&31)
-#define T_SWAPFIRST(s)        (((s)>>14)&1)
-#define T_FLAVOR(s)           (((s)>>13)&1)
-#define T_PLANAR(p)           (((p)>>12)&1)
-#define T_ENDIAN16(e)         (((e)>>11)&1)
-#define T_DOSWAP(e)           (((e)>>10)&1)
-#define T_EXTRA(e)            (((e)>>7)&7)
-#define T_CHANNELS(c)         (((c)>>3)&15)
-#define T_BYTES(b)            ((b)&7)
-
-
-// Pixel types
-#define PT_ANY       0    // Don't check colorspace
-                          // 1 & 2 are reserved
-#define PT_GRAY      3
-#define PT_RGB       4
-#define PT_CMY       5
-#define PT_CMYK      6
-#define PT_YCbCr     7
-#define PT_YUV       8      // Lu'v'
-#define PT_XYZ       9
-#define PT_Lab       10
-#define PT_YUVK      11     // Lu'v'K
-#define PT_HSV       12
-#define PT_HLS       13
-#define PT_Yxy       14
-
-#define PT_MCH1      15
-#define PT_MCH2      16
-#define PT_MCH3      17
-#define PT_MCH4      18
-#define PT_MCH5      19
-#define PT_MCH6      20
-#define PT_MCH7      21
-#define PT_MCH8      22
-#define PT_MCH9      23
-#define PT_MCH10     24
-#define PT_MCH11     25
-#define PT_MCH12     26
-#define PT_MCH13     27
-#define PT_MCH14     28
-#define PT_MCH15     29
-
-#define PT_LabV2     30     // Identical to PT_Lab, but using the V2 old encoding
-
-// Some (not all!) representations
-
-#ifndef TYPE_RGB_8      // TYPE_RGB_8 is a very common identifier, so don't include ours
-                        // if user has it already defined.
-
-#define TYPE_GRAY_8            (COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(1))
-#define TYPE_GRAY_8_REV        (COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(1)|FLAVOR_SH(1))
-#define TYPE_GRAY_16           (COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(2))
-#define TYPE_GRAY_16_REV       (COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(2)|FLAVOR_SH(1))
-#define TYPE_GRAY_16_SE        (COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_GRAYA_8           (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(1))
-#define TYPE_GRAYA_16          (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(2))
-#define TYPE_GRAYA_16_SE       (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_GRAYA_8_PLANAR    (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_GRAYA_16_PLANAR   (COLORSPACE_SH(PT_GRAY)|EXTRA_SH(1)|CHANNELS_SH(1)|BYTES_SH(2)|PLANAR_SH(1))
-
-#define TYPE_RGB_8             (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_RGB_8_PLANAR      (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_BGR_8             (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_BGR_8_PLANAR      (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|PLANAR_SH(1))
-#define TYPE_RGB_16            (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_RGB_16_PLANAR     (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_RGB_16_SE         (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_BGR_16            (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_BGR_16_PLANAR     (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|PLANAR_SH(1))
-#define TYPE_BGR_16_SE         (COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-
-#define TYPE_RGBA_8            (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_RGBA_8_PLANAR     (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_RGBA_16           (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_RGBA_16_PLANAR    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_RGBA_16_SE        (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-#define TYPE_ARGB_8            (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_ARGB_16           (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|SWAPFIRST_SH(1))
-
-#define TYPE_ABGR_8            (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_ABGR_16           (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_ABGR_16_PLANAR    (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|PLANAR_SH(1))
-#define TYPE_ABGR_16_SE        (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-
-#define TYPE_BGRA_8            (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_BGRA_16           (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_BGRA_16_SE        (COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1)|SWAPFIRST_SH(1))
-
-#define TYPE_CMY_8             (COLORSPACE_SH(PT_CMY)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_CMY_8_PLANAR      (COLORSPACE_SH(PT_CMY)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_CMY_16            (COLORSPACE_SH(PT_CMY)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_CMY_16_PLANAR     (COLORSPACE_SH(PT_CMY)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_CMY_16_SE         (COLORSPACE_SH(PT_CMY)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-#define TYPE_CMYK_8            (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1))
-#define TYPE_CMYKA_8           (COLORSPACE_SH(PT_CMYK)|EXTRA_SH(1)|CHANNELS_SH(4)|BYTES_SH(1))
-#define TYPE_CMYK_8_REV        (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1))
-#define TYPE_YUVK_8            TYPE_CMYK_8_REV
-#define TYPE_CMYK_8_PLANAR     (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_CMYK_16           (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2))
-#define TYPE_CMYK_16_REV       (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|FLAVOR_SH(1))
-#define TYPE_YUVK_16           TYPE_CMYK_16_REV
-#define TYPE_CMYK_16_PLANAR    (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_CMYK_16_SE        (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-#define TYPE_KYMC_8            (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC_16           (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC_16_SE        (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-
-#define TYPE_KCMY_8            (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_KCMY_8_REV        (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_KCMY_16           (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|SWAPFIRST_SH(1))
-#define TYPE_KCMY_16_REV       (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|FLAVOR_SH(1)|SWAPFIRST_SH(1))
-#define TYPE_KCMY_16_SE        (COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(2)|ENDIAN16_SH(1)|SWAPFIRST_SH(1))
-
-#define TYPE_CMYK5_8           (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(1))
-#define TYPE_CMYK5_16          (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(2))
-#define TYPE_CMYK5_16_SE       (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC5_8           (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC5_16          (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC5_16_SE       (COLORSPACE_SH(PT_MCH5)|CHANNELS_SH(5)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK6_8           (COLORSPACE_SH(PT_MCH6)|CHANNELS_SH(6)|BYTES_SH(1))
-#define TYPE_CMYK6_8_PLANAR    (COLORSPACE_SH(PT_MCH6)|CHANNELS_SH(6)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_CMYK6_16          (COLORSPACE_SH(PT_MCH6)|CHANNELS_SH(6)|BYTES_SH(2))
-#define TYPE_CMYK6_16_PLANAR   (COLORSPACE_SH(PT_MCH6)|CHANNELS_SH(6)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_CMYK6_16_SE       (COLORSPACE_SH(PT_MCH6)|CHANNELS_SH(6)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_CMYK7_8           (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(1))
-#define TYPE_CMYK7_16          (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(2))
-#define TYPE_CMYK7_16_SE       (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC7_8           (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC7_16          (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC7_16_SE       (COLORSPACE_SH(PT_MCH7)|CHANNELS_SH(7)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK8_8           (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(1))
-#define TYPE_CMYK8_16          (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(2))
-#define TYPE_CMYK8_16_SE       (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC8_8           (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC8_16          (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC8_16_SE       (COLORSPACE_SH(PT_MCH8)|CHANNELS_SH(8)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK9_8           (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(1))
-#define TYPE_CMYK9_16          (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(2))
-#define TYPE_CMYK9_16_SE       (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC9_8           (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC9_16          (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC9_16_SE       (COLORSPACE_SH(PT_MCH9)|CHANNELS_SH(9)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK10_8          (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(1))
-#define TYPE_CMYK10_16         (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(2))
-#define TYPE_CMYK10_16_SE      (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC10_8          (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC10_16         (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC10_16_SE      (COLORSPACE_SH(PT_MCH10)|CHANNELS_SH(10)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK11_8          (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(1))
-#define TYPE_CMYK11_16         (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(2))
-#define TYPE_CMYK11_16_SE      (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC11_8          (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC11_16         (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC11_16_SE      (COLORSPACE_SH(PT_MCH11)|CHANNELS_SH(11)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-#define TYPE_CMYK12_8          (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(1))
-#define TYPE_CMYK12_16         (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(2))
-#define TYPE_CMYK12_16_SE      (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(2)|ENDIAN16_SH(1))
-#define TYPE_KYMC12_8          (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(1)|DOSWAP_SH(1))
-#define TYPE_KYMC12_16         (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(2)|DOSWAP_SH(1))
-#define TYPE_KYMC12_16_SE      (COLORSPACE_SH(PT_MCH12)|CHANNELS_SH(12)|BYTES_SH(2)|DOSWAP_SH(1)|ENDIAN16_SH(1))
-
-// Colorimetric
-#define TYPE_XYZ_16            (COLORSPACE_SH(PT_XYZ)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_Lab_8             (COLORSPACE_SH(PT_Lab)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_LabV2_8           (COLORSPACE_SH(PT_LabV2)|CHANNELS_SH(3)|BYTES_SH(1))
-
-#define TYPE_ALab_8            (COLORSPACE_SH(PT_Lab)|CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|DOSWAP_SH(1))
-#define TYPE_ALabV2_8          (COLORSPACE_SH(PT_LabV2)|CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|DOSWAP_SH(1))
-#define TYPE_Lab_16            (COLORSPACE_SH(PT_Lab)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_LabV2_16          (COLORSPACE_SH(PT_LabV2)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_Yxy_16            (COLORSPACE_SH(PT_Yxy)|CHANNELS_SH(3)|BYTES_SH(2))
-
-// YCbCr
-#define TYPE_YCbCr_8           (COLORSPACE_SH(PT_YCbCr)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_YCbCr_8_PLANAR    (COLORSPACE_SH(PT_YCbCr)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_YCbCr_16          (COLORSPACE_SH(PT_YCbCr)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_YCbCr_16_PLANAR   (COLORSPACE_SH(PT_YCbCr)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_YCbCr_16_SE       (COLORSPACE_SH(PT_YCbCr)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-// YUV
-#define TYPE_YUV_8             (COLORSPACE_SH(PT_YUV)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_YUV_8_PLANAR      (COLORSPACE_SH(PT_YUV)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_YUV_16            (COLORSPACE_SH(PT_YUV)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_YUV_16_PLANAR     (COLORSPACE_SH(PT_YUV)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_YUV_16_SE         (COLORSPACE_SH(PT_YUV)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-// HLS
-#define TYPE_HLS_8             (COLORSPACE_SH(PT_HLS)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_HLS_8_PLANAR      (COLORSPACE_SH(PT_HLS)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_HLS_16            (COLORSPACE_SH(PT_HLS)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_HLS_16_PLANAR     (COLORSPACE_SH(PT_HLS)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_HLS_16_SE         (COLORSPACE_SH(PT_HLS)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-// HSV
-#define TYPE_HSV_8             (COLORSPACE_SH(PT_HSV)|CHANNELS_SH(3)|BYTES_SH(1))
-#define TYPE_HSV_8_PLANAR      (COLORSPACE_SH(PT_HSV)|CHANNELS_SH(3)|BYTES_SH(1)|PLANAR_SH(1))
-#define TYPE_HSV_16            (COLORSPACE_SH(PT_HSV)|CHANNELS_SH(3)|BYTES_SH(2))
-#define TYPE_HSV_16_PLANAR     (COLORSPACE_SH(PT_HSV)|CHANNELS_SH(3)|BYTES_SH(2)|PLANAR_SH(1))
-#define TYPE_HSV_16_SE         (COLORSPACE_SH(PT_HSV)|CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1))
-
-// Named color index. Only 16 bits allowed (don't check colorspace)
-#define TYPE_NAMED_COLOR_INDEX (CHANNELS_SH(1)|BYTES_SH(2))
-
-// Float formatters.
-#define TYPE_XYZ_FLT          (FLOAT_SH(1)|COLORSPACE_SH(PT_XYZ)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_XYZA_FLT         (FLOAT_SH(1)|COLORSPACE_SH(PT_XYZ)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_Lab_FLT          (FLOAT_SH(1)|COLORSPACE_SH(PT_Lab)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_LabA_FLT         (FLOAT_SH(1)|COLORSPACE_SH(PT_Lab)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_GRAY_FLT         (FLOAT_SH(1)|COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(4))
-#define TYPE_RGB_FLT          (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_RGBA_FLT         (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4))
-#define TYPE_CMYK_FLT         (FLOAT_SH(1)|COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(4))
-
-// Floating point formatters.  
-// NOTE THAT 'BYTES' FIELD IS SET TO ZERO ON DLB because 8 bytes overflows the bitfield
-#define TYPE_XYZ_DBL          (FLOAT_SH(1)|COLORSPACE_SH(PT_XYZ)|CHANNELS_SH(3)|BYTES_SH(0))
-#define TYPE_Lab_DBL          (FLOAT_SH(1)|COLORSPACE_SH(PT_Lab)|CHANNELS_SH(3)|BYTES_SH(0))
-#define TYPE_GRAY_DBL         (FLOAT_SH(1)|COLORSPACE_SH(PT_GRAY)|CHANNELS_SH(1)|BYTES_SH(0))
-#define TYPE_RGB_DBL          (FLOAT_SH(1)|COLORSPACE_SH(PT_RGB)|CHANNELS_SH(3)|BYTES_SH(0))
-#define TYPE_CMYK_DBL         (FLOAT_SH(1)|COLORSPACE_SH(PT_CMYK)|CHANNELS_SH(4)|BYTES_SH(0))
-
-#endif
-
-// Colorspaces
-typedef struct {
-        cmsFloat64Number X;
-        cmsFloat64Number Y;
-        cmsFloat64Number Z;
-
-    } cmsCIEXYZ;
-
-typedef struct {
-        cmsFloat64Number x;
-        cmsFloat64Number y;
-        cmsFloat64Number Y;
-
-    } cmsCIExyY;
-
-typedef struct {
-        cmsFloat64Number L;
-        cmsFloat64Number a;
-        cmsFloat64Number b;
-
-    } cmsCIELab;
-
-typedef struct {
-        cmsFloat64Number L;
-        cmsFloat64Number C;
-        cmsFloat64Number h;
-
-    } cmsCIELCh;
-
-typedef struct {
-        cmsFloat64Number J;
-        cmsFloat64Number C;
-        cmsFloat64Number h;
-
-    } cmsJCh;
-
-typedef struct {
-        cmsCIEXYZ  Red;
-        cmsCIEXYZ  Green;
-        cmsCIEXYZ  Blue;
-
-    } cmsCIEXYZTRIPLE;
-
-typedef struct {
-        cmsCIExyY  Red;
-        cmsCIExyY  Green;
-        cmsCIExyY  Blue;
-
-    } cmsCIExyYTRIPLE;
-
-// Illuminant types for structs below
-#define cmsILLUMINANT_TYPE_UNKNOWN 0x0000000
-#define cmsILLUMINANT_TYPE_D50     0x0000001
-#define cmsILLUMINANT_TYPE_D65     0x0000002
-#define cmsILLUMINANT_TYPE_D93     0x0000003
-#define cmsILLUMINANT_TYPE_F2      0x0000004
-#define cmsILLUMINANT_TYPE_D55     0x0000005
-#define cmsILLUMINANT_TYPE_A       0x0000006
-#define cmsILLUMINANT_TYPE_E       0x0000007
-#define cmsILLUMINANT_TYPE_F8      0x0000008
-
-typedef struct {
-        cmsUInt32Number  Observer;    // 0 = unknown, 1=CIE 1931, 2=CIE 1964
-        cmsCIEXYZ        Backing;     // Value of backing
-        cmsUInt32Number  Geometry;    // 0=unknown, 1=45/0, 0/45 2=0d, d/0
-        cmsFloat64Number Flare;       // 0..1.0
-        cmsUInt32Number  IlluminantType;
-
-    } cmsICCMeasurementConditions;
-
-typedef struct {
-        cmsCIEXYZ       IlluminantXYZ;   // Not the same struct as CAM02,
-        cmsCIEXYZ       SurroundXYZ;     // This is for storing the tag
-        cmsUInt32Number IlluminantType;  // viewing condition
-
-    } cmsICCViewingConditions;
-
-// Support of non-standard functions --------------------------------------------------------------------------------------
-
-CMSAPI int               CMSEXPORT cmsstrcasecmp(const char* s1, const char* s2);
-CMSAPI long int          CMSEXPORT cmsfilelength(FILE* f);
-
-// Plug-In registering  ---------------------------------------------------------------------------------------------------
-
-CMSAPI cmsBool           CMSEXPORT cmsPlugin(void* Plugin);
-CMSAPI void              CMSEXPORT cmsUnregisterPlugins(void);
-
-// Error logging ----------------------------------------------------------------------------------------------------------
-
-// There is no error handling at all. When a function fails, it returns proper value.
-// For example, all create functions does return NULL on failure. Other may return FALSE.
-// It may be interesting, for the developer, to know why the function is failing.
-// for that reason, lcms2 does offer a logging function. This function will get
-// an ENGLISH string with some clues on what is going wrong. You can show this
-// info to the end user if you wish, or just create some sort of log on disk.
-// The logging function should NOT terminate the program, as this obviously can leave
-// unfreed resources. It is the programmer's responsibility to check each function
-// return code to make sure it didn't fail.
-
-#define cmsERROR_UNDEFINED                    0
-#define cmsERROR_FILE                         1
-#define cmsERROR_RANGE                        2
-#define cmsERROR_INTERNAL                     3
-#define cmsERROR_NULL                         4
-#define cmsERROR_READ                         5
-#define cmsERROR_SEEK                         6
-#define cmsERROR_WRITE                        7
-#define cmsERROR_UNKNOWN_EXTENSION            8
-#define cmsERROR_COLORSPACE_CHECK             9
-#define cmsERROR_ALREADY_DEFINED              10
-#define cmsERROR_BAD_SIGNATURE                11
-#define cmsERROR_CORRUPTION_DETECTED          12
-#define cmsERROR_NOT_SUITABLE                 13
-
-// Error logger is called with the ContextID when a message is raised. This gives the
-// chance to know which thread is responsible of the warning and any environment associated
-// with it. Non-multithreading applications may safely ignore this parameter.
-// Note that under certain special circumstances, ContextID may be NULL.
-typedef void  (* cmsLogErrorHandlerFunction)(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text);
-
-// Allows user to set any specific logger
-CMSAPI void              CMSEXPORT cmsSetLogErrorHandler(cmsLogErrorHandlerFunction Fn);
-
-// Conversions --------------------------------------------------------------------------------------------------------------
-
-// Returns pointers to constant structs
-CMSAPI const cmsCIEXYZ*  CMSEXPORT cmsD50_XYZ(void);
-CMSAPI const cmsCIExyY*  CMSEXPORT cmsD50_xyY(void);
-
-// Colorimetric space conversions
-CMSAPI void              CMSEXPORT cmsXYZ2xyY(cmsCIExyY* Dest, const cmsCIEXYZ* Source);
-CMSAPI void              CMSEXPORT cmsxyY2XYZ(cmsCIEXYZ* Dest, const cmsCIExyY* Source);
-CMSAPI void              CMSEXPORT cmsXYZ2Lab(const cmsCIEXYZ* WhitePoint, cmsCIELab* Lab, const cmsCIEXYZ* xyz);
-CMSAPI void              CMSEXPORT cmsLab2XYZ(const cmsCIEXYZ* WhitePoint, cmsCIEXYZ* xyz, const cmsCIELab* Lab);
-CMSAPI void              CMSEXPORT cmsLab2LCh(cmsCIELCh*LCh, const cmsCIELab* Lab);
-CMSAPI void              CMSEXPORT cmsLCh2Lab(cmsCIELab* Lab, const cmsCIELCh* LCh);
-
-// Encoding /Decoding on PCS
-CMSAPI void              CMSEXPORT cmsLabEncoded2Float(cmsCIELab* Lab, const cmsUInt16Number wLab[3]);
-CMSAPI void              CMSEXPORT cmsLabEncoded2FloatV2(cmsCIELab* Lab, const cmsUInt16Number wLab[3]);
-CMSAPI void              CMSEXPORT cmsFloat2LabEncoded(cmsUInt16Number wLab[3], const cmsCIELab* Lab);
-CMSAPI void              CMSEXPORT cmsFloat2LabEncodedV2(cmsUInt16Number wLab[3], const cmsCIELab* Lab);
-CMSAPI void              CMSEXPORT cmsXYZEncoded2Float(cmsCIEXYZ* fxyz, const cmsUInt16Number XYZ[3]);
-CMSAPI void              CMSEXPORT cmsFloat2XYZEncoded(cmsUInt16Number XYZ[3], const cmsCIEXYZ* fXYZ);
-
-// DeltaE metrics
-CMSAPI cmsFloat64Number  CMSEXPORT cmsDeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsCIE94DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsBFDdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsCMCdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number l, cmsFloat64Number c);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsCIE2000DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number Kl, cmsFloat64Number Kc, cmsFloat64Number Kh);
-
-// Temperature <-> Chromaticity (Black body)
-CMSAPI cmsBool           CMSEXPORT cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number  TempK);
-CMSAPI cmsBool           CMSEXPORT cmsTempFromWhitePoint(cmsFloat64Number* TempK, const cmsCIExyY* WhitePoint);
-
-// Chromatic adaptation
-CMSAPI cmsBool           CMSEXPORT cmsAdaptToIlluminant(cmsCIEXYZ* Result, const cmsCIEXYZ* SourceWhitePt,
-                                                                           const cmsCIEXYZ* Illuminant,
-                                                                           const cmsCIEXYZ* Value);
-
-// CIECAM02 ---------------------------------------------------------------------------------------------------
-
-// Viewing conditions. Please note those are CAM model viewing conditions, and not the ICC tag viewing
-// conditions, which I'm naming cmsICCViewingConditions to make differences evident. Unfortunately, the tag
-// cannot deal with surround La, Yb and D value so is basically useless to store CAM02 viewing conditions.
-
-
-#define AVG_SURROUND       1
-#define DIM_SURROUND       2
-#define DARK_SURROUND      3
-#define CUTSHEET_SURROUND  4
-
-#define D_CALCULATE        (-1)
-
-typedef struct {
-    cmsCIEXYZ        whitePoint;
-    cmsFloat64Number Yb;
-    cmsFloat64Number La;
-    int              surround;
-    cmsFloat64Number D_value;
-
-    } cmsViewingConditions;
-
-CMSAPI cmsHANDLE         CMSEXPORT cmsCIECAM02Init(cmsContext ContextID, const cmsViewingConditions* pVC);
-CMSAPI void              CMSEXPORT cmsCIECAM02Done(cmsHANDLE hModel);
-CMSAPI void              CMSEXPORT cmsCIECAM02Forward(cmsHANDLE hModel, const cmsCIEXYZ* pIn, cmsJCh* pOut);
-CMSAPI void              CMSEXPORT cmsCIECAM02Reverse(cmsHANDLE hModel, const cmsJCh* pIn,    cmsCIEXYZ* pOut);
-
-
-// Tone curves -----------------------------------------------------------------------------------------
-
-// This describes a curve segment. For a table of supported types, see the manual. User can increase the number of
-// available types by using a proper plug-in. Parametric segments allow 10 parameters at most
-
-typedef struct {
-    cmsFloat32Number   x0, x1;           // Domain; for x0 < x <= x1
-    cmsInt32Number     Type;             // Parametric type, Type == 0 means sampled segment. Negative values are reserved
-    cmsFloat64Number   Params[10];       // Parameters if Type != 0
-    cmsUInt32Number    nGridPoints;      // Number of grid points if Type == 0
-    cmsFloat32Number*  SampledPoints;    // Points to an array of floats if Type == 0
-
-} cmsCurveSegment;
-
-// The internal representation is none of your business.
-typedef struct _cms_curve_struct cmsToneCurve;
-
-CMSAPI cmsToneCurve*     CMSEXPORT cmsBuildSegmentedToneCurve(cmsContext ContextID, cmsInt32Number nSegments, const cmsCurveSegment Segments[]);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsBuildParametricToneCurve(cmsContext ContextID, cmsInt32Number Type, const cmsFloat64Number Params[]);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsBuildGamma(cmsContext ContextID, cmsFloat64Number Gamma);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsBuildTabulatedToneCurve16(cmsContext ContextID, cmsInt32Number nEntries, const cmsUInt16Number values[]);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[]);
-CMSAPI void              CMSEXPORT cmsFreeToneCurve(cmsToneCurve* Curve);
-CMSAPI void              CMSEXPORT cmsFreeToneCurveTriple(cmsToneCurve* Curve[3]);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsDupToneCurve(const cmsToneCurve* Src);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsReverseToneCurve(const cmsToneCurve* InGamma);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsReverseToneCurveEx(cmsInt32Number nResultSamples, const cmsToneCurve* InGamma);
-CMSAPI cmsToneCurve*     CMSEXPORT cmsJoinToneCurve(cmsContext ContextID, const cmsToneCurve* X,  const cmsToneCurve* Y, cmsUInt32Number nPoints);
-CMSAPI cmsBool           CMSEXPORT cmsSmoothToneCurve(cmsToneCurve* Tab, cmsFloat64Number lambda);
-CMSAPI cmsFloat32Number  CMSEXPORT cmsEvalToneCurveFloat(const cmsToneCurve* Curve, cmsFloat32Number v);
-CMSAPI cmsUInt16Number   CMSEXPORT cmsEvalToneCurve16(const cmsToneCurve* Curve, cmsUInt16Number v);
-CMSAPI cmsBool           CMSEXPORT cmsIsToneCurveMultisegment(const cmsToneCurve* InGamma);
-CMSAPI cmsBool           CMSEXPORT cmsIsToneCurveLinear(const cmsToneCurve* Curve);
-CMSAPI cmsBool           CMSEXPORT cmsIsToneCurveMonotonic(const cmsToneCurve* t);
-CMSAPI cmsBool           CMSEXPORT cmsIsToneCurveDescending(const cmsToneCurve* t);
-CMSAPI cmsInt32Number    CMSEXPORT cmsGetToneCurveParametricType(const cmsToneCurve* t);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsEstimateGamma(const cmsToneCurve* t, cmsFloat64Number Precision);
-
-
-// Implements pipelines of multi-processing elements -------------------------------------------------------------
-
-// Nothing to see here, move along
-typedef struct _cmsPipeline_struct cmsPipeline;
-typedef struct _cmsStage_struct cmsStage;
-
-// Those are hi-level pipelines
-CMSAPI cmsPipeline*      CMSEXPORT cmsPipelineAlloc(cmsContext ContextID, cmsUInt32Number InputChannels, cmsUInt32Number OutputChannels);
-CMSAPI void              CMSEXPORT cmsPipelineFree(cmsPipeline* lut);
-CMSAPI cmsPipeline*      CMSEXPORT cmsPipelineDup(const cmsPipeline* Orig);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsPipelineInputChannels(const cmsPipeline* lut);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsPipelineOutputChannels(const cmsPipeline* lut);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsPipelineStageCount(const cmsPipeline* lut);
-CMSAPI cmsStage*         CMSEXPORT cmsPipelineGetPtrToFirstStage(const cmsPipeline* lut);
-CMSAPI cmsStage*         CMSEXPORT cmsPipelineGetPtrToLastStage(const cmsPipeline* lut);
-
-CMSAPI void              CMSEXPORT cmsPipelineEval16(const cmsUInt16Number In[], cmsUInt16Number Out[], const cmsPipeline* lut);
-CMSAPI void              CMSEXPORT cmsPipelineEvalFloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsPipeline* lut);
-CMSAPI cmsBool           CMSEXPORT cmsPipelineEvalReverseFloat(cmsFloat32Number Target[], cmsFloat32Number Result[], cmsFloat32Number Hint[], const cmsPipeline* lut);
-CMSAPI cmsBool           CMSEXPORT cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2);
-CMSAPI cmsBool           CMSEXPORT cmsPipelineSetSaveAs8bitsFlag(cmsPipeline* lut, cmsBool On);
-
-// Where to place/locate the stages in the pipeline chain
-typedef enum { cmsAT_BEGIN, cmsAT_END } cmsStageLoc;
-
-CMSAPI void              CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe);
-CMSAPI void              CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe);
-
-// This function is quite useful to analyze the structure of a Pipeline and retrieve the Stage elements
-// that conform the Pipeline. It should be called with the Pipeline, the number of expected elements and
-// then a list of expected types followed with a list of double pointers to Stage elements. If
-// the function founds a match with current pipeline, it fills the pointers and returns TRUE
-// if not, returns FALSE without touching anything.
-CMSAPI cmsBool           CMSEXPORT cmsPipelineCheckAndRetreiveStages(const cmsPipeline* Lut, cmsUInt32Number n, ...);
-
-// Matrix has double precision and CLUT has only float precision. That is because an ICC profile can encode
-// matrices with far more precision that CLUTS
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocIdentity(cmsContext ContextID, cmsUInt32Number nChannels);
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocToneCurves(cmsContext ContextID, cmsUInt32Number nChannels, cmsToneCurve* const Curves[]);
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocMatrix(cmsContext ContextID, cmsUInt32Number Rows, cmsUInt32Number Cols, const cmsFloat64Number* Matrix, const cmsFloat64Number* Offset);
-
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocCLut16bit(cmsContext ContextID, cmsUInt32Number nGridPoints, cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsUInt16Number* Table);
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocCLutFloat(cmsContext ContextID, cmsUInt32Number nGridPoints, cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsFloat32Number* Table);
-
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocCLut16bitGranular(cmsContext ContextID, const cmsUInt32Number clutPoints[], cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsUInt16Number* Table);
-CMSAPI cmsStage*         CMSEXPORT cmsStageAllocCLutFloatGranular(cmsContext ContextID, const cmsUInt32Number clutPoints[], cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsFloat32Number* Table);
-
-CMSAPI cmsStage*         CMSEXPORT cmsStageDup(cmsStage* mpe);
-CMSAPI void              CMSEXPORT cmsStageFree(cmsStage* mpe);
-CMSAPI cmsStage*         CMSEXPORT cmsStageNext(const cmsStage* mpe);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsStageInputChannels(const cmsStage* mpe);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsStageOutputChannels(const cmsStage* mpe);
-CMSAPI cmsStageSignature CMSEXPORT cmsStageType(const cmsStage* mpe);
-CMSAPI void*             CMSEXPORT cmsStageData(const cmsStage* mpe);
-
-// Sampling
-typedef cmsInt32Number (* cmsSAMPLER16)   (register const cmsUInt16Number In[],
-                                            register cmsUInt16Number Out[],
-                                            register void * Cargo);
-
-typedef cmsInt32Number (* cmsSAMPLERFLOAT)(register const cmsFloat32Number In[],
-                                            register cmsFloat32Number Out[],
-                                            register void * Cargo);
-
-// Use this flag to prevent changes being written to destination
-#define SAMPLER_INSPECT     0x01000000
-
-// For CLUT only
-CMSAPI cmsBool           CMSEXPORT cmsStageSampleCLut16bit(cmsStage* mpe,    cmsSAMPLER16 Sampler,    void* Cargo, cmsUInt32Number dwFlags);
-CMSAPI cmsBool           CMSEXPORT cmsStageSampleCLutFloat(cmsStage* mpe, cmsSAMPLERFLOAT Sampler, void* Cargo, cmsUInt32Number dwFlags);
-
-
-// Slicers
-CMSAPI cmsBool           CMSEXPORT cmsSliceSpace16(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],
-                                                   cmsSAMPLER16 Sampler, void * Cargo);
-
-CMSAPI cmsBool           CMSEXPORT cmsSliceSpaceFloat(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],
-                                                   cmsSAMPLERFLOAT Sampler, void * Cargo);
-
-// Multilocalized Unicode management ---------------------------------------------------------------------------------------
-
-typedef struct _cms_MLU_struct cmsMLU;
-
-#define  cmsNoLanguage "\0\0"
-#define  cmsNoCountry  "\0\0"
-
-CMSAPI cmsMLU*           CMSEXPORT cmsMLUalloc(cmsContext ContextID, cmsUInt32Number nItems);
-CMSAPI void              CMSEXPORT cmsMLUfree(cmsMLU* mlu);
-CMSAPI cmsMLU*           CMSEXPORT cmsMLUdup(const cmsMLU* mlu);
-
-CMSAPI cmsBool           CMSEXPORT cmsMLUsetASCII(cmsMLU* mlu,
-                                                  const char LanguageCode[3], const char CountryCode[3],
-                                                  const char* ASCIIString);
-CMSAPI cmsBool           CMSEXPORT cmsMLUsetWide(cmsMLU* mlu,
-                                                  const char LanguageCode[3], const char CountryCode[3],
-                                                  const wchar_t* WideString);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetASCII(const cmsMLU* mlu,
-                                                  const char LanguageCode[3], const char CountryCode[3],
-                                                  char* Buffer,    cmsUInt32Number BufferSize);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
-                                                 const char LanguageCode[3], const char CountryCode[3],
-                                                 wchar_t* Buffer, cmsUInt32Number BufferSize);
-
-CMSAPI cmsBool           CMSEXPORT cmsMLUgetTranslation(const cmsMLU* mlu,
-                                                         const char LanguageCode[3], const char CountryCode[3],
-                                                         char ObtainedLanguage[3], char ObtainedCountry[3]);
-
-// Undercolorremoval & black generation -------------------------------------------------------------------------------------
-
-typedef struct {
-        cmsToneCurve* Ucr;
-        cmsToneCurve* Bg;
-        cmsMLU*       Desc;
-
-} cmsUcrBg;
-
-// Screening ----------------------------------------------------------------------------------------------------------------
-
-#define cmsPRINTER_DEFAULT_SCREENS     0x0001
-#define cmsFREQUENCE_UNITS_LINES_CM    0x0000
-#define cmsFREQUENCE_UNITS_LINES_INCH  0x0002
-
-#define cmsSPOT_UNKNOWN         0
-#define cmsSPOT_PRINTER_DEFAULT 1
-#define cmsSPOT_ROUND           2
-#define cmsSPOT_DIAMOND         3
-#define cmsSPOT_ELLIPSE         4
-#define cmsSPOT_LINE            5
-#define cmsSPOT_SQUARE          6
-#define cmsSPOT_CROSS           7
-
-typedef struct {
-    cmsFloat64Number  Frequency;
-    cmsFloat64Number  ScreenAngle;
-    cmsUInt32Number   SpotShape;
-
-} cmsScreeningChannel;
-
-typedef struct {
-    cmsUInt32Number Flag;
-    cmsUInt32Number nChannels;
-    cmsScreeningChannel Channels[cmsMAXCHANNELS];
-
-} cmsScreening;
-
-
-// Named color -----------------------------------------------------------------------------------------------------------------
-
-typedef struct _cms_NAMEDCOLORLIST_struct cmsNAMEDCOLORLIST;
-
-CMSAPI cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID,
-                                                           cmsUInt32Number n,
-                                                           cmsUInt32Number ColorantCount,
-                                                           const char* Prefix, const char* Suffix);
-
-CMSAPI void               CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v);
-CMSAPI cmsNAMEDCOLORLIST* CMSEXPORT cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v);
-CMSAPI cmsBool            CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* v, const char* Name,
-                                                            cmsUInt16Number PCS[3],
-                                                            cmsUInt16Number Colorant[cmsMAXCHANNELS]);
-
-CMSAPI cmsUInt32Number    CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* v);
-CMSAPI cmsInt32Number     CMSEXPORT cmsNamedColorIndex(const cmsNAMEDCOLORLIST* v, const char* Name);
-
-CMSAPI cmsBool            CMSEXPORT cmsNamedColorInfo(const cmsNAMEDCOLORLIST* NamedColorList, cmsUInt32Number nColor,
-                                                      char* Name,
-                                                      char* Prefix,
-                                                      char* Suffix,
-                                                      cmsUInt16Number* PCS,
-                                                      cmsUInt16Number* Colorant);
-
-// Retrieve named color list from transform
-CMSAPI cmsNAMEDCOLORLIST* CMSEXPORT cmsGetNamedColorList(cmsHTRANSFORM xform);
-
-// Profile sequence -----------------------------------------------------------------------------------------------------
-
-// Profile sequence descriptor. Some fields come from profile sequence descriptor tag, others
-// come from Profile Sequence Identifier Tag
-typedef struct {
-    cmsSignature           deviceMfg;
-    cmsSignature           deviceModel;
-    cmsUInt64Number        attributes;
-    cmsTechnologySignature technology;
-    cmsProfileID           ProfileID;
-    cmsMLU*                Manufacturer;
-    cmsMLU*                Model;
-    cmsMLU*                Description;
-
-} cmsPSEQDESC;
-
-typedef struct {
-
-    cmsUInt32Number n;
-    cmsContext     ContextID;
-    cmsPSEQDESC*    seq;
-
-} cmsSEQ;
-
-CMSAPI cmsSEQ*           CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n);
-CMSAPI cmsSEQ*           CMSEXPORT cmsDupProfileSequenceDescription(const cmsSEQ* pseq);
-CMSAPI void              CMSEXPORT cmsFreeProfileSequenceDescription(cmsSEQ* pseq);
-
-// Access to Profile data ----------------------------------------------------------------------------------------------
-CMSAPI cmsHPROFILE       CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID);
-
-CMSAPI cmsContext        CMSEXPORT cmsGetProfileContextID(cmsHPROFILE hProfile);
-CMSAPI cmsInt32Number    CMSEXPORT cmsGetTagCount(cmsHPROFILE hProfile);
-CMSAPI cmsTagSignature   CMSEXPORT cmsGetTagSignature(cmsHPROFILE hProfile, cmsUInt32Number n);
-CMSAPI cmsBool           CMSEXPORT cmsIsTag(cmsHPROFILE hProfile, cmsTagSignature sig);
-
-// Read and write pre-formatted data
-CMSAPI void*             CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig);
-CMSAPI cmsBool           CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data);
-CMSAPI cmsBool           CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest);
-CMSAPI cmsTagSignature   CMSEXPORT cmsTagLinkedTo(cmsHPROFILE hProfile, cmsTagSignature sig);
-
-// Read and write raw data
-CMSAPI cmsInt32Number    CMSEXPORT cmsReadRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, void* Buffer, cmsUInt32Number BufferSize);
-CMSAPI cmsBool           CMSEXPORT cmsWriteRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data, cmsUInt32Number Size);
-
-// Access header data
-#define cmsEmbeddedProfileFalse    0x00000000 
-#define cmsEmbeddedProfileTrue     0x00000001 
-#define cmsUseAnywhere             0x00000000 
-#define cmsUseWithEmbeddedDataOnly 0x00000002
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderFlags(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags);
-CMSAPI void              CMSEXPORT cmsGetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID);
-CMSAPI cmsBool           CMSEXPORT cmsGetHeaderCreationDateTime(cmsHPROFILE hProfile, struct tm *Dest);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderRenderingIntent(cmsHPROFILE hProfile);
-
-CMSAPI void              CMSEXPORT cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model);
-CMSAPI void              CMSEXPORT cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags);
-CMSAPI void              CMSEXPORT cmsSetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID);
-CMSAPI void              CMSEXPORT cmsSetHeaderRenderingIntent(cmsHPROFILE hProfile, cmsUInt32Number RenderingIntent);
-
-CMSAPI cmsColorSpaceSignature
-                         CMSEXPORT cmsGetPCS(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetPCS(cmsHPROFILE hProfile, cmsColorSpaceSignature pcs);
-CMSAPI cmsColorSpaceSignature
-                         CMSEXPORT cmsGetColorSpace(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetColorSpace(cmsHPROFILE hProfile, cmsColorSpaceSignature sig);
-CMSAPI cmsProfileClassSignature
-                         CMSEXPORT cmsGetDeviceClass(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetDeviceClass(cmsHPROFILE hProfile, cmsProfileClassSignature sig);
-CMSAPI void              CMSEXPORT cmsSetProfileVersion(cmsHPROFILE hProfile, cmsFloat64Number Version);
-CMSAPI cmsFloat64Number  CMSEXPORT cmsGetProfileVersion(cmsHPROFILE hProfile);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetEncodedICCversion(cmsHPROFILE hProfile);
-CMSAPI void              CMSEXPORT cmsSetEncodedICCversion(cmsHPROFILE hProfile, cmsUInt32Number Version);
-
-// How profiles may be used
-#define LCMS_USED_AS_INPUT      0
-#define LCMS_USED_AS_OUTPUT     1
-#define LCMS_USED_AS_PROOF      2
-
-CMSAPI cmsBool           CMSEXPORT cmsIsIntentSupported(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection);
-CMSAPI cmsBool           CMSEXPORT cmsIsMatrixShaper(cmsHPROFILE hProfile);
-CMSAPI cmsBool           CMSEXPORT cmsIsCLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection);
-
-// Translate form/to our notation to ICC
-CMSAPI cmsColorSpaceSignature   CMSEXPORT _cmsICCcolorSpace(int OurNotation);
-CMSAPI int                      CMSEXPORT _cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace);
-
-// Build a suitable formatter for the colorspace of this profile
-CMSAPI cmsUInt32Number   CMSEXPORT cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat);
-CMSAPI cmsUInt32Number   CMSEXPORT cmsFormatterForPCSOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat);
-
-
-// Localized info
-typedef enum {
-             cmsInfoDescription  = 0,
-             cmsInfoManufacturer = 1,
-             cmsInfoModel        = 2,
-             cmsInfoCopyright    = 3
-} cmsInfoType;
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetProfileInfo(cmsHPROFILE hProfile, cmsInfoType Info,
-                                                            const char LanguageCode[3], const char CountryCode[3],
-                                                            wchar_t* Buffer, cmsUInt32Number BufferSize);
-
-CMSAPI cmsUInt32Number   CMSEXPORT cmsGetProfileInfoASCII(cmsHPROFILE hProfile, cmsInfoType Info,
-                                                            const char LanguageCode[3], const char CountryCode[3],
-                                                            char* Buffer, cmsUInt32Number BufferSize);
-
-// IO handlers ----------------------------------------------------------------------------------------------------------
-
-typedef struct _cms_io_handler cmsIOHANDLER;
-
-CMSAPI cmsIOHANDLER*     CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode);
-CMSAPI cmsIOHANDLER*     CMSEXPORT cmsOpenIOhandlerFromStream(cmsContext ContextID, FILE* Stream);
-CMSAPI cmsIOHANDLER*     CMSEXPORT cmsOpenIOhandlerFromMem(cmsContext ContextID, void *Buffer, cmsUInt32Number size, const char* AccessMode);
-CMSAPI cmsIOHANDLER*     CMSEXPORT cmsOpenIOhandlerFromNULL(cmsContext ContextID);
-CMSAPI cmsBool           CMSEXPORT cmsCloseIOhandler(cmsIOHANDLER* io);
-
-// MD5 message digest --------------------------------------------------------------------------------------------------
-
-CMSAPI cmsBool           CMSEXPORT cmsMD5computeID(cmsHPROFILE hProfile);
-
-// Profile high level funtions ------------------------------------------------------------------------------------------
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromFile(const char *ICCProfile, const char *sAccess);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromFileTHR(cmsContext ContextID, const char *ICCProfile, const char *sAccess);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromStream(FILE* ICCProfile, const char* sAccess);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromStreamTHR(cmsContext ContextID, FILE* ICCProfile, const char* sAccess);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromMem(const void * MemPtr, cmsUInt32Number dwSize);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromMemTHR(cmsContext ContextID, const void * MemPtr, cmsUInt32Number dwSize);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsOpenProfileFromIOhandlerTHR(cmsContext ContextID, cmsIOHANDLER* io);
-CMSAPI cmsBool          CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile);
-
-CMSAPI cmsBool          CMSEXPORT cmsSaveProfileToFile(cmsHPROFILE hProfile, const char* FileName);
-CMSAPI cmsBool          CMSEXPORT cmsSaveProfileToStream(cmsHPROFILE hProfile, FILE* Stream);
-CMSAPI cmsBool          CMSEXPORT cmsSaveProfileToMem(cmsHPROFILE hProfile, void *MemPtr, cmsUInt32Number* BytesNeeded);
-CMSAPI cmsUInt32Number  CMSEXPORT cmsSaveProfileToIOhandler(cmsHPROFILE hProfile, cmsIOHANDLER* io);
-
-// Predefined virtual profiles ------------------------------------------------------------------------------------------
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateRGBProfileTHR(cmsContext ContextID,
-                                                   const cmsCIExyY* WhitePoint,
-                                                   const cmsCIExyYTRIPLE* Primaries,
-                                                   cmsToneCurve* const TransferFunction[3]);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateRGBProfile(const cmsCIExyY* WhitePoint,
-                                                   const cmsCIExyYTRIPLE* Primaries,
-                                                   cmsToneCurve* const TransferFunction[3]);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateGrayProfileTHR(cmsContext ContextID,
-                                                    const cmsCIExyY* WhitePoint,
-                                                    const cmsToneCurve* TransferFunction);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateGrayProfile(const cmsCIExyY* WhitePoint,
-                                                    const cmsToneCurve* TransferFunction);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,
-                                                                cmsColorSpaceSignature ColorSpace,
-                                                                cmsToneCurve* const TransferFunctions[]);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLinearizationDeviceLink(cmsColorSpaceSignature ColorSpace,
-                                                                cmsToneCurve* const TransferFunctions[]);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,
-                                                              cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateInkLimitingDeviceLink(cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit);
-
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLab2Profile(const cmsCIExyY* WhitePoint);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateLab4Profile(const cmsCIExyY* WhitePoint);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateXYZProfileTHR(cmsContext ContextID);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateXYZProfile(void);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_sRGBProfileTHR(cmsContext ContextID);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_sRGBProfile(void);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,
-                                                             int nLUTPoints,
-                                                             cmsFloat64Number Bright,
-                                                             cmsFloat64Number Contrast,
-                                                             cmsFloat64Number Hue,
-                                                             cmsFloat64Number Saturation,
-                                                             int TempSrc,
-                                                             int TempDest);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateBCHSWabstractProfile(int nLUTPoints,
-                                                             cmsFloat64Number Bright,
-                                                             cmsFloat64Number Contrast,
-                                                             cmsFloat64Number Hue,
-                                                             cmsFloat64Number Saturation,
-                                                             int TempSrc,
-                                                             int TempDest);
-
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateNULLProfileTHR(cmsContext ContextID);
-CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateNULLProfile(void);
-
-// Converts a transform to a devicelink profile
-CMSAPI cmsHPROFILE      CMSEXPORT cmsTransform2DeviceLink(cmsHTRANSFORM hTransform, cmsFloat64Number Version, cmsUInt32Number dwFlags);
-
-// Intents ----------------------------------------------------------------------------------------------
-
-// ICC Intents
-#define INTENT_PERCEPTUAL                              0
-#define INTENT_RELATIVE_COLORIMETRIC                   1
-#define INTENT_SATURATION                              2
-#define INTENT_ABSOLUTE_COLORIMETRIC                   3
-
-// Non-ICC intents
-#define INTENT_PRESERVE_K_ONLY_PERCEPTUAL             10
-#define INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC  11
-#define INTENT_PRESERVE_K_ONLY_SATURATION             12
-#define INTENT_PRESERVE_K_PLANE_PERCEPTUAL            13
-#define INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC 14
-#define INTENT_PRESERVE_K_PLANE_SATURATION            15
-
-// Call with NULL as parameters to get the intent count
-CMSAPI cmsUInt32Number  CMSEXPORT cmsGetSupportedIntents(cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions);
-
-// Flags
-
-#define cmsFLAGS_NOCACHE                  0x0040    // Inhibit 1-pixel cache
-#define cmsFLAGS_NOOPTIMIZE               0x0100    // Inhibit optimizations
-#define cmsFLAGS_NULLTRANSFORM            0x0200    // Don't transform anyway
-
-// Proofing flags
-#define cmsFLAGS_GAMUTCHECK               0x1000    // Out of Gamut alarm
-#define cmsFLAGS_SOFTPROOFING             0x4000    // Do softproofing
-
-// Misc
-#define cmsFLAGS_BLACKPOINTCOMPENSATION   0x2000
-#define cmsFLAGS_NOWHITEONWHITEFIXUP      0x0004    // Don't fix scum dot
-#define cmsFLAGS_HIGHRESPRECALC           0x0400    // Use more memory to give better accurancy
-#define cmsFLAGS_LOWRESPRECALC            0x0800    // Use less memory to minimize resouces
-
-// For devicelink creation
-#define cmsFLAGS_8BITS_DEVICELINK         0x0008   // Create 8 bits devicelinks
-#define cmsFLAGS_GUESSDEVICECLASS         0x0020   // Guess device class (for transform2devicelink)
-#define cmsFLAGS_KEEP_SEQUENCE            0x0080   // Keep profile sequence for devicelink creation
-
-// Specific to a particular optimizations
-#define cmsFLAGS_FORCE_CLUT               0x0002    // Force CLUT optimization
-#define cmsFLAGS_CLUT_POST_LINEARIZATION  0x0001    // create postlinearization tables if possible
-#define cmsFLAGS_CLUT_PRE_LINEARIZATION   0x0010    // create prelinearization tables if possible
-
-// Fine-tune control over number of gridpoints
-#define cmsFLAGS_GRIDPOINTS(n)           (((n) & 0xFF) << 16)
-
-// CRD special
-#define cmsFLAGS_NODEFAULTRESOURCEDEF     0x01000000
-
-// Transforms ---------------------------------------------------------------------------------------------------
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateTransformTHR(cmsContext ContextID,
-                                                  cmsHPROFILE Input,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsHPROFILE Output,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags);
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateTransform(cmsHPROFILE Input,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsHPROFILE Output,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags);
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateProofingTransformTHR(cmsContext ContextID,
-                                                  cmsHPROFILE Input,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsHPROFILE Output,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsHPROFILE Proofing,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number ProofingIntent,
-                                                  cmsUInt32Number dwFlags);
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateProofingTransform(cmsHPROFILE Input,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsHPROFILE Output,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsHPROFILE Proofing,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number ProofingIntent,
-                                                  cmsUInt32Number dwFlags);
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateMultiprofileTransformTHR(cmsContext ContextID,
-                                                  cmsHPROFILE hProfiles[],
-                                                  cmsUInt32Number nProfiles,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags);
-
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateMultiprofileTransform(cmsHPROFILE hProfiles[],
-                                                  cmsUInt32Number nProfiles,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags);
-
-
-CMSAPI cmsHTRANSFORM    CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
-                                                   cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],
-                                                   cmsBool  BPC[],
-                                                   cmsUInt32Number Intents[],
-                                                   cmsFloat64Number AdaptationStates[],
-                                                   cmsHPROFILE hGamutProfile,
-                                                   cmsUInt32Number nGamutPCSposition,
-                                                   cmsUInt32Number InputFormat,
-                                                   cmsUInt32Number OutputFormat,
-                                                   cmsUInt32Number dwFlags);
-
-CMSAPI void             CMSEXPORT cmsDeleteTransform(cmsHTRANSFORM hTransform);
-
-CMSAPI void             CMSEXPORT cmsDoTransform(cmsHTRANSFORM Transform,
-                                                 const void * InputBuffer,
-                                                 void * OutputBuffer,
-                                                 cmsUInt32Number Size);
-
-CMSAPI void             CMSEXPORT cmsSetAlarmCodes(cmsUInt16Number NewAlarm[cmsMAXCHANNELS]);
-CMSAPI void             CMSEXPORT cmsGetAlarmCodes(cmsUInt16Number NewAlarm[cmsMAXCHANNELS]);
-
-// Adaptation state for absolute colorimetric intent
-CMSAPI cmsFloat64Number CMSEXPORT cmsSetAdaptationState(cmsFloat64Number d);
-
-// Grab the ContextID from an open transform. Returns NULL if a NULL transform is passed
-CMSAPI cmsContext       CMSEXPORT cmsGetTransformContextID(cmsHTRANSFORM hTransform);
-
-// For backwards compatibility
-CMSAPI cmsBool          CMSEXPORT cmsChangeBuffersFormat(cmsHTRANSFORM hTransform, 
-                                                         cmsUInt32Number InputFormat, 
-                                                         cmsUInt32Number OutputFormat);
-
-
-
-// PostScript ColorRenderingDictionary and ColorSpaceArray ----------------------------------------------------
-
-typedef enum { cmsPS_RESOURCE_CSA, cmsPS_RESOURCE_CRD } cmsPSResourceType;
-
-// lcms2 unified method to access postscript color resources
-CMSAPI cmsUInt32Number  CMSEXPORT cmsGetPostScriptColorResource(cmsContext ContextID,
-                                                                cmsPSResourceType Type,
-                                                                cmsHPROFILE hProfile,
-                                                                cmsUInt32Number Intent,
-                                                                cmsUInt32Number dwFlags,
-                                                                cmsIOHANDLER* io);
-
-CMSAPI cmsUInt32Number  CMSEXPORT cmsGetPostScriptCSA(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags, void* Buffer, cmsUInt32Number dwBufferLen);
-CMSAPI cmsUInt32Number  CMSEXPORT cmsGetPostScriptCRD(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags, void* Buffer, cmsUInt32Number dwBufferLen);
-
-
-// IT8.7 / CGATS.17-200x handling -----------------------------------------------------------------------------
-
-CMSAPI cmsHANDLE        CMSEXPORT cmsIT8Alloc(cmsContext ContextID);
-CMSAPI void             CMSEXPORT cmsIT8Free(cmsHANDLE hIT8);
-
-// Tables
-CMSAPI cmsUInt32Number  CMSEXPORT cmsIT8TableCount(cmsHANDLE hIT8);
-CMSAPI cmsInt32Number   CMSEXPORT cmsIT8SetTable(cmsHANDLE hIT8, cmsUInt32Number nTable);
-
-// Persistence
-CMSAPI cmsHANDLE        CMSEXPORT cmsIT8LoadFromFile(cmsContext ContextID, const char* cFileName);
-CMSAPI cmsHANDLE        CMSEXPORT cmsIT8LoadFromMem(cmsContext ContextID, void *Ptr, cmsUInt32Number len);
-// CMSAPI cmsHANDLE        CMSEXPORT cmsIT8LoadFromIOhandler(cmsContext ContextID, cmsIOHANDLER* io);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SaveToFile(cmsHANDLE hIT8, const char* cFileName);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SaveToMem(cmsHANDLE hIT8, void *MemPtr, cmsUInt32Number* BytesNeeded);
-
-// Properties
-CMSAPI const char*      CMSEXPORT cmsIT8GetSheetType(cmsHANDLE hIT8);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetSheetType(cmsHANDLE hIT8, const char* Type);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetComment(cmsHANDLE hIT8, const char* cComment);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetPropertyStr(cmsHANDLE hIT8, const char* cProp, const char *Str);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetPropertyDbl(cmsHANDLE hIT8, const char* cProp, cmsFloat64Number Val);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetPropertyHex(cmsHANDLE hIT8, const char* cProp, cmsUInt32Number Val);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetPropertyUncooked(cmsHANDLE hIT8, const char* Key, const char* Buffer);
-
-
-CMSAPI const char*      CMSEXPORT cmsIT8GetProperty(cmsHANDLE hIT8, const char* cProp);
-CMSAPI cmsFloat64Number CMSEXPORT cmsIT8GetPropertyDbl(cmsHANDLE hIT8, const char* cProp);
-CMSAPI cmsUInt32Number  CMSEXPORT cmsIT8EnumProperties(cmsHANDLE hIT8, char ***PropertyNames);
-
-// Datasets
-CMSAPI const char*      CMSEXPORT cmsIT8GetDataRowCol(cmsHANDLE hIT8, int row, int col);
-CMSAPI cmsFloat64Number CMSEXPORT cmsIT8GetDataRowColDbl(cmsHANDLE hIT8, int row, int col);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetDataRowCol(cmsHANDLE hIT8, int row, int col,
-                                                const char* Val);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetDataRowColDbl(cmsHANDLE hIT8, int row, int col,
-                                                cmsFloat64Number Val);
-
-CMSAPI const char*      CMSEXPORT cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample);
-
-
-CMSAPI cmsFloat64Number CMSEXPORT cmsIT8GetDataDbl(cmsHANDLE hIT8, const char* cPatch, const char* cSample);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetData(cmsHANDLE hIT8, const char* cPatch,
-                                                const char* cSample,
-                                                const char *Val);
-
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetDataDbl(cmsHANDLE hIT8, const char* cPatch,
-                                                const char* cSample,
-                                                cmsFloat64Number Val);
-
-CMSAPI int              CMSEXPORT cmsIT8FindDataFormat(cmsHANDLE hIT8, const char* cSample);
-CMSAPI cmsBool          CMSEXPORT cmsIT8SetDataFormat(cmsHANDLE hIT8, int n, const char *Sample);
-CMSAPI int              CMSEXPORT cmsIT8EnumDataFormat(cmsHANDLE hIT8, char ***SampleNames);
-
-CMSAPI const char*      CMSEXPORT cmsIT8GetPatchName(cmsHANDLE hIT8, int nPatch, char* buffer);
-
-// The LABEL extension
-CMSAPI int              CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType);
-
-// Formatter for double
-CMSAPI void             CMSEXPORT cmsIT8DefineDblFormat(cmsHANDLE hIT8, const char* Formatter);
-
-// Gamut boundary description routines ------------------------------------------------------------------------------
-
-CMSAPI cmsHANDLE        CMSEXPORT cmsGBDAlloc(cmsContext ContextID);
-CMSAPI void             CMSEXPORT cmsGBDFree(cmsHANDLE hGBD);
-CMSAPI cmsBool          CMSEXPORT cmsGDBAddPoint(cmsHANDLE hGBD, const cmsCIELab* Lab);
-CMSAPI cmsBool          CMSEXPORT cmsGDBCompute(cmsHANDLE  hGDB, cmsUInt32Number dwFlags);
-CMSAPI cmsBool          CMSEXPORT cmsGDBCheckPoint(cmsHANDLE hGBD, const cmsCIELab* Lab);
-
-// Feature detection  ----------------------------------------------------------------------------------------------
-
-// Estimate the black point
-CMSAPI cmsBool          CMSEXPORT cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags);
-
-// Estimate total area coverage
-CMSAPI cmsFloat64Number CMSEXPORT cmsDetectTAC(cmsHPROFILE hProfile);
-
-
-// Poor man's gamut mapping
-CMSAPI cmsBool          CMSEXPORT cmsDesaturateLab(cmsCIELab* Lab,
-                                                   double amax, double amin,
-                                                   double bmax, double bmin);
-
-#ifndef CMS_USE_CPP_API
-#   ifdef __cplusplus
-    }
-#   endif
-#endif
-
-#define _lcms2_H
-#endif
diff --git a/thirdparty/liblcms2/include/lcms2_plugin.h b/thirdparty/liblcms2/include/lcms2_plugin.h
deleted file mode 100644
index 896fa49..0000000
--- a/thirdparty/liblcms2/include/lcms2_plugin.h
+++ /dev/null
@@ -1,535 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the Software
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-// This is the plug-in header file. Normal LittleCMS clients should not use it.
-// It is provided for plug-in writters that may want to access the support
-// functions to do low level operations. All plug-in related structures
-// are defined here. Including this file forces to include the standard API too.
-
-#ifndef _lcms_plugin_H
-
-// Deal with Microsoft's attempt at deprecating C standard runtime functions
-#ifdef _MSC_VER
-#    if (_MSC_VER >= 1400)
-#      ifndef _CRT_SECURE_NO_DEPRECATE
-#        define _CRT_SECURE_NO_DEPRECATE
-#      endif
-#      ifndef _CRT_SECURE_NO_WARNINGS
-#        define _CRT_SECURE_NO_WARNINGS
-#      endif
-#    endif
-#endif
-
-#ifndef _lcms2_H
-#include "lcms2.h"
-#endif
-
-// We need some standard C functions.
-#include <stdlib.h>
-#include <math.h>
-#include <stdarg.h>
-#include <memory.h>
-#include <string.h>
-
-
-#ifndef CMS_USE_CPP_API
-#   ifdef __cplusplus
-extern "C" {
-#   endif
-#endif
-
-// Vector & Matrix operations -----------------------------------------------------------------------
-
-// Axis of the matrix/array. No specific meaning at all.
-#define VX      0
-#define VY      1
-#define VZ      2
-
-// Vectors
-typedef struct {
-    cmsFloat64Number n[3];
-
-    } cmsVEC3;
-
-// 3x3 Matrix
-typedef struct {
-    cmsVEC3 v[3];
-
-    } cmsMAT3;
-
-CMSAPI void               CMSEXPORT _cmsVEC3init(cmsVEC3* r, cmsFloat64Number x, cmsFloat64Number y, cmsFloat64Number z);
-CMSAPI void               CMSEXPORT _cmsVEC3minus(cmsVEC3* r, const cmsVEC3* a, const cmsVEC3* b);
-CMSAPI void               CMSEXPORT _cmsVEC3cross(cmsVEC3* r, const cmsVEC3* u, const cmsVEC3* v);
-CMSAPI cmsFloat64Number   CMSEXPORT _cmsVEC3dot(const cmsVEC3* u, const cmsVEC3* v);
-CMSAPI cmsFloat64Number   CMSEXPORT _cmsVEC3length(const cmsVEC3* a);
-CMSAPI cmsFloat64Number   CMSEXPORT _cmsVEC3distance(const cmsVEC3* a, const cmsVEC3* b);
-
-CMSAPI void               CMSEXPORT _cmsMAT3identity(cmsMAT3* a);
-CMSAPI cmsBool            CMSEXPORT _cmsMAT3isIdentity(const cmsMAT3* a);
-CMSAPI void               CMSEXPORT _cmsMAT3per(cmsMAT3* r, const cmsMAT3* a, const cmsMAT3* b);
-CMSAPI cmsBool            CMSEXPORT _cmsMAT3inverse(const cmsMAT3* a, cmsMAT3* b);
-CMSAPI cmsBool            CMSEXPORT _cmsMAT3solve(cmsVEC3* x, cmsMAT3* a, cmsVEC3* b);
-CMSAPI void               CMSEXPORT _cmsMAT3eval(cmsVEC3* r, const cmsMAT3* a, const cmsVEC3* v);
-
-
-// Error logging  -------------------------------------------------------------------------------------
-
-CMSAPI void               CMSEXPORT  cmsSignalError(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *ErrorText, ...);
-
-// Memory management ----------------------------------------------------------------------------------
-
-CMSAPI void*              CMSEXPORT _cmsMalloc(cmsContext ContextID, cmsUInt32Number size);
-CMSAPI void*              CMSEXPORT _cmsMallocZero(cmsContext ContextID, cmsUInt32Number size);
-CMSAPI void*              CMSEXPORT _cmsCalloc(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size);
-CMSAPI void*              CMSEXPORT _cmsRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize);
-CMSAPI void               CMSEXPORT _cmsFree(cmsContext ContextID, void* Ptr);
-CMSAPI void*              CMSEXPORT _cmsDupMem(cmsContext ContextID, const void* Org, cmsUInt32Number size);
-
-// I/O handler ----------------------------------------------------------------------------------
-
-struct _cms_io_handler {
-
-    void* stream;   // Associated stream, which is implemented differently depending on media.
-
-    cmsContext        ContextID;
-    cmsUInt32Number   UsedSpace;
-    cmsUInt32Number   ReportedSize;
-    char              PhysicalFile[cmsMAX_PATH];
-
-    cmsUInt32Number   (* Read)(struct _cms_io_handler* iohandler, void *Buffer,
-                                                                  cmsUInt32Number size,
-                                                                  cmsUInt32Number count);
-    cmsBool           (* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset);
-    cmsBool           (* Close)(struct _cms_io_handler* iohandler);
-    cmsUInt32Number   (* Tell)(struct _cms_io_handler* iohandler);
-    cmsBool           (* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,
-                                                                   const void* Buffer);
-};
-
-// Endianess adjust functions
-CMSAPI cmsUInt16Number   CMSEXPORT  _cmsAdjustEndianess16(cmsUInt16Number Word);
-CMSAPI cmsUInt32Number   CMSEXPORT  _cmsAdjustEndianess32(cmsUInt32Number Value);
-CMSAPI void              CMSEXPORT  _cmsAdjustEndianess64(cmsUInt64Number* Result, cmsUInt64Number QWord);
-
-// Helper IO functions
-CMSAPI cmsBool           CMSEXPORT  _cmsReadUInt8Number(cmsIOHANDLER* io,  cmsUInt8Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadUInt16Number(cmsIOHANDLER* io, cmsUInt16Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadUInt32Number(cmsIOHANDLER* io, cmsUInt32Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadFloat32Number(cmsIOHANDLER* io, cmsFloat32Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsRead15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number* n);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadXYZNumber(cmsIOHANDLER* io, cmsCIEXYZ* XYZ);
-CMSAPI cmsBool           CMSEXPORT  _cmsReadUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, cmsUInt16Number* Array);
-
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteUInt8Number(cmsIOHANDLER* io, cmsUInt8Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteUInt16Number(cmsIOHANDLER* io, cmsUInt16Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteUInt32Number(cmsIOHANDLER* io, cmsUInt32Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteFloat32Number(cmsIOHANDLER* io, cmsFloat32Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteUInt64Number(cmsIOHANDLER* io, cmsUInt64Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWrite15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number n);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteXYZNumber(cmsIOHANDLER* io, const cmsCIEXYZ* XYZ);
-CMSAPI cmsBool           CMSEXPORT  _cmsWriteUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, const cmsUInt16Number* Array);
-
-// ICC base tag
-typedef struct {
-    cmsTagTypeSignature  sig;
-    cmsInt8Number        reserved[4];
-
-} _cmsTagBase;
-
-// Type base helper functions
-CMSAPI cmsTagTypeSignature  CMSEXPORT _cmsReadTypeBase(cmsIOHANDLER* io);
-CMSAPI cmsBool              CMSEXPORT _cmsWriteTypeBase(cmsIOHANDLER* io, cmsTagTypeSignature sig);
-
-// Alignment functions
-CMSAPI cmsBool             CMSEXPORT _cmsReadAlignment(cmsIOHANDLER* io);
-CMSAPI cmsBool             CMSEXPORT _cmsWriteAlignment(cmsIOHANDLER* io);
-
-// To deal with text streams. 2K at most
-CMSAPI cmsBool             CMSEXPORT _cmsIOPrintf(cmsIOHANDLER* io, const char* frm, ...);
-
-// Fixed point helper functions
-CMSAPI cmsFloat64Number    CMSEXPORT _cms8Fixed8toDouble(cmsUInt16Number fixed8);
-CMSAPI cmsUInt16Number     CMSEXPORT _cmsDoubleTo8Fixed8(cmsFloat64Number val);
-
-CMSAPI cmsFloat64Number    CMSEXPORT _cms15Fixed16toDouble(cmsS15Fixed16Number fix32);
-CMSAPI cmsS15Fixed16Number CMSEXPORT _cmsDoubleTo15Fixed16(cmsFloat64Number v);
-
-// Date/time helper functions
-CMSAPI void                CMSEXPORT _cmsEncodeDateTimeNumber(cmsDateTimeNumber *Dest, const struct tm *Source);
-CMSAPI void                CMSEXPORT _cmsDecodeDateTimeNumber(const cmsDateTimeNumber *Source, struct tm *Dest);
-
-
-//----------------------------------------------------------------------------------------------------------
-
-// Plug-in foundation
-#define cmsPluginMagicNumber                 0x61637070     // 'acpp'
-
-#define cmsPluginMemHandlerSig               0x6D656D48     // 'memH'
-#define cmsPluginInterpolationSig            0x696E7048     // 'inpH'
-#define cmsPluginParametricCurveSig          0x70617248     // 'parH'
-#define cmsPluginFormattersSig               0x66726D48     // 'frmH
-#define cmsPluginTagTypeSig                  0x74797048     // 'typH'
-#define cmsPluginTagSig                      0x74616748     // 'tagH'
-#define cmsPluginRenderingIntentSig          0x696E7448     // 'intH'
-#define cmsPluginMultiProcessElementSig      0x6D706548     // 'mpeH'
-#define cmsPluginOptimizationSig             0x6F707448     // 'optH'
-
-typedef struct _cmsPluginBaseStruct {
-
-        cmsUInt32Number                Magic;               // 'acpp' signature
-        cmsUInt32Number                ExpectedVersion;     // Expected version of LittleCMS
-        cmsUInt32Number                Type;                // Type of plug-in
-        struct _cmsPluginBaseStruct*   Next;                // For multiple plugin definition. NULL for end of list.
-
-} cmsPluginBase;
-
-// Maximum number of types in a plugin array
-#define MAX_TYPES_IN_LCMS_PLUGIN    20
-
-//----------------------------------------------------------------------------------------------------------
-
-// Memory handler. Each new plug-in type replaces current behaviour
-typedef struct {
-
-        cmsPluginBase base;
-
-        // Required
-        void * (* MallocPtr)(cmsContext ContextID, cmsUInt32Number size);
-        void   (* FreePtr)(cmsContext ContextID, void *Ptr);
-        void * (* ReallocPtr)(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize);
-
-        // Optional
-        void * (* MallocZeroPtr)(cmsContext ContextID, cmsUInt32Number size);
-        void * (* CallocPtr)(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size);
-        void * (* DupPtr)(cmsContext ContextID, const void* Org, cmsUInt32Number size);
-
-} cmsPluginMemHandler;
-
-
-// ------------------------------------------------------------------------------------------------------------------
-
-// Interpolation. 16 bits and floating point versions.
-struct _cms_interp_struc;
-
-// Interpolation callbacks
-
-// 16 bits forward interpolation. This function performs precision-limited linear interpolation
-// and is supposed to be quite fast. Implementation may be tetrahedral or trilinear, and plug-ins may
-// choose to implement any other interpolation algorithm.
-typedef void (* _cmsInterpFn16)(register const cmsUInt16Number Input[],
-                                register cmsUInt16Number Output[],
-                                register const struct _cms_interp_struc* p);
-
-// Floating point forward interpolation. Full precision interpolation using floats. This is not a
-// time critical function. Implementation may be tetrahedral or trilinear, and plug-ins may
-// choose to implement any other interpolation algorithm.
-typedef void (* _cmsInterpFnFloat)(cmsFloat32Number const Input[],
-                                   cmsFloat32Number Output[],
-                                   const struct _cms_interp_struc* p);
-
-
-
-// This type holds a pointer to an interpolator that can be either 16 bits or float
-typedef union {
-    _cmsInterpFn16       Lerp16;            // Forward interpolation in 16 bits
-    _cmsInterpFnFloat    LerpFloat;         // Forward interpolation in floating point
-} cmsInterpFunction;
-
-// Flags for interpolator selection
-#define CMS_LERP_FLAGS_16BITS             0x0000        // The default
-#define CMS_LERP_FLAGS_FLOAT              0x0001        // Requires different implementation
-#define CMS_LERP_FLAGS_TRILINEAR          0x0100        // Hint only
-
-
-#define MAX_INPUT_DIMENSIONS 8
-
-typedef struct _cms_interp_struc {  // Used on all interpolations. Supplied by lcms2 when calling the interpolation function
-
-    cmsContext ContextID;     // The calling thread
-
-    cmsUInt32Number dwFlags;  // Keep original flags
-    cmsUInt32Number nInputs;  // != 1 only in 3D interpolation
-    cmsUInt32Number nOutputs; // != 1 only in 3D interpolation
-
-    cmsUInt32Number nSamples[MAX_INPUT_DIMENSIONS];  // Valid on all kinds of tables
-    cmsUInt32Number Domain[MAX_INPUT_DIMENSIONS];    // Domain = nSamples - 1
-
-    cmsUInt32Number opta[MAX_INPUT_DIMENSIONS];     // Optimization for 3D CLUT. This is the number of nodes premultiplied for each
-                                                    // dimension. For example, in 7 nodes, 7, 7^2 , 7^3, 7^4, etc. On non-regular
-                                                    // Samplings may vary according of the number of nodes for each dimension.
-
-    const void *Table;                // Points to the actual interpolation table
-    cmsInterpFunction Interpolation;  // Points to the function to do the interpolation
-
- } cmsInterpParams;
-
-// Interpolators factory
-typedef cmsInterpFunction (* cmsInterpFnFactory)(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags);
-
-// The plug-in
-typedef struct {
-    cmsPluginBase base;
-
-    // Points to a user-supplied function which implements the factory
-    cmsInterpFnFactory InterpolatorsFactory;
-
-} cmsPluginInterpolation;
-
-//----------------------------------------------------------------------------------------------------------
-
-// Parametric curves. A negative type means same function but analytically inverted. Max. number of params is 10
-
-// Evaluator callback for user-suplied parametric curves. May implement more than one type
-typedef  cmsFloat64Number (* cmsParametricCurveEvaluator)(cmsInt32Number Type, const cmsFloat64Number Params[10], cmsFloat64Number R);
-
-// Plug-in may implement an arbitrary number of parametric curves
-typedef struct {
-    cmsPluginBase base;
-
-    cmsUInt32Number nFunctions;                                     // Number of supported functions
-    cmsUInt32Number FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types
-    cmsUInt32Number ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function
-
-    cmsParametricCurveEvaluator    Evaluator;                       // The evaluator
-
-} cmsPluginParametricCurves;
-//----------------------------------------------------------------------------------------------------------
-
-// Formatters. This plug-in adds new handlers, replacing them if they already exist. Formatters dealing with
-// cmsFloat32Number (bps = 4) or double (bps = 0) types are requested via FormatterFloat callback. Others come across
-// Formatter16 callback
-
-struct _cmstransform_struct;
-
-typedef cmsUInt8Number* (* cmsFormatter16)(register struct _cmstransform_struct* CMMcargo,
-                                           register cmsUInt16Number Values[],
-                                           register cmsUInt8Number*  Buffer,
-                                           register cmsUInt32Number  Stride);
-
-typedef cmsUInt8Number* (* cmsFormatterFloat)(struct _cmstransform_struct* CMMcargo,
-                                              cmsFloat32Number Values[],
-                                              cmsUInt8Number*  Buffer,
-                                              cmsUInt32Number  Stride);
-
-// This type holds a pointer to a formatter that can be either 16 bits or cmsFloat32Number
-typedef union {
-    cmsFormatter16    Fmt16;
-    cmsFormatterFloat FmtFloat;
-
-} cmsFormatter;
-
-#define CMS_PACK_FLAGS_16BITS       0x0000
-#define CMS_PACK_FLAGS_FLOAT        0x0001
-
-typedef enum { cmsFormatterInput=0, cmsFormatterOutput=1 } cmsFormatterDirection;
-
-typedef cmsFormatter (* cmsFormatterFactory)(cmsUInt32Number Type,           // Specific type, i.e. TYPE_RGB_8
-                                             cmsFormatterDirection Dir,
-                                             cmsUInt32Number dwFlags);      // precision
-
-// Plug-in may implement an arbitrary number of formatters
-typedef struct {
-    cmsPluginBase          base;
-    cmsFormatterFactory    FormattersFactory;
-
-} cmsPluginFormatters;
-
-//----------------------------------------------------------------------------------------------------------
-
-// Tag type handler. Each type is free to return anything it wants, and it is up to the caller to
-// know in advance what is the type contained in the tag.
-typedef struct _cms_typehandler_struct {
-
-        cmsTagTypeSignature Signature;     // The signature of the type
-
-        // Allocates and reads items
-        void *   (* ReadPtr)(struct _cms_typehandler_struct* self,
-                             cmsIOHANDLER*      io,
-                             cmsUInt32Number*   nItems,
-                             cmsUInt32Number    SizeOfTag);
-
-        // Writes n Items
-        cmsBool  (* WritePtr)(struct _cms_typehandler_struct* self,
-                              cmsIOHANDLER*     io,
-                              void*             Ptr,
-                              cmsUInt32Number   nItems);
-
-        // Duplicate an item or array of items
-        void*   (* DupPtr)(struct _cms_typehandler_struct* self,
-                           const void *Ptr,
-                           cmsUInt32Number n);
-
-        // Free all resources
-        void    (* FreePtr)(struct _cms_typehandler_struct* self,
-                            void *Ptr);
-
-        // Additional parameters used by the calling thread
-        cmsContext     ContextID;
-        cmsUInt32Number  ICCVersion;
-
-} cmsTagTypeHandler;
-
-// Each plug-in implements a single type
-typedef struct {
-        cmsPluginBase      base;
-        cmsTagTypeHandler  Handler;
-
-} cmsPluginTagType;
-
-//----------------------------------------------------------------------------------------------------------
-
-// This is the tag plugin, which identifies tags. For writing, a pointer to function is provided.
-// This function should return the desired type for this tag, given the version of profile
-// and the data being serialized.
-typedef struct {
-
-    cmsUInt32Number     ElemCount;          // If this tag needs an array, how many elements should keep
-
-    // For reading.
-    cmsUInt32Number     nSupportedTypes;    // In how many types this tag can come (MAX_TYPES_IN_LCMS_PLUGIN maximum)
-    cmsTagTypeSignature SupportedTypes[MAX_TYPES_IN_LCMS_PLUGIN];
-
-    // For writting
-    cmsTagTypeSignature (* DecideType)(cmsFloat64Number ICCVersion, const void *Data);
-
-} cmsTagDescriptor;
-
-// Plug-in implements a single tag
-typedef struct {
-    cmsPluginBase    base;
-
-    cmsTagSignature  Signature;
-    cmsTagDescriptor Descriptor;
-
-} cmsPluginTag;
-
-//----------------------------------------------------------------------------------------------------------
-
-// Custom intents. This function should join all profiles specified in the array in
-// a single LUT. Any custom intent in the chain redirects to custom function. If more than
-// one custom intent is found, the one located first is invoked. Usually users should use only one
-// custom intent, so mixing custom intents in same multiprofile transform is not supported.
-
-typedef cmsPipeline* (* cmsIntentFn)( cmsContext       ContextID,
-                                      cmsUInt32Number  nProfiles,
-                                      cmsUInt32Number  Intents[],
-                                      cmsHPROFILE      hProfiles[],
-                                      cmsBool          BPC[],
-                                      cmsFloat64Number AdaptationStates[],
-                                      cmsUInt32Number  dwFlags);
-
-
-// Each plug-in defines a single intent number.
-typedef struct {
-    cmsPluginBase     base;
-    cmsUInt32Number   Intent;
-    cmsIntentFn       Link;
-    char              Description[256];
-
-} cmsPluginRenderingIntent;
-
-
-// The default ICC intents (perceptual, saturation, rel.col and abs.col)
-CMSAPI cmsPipeline*  CMSEXPORT _cmsDefaultICCintents(cmsContext       ContextID,
-                                                     cmsUInt32Number  nProfiles,
-                                                     cmsUInt32Number  Intents[],
-                                                     cmsHPROFILE      hProfiles[],
-                                                     cmsBool          BPC[],
-                                                     cmsFloat64Number AdaptationStates[],
-                                                     cmsUInt32Number  dwFlags);
-
-
-//----------------------------------------------------------------------------------------------------------
-
-// Pipelines, Multi Process Elements.
-
-typedef void (* _cmsStageEvalFn)     (const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage* mpe);
-typedef void*(* _cmsStageDupElemFn)  (cmsStage* mpe);
-typedef void (* _cmsStageFreeElemFn) (cmsStage* mpe);
-
-
-// This function allocates a generic MPE
-CMSAPI cmsStage* CMSEXPORT _cmsStageAllocPlaceholder(cmsContext ContextID,
-                                cmsStageSignature     Type,
-                                cmsUInt32Number       InputChannels,
-                                cmsUInt32Number       OutputChannels,
-                                _cmsStageEvalFn       EvalPtr,            // Points to fn that evaluates the element (always in floating point)
-                                _cmsStageDupElemFn    DupElemPtr,         // Points to a fn that duplicates the stage
-                                _cmsStageFreeElemFn   FreePtr,            // Points to a fn that sets the element free
-                                void*                 Data);              // A generic pointer to whatever memory needed by the element
-typedef struct {
-      cmsPluginBase     base;
-      cmsTagTypeHandler Handler;
-
-}  cmsPluginMultiProcessElement;
-
-//----------------------------------------------------------------------------------------------------------
-// Optimization. Using this plug-in, additional optimization strategies may be implemented.
-// The function should return TRUE if any optimization is done on the LUT, this terminates
-// the optimization  search. Or FALSE if it is unable to optimize and want to give a chance
-// to the rest of optimizers.
-
-typedef void     (* _cmsOPTeval16Fn)(register const cmsUInt16Number In[],
-                                     register cmsUInt16Number Out[],
-                                     register const void* Data);
-
-typedef void     (* _cmsOPTfreeDataFn)(cmsContext ContextID, void* Data);
-typedef void*    (* _cmsOPTdupDataFn)(cmsContext ContextID, const void* Data);
-
-
-typedef cmsBool  (* _cmsOPToptimizeFn)(cmsPipeline** Lut,
-                                       cmsUInt32Number  Intent,
-                                       cmsUInt32Number* InputFormat,
-                                       cmsUInt32Number* OutputFormat,
-                                       cmsUInt32Number* dwFlags);
-
-// This function may be used to set the optional evaluator and a block of private data. If private data is being used, an optional
-// duplicator and free functions should also be specified in order to duplicate the LUT construct. Use NULL to inhibit such functionality.
-
-CMSAPI void CMSEXPORT _cmsPipelineSetOptimizationParameters(cmsPipeline* Lut,
-                                               _cmsOPTeval16Fn Eval16,
-                                               void* PrivateData,
-                                               _cmsOPTfreeDataFn FreePrivateDataFn,
-                                               _cmsOPTdupDataFn DupPrivateDataFn);
-
-typedef struct {
-      cmsPluginBase     base;
-
-      // Optimize entry point
-      _cmsOPToptimizeFn  OptimizePtr;
-
-}  cmsPluginOptimization;
-
-//----------------------------------------------------------------------------------------------------------
-
-#ifndef CMS_USE_CPP_API
-#   ifdef __cplusplus
-    }
-#   endif
-#endif
-
-#define _lcms_plugin_H
-#endif
diff --git a/thirdparty/liblcms2/src/cmscam02.c b/thirdparty/liblcms2/src/cmscam02.c
deleted file mode 100644
index 08eea16..0000000
--- a/thirdparty/liblcms2/src/cmscam02.c
+++ /dev/null
@@ -1,483 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// CIECAM 02 appearance model. Many thanks to Jordi Vilar for the debugging.
-
-// ---------- Implementation --------------------------------------------
-
-typedef struct  {
-    
-    cmsFloat64Number XYZ[3];
-    cmsFloat64Number RGB[3];
-    cmsFloat64Number RGBc[3];
-    cmsFloat64Number RGBp[3];
-    cmsFloat64Number RGBpa[3];
-    cmsFloat64Number a, b, h, e, H, A, J, Q, s, t, C, M;
-    cmsFloat64Number abC[2];
-    cmsFloat64Number abs[2];
-    cmsFloat64Number abM[2];
-    
-} CAM02COLOR;
-
-typedef struct  {
-    
-    CAM02COLOR adoptedWhite;
-    cmsFloat64Number LA, Yb;
-    cmsFloat64Number F, c, Nc;
-    cmsUInt32Number surround;
-    cmsFloat64Number n, Nbb, Ncb, z, FL, D;
-    
-	cmsContext ContextID;
-
-} cmsCIECAM02;
-
-
-static
-cmsFloat64Number compute_n(cmsCIECAM02* pMod) 
-{
-    return (pMod -> Yb / pMod -> adoptedWhite.XYZ[1]);
-}
-
-static
-cmsFloat64Number compute_z(cmsCIECAM02* pMod) 
-{
-    return (1.48 + pow(pMod -> n, 0.5));
-}
-
-static
-cmsFloat64Number computeNbb(cmsCIECAM02* pMod) 
-{
-    return (0.725 * pow((1.0 / pMod -> n), 0.2));
-}
-
-static
-cmsFloat64Number computeFL(cmsCIECAM02* pMod) 
-{
-    cmsFloat64Number k, FL;
-    
-    k = 1.0 / ((5.0 * pMod->LA) + 1.0);
-    FL = 0.2 * pow(k, 4.0) * (5.0 * pMod->LA) + 0.1 *
-        (pow((1.0 - pow(k, 4.0)), 2.0)) *
-        (pow((5.0 * pMod->LA), (1.0 / 3.0)));
-    
-    return FL;
-}
-
-static    
-cmsFloat64Number computeD(cmsCIECAM02* pMod) 
-{
-    cmsFloat64Number D;
-
-    D = pMod->F - (1.0/3.6)*(exp(((-pMod ->LA-42) / 92.0)));
-
-    return D;
-}
-
-
-static
-CAM02COLOR XYZtoCAT02(CAM02COLOR clr) 
-{
-    clr.RGB[0] = (clr.XYZ[0] *  0.7328) + (clr.XYZ[1] *  0.4296) + (clr.XYZ[2] * -0.1624);
-    clr.RGB[1] = (clr.XYZ[0] * -0.7036) + (clr.XYZ[1] *  1.6975) + (clr.XYZ[2] *  0.0061);
-    clr.RGB[2] = (clr.XYZ[0] *  0.0030) + (clr.XYZ[1] *  0.0136) + (clr.XYZ[2] *  0.9834);
-    
-    return clr;
-}
-
-static
-CAM02COLOR ChromaticAdaptation(CAM02COLOR clr, cmsCIECAM02* pMod) 
-{
-    cmsUInt32Number i;
-
-    for (i = 0; i < 3; i++) {
-        clr.RGBc[i] = ((pMod -> adoptedWhite.XYZ[1] *
-            (pMod->D / pMod -> adoptedWhite.RGB[i])) +
-            (1.0 - pMod->D)) * clr.RGB[i];
-    }
-
-    return clr; 
-}
-
-
-static
-CAM02COLOR CAT02toHPE(CAM02COLOR clr) 
-{
-    cmsFloat64Number M[9];
-        
-    M[0] =(( 0.38971 *  1.096124) + (0.68898 * 0.454369) + (-0.07868 * -0.009628));
-    M[1] =(( 0.38971 * -0.278869) + (0.68898 * 0.473533) + (-0.07868 * -0.005698));
-    M[2] =(( 0.38971 *  0.182745) + (0.68898 * 0.072098) + (-0.07868 *  1.015326));
-    M[3] =((-0.22981 *  1.096124) + (1.18340 * 0.454369) + ( 0.04641 * -0.009628));
-    M[4] =((-0.22981 * -0.278869) + (1.18340 * 0.473533) + ( 0.04641 * -0.005698));
-    M[5] =((-0.22981 *  0.182745) + (1.18340 * 0.072098) + ( 0.04641 *  1.015326));
-    M[6] =(-0.009628);
-    M[7] =(-0.005698);
-    M[8] =( 1.015326);
-    
-    clr.RGBp[0] = (clr.RGBc[0] * M[0]) +  (clr.RGBc[1] * M[1]) + (clr.RGBc[2] * M[2]);
-    clr.RGBp[1] = (clr.RGBc[0] * M[3]) +  (clr.RGBc[1] * M[4]) + (clr.RGBc[2] * M[5]);
-    clr.RGBp[2] = (clr.RGBc[0] * M[6]) +  (clr.RGBc[1] * M[7]) + (clr.RGBc[2] * M[8]);
-    
-    return  clr;
-}
-
-static
-CAM02COLOR NonlinearCompression(CAM02COLOR clr, cmsCIECAM02* pMod) 
-{
-    cmsUInt32Number i;
-    cmsFloat64Number temp;
-
-    for (i = 0; i < 3; i++) {
-        if (clr.RGBp[i] < 0) {
-
-            temp = pow((-1.0 * pMod->FL * clr.RGBp[i] / 100.0), 0.42);
-            clr.RGBpa[i] = (-1.0 * 400.0 * temp) / (temp + 27.13) + 0.1;
-        }
-        else {
-            temp = pow((pMod->FL * clr.RGBp[i] / 100.0), 0.42);
-            clr.RGBpa[i] = (400.0 * temp) / (temp + 27.13) + 0.1;
-        }
-    }
-    
-    clr.A = (((2.0 * clr.RGBpa[0]) + clr.RGBpa[1] + 
-        (clr.RGBpa[2] / 20.0)) - 0.305) * pMod->Nbb;
-
-    return clr;
-}
-
-static
-CAM02COLOR ComputeCorrelates(CAM02COLOR clr, cmsCIECAM02* pMod) 
-{
-    cmsFloat64Number a, b, temp, e, t, r2d, d2r;
-
-    a = clr.RGBpa[0] - (12.0 * clr.RGBpa[1] / 11.0) + (clr.RGBpa[2] / 11.0);
-    b = (clr.RGBpa[0] + clr.RGBpa[1] - (2.0 * clr.RGBpa[2])) / 9.0;
-    
-    r2d = (180.0 / 3.141592654);
-    if (a == 0) {
-        if (b == 0)     clr.h = 0;
-        else if (b > 0) clr.h = 90;
-        else            clr.h = 270;
-    }
-    else if (a > 0) {
-        temp = b / a;
-        if (b > 0)       clr.h = (r2d * atan(temp));
-        else if (b == 0) clr.h = 0;
-        else             clr.h = (r2d * atan(temp)) + 360;
-    }
-    else {
-        temp = b / a;
-        clr.h = (r2d * atan(temp)) + 180;
-    }
-    
-    d2r = (3.141592654 / 180.0);
-    e = ((12500.0 / 13.0) * pMod->Nc * pMod->Ncb) * 
-        (cos((clr.h * d2r + 2.0)) + 3.8); 
-    
-    if (clr.h < 20.14) {
-        temp = ((clr.h + 122.47)/1.2) + ((20.14 - clr.h)/0.8);
-        clr.H = 300 + (100*((clr.h + 122.47)/1.2)) / temp;
-    }
-    else if (clr.h < 90.0) {
-        temp = ((clr.h - 20.14)/0.8) + ((90.00 - clr.h)/0.7);
-        clr.H = (100*((clr.h - 20.14)/0.8)) / temp;
-    }
-    else if (clr.h < 164.25) {
-        temp = ((clr.h - 90.00)/0.7) + ((164.25 - clr.h)/1.0);
-        clr.H = 100 + ((100*((clr.h - 90.00)/0.7)) / temp);
-    }
-    else if (clr.h < 237.53) {
-        temp = ((clr.h - 164.25)/1.0) + ((237.53 - clr.h)/1.2);
-        clr.H = 200 + ((100*((clr.h - 164.25)/1.0)) / temp);
-    }
-    else {
-        temp = ((clr.h - 237.53)/1.2) + ((360 - clr.h + 20.14)/0.8);
-        clr.H = 300 + ((100*((clr.h - 237.53)/1.2)) / temp);
-    }
-    
-    clr.J = 100.0 * pow((clr.A / pMod->adoptedWhite.A), 
-        (pMod->c * pMod->z));
-
-    clr.Q = (4.0 / pMod->c) * pow((clr.J / 100.0), 0.5) *
-        (pMod->adoptedWhite.A + 4.0) * pow(pMod->FL, 0.25);
-    
-    t = (e * pow(((a * a) + (b * b)), 0.5)) /
-        (clr.RGBpa[0] + clr.RGBpa[1] + 
-        ((21.0 / 20.0) * clr.RGBpa[2]));
-
-    clr.C = pow(t, 0.9) * pow((clr.J / 100.0), 0.5) *
-        pow((1.64 - pow(0.29, pMod->n)), 0.73);
-
-    clr.M = clr.C * pow(pMod->FL, 0.25);
-    clr.s = 100.0 * pow((clr.M / clr.Q), 0.5);
-    
-    return clr;
-}
-
-
-static
-CAM02COLOR InverseCorrelates(CAM02COLOR clr, cmsCIECAM02* pMod) 
-{
-    
-    cmsFloat64Number t, e, p1, p2, p3, p4, p5, hr, d2r;
-    d2r = 3.141592654 / 180.0;
-    
-    t = pow( (clr.C / (pow((clr.J / 100.0), 0.5) *
-        (pow((1.64 - pow(0.29, pMod->n)), 0.73)))), 
-        (1.0 / 0.9) );
-    e = ((12500.0 / 13.0) * pMod->Nc * pMod->Ncb) *
-        (cos((clr.h * d2r + 2.0)) + 3.8);
-    
-    clr.A = pMod->adoptedWhite.A * pow(
-           (clr.J / 100.0),
-           (1.0 / (pMod->c * pMod->z)));
-    
-    p1 = e / t;
-    p2 = (clr.A / pMod->Nbb) + 0.305;
-    p3 = 21.0 / 20.0;
-    
-    hr = clr.h * d2r;
-    
-    if (fabs(sin(hr)) >= fabs(cos(hr))) {
-        p4 = p1 / sin(hr);
-        clr.b = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /
-            (p4 + (2.0 + p3) * (220.0 / 1403.0) *
-            (cos(hr) / sin(hr)) - (27.0 / 1403.0) +
-            p3 * (6300.0 / 1403.0));
-        clr.a = clr.b * (cos(hr) / sin(hr));
-    }
-    else {
-        p5 = p1 / cos(hr);
-        clr.a = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /
-            (p5 + (2.0 + p3) * (220.0 / 1403.0) -
-            ((27.0 / 1403.0) - p3 * (6300.0 / 1403.0)) *
-            (sin(hr) / cos(hr)));
-        clr.b = clr.a * (sin(hr) / cos(hr));
-    }
-    
-    clr.RGBpa[0] = ((460.0 / 1403.0) * p2) + 
-              ((451.0 / 1403.0) * clr.a) +
-              ((288.0 / 1403.0) * clr.b);
-    clr.RGBpa[1] = ((460.0 / 1403.0) * p2) - 
-              ((891.0 / 1403.0) * clr.a) -
-              ((261.0 / 1403.0) * clr.b);
-    clr.RGBpa[2] = ((460.0 / 1403.0) * p2) -
-              ((220.0 / 1403.0) * clr.a) -
-              ((6300.0 / 1403.0) * clr.b);
-    
-    return clr;
-}
-
-static
-CAM02COLOR InverseNonlinearity(CAM02COLOR clr, cmsCIECAM02* pMod)
-{
-    cmsUInt32Number i;
-    cmsFloat64Number c1;
-    
-    for (i = 0; i < 3; i++) {
-        if ((clr.RGBpa[i] - 0.1) < 0) c1 = -1;
-        else                               c1 = 1;
-        clr.RGBp[i] = c1 * (100.0 / pMod->FL) *
-            pow(((27.13 * fabs(clr.RGBpa[i] - 0.1)) /
-            (400.0 - fabs(clr.RGBpa[i] - 0.1))),
-            (1.0 / 0.42));
-    }
-    
-    return clr;
-}
-
-static
-CAM02COLOR HPEtoCAT02(CAM02COLOR clr) 
-{
-    cmsFloat64Number M[9];
-    
-    M[0] = (( 0.7328 *  1.910197) + (0.4296 * 0.370950));
-    M[1] = (( 0.7328 * -1.112124) + (0.4296 * 0.629054));
-    M[2] = (( 0.7328 *  0.201908) + (0.4296 * 0.000008) - 0.1624);
-    M[3] = ((-0.7036 *  1.910197) + (1.6975 * 0.370950));
-    M[4] = ((-0.7036 * -1.112124) + (1.6975 * 0.629054));
-    M[5] = ((-0.7036 *  0.201908) + (1.6975 * 0.000008) + 0.0061);
-    M[6] = (( 0.0030 *  1.910197) + (0.0136 * 0.370950));
-    M[7] = (( 0.0030 * -1.112124) + (0.0136 * 0.629054));
-    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);;
-    
-    clr.RGBc[0] = (clr.RGBp[0] * M[0]) + (clr.RGBp[1] * M[1]) + (clr.RGBp[2] * M[2]);
-    clr.RGBc[1] = (clr.RGBp[0] * M[3]) + (clr.RGBp[1] * M[4]) + (clr.RGBp[2] * M[5]);
-    clr.RGBc[2] = (clr.RGBp[0] * M[6]) + (clr.RGBp[1] * M[7]) + (clr.RGBp[2] * M[8]);
-    return clr;
-}
-
-
-static
-CAM02COLOR InverseChromaticAdaptation(CAM02COLOR clr,  cmsCIECAM02* pMod) 
-{
-    cmsUInt32Number i;
-    for (i = 0; i < 3; i++) { 
-        clr.RGB[i] = clr.RGBc[i] /
-            ((pMod->adoptedWhite.XYZ[1] * pMod->D / pMod->adoptedWhite.RGB[i]) + 1.0 - pMod->D);
-    }
-    return clr;
-}
-
-
-static
-CAM02COLOR CAT02toXYZ(CAM02COLOR clr) 
-{
-    clr.XYZ[0] = (clr.RGB[0] *  1.096124) + (clr.RGB[1] * -0.278869) + (clr.RGB[2] *  0.182745);
-    clr.XYZ[1] = (clr.RGB[0] *  0.454369) + (clr.RGB[1] *  0.473533) + (clr.RGB[2] *  0.072098);
-    clr.XYZ[2] = (clr.RGB[0] * -0.009628) + (clr.RGB[1] * -0.005698) + (clr.RGB[2] *  1.015326);
-    
-    return clr;
-}
-
-
-cmsHANDLE  CMSEXPORT cmsCIECAM02Init(cmsContext ContextID, const cmsViewingConditions* pVC)
-{
-	cmsCIECAM02* lpMod;
-
-	_cmsAssert(pVC != NULL);
-
-	if((lpMod = (cmsCIECAM02*) _cmsMallocZero(ContextID, sizeof(cmsCIECAM02))) == NULL) {
-		return NULL;
-	}
-
-	lpMod ->ContextID = ContextID;
-
-	lpMod ->adoptedWhite.XYZ[0] = pVC ->whitePoint.X;
-	lpMod ->adoptedWhite.XYZ[1] = pVC ->whitePoint.Y;
-	lpMod ->adoptedWhite.XYZ[2] = pVC ->whitePoint.Z;
-
-	lpMod -> LA       = pVC ->La;
-	lpMod -> Yb       = pVC ->Yb;
-	lpMod -> D        = pVC ->D_value;
-	lpMod -> surround = pVC ->surround;
-
-	switch (lpMod -> surround) {
-
-
-	case CUTSHEET_SURROUND:
-		lpMod->F = 0.8;
-		lpMod->c = 0.41;
-		lpMod->Nc = 0.8;
-		break;
-
-	case DARK_SURROUND:
-		lpMod -> F  = 0.8;
-		lpMod -> c  = 0.525;
-		lpMod -> Nc = 0.8;
-		break;
-
-	case DIM_SURROUND:
-		lpMod -> F  = 0.9;
-		lpMod -> c  = 0.59;
-		lpMod -> Nc = 0.95;
-		break;
-
-	default:
-		// Average surround
-		lpMod -> F  = 1.0;
-		lpMod -> c  = 0.69;
-		lpMod -> Nc = 1.0;
-	}
-
-	lpMod -> n   = compute_n(lpMod);
-	lpMod -> z   = compute_z(lpMod);
-	lpMod -> Nbb = computeNbb(lpMod);
-	lpMod -> FL  = computeFL(lpMod);
-
-	if (lpMod -> D == D_CALCULATE) {
-		lpMod -> D   = computeD(lpMod);
-	}
-
-	lpMod -> Ncb = lpMod -> Nbb;
-
-	lpMod -> adoptedWhite = XYZtoCAT02(lpMod -> adoptedWhite);
-	lpMod -> adoptedWhite = ChromaticAdaptation(lpMod -> adoptedWhite, lpMod);
-	lpMod -> adoptedWhite = CAT02toHPE(lpMod -> adoptedWhite);
-	lpMod -> adoptedWhite = NonlinearCompression(lpMod -> adoptedWhite, lpMod);
-
-	return (cmsHANDLE) lpMod;
-
-}
-
-void CMSEXPORT cmsCIECAM02Done(cmsHANDLE hModel)
-{
-    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
-
-	if (lpMod) _cmsFree(lpMod ->ContextID, lpMod);
-}
-
-
-void CMSEXPORT cmsCIECAM02Forward(cmsHANDLE hModel, const cmsCIEXYZ* pIn, cmsJCh* pOut)
-{    
-    CAM02COLOR clr;
-    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
-    
-	_cmsAssert(lpMod != NULL);
-	_cmsAssert(pIn != NULL);
-	_cmsAssert(pOut != NULL);
-
-    clr.XYZ[0] = pIn ->X;
-    clr.XYZ[1] = pIn ->Y;
-    clr.XYZ[2] = pIn ->Z;
-    
-    clr = XYZtoCAT02(clr);
-    clr = ChromaticAdaptation(clr, lpMod);
-    clr = CAT02toHPE(clr);
-    clr = NonlinearCompression(clr, lpMod);
-    clr = ComputeCorrelates(clr, lpMod);
-    
-    pOut ->J = clr.J;
-    pOut ->C = clr.C;
-    pOut ->h = clr.h;         
-}
-
-void CMSEXPORT cmsCIECAM02Reverse(cmsHANDLE hModel, const cmsJCh* pIn, cmsCIEXYZ* pOut)
-{
-    CAM02COLOR clr;
-    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
-    
-	_cmsAssert(lpMod != NULL);
-	_cmsAssert(pIn != NULL);
-	_cmsAssert(pOut != NULL);
-
-    clr.J = pIn -> J;
-    clr.C = pIn -> C;
-    clr.h = pIn -> h;
-    
-    clr = InverseCorrelates(clr, lpMod);
-    clr = InverseNonlinearity(clr, lpMod);
-    clr = HPEtoCAT02(clr);
-    clr = InverseChromaticAdaptation(clr, lpMod);
-    clr = CAT02toXYZ(clr);
-    
-    pOut ->X = clr.XYZ[0];
-    pOut ->Y = clr.XYZ[1];
-    pOut ->Z = clr.XYZ[2];
-}
-
diff --git a/thirdparty/liblcms2/src/cmscgats.c b/thirdparty/liblcms2/src/cmscgats.c
deleted file mode 100644
index d41c15a..0000000
--- a/thirdparty/liblcms2/src/cmscgats.c
+++ /dev/null
@@ -1,2655 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// IT8.7 / CGATS.17-200x handling -----------------------------------------------------------------------------
-
-
-#define MAXID        128     // Max lenght of identifier
-#define MAXSTR      1024     // Max lenght of string
-#define MAXTABLES    255     // Max Number of tables in a single stream
-#define MAXINCLUDE    20     // Max number of nested includes
-
-#define DEFAULT_DBL_FORMAT  "%.10g" // Double formatting
-
-#ifdef CMS_IS_WINDOWS_
-#    include <io.h>
-#    define DIR_CHAR    '\\'
-#else
-#    define DIR_CHAR    '/'
-#endif
-
-// Symbols
-typedef enum { 
-
-        SNONE,
-        SINUM,      // Integer
-        SDNUM,      // Real
-        SIDENT,     // Identifier
-        SSTRING,    // string
-        SCOMMENT,   // comment
-        SEOLN,      // End of line
-        SEOF,       // End of stream
-        SSYNERROR,  // Syntax error found on stream
-
-        // Keywords
-
-        SBEGIN_DATA,
-        SBEGIN_DATA_FORMAT,
-        SEND_DATA,
-        SEND_DATA_FORMAT,
-        SKEYWORD,
-        SDATA_FORMAT_ID,
-        SINCLUDE
-
-    } SYMBOL;
-
-
-// How to write the value
-typedef enum { 
-
-        WRITE_UNCOOKED,
-        WRITE_STRINGIFY,            
-        WRITE_HEXADECIMAL,
-        WRITE_BINARY,
-        WRITE_PAIR
-
-    } WRITEMODE;
-
-// Linked list of variable names
-typedef struct _KeyVal {
-
-        struct _KeyVal*  Next;
-        char*            Keyword;       // Name of variable
-        struct _KeyVal*  NextSubkey;    // If key is a dictionary, points to the next item
-        char*            Subkey;        // If key is a dictionary, points to the subkey name
-        char*            Value;         // Points to value
-        WRITEMODE        WriteAs;       // How to write the value
-
-   } KEYVALUE;
-
-
-// Linked list of memory chunks (Memory sink)
-typedef struct _OwnedMem {
-
-        struct _OwnedMem* Next;
-        void *            Ptr;          // Point to value
-
-   } OWNEDMEM;
-
-// Suballocator
-typedef struct _SubAllocator {
-
-         cmsUInt8Number* Block;
-         cmsUInt32Number BlockSize;
-         cmsUInt32Number Used;
- 
-    } SUBALLOCATOR;
-
-// Table. Each individual table can hold properties and rows & cols
-typedef struct _Table {
-        
-        int            nSamples, nPatches;    // Cols, Rows
-        int            SampleID;              // Pos of ID
-        
-        KEYVALUE*      HeaderList;            // The properties
-        
-        char**         DataFormat;            // The binary stream descriptor
-        char**         Data;                  // The binary stream        
-
-    } TABLE;
-
-// File stream being parsed
-typedef struct _FileContext {
-        char           FileName[cmsMAX_PATH];    // File name if being readed from file
-        FILE*          Stream;                   // File stream or NULL if holded in memory
-    } FILECTX;
-
-// This struct hold all information about an open IT8 handler. 
-typedef struct {
-
-        char SheetType[MAXSTR];               // The first row of the IT8 (the type)
-
-        cmsUInt32Number  TablesCount;                     // How many tables in this stream
-        cmsUInt32Number  nTable;                          // The actual table
-
-        TABLE Tab[MAXTABLES];
-
-        // Memory management
-        OWNEDMEM*      MemorySink;            // The storage backend
-        SUBALLOCATOR   Allocator;             // String suballocator -- just to keep it fast
-
-        // Parser state machine
-        SYMBOL         sy;                    // Current symbol
-        int            ch;                    // Current character
-      
-        int            inum;                  // integer value
-        cmsFloat64Number         dnum;                  // real value
-        char           id[MAXID];             // identifier
-        char           str[MAXSTR];           // string
-
-        // Allowed keywords & datasets. They have visibility on whole stream
-        KEYVALUE*     ValidKeywords;
-        KEYVALUE*     ValidSampleID;
-              
-        char*          Source;                // Points to loc. being parsed
-        int            lineno;                // line counter for error reporting
-       
-        FILECTX*       FileStack[MAXINCLUDE]; // Stack of files being parsed
-        int            IncludeSP;             // Include Stack Pointer
-
-        char*          MemoryBlock;           // The stream if holded in memory
-
-        char           DoubleFormatter[MAXID];// Printf-like 'cmsFloat64Number' formatter
-
-        cmsContext    ContextID;              // The threading context
-
-   } cmsIT8;
-
-
-// The stream for save operations
-typedef struct {
-
-        FILE* stream;   // For save-to-file behaviour
-
-        cmsUInt8Number* Base;
-        cmsUInt8Number* Ptr;        // For save-to-mem behaviour
-        cmsUInt32Number Used;
-        cmsUInt32Number Max;
-
-    } SAVESTREAM;
-
-
-// ------------------------------------------------------ cmsIT8 parsing routines
-
-
-// A keyword
-typedef struct {
-
-        const char *id;
-        SYMBOL sy;
-
-   } KEYWORD;
-
-// The keyword->symbol translation table. Sorting is required.
-static const KEYWORD TabKeys[] = {
- 
-        {"$INCLUDE",               SINCLUDE},   // This is an extension!
-        {".INCLUDE",               SINCLUDE},   // This is an extension!
-
-        {"BEGIN_DATA",             SBEGIN_DATA },
-        {"BEGIN_DATA_FORMAT",      SBEGIN_DATA_FORMAT },
-        {"DATA_FORMAT_IDENTIFIER", SDATA_FORMAT_ID},
-        {"END_DATA",               SEND_DATA},
-        {"END_DATA_FORMAT",        SEND_DATA_FORMAT},
-        {"KEYWORD",                SKEYWORD}
-        };
-
-#define NUMKEYS (sizeof(TabKeys)/sizeof(KEYWORD))
-
-// Predefined properties
-
-// A property
-typedef struct {
-        const char *id;    // The identifier
-        WRITEMODE as;      // How is supposed to be written
-    } PROPERTY;
-
-static PROPERTY PredefinedProperties[] = {
-
-        {"NUMBER_OF_FIELDS", WRITE_UNCOOKED},    // Required - NUMBER OF FIELDS
-        {"NUMBER_OF_SETS",   WRITE_UNCOOKED},    // Required - NUMBER OF SETS
-        {"ORIGINATOR",       WRITE_STRINGIFY},   // Required - Identifies the specific system, organization or individual that created the data file.
-        {"FILE_DESCRIPTOR",  WRITE_STRINGIFY},   // Required - Describes the purpose or contents of the data file.
-        {"CREATED",          WRITE_STRINGIFY},   // Required - Indicates date of creation of the data file.
-        {"DESCRIPTOR",       WRITE_STRINGIFY},   // Required  - Describes the purpose or contents of the data file.
-        {"DIFFUSE_GEOMETRY", WRITE_STRINGIFY},   // The diffuse geometry used. Allowed values are "sphere" or "opal".
-        {"MANUFACTURER",     WRITE_STRINGIFY},
-        {"MANUFACTURE",      WRITE_STRINGIFY},   // Some broken Fuji targets does store this value
-        {"PROD_DATE",        WRITE_STRINGIFY},   // Identifies year and month of production of the target in the form yyyy:mm.
-        {"SERIAL",           WRITE_STRINGIFY},   // Uniquely identifies individual physical target.
-
-        {"MATERIAL",         WRITE_STRINGIFY},   // Identifies the material on which the target was produced using a code
-                               // uniquely identifying th e material. This is intend ed to be used for IT8.7
-                               // physical targets only (i.e . IT8.7/1 a nd IT8.7/2).
-
-        {"INSTRUMENTATION",  WRITE_STRINGIFY},   // Used to report the specific instrumentation used (manufacturer and
-                               // model number) to generate the data reported. This data will often
-                               // provide more information about the particular data collected than an
-                               // extensive list of specific details. This is particularly important for
-                               // spectral data or data derived from spectrophotometry.
-
-        {"MEASUREMENT_SOURCE", WRITE_STRINGIFY}, // Illumination used for spectral measurements. This data helps provide
-                               // a guide to the potential for issues of paper fluorescence, etc.
-
-        {"PRINT_CONDITIONS", WRITE_STRINGIFY},   // Used to define the characteristics of the printed sheet being reported.
-                               // Where standard conditions have been defined (e.g., SWOP at nominal)
-                               // named conditions may suffice. Otherwise, detailed information is
-                               // needed.
-
-        {"SAMPLE_BACKING",   WRITE_STRINGIFY},   // Identifies the backing material used behind the sample during
-                               // measurement. Allowed values are black, white, or {"na".
-
-        {"CHISQ_DOF",        WRITE_STRINGIFY},   // Degrees of freedom associated with the Chi squared statistic
-
-       // below properties are new in recent specs:
-
-        {"MEASUREMENT_GEOMETRY", WRITE_STRINGIFY}, // The type of measurement, either reflection or transmission, should be indicated 
-                               // along with details of the geometry and the aperture size and shape. For example, 
-                               // for transmission measurements it is important to identify 0/diffuse, diffuse/0, 
-                               // opal or integrating sphere, etc. For reflection it is important to identify 0/45, 
-                               // 45/0, sphere (specular included or excluded), etc.
-
-       {"FILTER",            WRITE_STRINGIFY},   // Identifies the use of physical filter(s) during measurement. Typically used to 
-                               // denote the use of filters such as none, D65, Red, Green or Blue.
-
-       {"POLARIZATION",      WRITE_STRINGIFY},   // Identifies the use of a physical polarization filter during measurement. Allowed 
-                               // values are {"yes, white, none or na.
-
-       {"WEIGHTING_FUNCTION", WRITE_PAIR},   // Indicates such functions as: the CIE standard observer functions used in the 
-                               // calculation of various data parameters (2 degree and 10 degree), CIE standard 
-                               // illuminant functions used in the calculation of various data parameters (e.g., D50,
-                               // D65, etc.), density status response, etc. If used there shall be at least one 
-                               // name-value pair following the WEIGHTING_FUNCTION tag/keyword. The first attribute 
-                               // in the set shall be {"name" and shall identify the particular parameter used.
-                               // The second shall be {"value" and shall provide the value associated with that name. 
-                               // For ASCII data, a string containing the Name and Value attribute pairs shall follow 
-                               // the weighting function keyword. A semi-colon separates attribute pairs from each 
-                               // other and within the attribute the name and value are separated by a comma.
-
-       {"COMPUTATIONAL_PARAMETER", WRITE_PAIR}, // Parameter that is used in computing a value from measured data. Name is the name 
-                               // of the calculation, parameter is the name of the parameter used in the calculation 
-                               // and value is the value of the parameter.
-
-       {"TARGET_TYPE",        WRITE_STRINGIFY},  // The type of target being measured, e.g. IT8.7/1, IT8.7/3, user defined, etc.
-
-       {"COLORANT",           WRITE_STRINGIFY},  // Identifies the colorant(s) used in creating the target.
-
-       {"TABLE_DESCRIPTOR",   WRITE_STRINGIFY},  // Describes the purpose or contents of a data table.
-
-       {"TABLE_NAME",         WRITE_STRINGIFY}   // Provides a short name for a data table.
-};
-
-#define NUMPREDEFINEDPROPS (sizeof(PredefinedProperties)/sizeof(PROPERTY))
-
-
-// Predefined sample types on dataset
-static const char* PredefinedSampleID[] = {
-        "SAMPLE_ID",      // Identifies sample that data represents
-        "STRING",         // Identifies label, or other non-machine readable value. 
-                          // Value must begin and end with a " symbol
-
-        "CMYK_C",         // Cyan component of CMYK data expressed as a percentage
-        "CMYK_M",         // Magenta component of CMYK data expressed as a percentage
-        "CMYK_Y",         // Yellow component of CMYK data expressed as a percentage
-        "CMYK_K",         // Black component of CMYK data expressed as a percentage
-        "D_RED",          // Red filter density
-        "D_GREEN",        // Green filter density
-        "D_BLUE",         // Blue filter density
-        "D_VIS",          // Visual filter density
-        "D_MAJOR_FILTER", // Major filter d ensity
-        "RGB_R",          // Red component of RGB data
-        "RGB_G",          // Green component of RGB data
-        "RGB_B",          // Blue com ponent of RGB data
-        "SPECTRAL_NM",    // Wavelength of measurement expressed in nanometers
-        "SPECTRAL_PCT",   // Percentage reflectance/transmittance
-        "SPECTRAL_DEC",   // Reflectance/transmittance
-        "XYZ_X",          // X component of tristimulus data
-        "XYZ_Y",          // Y component of tristimulus data
-        "XYZ_Z",          // Z component of tristimulus data
-        "XYY_X"           // x component of chromaticity data
-        "XYY_Y",          // y component of chromaticity data
-        "XYY_CAPY",       // Y component of tristimulus data
-        "LAB_L",          // L* component of Lab data
-        "LAB_A",          // a* component of Lab data
-        "LAB_B",          // b* component of Lab data
-        "LAB_C",          // C*ab component of Lab data
-        "LAB_H",          // hab component of Lab data
-        "LAB_DE",         // CIE dE
-        "LAB_DE_94",      // CIE dE using CIE 94
-        "LAB_DE_CMC",     // dE using CMC
-        "LAB_DE_2000",    // CIE dE using CIE DE 2000
-        "MEAN_DE",        // Mean Delta E (LAB_DE) of samples compared to batch average
-                          // (Used for data files for ANSI IT8.7/1 and IT8.7/2 targets)
-        "STDEV_X",        // Standard deviation of X (tristimulus data)
-        "STDEV_Y",        // Standard deviation of Y (tristimulus data)
-        "STDEV_Z",        // Standard deviation of Z (tristimulus data)
-        "STDEV_L",        // Standard deviation of L*
-        "STDEV_A",        // Standard deviation of a*
-        "STDEV_B",        // Standard deviation of b*
-        "STDEV_DE",       // Standard deviation of CIE dE
-        "CHI_SQD_PAR"};   // The average of the standard deviations of L*, a* and b*. It is
-                          // used to derive an estimate of the chi-squared parameter which is
-                          // recommended as the predictor of the variability of dE
-
-#define NUMPREDEFINEDSAMPLEID (sizeof(PredefinedSampleID)/sizeof(char *))
-
-//Forward declaration of some internal functions        
-static void* AllocChunk(cmsIT8* it8, cmsUInt32Number size);
-
-// Checks if c is a separator
-static
-cmsBool isseparator(int c)
-{
-        return (c == ' ') || (c == '\t') || (c == '\r');
-}
-
-// Checks whatever if c is a valid identifier char
-static 
-cmsBool ismiddle(int c)
-{
-   return (!isseparator(c) && (c != '#') && (c !='\"') && (c != '\'') && (c > 32) && (c < 127));
-}
-
-// Checks whatsever if c is a valid identifier middle char.
-static
-cmsBool isidchar(int c)
-{
-   return isalnum(c) || ismiddle(c);
-}
-
-// Checks whatsever if c is a valid identifier first char.
-static
-cmsBool isfirstidchar(int c)
-{
-     return !isdigit(c) && ismiddle(c);
-}
-
-// Guess whether the supplied path looks like an absolute path
-static
-cmsBool isabsolutepath(const char *path)
-{
-    char ThreeChars[4];
-
-    if(path == NULL)
-        return FALSE;
-    if (path[0] == 0) 
-        return FALSE;
-
-    strncpy(ThreeChars, path, 3);
-    ThreeChars[3] = 0;
-
-    if(ThreeChars[0] == DIR_CHAR)
-        return TRUE;
-
-#ifdef  CMS_IS_WINDOWS_
-    if (isalpha((int) ThreeChars[0]) && ThreeChars[1] == ':')
-        return TRUE;
-#endif
-    return FALSE;
-}
-
-// Makes a file path based on a given reference path
-// NOTE: this function doesn't check if the path exists or even if it's legal
-static 
-cmsBool BuildAbsolutePath(const char *relPath, const char *basePath, char *buffer, cmsUInt32Number MaxLen)
-{
-    char *tail;
-    cmsUInt32Number len;
-
-    // Already absolute?
-    if (isabsolutepath(relPath)) {
-
-        strncpy(buffer, relPath, MaxLen);
-        buffer[MaxLen-1] = 0;
-        return TRUE;
-    }
-
-    // No, search for last 
-    strncpy(buffer, basePath, MaxLen);  
-    buffer[MaxLen-1] = 0;
-
-    tail = strrchr(buffer, DIR_CHAR);
-    if (tail == NULL) return FALSE;    // Is not absolute and has no separators??
-
-    len = (cmsUInt32Number) (tail - buffer);
-    if (len >= MaxLen) return FALSE;
-
-    // No need to assure zero terminator over here
-    strncpy(tail + 1, relPath, MaxLen - len);   
-
-    return TRUE;    
-}
-
-
-// Make sure no exploit is being even tried
-static
-const char* NoMeta(const char* str)
-{
-    if (strchr(str, '%') != NULL) 
-        return "**** CORRUPTED FORMAT STRING ***";
-
-    return str;
-}
-
-// Syntax error
-static
-cmsBool SynError(cmsIT8* it8, const char *Txt, ...)
-{
-    char Buffer[256], ErrMsg[1024];
-    va_list args;
-
-    va_start(args, Txt);
-    vsnprintf(Buffer, 255, Txt, args);
-    Buffer[255] = 0;
-    va_end(args);
-
-    snprintf(ErrMsg, 1023, "%s: Line %d, %s", it8->FileStack[it8 ->IncludeSP]->FileName, it8->lineno, Buffer);
-    ErrMsg[1023] = 0;
-    it8->sy = SSYNERROR;
-    cmsSignalError(it8 ->ContextID, cmsERROR_CORRUPTION_DETECTED, "%s", ErrMsg);
-    return FALSE;
-}
-
-// Check if current symbol is same as specified. issue an error else.
-static
-cmsBool Check(cmsIT8* it8, SYMBOL sy, const char* Err)
-{
-        if (it8 -> sy != sy)
-                return SynError(it8, NoMeta(Err));
-        return TRUE;
-}
-
-// Read Next character from stream
-static
-void NextCh(cmsIT8* it8)
-{
-    if (it8 -> FileStack[it8 ->IncludeSP]->Stream) {
-
-        it8 ->ch = fgetc(it8 ->FileStack[it8 ->IncludeSP]->Stream);
-
-        if (feof(it8 -> FileStack[it8 ->IncludeSP]->Stream))  {
-
-            if (it8 ->IncludeSP > 0) {
-
-                fclose(it8 ->FileStack[it8->IncludeSP--]->Stream);
-                it8 -> ch = ' ';                            // Whitespace to be ignored
-
-            } else
-                it8 ->ch = 0;   // EOF
-        }              
-    }
-    else {
-        it8->ch = *it8->Source;
-        if (it8->ch) it8->Source++;
-    }
-}
-
-
-// Try to see if current identifier is a keyword, if so return the referred symbol
-static
-SYMBOL BinSrchKey(const char *id)
-{
-    int l = 1;
-    int r = NUMKEYS;
-    int x, res;
-
-    while (r >= l)
-    {
-        x = (l+r)/2;
-        res = cmsstrcasecmp(id, TabKeys[x-1].id);
-        if (res == 0) return TabKeys[x-1].sy;
-        if (res < 0) r = x - 1;
-        else l = x + 1;
-    }
-
-    return SNONE;
-}
-
-
-// 10 ^n
-static
-cmsFloat64Number xpow10(int n)
-{
-    return pow(10, (cmsFloat64Number) n);
-}
-
-
-//  Reads a Real number, tries to follow from integer number
-static
-void ReadReal(cmsIT8* it8, int inum)
-{
-    it8->dnum = (cmsFloat64Number) inum;
-
-    while (isdigit(it8->ch)) {
-
-        it8->dnum = it8->dnum * 10.0 + (it8->ch - '0');
-        NextCh(it8);
-    }
-
-    if (it8->ch == '.') {        // Decimal point
-
-        cmsFloat64Number frac = 0.0;      // fraction
-        int prec = 0;           // precision
-
-        NextCh(it8);               // Eats dec. point
-
-        while (isdigit(it8->ch)) {
-
-            frac = frac * 10.0 + (it8->ch - '0');
-            prec++;
-            NextCh(it8);
-        }
-
-        it8->dnum = it8->dnum + (frac / xpow10(prec));
-    }
-
-    // Exponent, example 34.00E+20
-    if (toupper(it8->ch) == 'E') {
-
-        int e;
-        int sgn;
-
-        NextCh(it8); sgn = 1;
-
-        if (it8->ch == '-') {
-
-            sgn = -1; NextCh(it8);
-        }
-        else
-            if (it8->ch == '+') {
-
-                sgn = +1;
-                NextCh(it8);
-            }
-
-            e = 0;
-            while (isdigit(it8->ch)) {
-
-                if ((cmsFloat64Number) e * 10L < INT_MAX)
-                    e = e * 10 + (it8->ch - '0');
-
-                NextCh(it8);
-            }
-
-            e = sgn*e;
-            it8 -> dnum = it8 -> dnum * xpow10(e);
-    }
-}
-
-
-
-// Reads next symbol
-static
-void InSymbol(cmsIT8* it8)
-{
-    register char *idptr;
-    register int k;
-    SYMBOL key;
-    int sng;
-    
-    do {
-        
-        while (isseparator(it8->ch))
-            NextCh(it8);
-        
-        if (isfirstidchar(it8->ch)) {          // Identifier
-                        
-            k = 0;
-            idptr = it8->id;
-            
-            do {
-                
-                if (++k < MAXID) *idptr++ = (char) it8->ch;
-                
-                NextCh(it8);
-                
-            } while (isidchar(it8->ch));
-            
-            *idptr = '\0';
-            
-            
-            key = BinSrchKey(it8->id);
-            if (key == SNONE) it8->sy = SIDENT;
-            else it8->sy = key;
-            
-        }
-        else                         // Is a number?
-            if (isdigit(it8->ch) || it8->ch == '.' || it8->ch == '-' || it8->ch == '+')
-            {
-                int sign = 1;
-                
-                if (it8->ch == '-') {
-                    sign = -1;
-                    NextCh(it8);
-                }
-                
-                it8->inum = 0;
-                it8->sy   = SINUM;
-                
-                if (it8->ch == '0') {          // 0xnnnn (Hexa) or 0bnnnn (Binary)
-                
-                    NextCh(it8);
-                    if (toupper(it8->ch) == 'X') {
-
-                        int j;
-                        
-                        NextCh(it8);
-                        while (isxdigit(it8->ch))
-                        {
-                            it8->ch = toupper(it8->ch);
-                            if (it8->ch >= 'A' && it8->ch <= 'F')  j = it8->ch -'A'+10;
-                            else j = it8->ch - '0';
-                            
-                            if ((long) it8->inum * 16L > (long) INT_MAX)
-                            {
-                                SynError(it8, "Invalid hexadecimal number");
-                                return;
-                            }
-                            
-                            it8->inum = it8->inum * 16 + j;
-                            NextCh(it8);
-                        }
-                        return;
-                    }
-                    
-                    if (toupper(it8->ch) == 'B') {  // Binary
-                    
-                        int j;
-                        
-                        NextCh(it8);
-                        while (it8->ch == '0' || it8->ch == '1')
-                        {
-                            j = it8->ch - '0';
-                            
-                            if ((long) it8->inum * 2L > (long) INT_MAX)
-                            {
-                                SynError(it8, "Invalid binary number");
-                                return;
-                            }
-                            
-                            it8->inum = it8->inum * 2 + j;
-                            NextCh(it8);
-                        }
-                        return;
-                    }
-                }
-                
-
-                while (isdigit(it8->ch)) {
-
-                    if ((long) it8->inum * 10L > (long) INT_MAX) {
-                        ReadReal(it8, it8->inum);
-                        it8->sy = SDNUM;
-                        it8->dnum *= sign;
-                        return;
-                    }
-                    
-                    it8->inum = it8->inum * 10 + (it8->ch - '0');
-                    NextCh(it8);
-                }
-                
-                if (it8->ch == '.') {
-                    
-                    ReadReal(it8, it8->inum);
-                    it8->sy = SDNUM;
-                    it8->dnum *= sign;
-                    return;
-                }
-                
-                it8 -> inum *= sign;
-
-                // Special case. Numbers followed by letters are taken as identifiers
-
-                if (isidchar(it8 ->ch)) {
-
-                    if (it8 ->sy == SINUM) {
-
-                        sprintf(it8->id, "%d", it8->inum);
-                    }
-                    else {
-
-                        sprintf(it8->id, it8 ->DoubleFormatter, it8->dnum);
-                    }
-
-                    k = (int) strlen(it8 ->id);
-                    idptr = it8 ->id + k;
-                    do {
-                
-                        if (++k < MAXID) *idptr++ = (char) it8->ch;
-                
-                        NextCh(it8);
-                
-                    } while (isidchar(it8->ch));
-            
-                    *idptr = '\0';                    
-                    it8->sy = SIDENT;
-                }
-                return;
-                
-            }
-            else
-                switch ((int) it8->ch) {
-
-        // EOF marker -- ignore it
-        case '\x1a':
-            NextCh(it8);
-            break;
-
-        // Eof stream markers
-        case 0:
-        case -1:
-            it8->sy = SEOF;
-            break;
-            
-            
-        // Next line            
-        case '\n':
-            NextCh(it8);
-            it8->sy = SEOLN;
-            it8->lineno++;
-            break;
-            
-        // Comment
-        case '#':
-            NextCh(it8);
-            while (it8->ch && it8->ch != '\n')
-                NextCh(it8);
-            
-            it8->sy = SCOMMENT;
-            break;
-            
-        // String.
-        case '\'':
-        case '\"':
-            idptr = it8->str;
-            sng = it8->ch;
-            k = 0;
-            NextCh(it8);
-            
-            while (k < MAXSTR && it8->ch != sng) {
-                
-                if (it8->ch == '\n'|| it8->ch == '\r') k = MAXSTR+1;
-                else {                                    
-                    *idptr++ = (char) it8->ch;
-                    NextCh(it8);
-                    k++;
-                }
-            }
-            
-            it8->sy = SSTRING;
-            *idptr = '\0';
-            NextCh(it8);
-            break;
-            
-            
-        default:
-            SynError(it8, "Unrecognized character: 0x%x", it8 ->ch);            
-            return;            
-            }
-            
-    } while (it8->sy == SCOMMENT);
-
-    // Handle the include special token
-
-    if (it8 -> sy == SINCLUDE) {
-
-                FILECTX* FileNest;
-
-                if(it8 -> IncludeSP >= (MAXINCLUDE-1)) {
-
-                    SynError(it8, "Too many recursion levels");
-                    return;
-                }
-
-                InSymbol(it8);
-                if (!Check(it8, SSTRING, "Filename expected")) return;
-
-                FileNest = it8 -> FileStack[it8 -> IncludeSP + 1];
-                if(FileNest == NULL) {
-
-                    FileNest = it8 ->FileStack[it8 -> IncludeSP + 1] = (FILECTX*)AllocChunk(it8, sizeof(FILECTX));
-                    //if(FileNest == NULL)
-                    //  TODO: how to manage out-of-memory conditions?
-                }
-
-                if (BuildAbsolutePath(it8->str, 
-                                      it8->FileStack[it8->IncludeSP]->FileName, 
-                                      FileNest->FileName, cmsMAX_PATH-1) == FALSE) {
-                    SynError(it8, "File path too long");
-                    return;
-                }
-
-                FileNest->Stream = fopen(FileNest->FileName, "rt");
-                if (FileNest->Stream == NULL) {
-
-                        SynError(it8, "File %s not found", FileNest->FileName);
-                        return;
-                }
-                it8->IncludeSP++;
-
-                it8 ->ch = ' ';
-                InSymbol(it8);    
-    }
-                
-}
-
-// Checks end of line separator
-static
-cmsBool CheckEOLN(cmsIT8* it8)
-{
-        if (!Check(it8, SEOLN, "Expected separator")) return FALSE;
-        while (it8 -> sy == SEOLN)
-                        InSymbol(it8);
-        return TRUE;
-
-}
-
-// Skip a symbol
-
-static
-void Skip(cmsIT8* it8, SYMBOL sy)
-{
-        if (it8->sy == sy && it8->sy != SEOF)
-                        InSymbol(it8);
-}
-
-
-// Skip multiple EOLN
-static
-void SkipEOLN(cmsIT8* it8)
-{
-    while (it8->sy == SEOLN) {
-             InSymbol(it8);
-    }
-}
-
-
-// Returns a string holding current value
-static
-cmsBool GetVal(cmsIT8* it8, char* Buffer, cmsUInt32Number max, const char* ErrorTitle)
-{
-    switch (it8->sy) {
-
-    case SIDENT:  strncpy(Buffer, it8->id, max); 
-                  Buffer[max-1]=0;
-                  break;
-    case SINUM:   snprintf(Buffer, max, "%d", it8 -> inum); break;
-    case SDNUM:   snprintf(Buffer, max, it8->DoubleFormatter, it8 -> dnum); break;
-    case SSTRING: strncpy(Buffer, it8->str, max); 
-                  Buffer[max-1] = 0;
-                  break;
-
-
-    default:
-         return SynError(it8, "%s", ErrorTitle);
-    }
-
-    Buffer[max] = 0;
-    return TRUE;
-}
-
-// ---------------------------------------------------------- Table
-
-static
-TABLE* GetTable(cmsIT8* it8)
-{        
-   if ((it8 -> nTable >= it8 ->TablesCount)) {
-
-           SynError(it8, "Table %d out of sequence", it8 -> nTable);
-           return it8 -> Tab;
-   }            
-
-   return it8 ->Tab + it8 ->nTable;
-}
-
-// ---------------------------------------------------------- Memory management
-
-
-// Frees an allocator and owned memory
-void CMSEXPORT cmsIT8Free(cmsHANDLE hIT8)
-{
-   cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    if (it8 == NULL)
-        return;
-
-    if (it8->MemorySink) {
-
-        OWNEDMEM* p;
-        OWNEDMEM* n;
-
-        for (p = it8->MemorySink; p != NULL; p = n) {
-
-            n = p->Next;
-            if (p->Ptr) _cmsFree(it8 ->ContextID, p->Ptr);
-            _cmsFree(it8 ->ContextID, p);
-        }
-    }
-
-    if (it8->MemoryBlock)
-        _cmsFree(it8 ->ContextID, it8->MemoryBlock);    
-
-    _cmsFree(it8 ->ContextID, it8);
-}
-
-
-// Allocates a chunk of data, keep linked list
-static
-void* AllocBigBlock(cmsIT8* it8, cmsUInt32Number size)
-{
-    OWNEDMEM* ptr1;
-    void* ptr = _cmsMallocZero(it8->ContextID, size);
-
-    if (ptr != NULL) {
-
-        ptr1 = (OWNEDMEM*) _cmsMallocZero(it8 ->ContextID, sizeof(OWNEDMEM));
-
-        if (ptr1 == NULL) {
-
-            _cmsFree(it8 ->ContextID, ptr);
-            return NULL;
-        }
-
-        ptr1-> Ptr        = ptr;
-        ptr1-> Next       = it8 -> MemorySink;
-        it8 -> MemorySink = ptr1;
-    }
-
-    return ptr;
-}
-
-
-// Suballocator.
-static
-void* AllocChunk(cmsIT8* it8, cmsUInt32Number size)
-{
-    cmsUInt32Number Free = it8 ->Allocator.BlockSize - it8 ->Allocator.Used;
-    cmsUInt8Number* ptr;
-
-    size = _cmsALIGNLONG(size);
-
-    if (size > Free) {
-
-        if (it8 -> Allocator.BlockSize == 0)
-
-                it8 -> Allocator.BlockSize = 20*1024;
-        else
-                it8 ->Allocator.BlockSize *= 2;
-
-        if (it8 ->Allocator.BlockSize < size)
-                it8 ->Allocator.BlockSize = size;
-
-        it8 ->Allocator.Used = 0;
-        it8 ->Allocator.Block = (cmsUInt8Number*)  AllocBigBlock(it8, it8 ->Allocator.BlockSize);
-    }
-            
-    ptr = it8 ->Allocator.Block + it8 ->Allocator.Used;
-    it8 ->Allocator.Used += size;
-
-    return (void*) ptr;
-    
-}
-
-
-// Allocates a string
-static
-char *AllocString(cmsIT8* it8, const char* str)
-{
-    cmsUInt32Number Size = (cmsUInt32Number) strlen(str)+1;
-    char *ptr;
-
-
-    ptr = (char *) AllocChunk(it8, Size);
-    if (ptr) strncpy (ptr, str, Size-1);
-
-    return ptr;
-}  
-
-// Searches through linked list
-
-static
-cmsBool IsAvailableOnList(KEYVALUE* p, const char* Key, const char* Subkey, KEYVALUE** LastPtr)
-{
-    if (LastPtr) *LastPtr = p;
-
-    for (;  p != NULL; p = p->Next) {
-
-        if (LastPtr) *LastPtr = p;
-
-        if (*Key != '#') { // Comments are ignored
-
-            if (cmsstrcasecmp(Key, p->Keyword) == 0)
-                    break;
-        }
-        }
-
-    if (p == NULL)
-        return FALSE;
-
-    if (Subkey == 0)
-        return TRUE;
-
-    for (; p != NULL; p = p->NextSubkey) {
-
-        if (LastPtr) *LastPtr = p;
-
-        if (cmsstrcasecmp(Subkey, p->Subkey) == 0)
-                    return TRUE;
-        }
-
-    return FALSE;
-}
-
-
-
-// Add a property into a linked list
-static
-KEYVALUE* AddToList(cmsIT8* it8, KEYVALUE** Head, const char *Key, const char *Subkey, const char* xValue, WRITEMODE WriteAs)
-{
-    KEYVALUE* p;
-    KEYVALUE* last;
-
-
-    // Check if property is already in list 
-
-    if (IsAvailableOnList(*Head, Key, Subkey, &p)) {
-
-        // This may work for editing properties
-
-        //     return SynError(it8, "duplicate key <%s>", Key);                                        
-    }
-    else {
-
-        last = p;
-
-        // Allocate the container
-        p = (KEYVALUE*) AllocChunk(it8, sizeof(KEYVALUE));
-        if (p == NULL)
-        {
-            SynError(it8, "AddToList: out of memory");        
-            return NULL;
-        }
-
-        // Store name and value
-        p->Keyword = AllocString(it8, Key);
-        p->Subkey = (Subkey == NULL) ? NULL : AllocString(it8, Subkey);
-
-        // Keep the container in our list
-        if (*Head == NULL) {
-            *Head = p;
-        }
-        else
-        {
-            if (Subkey != NULL && last != NULL) {
-            
-                last->NextSubkey = p;
-
-                // If Subkey is not null, then last is the last property with the same key,
-                // but not necessarily is the last property in the list, so we need to move
-                // to the actual list end
-                while (last->Next != NULL) 
-                         last = last->Next;
-            }
-
-            if (last != NULL) last->Next = p;
-        }
-
-        p->Next    = NULL;
-        p->NextSubkey = NULL;
-    }
-
-    p->WriteAs = WriteAs;
-
-    if (xValue != NULL) {
-
-        p->Value   = AllocString(it8, xValue);
-    }
-    else {
-        p->Value   = NULL;
-    }
-
-    return p;
-}
-
-static
-KEYVALUE* AddAvailableProperty(cmsIT8* it8, const char* Key, WRITEMODE as)
-{
-    return AddToList(it8, &it8->ValidKeywords, Key, NULL, NULL, as);
-}
-
-
-static
-KEYVALUE* AddAvailableSampleID(cmsIT8* it8, const char* Key)
-{
-    return AddToList(it8, &it8->ValidSampleID, Key, NULL, NULL, WRITE_UNCOOKED);
-}
-
-
-static
-void AllocTable(cmsIT8* it8)
-{
-    TABLE* t;
-
-    t = it8 ->Tab + it8 ->TablesCount;
-
-    t->HeaderList = NULL;
-    t->DataFormat = NULL;
-    t->Data       = NULL;
-   
-    it8 ->TablesCount++;
-}
-
-
-cmsInt32Number CMSEXPORT cmsIT8SetTable(cmsHANDLE  IT8, cmsUInt32Number nTable)
-{
-     cmsIT8* it8 = (cmsIT8*) IT8;
-
-     if (nTable >= it8 ->TablesCount) {
-
-         if (nTable == it8 ->TablesCount) {
-
-             AllocTable(it8);
-         }
-         else {
-             SynError(it8, "Table %d is out of sequence", nTable);
-             return -1;
-         }
-     }
-
-     it8 ->nTable = nTable;
-
-     return nTable;
-}
-
-
-
-// Init an empty container
-cmsHANDLE  CMSEXPORT cmsIT8Alloc(cmsContext ContextID)
-{
-    cmsIT8* it8;
-    int i;
-
-    it8 = (cmsIT8*) _cmsMallocZero(ContextID, sizeof(cmsIT8));
-    if (it8 == NULL) return NULL;
-
-    AllocTable(it8);
-    
-    it8->MemoryBlock = NULL;
-    it8->MemorySink  = NULL;
-    
-    it8 ->nTable = 0;
-
-    it8->ContextID = ContextID;
-    it8->Allocator.Used = 0;
-    it8->Allocator.Block = NULL;
-    it8->Allocator.BlockSize = 0;  
-
-    it8->ValidKeywords = NULL;
-    it8->ValidSampleID = NULL;
-
-    it8 -> sy = SNONE;
-    it8 -> ch = ' ';
-    it8 -> Source = NULL;
-    it8 -> inum = 0;
-    it8 -> dnum = 0.0;
-
-    it8->FileStack[0] = (FILECTX*)AllocChunk(it8, sizeof(FILECTX));
-    it8->IncludeSP   = 0;
-    it8 -> lineno = 1;
-
-    strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);
-    strcpy(it8->SheetType, "CGATS.17");
-
-    // Initialize predefined properties & data
-    
-    for (i=0; i < NUMPREDEFINEDPROPS; i++)
-            AddAvailableProperty(it8, PredefinedProperties[i].id, PredefinedProperties[i].as);
-
-    for (i=0; i < NUMPREDEFINEDSAMPLEID; i++)
-            AddAvailableSampleID(it8, PredefinedSampleID[i]);
-
-
-   return (cmsHANDLE) it8;
-}
-
-
-const char* CMSEXPORT cmsIT8GetSheetType(cmsHANDLE hIT8)
-{
-        cmsIT8* it8 = (cmsIT8*) hIT8;
-
-        return it8 ->SheetType;
-
-}
-
-cmsBool CMSEXPORT cmsIT8SetSheetType(cmsHANDLE hIT8, const char* Type)
-{
-        cmsIT8* it8 = (cmsIT8*) hIT8;
-
-        strncpy(it8 ->SheetType, Type, MAXSTR-1);
-        it8 ->SheetType[MAXSTR-1] = 0;
-        return TRUE;
-}
-
-cmsBool CMSEXPORT cmsIT8SetComment(cmsHANDLE hIT8, const char* Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    if (!Val) return FALSE;
-    if (!*Val) return FALSE;
-
-    return AddToList(it8, &GetTable(it8)->HeaderList, "# ", NULL, Val, WRITE_UNCOOKED) != NULL;
-}
-
-
-
-// Sets a property
-cmsBool CMSEXPORT cmsIT8SetPropertyStr(cmsHANDLE hIT8, const char* Key, const char *Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    if (!Val) return FALSE;
-    if (!*Val) return FALSE;
-
-    return AddToList(it8, &GetTable(it8)->HeaderList, Key, NULL, Val, WRITE_STRINGIFY) != NULL;
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetPropertyDbl(cmsHANDLE hIT8, const char* cProp, cmsFloat64Number Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    char Buffer[1024];
-   
-    sprintf(Buffer, it8->DoubleFormatter, Val);
-
-    return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_UNCOOKED) != NULL;    
-}
-
-cmsBool CMSEXPORT cmsIT8SetPropertyHex(cmsHANDLE hIT8, const char* cProp, cmsUInt32Number Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    char Buffer[1024];
-   
-    sprintf(Buffer, "%d", Val);
-
-    return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_HEXADECIMAL) != NULL;    
-}
-
-cmsBool CMSEXPORT cmsIT8SetPropertyUncooked(cmsHANDLE hIT8, const char* Key, const char* Buffer)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;    
-    
-    return AddToList(it8, &GetTable(it8)->HeaderList, Key, NULL, Buffer, WRITE_UNCOOKED) != NULL;
-}
-
-cmsBool CMSEXPORT cmsIT8SetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char* SubKey, const char *Buffer)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    return AddToList(it8, &GetTable(it8)->HeaderList, Key, SubKey, Buffer, WRITE_PAIR) != NULL;
-}
-
-// Gets a property
-const char* CMSEXPORT cmsIT8GetProperty(cmsHANDLE hIT8, const char* Key)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    KEYVALUE* p;
-
-    if (IsAvailableOnList(GetTable(it8) -> HeaderList, Key, NULL, &p))
-    {
-        return p -> Value;
-    }
-    return NULL;
-}
-
-
-cmsFloat64Number CMSEXPORT cmsIT8GetPropertyDbl(cmsHANDLE hIT8, const char* cProp)
-{
-    const char *v = cmsIT8GetProperty(hIT8, cProp);
-
-    if (v) return atof(v);
-    else return 0.0;
-}
-
-const char* CMSEXPORT cmsIT8GetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char *SubKey)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    KEYVALUE* p;
-
-    if (IsAvailableOnList(GetTable(it8) -> HeaderList, Key, SubKey, &p)) {
-        return p -> Value;
-    }
-    return NULL;
-}
-
-// ----------------------------------------------------------------- Datasets
-
-
-static
-void AllocateDataFormat(cmsIT8* it8)
-{
-    TABLE* t = GetTable(it8);
-
-    if (t -> DataFormat) return;    // Already allocated
-
-    t -> nSamples  = (int) cmsIT8GetPropertyDbl(it8, "NUMBER_OF_FIELDS");
-
-    if (t -> nSamples <= 0) {
-
-        SynError(it8, "AllocateDataFormat: Unknown NUMBER_OF_FIELDS");
-        t -> nSamples = 10;
-        }
-
-    t -> DataFormat = (char**) AllocChunk (it8, (t->nSamples + 1) * sizeof(char *));
-    if (t->DataFormat == NULL) {
-
-        SynError(it8, "AllocateDataFormat: Unable to allocate dataFormat array");
-    }
-
-}
-
-static
-const char *GetDataFormat(cmsIT8* it8, int n)
-{
-    TABLE* t = GetTable(it8);
-
-    if (t->DataFormat)
-        return t->DataFormat[n];
-
-    return NULL;
-}
-
-static
-cmsBool SetDataFormat(cmsIT8* it8, int n, const char *label)
-{
-    TABLE* t = GetTable(it8);
-
-    if (!t->DataFormat)
-        AllocateDataFormat(it8);
-
-    if (n > t -> nSamples) {
-        SynError(it8, "More than NUMBER_OF_FIELDS fields.");
-        return FALSE;
-    }
-    
-    if (t->DataFormat) {                
-        t->DataFormat[n] = AllocString(it8, label);
-    }
-
-    return TRUE;
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetDataFormat(cmsHANDLE  h, int n, const char *Sample)
-{
-        cmsIT8* it8 = (cmsIT8*) h;
-        return SetDataFormat(it8, n, Sample);
-}
-
-static
-void AllocateDataSet(cmsIT8* it8)
-{
-    TABLE* t = GetTable(it8);
-
-    if (t -> Data) return;    // Already allocated
-
-    t-> nSamples   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_FIELDS"));
-    t-> nPatches   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_SETS"));
-
-    t-> Data = (char**)AllocChunk (it8, (t->nSamples + 1) * (t->nPatches + 1) *sizeof (char*));
-    if (t->Data == NULL) {
-
-        SynError(it8, "AllocateDataSet: Unable to allocate data array");
-    }
-
-}
-
-static
-char* GetData(cmsIT8* it8, int nSet, int nField)
-{
-    TABLE* t = GetTable(it8);
-    int  nSamples   = t -> nSamples;
-    int  nPatches   = t -> nPatches;
-    
-    if (nSet >= nPatches || nField >= nSamples)
-        return NULL;
-
-    if (!t->Data) return NULL;
-    return t->Data [nSet * nSamples + nField];
-}
-
-static
-cmsBool SetData(cmsIT8* it8, int nSet, int nField, const char *Val)
-{
-    TABLE* t = GetTable(it8);
-
-    if (!t->Data)
-        AllocateDataSet(it8);
-
-    if (!t->Data) return FALSE;
-
-    if (nSet > t -> nPatches || nSet < 0) {
-
-            return SynError(it8, "Patch %d out of range, there are %d patches", nSet, t -> nPatches);            
-    }
-
-    if (nField > t ->nSamples || nField < 0) {
-            return SynError(it8, "Sample %d out of range, there are %d samples", nField, t ->nSamples);
-            
-    }
-    
-    t->Data [nSet * t -> nSamples + nField] = AllocString(it8, Val);
-    return TRUE;
-}
-
-
-// --------------------------------------------------------------- File I/O
-
-
-// Writes a string to file
-static
-void WriteStr(SAVESTREAM* f, const char *str)
-{
-    cmsUInt32Number len;
-
-    if (str == NULL) 
-        str = " ";
-    
-    // Lenghth to write
-    len = (cmsUInt32Number) strlen(str);
-    f ->Used += len;
-    
-
-    if (f ->stream) {   // Should I write it to a file?
-
-        if (fwrite(str, 1, len, f->stream) != len) {
-            cmsSignalError(0, cmsERROR_WRITE, "Write to file error in CGATS parser");
-            return;
-        }          
-        
-    }
-    else {  // Or to a memory block?
-                        
-        if (f ->Base) {   // Am I just counting the bytes?
-            
-            if (f ->Used > f ->Max) {
-
-                 cmsSignalError(0, cmsERROR_WRITE, "Write to memory overflows in CGATS parser");
-                 return;
-            }
-            
-            memmove(f ->Ptr, str, len);
-            f->Ptr += len;
-        }
-                        
-    }   
-}
-
-
-// Write formatted
-
-static
-void Writef(SAVESTREAM* f, const char* frm, ...)
-{
-    char Buffer[4096];
-    va_list args;
-
-    va_start(args, frm);
-    vsnprintf(Buffer, 4095, frm, args);
-    Buffer[4095] = 0;
-    WriteStr(f, Buffer);
-    va_end(args);
-
-}
-
-// Writes full header
-static
-void WriteHeader(cmsIT8* it8, SAVESTREAM* fp)
-{
-    KEYVALUE* p;
-    TABLE* t = GetTable(it8);
-
-    
-    for (p = t->HeaderList; (p != NULL); p = p->Next)
-    {
-        if (*p ->Keyword == '#') {
-
-            char* Pt;
-            
-            WriteStr(fp, "#\n# ");
-            for (Pt = p ->Value; *Pt; Pt++) {
-
-
-                Writef(fp, "%c", *Pt);                
-
-                if (*Pt == '\n') {
-                    WriteStr(fp, "# ");
-                }
-            }
-        
-            WriteStr(fp, "\n#\n");
-            continue;
-        }
-
-
-        if (!IsAvailableOnList(it8-> ValidKeywords, p->Keyword, NULL, NULL)) {
-
-#ifdef CMS_STRICT_CGATS
-            WriteStr(fp, "KEYWORD\t\"");
-            WriteStr(fp, p->Keyword);
-            WriteStr(fp, "\"\n");
-#endif
-
-            AddAvailableProperty(it8, p->Keyword, WRITE_UNCOOKED);
-        }
-
-        WriteStr(fp, p->Keyword);
-        if (p->Value) {
-
-            switch (p ->WriteAs) {
-
-            case WRITE_UNCOOKED:
-                    Writef(fp, "\t%s", p ->Value);                    
-                    break;
-
-            case WRITE_STRINGIFY:
-                    Writef(fp, "\t\"%s\"", p->Value );
-                    break;
-
-            case WRITE_HEXADECIMAL:
-                    Writef(fp, "\t0x%X", atoi(p ->Value));
-                    break;
-
-            case WRITE_BINARY:
-                    Writef(fp, "\t0x%B", atoi(p ->Value));
-                    break;
-
-            case WRITE_PAIR:
-                    Writef(fp, "\t\"%s,%s\"", p->Subkey, p->Value);
-                    break;
-
-            default: SynError(it8, "Unknown write mode %d", p ->WriteAs);
-                     return;
-            }
-        }
-
-        WriteStr (fp, "\n");
-    }
-
-}
-
-
-// Writes the data format
-static
-void WriteDataFormat(SAVESTREAM* fp, cmsIT8* it8)
-{
-    int i, nSamples;
-    TABLE* t = GetTable(it8);
-
-    if (!t -> DataFormat) return;
-
-       WriteStr(fp, "BEGIN_DATA_FORMAT\n");
-       WriteStr(fp, " ");
-       nSamples = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_FIELDS"));
-
-       for (i = 0; i < nSamples; i++) {
-
-              WriteStr(fp, t->DataFormat[i]);
-              WriteStr(fp, ((i == (nSamples-1)) ? "\n" : "\t"));
-          }
-
-       WriteStr (fp, "END_DATA_FORMAT\n");
-}
-
-
-// Writes data array
-static
-void WriteData(SAVESTREAM* fp, cmsIT8* it8)
-{
-       int  i, j;
-       TABLE* t = GetTable(it8);
-
-       if (!t->Data) return;
-
-       WriteStr (fp, "BEGIN_DATA\n");
-
-       t->nPatches = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_SETS"));
-
-       for (i = 0; i < t-> nPatches; i++) {
-
-              WriteStr(fp, " ");
-
-              for (j = 0; j < t->nSamples; j++) {
-
-                     char *ptr = t->Data[i*t->nSamples+j];
-
-                     if (ptr == NULL) WriteStr(fp, "\"\"");
-                     else {
-                         // If value contains whitespace, enclose within quote
-
-                         if (strchr(ptr, ' ') != NULL) {
-
-                             WriteStr(fp, "\"");
-                             WriteStr(fp, ptr);
-                             WriteStr(fp, "\"");
-                         }
-                         else
-                            WriteStr(fp, ptr);
-                     }
-
-                     WriteStr(fp, ((j == (t->nSamples-1)) ? "\n" : "\t"));
-              }
-       }
-       WriteStr (fp, "END_DATA\n");
-}
-
-
-
-// Saves whole file
-cmsBool CMSEXPORT cmsIT8SaveToFile(cmsHANDLE hIT8, const char* cFileName)
-{
-    SAVESTREAM sd;  
-    cmsUInt32Number i;
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    memset(&sd, 0, sizeof(sd));
-
-    sd.stream = fopen(cFileName, "wt");
-    if (!sd.stream) return FALSE;
-    
-    WriteStr(&sd, it8->SheetType);
-    WriteStr(&sd, "\n");
-    for (i=0; i < it8 ->TablesCount; i++) {
-
-            cmsIT8SetTable(hIT8, i);
-            WriteHeader(it8, &sd);
-            WriteDataFormat(&sd, it8);
-            WriteData(&sd, it8);
-    }
-    
-    if (fclose(sd.stream) != 0) return FALSE;
-
-    return TRUE;
-}
-
-
-// Saves to memory
-cmsBool CMSEXPORT cmsIT8SaveToMem(cmsHANDLE hIT8, void *MemPtr, cmsUInt32Number* BytesNeeded)
-{
-    SAVESTREAM sd;  
-    cmsUInt32Number i;
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    memset(&sd, 0, sizeof(sd));
-
-    sd.stream = NULL;
-    sd.Base   = (cmsUInt8Number*)  MemPtr;
-    sd.Ptr    = sd.Base;
-
-    sd.Used = 0;
-
-    if (sd.Base) 
-        sd.Max  = *BytesNeeded;     // Write to memory?
-    else 
-        sd.Max  = 0;                // Just counting the needed bytes
-   
-    WriteStr(&sd, it8->SheetType);
-    WriteStr(&sd, "\n");
-    for (i=0; i < it8 ->TablesCount; i++) {
-
-            cmsIT8SetTable(hIT8, i);
-            WriteHeader(it8, &sd);
-            WriteDataFormat(&sd, it8);
-            WriteData(&sd, it8);
-    }
-    
-    sd.Used++;  // The \0 at the very end
-
-    if (sd.Base)
-        sd.Ptr = 0;
-
-    *BytesNeeded = sd.Used;
-
-    return TRUE;
-}
-
-
-// -------------------------------------------------------------- Higer level parsing
-
-static
-cmsBool DataFormatSection(cmsIT8* it8)
-{
-    int iField = 0;    
-    TABLE* t = GetTable(it8);
-
-    InSymbol(it8);   // Eats "BEGIN_DATA_FORMAT"
-    CheckEOLN(it8);
-
-    while (it8->sy != SEND_DATA_FORMAT &&
-        it8->sy != SEOLN &&
-        it8->sy != SEOF &&
-        it8->sy != SSYNERROR)  {
-        
-            if (it8->sy != SIDENT) {
-            
-                return SynError(it8, "Sample type expected");                    
-            }
-        
-            if (!SetDataFormat(it8, iField, it8->id)) return FALSE;
-            iField++;
-                
-            InSymbol(it8);
-            SkipEOLN(it8);
-       }
-
-       SkipEOLN(it8);
-       Skip(it8, SEND_DATA_FORMAT);
-       SkipEOLN(it8);
-
-       if (iField != t ->nSamples) {
-           SynError(it8, "Count mismatch. NUMBER_OF_FIELDS was %d, found %d\n", t ->nSamples, iField);
-
-           
-       }
-
-       return TRUE;
-}
-
-
-
-static
-cmsBool DataSection (cmsIT8* it8)
-{
-    int  iField = 0;
-    int  iSet   = 0;
-    char Buffer[256];
-    TABLE* t = GetTable(it8);
-
-    InSymbol(it8);   // Eats "BEGIN_DATA"
-    CheckEOLN(it8);
-
-    if (!t->Data)
-        AllocateDataSet(it8);
-
-    while (it8->sy != SEND_DATA && it8->sy != SEOF)
-    {
-        if (iField >= t -> nSamples) {
-            iField = 0;
-            iSet++;
-          
-        }
-
-        if (it8->sy != SEND_DATA && it8->sy != SEOF) {
-
-            if (!GetVal(it8, Buffer, 255, "Sample data expected"))
-                return FALSE;
-
-            if (!SetData(it8, iSet, iField, Buffer))
-                return FALSE;
-
-            iField++;
-            
-            InSymbol(it8);
-            SkipEOLN(it8);           
-        }
-    }
-
-    SkipEOLN(it8);
-    Skip(it8, SEND_DATA);
-    SkipEOLN(it8);
- 
-    // Check for data completion.
-
-    if ((iSet+1) != t -> nPatches)
-        return SynError(it8, "Count mismatch. NUMBER_OF_SETS was %d, found %d\n", t ->nPatches, iSet+1);
-
-    return TRUE;
-}
-
-
-
-
-static
-cmsBool HeaderSection(cmsIT8* it8)
-{
-    char VarName[MAXID];
-    char Buffer[MAXSTR];
-    KEYVALUE* Key;
-
-        while (it8->sy != SEOF &&
-               it8->sy != SSYNERROR &&
-               it8->sy != SBEGIN_DATA_FORMAT &&
-               it8->sy != SBEGIN_DATA) {
-
-
-        switch (it8 -> sy) {
-
-        case SKEYWORD:
-                InSymbol(it8);
-                if (!GetVal(it8, Buffer, MAXSTR-1, "Keyword expected")) return FALSE;                
-                if (!AddAvailableProperty(it8, Buffer, WRITE_UNCOOKED)) return FALSE;
-                InSymbol(it8);
-                break;
-
-
-        case SDATA_FORMAT_ID:
-                InSymbol(it8);
-                if (!GetVal(it8, Buffer, MAXSTR-1, "Keyword expected")) return FALSE;                
-                if (!AddAvailableSampleID(it8, Buffer)) return FALSE;
-                InSymbol(it8);
-                break;
-
-
-        case SIDENT:
-                strncpy(VarName, it8->id, MAXID-1);
-                VarName[MAXID-1] = 0;
-                
-                if (!IsAvailableOnList(it8-> ValidKeywords, VarName, NULL, &Key)) {
-
-#ifdef CMS_STRICT_CGATS               
-                 return SynError(it8, "Undefined keyword '%s'", VarName);
-#else
-                    Key = AddAvailableProperty(it8, VarName, WRITE_UNCOOKED);
-                    if (Key == NULL) return FALSE;
-#endif
-                }
-
-                InSymbol(it8);
-                if (!GetVal(it8, Buffer, MAXSTR-1, "Property data expected")) return FALSE;
-
-                if(Key->WriteAs != WRITE_PAIR) {
-                    AddToList(it8, &GetTable(it8)->HeaderList, VarName, NULL, Buffer, 
-                                (it8->sy == SSTRING) ? WRITE_STRINGIFY : WRITE_UNCOOKED);
-                }
-                else {
-                    const char *Subkey;
-                    char *Nextkey;
-                    if (it8->sy != SSTRING)
-                        return SynError(it8, "Invalid value '%s' for property '%s'.", Buffer, VarName);
-
-                    // chop the string as a list of "subkey, value" pairs, using ';' as a separator
-                    for (Subkey = Buffer; Subkey != NULL; Subkey = Nextkey)
-                    {
-                        char *Value, *temp;
-                
-                        //  identify token pair boundary
-                        Nextkey = (char*) strchr(Subkey, ';');
-                        if(Nextkey)
-                            *Nextkey++ = '\0';
-
-                        // for each pair, split the subkey and the value
-                        Value = (char*) strrchr(Subkey, ',');
-                        if(Value == NULL)
-                            return SynError(it8, "Invalid value for property '%s'.", VarName);
-
-                        // gobble the spaces before the coma, and the coma itself
-                        temp = Value++;
-                        do *temp-- = '\0'; while(temp >= Subkey && *temp == ' ');
-
-                        // gobble any space at the right
-                        temp = Value + strlen(Value) - 1;
-                        while(*temp == ' ') *temp-- = '\0'; 
-
-                        // trim the strings from the left
-                        Subkey += strspn(Subkey, " ");
-                        Value += strspn(Value, " ");
-
-                        if(Subkey[0] == 0 || Value[0] == 0)
-                            return SynError(it8, "Invalid value for property '%s'.", VarName);
-                        AddToList(it8, &GetTable(it8)->HeaderList, VarName, Subkey, Value, WRITE_PAIR);
-                    }
-                }
-                
-                InSymbol(it8);
-                break;
-
-        
-        case SEOLN: break;
-
-        default:
-                return SynError(it8, "expected keyword or identifier");
-        }
-
-    SkipEOLN(it8);
-    }
-
-    return TRUE;
-
-}
-
-
-static
-cmsBool ParseIT8(cmsIT8* it8, cmsBool nosheet)
-{
-    char* SheetTypePtr = it8 ->SheetType;
-
-    if (nosheet == 0) {
-
-    // First line is a very special case.
-
-    while (isseparator(it8->ch))
-            NextCh(it8);
-    
-    while (it8->ch != '\r' && it8 ->ch != '\n' && it8->ch != '\t' && it8 -> ch != -1) {
-
-        *SheetTypePtr++= (char) it8 ->ch;
-        NextCh(it8);
-    }
-    }
-
-    *SheetTypePtr = 0;
-    InSymbol(it8);
-   
-    SkipEOLN(it8);
-
-    while (it8-> sy != SEOF &&
-           it8-> sy != SSYNERROR) {
-
-            switch (it8 -> sy) {
-
-            case SBEGIN_DATA_FORMAT:
-                    if (!DataFormatSection(it8)) return FALSE;
-                    break;
-
-            case SBEGIN_DATA:
-
-                    if (!DataSection(it8)) return FALSE;
-                    
-                    if (it8 -> sy != SEOF) {
-
-                            AllocTable(it8);
-                            it8 ->nTable = it8 ->TablesCount - 1;
-                    }
-                    break;
-
-            case SEOLN:
-                    SkipEOLN(it8);
-                    break;
-
-            default:
-                    if (!HeaderSection(it8)) return FALSE;
-           }
-
-    }
-
-    return (it8 -> sy != SSYNERROR);
-}
-
-
-
-// Init usefull pointers
-
-static
-void CookPointers(cmsIT8* it8)
-{
-    int idField, i;
-    char* Fld;
-    cmsUInt32Number j;
-    cmsUInt32Number nOldTable = it8 ->nTable;
-
-    for (j=0; j < it8 ->TablesCount; j++) {
-
-    TABLE* t = it8 ->Tab + j;
-
-    t -> SampleID = 0;
-    it8 ->nTable = j;    
-
-    for (idField = 0; idField < t -> nSamples; idField++)
-    {
-        if (t ->DataFormat == NULL){
-            SynError(it8, "Undefined DATA_FORMAT");
-            return;
-        }
-
-        Fld = t->DataFormat[idField];
-        if (!Fld) continue;
-
-
-        if (cmsstrcasecmp(Fld, "SAMPLE_ID") == 0) {
-
-                    t -> SampleID = idField;
-                
-        for (i=0; i < t -> nPatches; i++) {
-
-                char *Data = GetData(it8, i, idField);
-                if (Data) {
-                    char Buffer[256];
-                
-                    strncpy(Buffer, Data, 255);
-                    Buffer[255] = 0;
-                                       
-                    if (strlen(Buffer) <= strlen(Data))
-                        strcpy(Data, Buffer);
-                    else
-                        SetData(it8, i, idField, Buffer);
-
-                }
-                }
-        
-        }
-
-        // "LABEL" is an extension. It keeps references to forward tables
-         
-        if ((cmsstrcasecmp(Fld, "LABEL") == 0) || Fld[0] == '$' ) {
-                                        
-                    // Search for table references...
-                    for (i=0; i < t -> nPatches; i++) {
-
-                            char *Label = GetData(it8, i, idField);
-                           
-                            if (Label) {                                
-                                
-                                cmsUInt32Number k;
-
-                                // This is the label, search for a table containing 
-                                // this property
-
-                                for (k=0; k < it8 ->TablesCount; k++) {
-
-                                    TABLE* Table = it8 ->Tab + k;
-                                    KEYVALUE* p;
-
-                                    if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {
-
-                                        // Available, keep type and table
-                                        char Buffer[256];
-
-                                        char *Type  = p ->Value;
-                                        int  nTable = k;                                        
-
-                                        snprintf(Buffer, 255, "%s %d %s", Label, nTable, Type );
-                                                                                
-                                        SetData(it8, i, idField, Buffer);
-                                    }
-                                }
-
-
-                            }
-
-                    }
-
-
-        }
-
-    }
-    }
-
-    it8 ->nTable = nOldTable;
-}
-
-// Try to infere if the file is a CGATS/IT8 file at all. Read first line
-// that should be something like some printable characters plus a \n
-
-static
-int IsMyBlock(cmsUInt8Number* Buffer, int n)
-{
-    int cols = 1, space = 0, quot = 0;
-    int i;
-
-    if (n < 10) return FALSE;   // Too small
-
-    if (n > 132)
-        n = 132;
-
-    for (i = 1; i < n; i++) {
-
-        switch(Buffer[i])
-        {
-        case '\n':
-        case '\r':
-            return quot == 1 || cols > 2 ? 0 : cols;
-        case '\t':
-        case ' ':
-            if(!quot && !space)
-                space = 1;
-            break;
-        case '\"':
-            quot = !quot;
-            break;
-        default:
-            if (Buffer[i] < 32) return 0;
-            if (Buffer[i] > 127) return 0;
-            cols += space;
-            space = 0;
-            break;
-        }
-    }
-
-    return FALSE;
-
-}
-
-
-static
-cmsBool IsMyFile(const char* FileName)
-{
-   FILE *fp;
-   cmsUInt32Number Size;
-   cmsUInt8Number Ptr[133];
-
-   fp = fopen(FileName, "rt");
-   if (!fp) {
-       cmsSignalError(0, cmsERROR_FILE, "File '%s' not found", FileName);
-       return FALSE;
-   }
-
-   Size = (cmsUInt32Number) fread(Ptr, 1, 132, fp);
-
-   if (fclose(fp) != 0) 
-	   return FALSE;
-
-   Ptr[Size] = '\0';
-
-   return IsMyBlock(Ptr, Size);
-}
-
-// ---------------------------------------------------------- Exported routines
-
-
-cmsHANDLE  CMSEXPORT cmsIT8LoadFromMem(cmsContext ContextID, void *Ptr, cmsUInt32Number len)
-{
-    cmsHANDLE hIT8; 
-    cmsIT8*  it8;
-	int type;
-
-	_cmsAssert(Ptr != NULL);
-	_cmsAssert(len != 0);
-
-    type = IsMyBlock((cmsUInt8Number*)Ptr, len);
-    if (type == 0) return NULL;
-    
-    hIT8 = cmsIT8Alloc(ContextID);
-    if (!hIT8) return NULL;
-
-    it8 = (cmsIT8*) hIT8;
-    it8 ->MemoryBlock = (char*) _cmsMalloc(ContextID, len + 1);
-
-    strncpy(it8 ->MemoryBlock, (const char*) Ptr, len);
-    it8 ->MemoryBlock[len] = 0;
-
-    strncpy(it8->FileStack[0]->FileName, "", cmsMAX_PATH-1);
-    it8-> Source = it8 -> MemoryBlock;
-
-    if (!ParseIT8(it8, type-1)) { 
-       
-        cmsIT8Free(hIT8); 
-        return FALSE; 
-    }
-
-    CookPointers(it8);
-    it8 ->nTable = 0;
-
-    _cmsFree(ContextID, it8->MemoryBlock);
-    it8 -> MemoryBlock = NULL;
-
-    return hIT8;
-
-
-}
-
-
-cmsHANDLE  CMSEXPORT cmsIT8LoadFromFile(cmsContext ContextID, const char* cFileName)
-{
-
-     cmsHANDLE hIT8; 
-     cmsIT8*  it8;
-	 int type;
-	 
-	 _cmsAssert(cFileName != NULL);
-
-	 type = IsMyFile(cFileName);
-     if (type == 0) return NULL;
-
-     hIT8 = cmsIT8Alloc(ContextID);
-     it8 = (cmsIT8*) hIT8;   
-     if (!hIT8) return NULL;
-
-
-     it8 ->FileStack[0]->Stream = fopen(cFileName, "rt");
-
-     if (!it8 ->FileStack[0]->Stream) {         
-         cmsIT8Free(hIT8);
-         return NULL;
-     }
-     
-
-    strncpy(it8->FileStack[0]->FileName, cFileName, cmsMAX_PATH-1);    
-    it8->FileStack[0]->FileName[cmsMAX_PATH-1] = 0;
-
-    if (!ParseIT8(it8, type-1)) { 
-    
-            fclose(it8 ->FileStack[0]->Stream);
-            cmsIT8Free(hIT8); 
-            return NULL; 
-    }
-
-    CookPointers(it8);
-    it8 ->nTable = 0;
-
-	if (fclose(it8 ->FileStack[0]->Stream)!= 0) {
-		    cmsIT8Free(hIT8); 
-            return NULL; 
-	}
-
-    return hIT8;
-
-}
-
-int CMSEXPORT cmsIT8EnumDataFormat(cmsHANDLE hIT8, char ***SampleNames)
-{
-	cmsIT8* it8 = (cmsIT8*) hIT8;
-	TABLE* t;
-
-	_cmsAssert(hIT8 != NULL);
-
-	t = GetTable(it8);
-
-	if (SampleNames) 
-		*SampleNames = t -> DataFormat;
-	return t -> nSamples;
-}
-
-
-cmsUInt32Number CMSEXPORT cmsIT8EnumProperties(cmsHANDLE hIT8, char ***PropertyNames)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    KEYVALUE* p;
-    cmsUInt32Number n;
-    char **Props;
-    TABLE* t;
-	
-	_cmsAssert(hIT8 != NULL);
-
-	t = GetTable(it8);
-
-    // Pass#1 - count properties
-
-    n = 0;
-    for (p = t -> HeaderList;  p != NULL; p = p->Next) {
-        n++;
-    }
-
-
-    Props = (char **) AllocChunk(it8, sizeof(char *) * n);
-
-    // Pass#2 - Fill pointers
-    n = 0;
-    for (p = t -> HeaderList;  p != NULL; p = p->Next) {
-        Props[n++] = p -> Keyword;
-    }
-
-    *PropertyNames = Props;
-    return n;
-}
-
-cmsUInt32Number CMSEXPORT cmsIT8EnumPropertyMulti(cmsHANDLE hIT8, const char* cProp, const char ***SubpropertyNames)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    KEYVALUE *p, *tmp;
-    cmsUInt32Number n;
-    const char **Props;
-    TABLE* t;
-	
-	_cmsAssert(hIT8 != NULL);
-
-
-	t = GetTable(it8);
-
-    if(!IsAvailableOnList(t->HeaderList, cProp, NULL, &p)) {
-        *SubpropertyNames = 0;
-        return 0;
-    }
-
-    // Pass#1 - count properties
-
-    n = 0;
-    for (tmp = p;  tmp != NULL; tmp = tmp->NextSubkey) {
-        if(tmp->Subkey != NULL)
-            n++;
-    }
-
-
-    Props = (const char **) AllocChunk(it8, sizeof(char *) * n);
-
-    // Pass#2 - Fill pointers
-    n = 0;
-    for (tmp = p;  tmp != NULL; tmp = tmp->NextSubkey) {
-        if(tmp->Subkey != NULL)
-            Props[n++] = p ->Subkey;
-    }
-
-    *SubpropertyNames = Props;
-    return n;
-}
-
-static
-int LocatePatch(cmsIT8* it8, const char* cPatch)
-{
-    int i;
-    const char *data;
-    TABLE* t = GetTable(it8);
-
-    for (i=0; i < t-> nPatches; i++) {
-
-        data = GetData(it8, i, t->SampleID);
-        
-        if (data != NULL) {
-
-                if (cmsstrcasecmp(data, cPatch) == 0)
-                        return i;
-                }
-        }
-
-        // SynError(it8, "Couldn't find patch '%s'\n", cPatch);                               
-        return -1;
-}
-
-
-static
-int LocateEmptyPatch(cmsIT8* it8)
-{
-    int i;
-    const char *data;
-    TABLE* t = GetTable(it8);
-
-    for (i=0; i < t-> nPatches; i++) {
-
-        data = GetData(it8, i, t->SampleID);
-
-        if (data == NULL) 
-            return i;
-
-    }
-
-    return -1;
-}
-
-static
-int LocateSample(cmsIT8* it8, const char* cSample)
-{
-    int i;
-    const char *fld;
-    TABLE* t = GetTable(it8);
-
-    for (i=0; i < t->nSamples; i++) {
-
-        fld = GetDataFormat(it8, i);
-        if (cmsstrcasecmp(fld, cSample) == 0)
-            return i;
-    }
-   
-    return -1;
-
-}
-
-
-int CMSEXPORT cmsIT8FindDataFormat(cmsHANDLE hIT8, const char* cSample)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-	_cmsAssert(hIT8 != NULL);
-
-    return LocateSample(it8, cSample);
-}
-
-
-
-const char* CMSEXPORT cmsIT8GetDataRowCol(cmsHANDLE hIT8, int row, int col)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-	_cmsAssert(hIT8 != NULL);
-
-    return GetData(it8, row, col);
-}
-
-
-cmsFloat64Number CMSEXPORT cmsIT8GetDataRowColDbl(cmsHANDLE hIT8, int row, int col)
-{
-    const char* Buffer;
-
-    Buffer = cmsIT8GetDataRowCol(hIT8, row, col);
-    
-    if (Buffer) {
-
-        return atof(Buffer);
-        
-    } else
-        return 0;
-
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetDataRowCol(cmsHANDLE hIT8, int row, int col, const char* Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    
-	_cmsAssert(hIT8 != NULL);
-
-    return SetData(it8, row, col, Val);        
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetDataRowColDbl(cmsHANDLE hIT8, int row, int col, cmsFloat64Number Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    char Buff[256];
-
-	_cmsAssert(hIT8 != NULL);
-
-    sprintf(Buff, it8->DoubleFormatter, Val);
-    
-    return SetData(it8, row, col, Buff);        
-}
-
-
-
-const char* CMSEXPORT cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample)                        
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    int iField, iSet;
-
-	_cmsAssert(hIT8 != NULL);
-
-    iField = LocateSample(it8, cSample);
-    if (iField < 0) {       
-        return NULL;
-    }
-
-    iSet = LocatePatch(it8, cPatch);
-    if (iSet < 0) {          
-            return NULL;
-    }
-
-    return GetData(it8, iSet, iField);
-}
-
-
-cmsFloat64Number CMSEXPORT cmsIT8GetDataDbl(cmsHANDLE  it8, const char* cPatch, const char* cSample)
-{
-    const char* Buffer;
-
-    Buffer = cmsIT8GetData(it8, cPatch, cSample);
-    
-    if (Buffer) {
-
-        return atof(Buffer);
-        
-    } else {
-        
-        return 0;
-    }
-}
-
-
-
-cmsBool CMSEXPORT cmsIT8SetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample, const char *Val)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-    int iField, iSet;
-    TABLE* t;
-	
-	_cmsAssert(hIT8 != NULL);
-
-	t = GetTable(it8);
-
-    iField = LocateSample(it8, cSample);
-
-    if (iField < 0) 
-        return FALSE;
-
-    if (t-> nPatches == 0) {
-
-        AllocateDataFormat(it8);
-        AllocateDataSet(it8);
-        CookPointers(it8);
-    }
-
-    if (cmsstrcasecmp(cSample, "SAMPLE_ID") == 0) {
-
-        iSet   = LocateEmptyPatch(it8);
-        if (iSet < 0) {
-            return SynError(it8, "Couldn't add more patches '%s'\n", cPatch);                        
-        }
-
-        iField = t -> SampleID;
-    }
-    else {
-        iSet = LocatePatch(it8, cPatch);
-        if (iSet < 0) {
-            return FALSE;
-        }
-    }
-
-    return SetData(it8, iSet, iField, Val);
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetDataDbl(cmsHANDLE hIT8, const char* cPatch,
-								   const char* cSample,
-								   cmsFloat64Number Val)
-{
-	cmsIT8* it8 = (cmsIT8*) hIT8;
-	char Buff[256];
-
-	_cmsAssert(hIT8 != NULL);
-
-	snprintf(Buff, 255, it8->DoubleFormatter, Val);
-	return cmsIT8SetData(hIT8, cPatch, cSample, Buff);
-}
-
-// Buffer should get MAXSTR at least
-
-const char* CMSEXPORT cmsIT8GetPatchName(cmsHANDLE hIT8, int nPatch, char* buffer)
-{
-	cmsIT8* it8 = (cmsIT8*) hIT8;
-	TABLE* t;
-	char* Data;
-
-	_cmsAssert(hIT8 != NULL);
-
-	t = GetTable(it8);
-	Data = GetData(it8, nPatch, t->SampleID);
-
-	if (!Data) return NULL;
-	if (!buffer) return Data;
-
-	strncpy(buffer, Data, MAXSTR-1);        
-	buffer[MAXSTR-1] = 0;
-	return buffer;
-}
-
-int CMSEXPORT cmsIT8GetPatchByName(cmsHANDLE hIT8, const char *cPatch)
-{
-	_cmsAssert(hIT8 != NULL);
-
-    return LocatePatch((cmsIT8*)hIT8, cPatch);
-}
-
-cmsUInt32Number CMSEXPORT cmsIT8TableCount(cmsHANDLE hIT8)
-{
-	cmsIT8* it8 = (cmsIT8*) hIT8;
-
-	_cmsAssert(hIT8 != NULL);
-
-	return it8 ->TablesCount;
-}
-
-// This handles the "LABEL" extension. 
-// Label, nTable, Type
-
-int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
-{
-    const char* cLabelFld;
-    char Type[256], Label[256];
-    int nTable;
-   
-    _cmsAssert(hIT8 != NULL);
-
-    if (cField != NULL && *cField == 0)
-            cField = "LABEL";
-
-    if (cField == NULL) 
-            cField = "LABEL";
-
-    cLabelFld = cmsIT8GetData(hIT8, cSet, cField); 
-    if (!cLabelFld) return -1;
-    
-    if (sscanf(cLabelFld, "%255s %d %255s", Label, &nTable, Type) != 3)
-            return -1;
-    
-    if (ExpectedType != NULL && *ExpectedType == 0)
-        ExpectedType = NULL;
-
-    if (ExpectedType) {
-
-        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
-    }
-
-    return cmsIT8SetTable(hIT8, nTable);    
-}
-
-
-cmsBool CMSEXPORT cmsIT8SetIndexColumn(cmsHANDLE hIT8, const char* cSample)
-{
-	cmsIT8* it8 = (cmsIT8*) hIT8;
-	int pos;
-
-	_cmsAssert(hIT8 != NULL);
-
-	pos = LocateSample(it8, cSample);
-	if(pos == -1)
-		return FALSE;
-
-	it8->Tab[it8->nTable].SampleID = pos;
-	return TRUE;
-}
-
-
-void CMSEXPORT cmsIT8DefineDblFormat(cmsHANDLE hIT8, const char* Formatter)
-{
-    cmsIT8* it8 = (cmsIT8*) hIT8;
-
-    _cmsAssert(hIT8 != NULL);
-
-    if (Formatter == NULL)
-        strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);
-    else
-        strcpy(it8->DoubleFormatter, Formatter);
-}
-
diff --git a/thirdparty/liblcms2/src/cmscnvrt.c b/thirdparty/liblcms2/src/cmscnvrt.c
deleted file mode 100644
index 8dadc87..0000000
--- a/thirdparty/liblcms2/src/cmscnvrt.c
+++ /dev/null
@@ -1,1039 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// Link several profiles to obtain a single LUT modelling the whole color transform. Intents, Black point 
-// compensation and Adaptation parameters may vary across profiles. BPC and Adaptation refers to the PCS
-// after the profile. I.e, BPC[0] refers to connexion between profile(0) and profile(1)
-cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID, 
-                              cmsUInt32Number nProfiles,
-                              cmsUInt32Number Intents[], 
-                              cmsHPROFILE     hProfiles[], 
-                              cmsBool         BPC[],
-                              cmsFloat64Number AdaptationStates[],
-                              cmsUInt32Number dwFlags);
-                                                        
-//---------------------------------------------------------------------------------
-
-// This is the default routine for ICC-style intents. A user may decide to override it by using a plugin. 
-// Supported intents are perceptual, relative colorimetric, saturation and ICC-absolute colorimetric
-static 
-cmsPipeline* DefaultICCintents(cmsContext     ContextID, 
-                               cmsUInt32Number nProfiles,
-                               cmsUInt32Number Intents[], 
-                               cmsHPROFILE     hProfiles[], 
-                               cmsBool         BPC[],
-                               cmsFloat64Number AdaptationStates[],
-                               cmsUInt32Number dwFlags);
-
-//---------------------------------------------------------------------------------
-
-// This is the entry for black-preserving K-only intents, which are non-ICC. Last profile have to be a output profile
-// to do the trick (no devicelinks allowed at that position)
-static
-cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID, 
-                                          cmsUInt32Number nProfiles,
-                                          cmsUInt32Number Intents[], 
-                                          cmsHPROFILE     hProfiles[], 
-                                          cmsBool         BPC[],
-                                          cmsFloat64Number AdaptationStates[],
-                                          cmsUInt32Number dwFlags);
-
-//---------------------------------------------------------------------------------
-
-// This is the entry for black-plane preserving, which are non-ICC. Again, Last profile have to be a output profile
-// to do the trick (no devicelinks allowed at that position)
-static
-cmsPipeline*  BlackPreservingKPlaneIntents(cmsContext     ContextID, 
-                                           cmsUInt32Number nProfiles,
-                                           cmsUInt32Number Intents[], 
-                                           cmsHPROFILE     hProfiles[], 
-                                           cmsBool         BPC[],
-                                           cmsFloat64Number AdaptationStates[],
-                                           cmsUInt32Number dwFlags);
-
-//---------------------------------------------------------------------------------
-
-
-// This is a structure holding implementations for all supported intents.
-typedef struct _cms_intents_list {
-
-    cmsUInt32Number Intent;
-    char            Description[256];
-    cmsIntentFn     Link;
-    struct _cms_intents_list*  Next;
-
-} cmsIntentsList;
-
-
-// Built-in intents
-static cmsIntentsList DefaultIntents[] = { 
-
-    { INTENT_PERCEPTUAL,                            "Perceptual",                                   DefaultICCintents,            &DefaultIntents[1] },
-    { INTENT_RELATIVE_COLORIMETRIC,                 "Relative colorimetric",                        DefaultICCintents,            &DefaultIntents[2] },
-    { INTENT_SATURATION,                            "Saturation",                                   DefaultICCintents,            &DefaultIntents[3] },
-    { INTENT_ABSOLUTE_COLORIMETRIC,                 "Absolute colorimetric",                        DefaultICCintents,            &DefaultIntents[4] },
-    { INTENT_PRESERVE_K_ONLY_PERCEPTUAL,            "Perceptual preserving black ink",              BlackPreservingKOnlyIntents,  &DefaultIntents[5] },
-    { INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC, "Relative colorimetric preserving black ink",   BlackPreservingKOnlyIntents,  &DefaultIntents[6] },
-    { INTENT_PRESERVE_K_ONLY_SATURATION,            "Saturation preserving black ink",              BlackPreservingKOnlyIntents,  &DefaultIntents[7] },
-    { INTENT_PRESERVE_K_PLANE_PERCEPTUAL,           "Perceptual preserving black plane",            BlackPreservingKPlaneIntents, &DefaultIntents[8] },
-    { INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC,"Relative colorimetric preserving black plane", BlackPreservingKPlaneIntents, &DefaultIntents[9] },
-    { INTENT_PRESERVE_K_PLANE_SATURATION,           "Saturation preserving black plane",            BlackPreservingKPlaneIntents, NULL } 
-};
-
-
-// A pointer to the begining of the list
-static cmsIntentsList *Intents = DefaultIntents;
-
-// Search the list for a suitable intent. Returns NULL if not found
-static 
-cmsIntentsList* SearchIntent(cmsUInt32Number Intent)
-{
-    cmsIntentsList* pt;
-
-    for (pt = Intents; pt != NULL; pt = pt -> Next)
-        if (pt ->Intent == Intent) return pt;
-
-    return NULL;
-}
-
-// Black point compensation. Implemented as a linear scaling in XYZ. Black points 
-// should come relative to the white point. Fills an matrix/offset element m
-// which is organized as a 4x4 matrix.
-static
-void ComputeBlackPointCompensation(const cmsCIEXYZ* BlackPointIn, 
-                                   const cmsCIEXYZ* BlackPointOut,
-                                   cmsMAT3* m, cmsVEC3* off)
-{ 
-  cmsFloat64Number ax, ay, az, bx, by, bz, tx, ty, tz;
-   
-   // Now we need to compute a matrix plus an offset m and of such of
-   // [m]*bpin + off = bpout
-   // [m]*D50  + off = D50
-   //
-   // This is a linear scaling in the form ax+b, where
-   // a = (bpout - D50) / (bpin - D50)
-   // b = - D50* (bpout - bpin) / (bpin - D50)
-
-   tx = BlackPointIn->X - cmsD50_XYZ()->X;
-   ty = BlackPointIn->Y - cmsD50_XYZ()->Y;
-   tz = BlackPointIn->Z - cmsD50_XYZ()->Z;
-
-   ax = (BlackPointOut->X - cmsD50_XYZ()->X) / tx;
-   ay = (BlackPointOut->Y - cmsD50_XYZ()->Y) / ty;
-   az = (BlackPointOut->Z - cmsD50_XYZ()->Z) / tz;
-
-   bx = - cmsD50_XYZ()-> X * (BlackPointOut->X - BlackPointIn->X) / tx;
-   by = - cmsD50_XYZ()-> Y * (BlackPointOut->Y - BlackPointIn->Y) / ty;
-   bz = - cmsD50_XYZ()-> Z * (BlackPointOut->Z - BlackPointIn->Z) / tz;
-
-   _cmsVEC3init(&m ->v[0], ax, 0,  0);
-   _cmsVEC3init(&m ->v[1], 0, ay,  0);
-   _cmsVEC3init(&m ->v[2], 0,  0,  az);
-   _cmsVEC3init(off, bx, by, bz);
-
-}
-
-
-// Approximate a blackbody illuminant based on CHAD information
-static
-cmsFloat64Number CHAD2Temp(const cmsMAT3* Chad)
-{
-    // Convert D50 across CHAD to get the absolute white point
-     cmsVEC3 d, s;
-     cmsCIEXYZ Dest;
-     cmsCIExyY DestChromaticity;
-     cmsFloat64Number TempK;
-
-    s.n[VX] = cmsD50_XYZ() -> X;
-    s.n[VY] = cmsD50_XYZ() -> Y;
-    s.n[VZ] = cmsD50_XYZ() -> Z;
-
-    _cmsMAT3eval(&d, Chad, &s);
-
-    Dest.X = d.n[VX];
-    Dest.Y = d.n[VY];
-    Dest.Z = d.n[VZ];
-
-    cmsXYZ2xyY(&DestChromaticity, &Dest);
-
-    if (!cmsTempFromWhitePoint(&TempK, &DestChromaticity))
-        return -1.0;
-
-    return TempK;
-}
-
-// Compute a CHAD based on a given temperature
-static
-void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)
-{
-    cmsCIEXYZ White;
-    cmsCIExyY ChromaticityOfWhite;
-    
-    cmsWhitePointFromTemp(&ChromaticityOfWhite, Temp);  
-    cmsxyY2XYZ(&White, &ChromaticityOfWhite);
-    _cmsAdaptationMatrix(Chad, NULL, cmsD50_XYZ(), &White);
-
-}
-
-// Join scalings to obtain relative input to absolute and then to relative output.
-// Result is stored in a 3x3 matrix
-static
-cmsBool  ComputeAbsoluteIntent(cmsFloat64Number AdaptationState,
-                               const cmsCIEXYZ* WhitePointIn,    
-                               const cmsMAT3* ChromaticAdaptationMatrixIn,
-                               const cmsCIEXYZ* WhitePointOut,
-                               const cmsMAT3* ChromaticAdaptationMatrixOut,
-                               cmsMAT3* m)
-{
-    cmsMAT3 Scale, m1, m2, m3;
-
-    // Adaptation state
-    if (AdaptationState == 1.0) {
-
-        // Observer is fully adapted. Keep chromatic adaptation. 
-        // That is the standard V4 behaviour
-        _cmsVEC3init(&m->v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);
-        _cmsVEC3init(&m->v[1], 0, WhitePointIn->Y / WhitePointOut->Y, 0);
-        _cmsVEC3init(&m->v[2], 0, 0, WhitePointIn->Z / WhitePointOut->Z);
-
-    }
-    else  {
-
-        // Incomplete adaptation. This is an advanced feature.
-        _cmsVEC3init(&Scale.v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);
-        _cmsVEC3init(&Scale.v[1], 0,  WhitePointIn->Y / WhitePointOut->Y, 0);
-        _cmsVEC3init(&Scale.v[2], 0, 0,  WhitePointIn->Z / WhitePointOut->Z);
-
-        m1 = *ChromaticAdaptationMatrixIn;
-        if (!_cmsMAT3inverse(&m1, &m2)) return FALSE; 
-        _cmsMAT3per(&m3, &m2, &Scale);
-
-        // m3 holds CHAD from input white to D50 times abs. col. scaling
-        if (AdaptationState == 0.0) {
-
-            // Observer is not adapted, undo the chromatic adaptation
-            _cmsMAT3per(m, &m3, ChromaticAdaptationMatrixOut);
-
-        } else {
-
-            cmsMAT3 MixedCHAD;
-            cmsFloat64Number TempSrc, TempDest, Temp;
-
-            TempSrc  = CHAD2Temp(ChromaticAdaptationMatrixIn);  // K for source white
-            TempDest = CHAD2Temp(ChromaticAdaptationMatrixOut); // K for dest white
-
-            if (TempSrc < 0.0 || TempDest < 0.0) return FALSE; // Something went wrong
-
-            if (_cmsMAT3isIdentity(&Scale) && fabs(TempSrc - TempDest) < 0.01) {
-
-                _cmsMAT3identity(m);
-                return TRUE;
-            }
-
-            Temp = AdaptationState * TempSrc + (1.0 - AdaptationState) * TempDest;
-
-            // Get a CHAD from D50 to whatever output temperature. This replaces output CHAD
-            Temp2CHAD(&MixedCHAD, Temp);
-
-            _cmsMAT3per(m, &m3, &MixedCHAD);
-        }
-
-    }
-    return TRUE;
-
-}
-
-// Just to see if m matrix should be applied
-static
-cmsBool IsEmptyLayer(cmsMAT3* m, cmsVEC3* off)
-{
-    cmsFloat64Number diff = 0;
-    cmsMAT3 Ident;
-    int i;
-    
-    if (m == NULL && off == NULL) return TRUE;  // NULL is allowed as an empty layer
-    if (m == NULL && off != NULL) return FALSE; // This is an internal error
-
-    _cmsMAT3identity(&Ident);
-    
-    for (i=0; i < 3*3; i++)
-        diff += fabs(((cmsFloat64Number*)m)[i] - ((cmsFloat64Number*)&Ident)[i]);
-
-    for (i=0; i < 3; i++)
-        diff += fabs(((cmsFloat64Number*)off)[i]);
-
-
-    return (diff < 0.002);
-}
-
-
-// Compute the conversion layer
-static
-cmsBool ComputeConversion(int i, cmsHPROFILE hProfiles[], 
-                                 cmsUInt32Number Intent, 
-                                 cmsBool BPC, 
-                                 cmsFloat64Number AdaptationState, 
-                                 cmsMAT3* m, cmsVEC3* off)
-{
-
-    int k;
-
-    // m  and off are set to identity and this is detected latter on
-    _cmsMAT3identity(m);
-    _cmsVEC3init(off, 0, 0, 0);
-
-    // If intent is abs. colorimetric,
-    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC) {
-
-        cmsCIEXYZ WhitePointIn, WhitePointOut;
-        cmsMAT3 ChromaticAdaptationMatrixIn, ChromaticAdaptationMatrixOut;  
-
-        _cmsReadMediaWhitePoint(&WhitePointIn,  hProfiles[i-1]);
-        _cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i-1]);
-
-        _cmsReadMediaWhitePoint(&WhitePointOut,  hProfiles[i]);
-        _cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i]);
-
-        if (!ComputeAbsoluteIntent(AdaptationState, 
-                                  &WhitePointIn,  &ChromaticAdaptationMatrixIn, 
-                                  &WhitePointOut, &ChromaticAdaptationMatrixOut, m)) return FALSE;
-
-    }
-    else {
-        // Rest of intents may apply BPC.
-
-        if (BPC) {
-
-            cmsCIEXYZ BlackPointIn, BlackPointOut;
-
-            cmsDetectBlackPoint(&BlackPointIn,  hProfiles[i-1], Intent, 0);
-            cmsDetectBlackPoint(&BlackPointOut, hProfiles[i], Intent, 0);
-
-            // If black points are equal, then do nothing
-            if (BlackPointIn.X != BlackPointOut.X ||
-                BlackPointIn.Y != BlackPointOut.Y ||
-                BlackPointIn.Z != BlackPointOut.Z) 
-                    ComputeBlackPointCompensation(&BlackPointIn, &BlackPointOut, m, off);
-        }
-    }
-
-    // Offset should be adjusted because the encoding. We encode XYZ normalized to 0..1.0,
-    // to do that, we divide by MAX_ENCODEABLE_XZY. The conversion stage goes XYZ -> XYZ so
-    // we have first to convert from encoded to XYZ and then convert back to encoded. 
-    // y = Mx + Off
-    // x = x'c
-    // y = M x'c + Off
-    // y = y'c; y' = y / c
-    // y' = (Mx'c + Off) /c = Mx' + (Off / c) 
-
-    for (k=0; k < 3; k++) {
-        off ->n[k] /= MAX_ENCODEABLE_XYZ;
-    }
-
-    return TRUE;
-}
-
-
-// Add a conversion stage if needed. If a matrix/offset m is given, it applies to XYZ space 
-static
-cmsBool AddConversion(cmsPipeline* Result, cmsColorSpaceSignature InPCS, cmsColorSpaceSignature OutPCS, cmsMAT3* m, cmsVEC3* off)
-{
-    cmsFloat64Number* m_as_dbl = (cmsFloat64Number*) m;
-    cmsFloat64Number* off_as_dbl = (cmsFloat64Number*) off;
-
-    // Handle PCS mismatches. A specialized stage is added to the LUT in such case
-    switch (InPCS) {
-
-        case cmsSigXYZData: // Input profile operates in XYZ
-
-            switch (OutPCS) {
-
-            case cmsSigXYZData:  // XYZ -> XYZ
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
-
-            case cmsSigLabData:  // XYZ -> Lab
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                break;
-
-            default:
-                return FALSE;   // Colorspace mismatch
-                }
-                break;
-
-
-        case cmsSigLabData: // Input profile operates in Lab
-
-            switch (OutPCS) {
-
-            case cmsSigXYZData:  // Lab -> XYZ
-
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
-
-            case cmsSigLabData:  // Lab -> Lab
-
-                if (!IsEmptyLayer(m, off)) {            
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));        
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                }
-                break;
-
-            default:
-                return FALSE;  // Mismatch
-            }
-            break;
-
-
-            // On colorspaces other than PCS, check for same space
-        default:
-            if (InPCS != OutPCS) return FALSE;
-            break;
-    }
-
-    return TRUE;
-}
-
-
-// Is a given space compatible with another?
-static
-cmsBool ColorSpaceIsCompatible(cmsColorSpaceSignature a, cmsColorSpaceSignature b)
-{
-    // If they are same, they are compatible.
-    if (a == b) return TRUE;
-
-    // Check for XYZ/Lab. Those spaces are interchangeable as they can be computed one from other.
-    if ((a == cmsSigXYZData) && (b == cmsSigLabData)) return TRUE;
-    if ((a == cmsSigLabData) && (b == cmsSigXYZData)) return TRUE;
-
-    return FALSE;
-}
-
-
-// Default handler for ICC-style intents
-static
-cmsPipeline* DefaultICCintents(cmsContext       ContextID, 
-                               cmsUInt32Number  nProfiles,
-                               cmsUInt32Number  TheIntents[], 
-                               cmsHPROFILE      hProfiles[], 
-                               cmsBool          BPC[],
-                               cmsFloat64Number AdaptationStates[],
-                               cmsUInt32Number  dwFlags)
-{
-    cmsPipeline* Lut, *Result;
-    cmsHPROFILE hProfile;
-    cmsMAT3 m;
-    cmsVEC3 off;
-    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut, CurrentColorSpace; 
-    cmsProfileClassSignature ClassSig;
-    cmsUInt32Number  i, Intent;
-
-	// For safety
-	if (nProfiles == 0) return NULL;
-
-    // Allocate an empty LUT for holding the result. 0 as channel count means 'undefined'
-    Result = cmsPipelineAlloc(ContextID, 0, 0);
-    if (Result == NULL) return NULL;
-
-    CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);    
-
-    for (i=0; i < nProfiles; i++) {
-
-        cmsBool  lIsDeviceLink, lIsInput;
-
-        hProfile      = hProfiles[i];
-        ClassSig      = cmsGetDeviceClass(hProfile);
-        lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );
-      
-        // First profile is used as input unless devicelink or abstract
-		if ((i == 0) && !lIsDeviceLink) {
-			lIsInput = TRUE;
-		}
-		else {
-		  // Else use profile in the input direction if current space is not PCS
-        lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&
-                        (CurrentColorSpace != cmsSigLabData);
-		}
-
-        Intent        = TheIntents[i];
-
-        if (lIsInput || lIsDeviceLink) {
-
-            ColorSpaceIn    = cmsGetColorSpace(hProfile);
-            ColorSpaceOut   = cmsGetPCS(hProfile);
-        }
-        else {
-
-            ColorSpaceIn    = cmsGetPCS(hProfile);
-            ColorSpaceOut   = cmsGetColorSpace(hProfile);
-        }
-
-        if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {
-
-            cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "ColorSpace mismatch");
-            goto Error;
-        }
-
-        // If devicelink is found, then no custom intent is allowed and we can 
-        // read the LUT to be applied. Settings don't apply here.       
-        if (lIsDeviceLink) {
-
-            // Get the involved LUT from the profile
-            Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
-            if (Lut == NULL) goto Error;
-
-            // What about abstract profiles?
-             if (ClassSig == cmsSigAbstractClass && i > 0) {
-                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
-             }
-             else {
-                _cmsMAT3identity(&m);
-                _cmsVEC3init(&off, 0, 0, 0);
-             }
-        
-
-            if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
-
-        }
-        else {
-
-            if (lIsInput) {
-                // Input direction means non-pcs connection, so proceed like devicelinks
-                Lut = _cmsReadInputLUT(hProfile, Intent);       
-                if (Lut == NULL) goto Error;
-            }
-            else {
-
-                // Output direction means PCS connection. Intent may apply here
-                Lut = _cmsReadOutputLUT(hProfile, Intent); 
-                if (Lut == NULL) goto Error;
-
-
-                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
-                if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
-
-            }
-        }
-
-        // Concatenate to the output LUT
-        cmsPipelineCat(Result, Lut);
-        cmsPipelineFree(Lut);                            
-
-        // Update current space
-        CurrentColorSpace = ColorSpaceOut;              
-    }
-
-    return Result;
-
-Error:
-
-    if (Result != NULL) cmsPipelineFree(Result);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(dwFlags);
-}
-
-
-// Wrapper for DLL calling convention
-cmsPipeline*  CMSEXPORT _cmsDefaultICCintents(cmsContext     ContextID, 
-                                              cmsUInt32Number nProfiles,
-                                              cmsUInt32Number TheIntents[], 
-                                              cmsHPROFILE     hProfiles[], 
-                                              cmsBool         BPC[],
-                                              cmsFloat64Number AdaptationStates[],
-                                              cmsUInt32Number dwFlags)
-{
-    return DefaultICCintents(ContextID, nProfiles, TheIntents, hProfiles, BPC, AdaptationStates, dwFlags);
-}
-
-// Black preserving intents ---------------------------------------------------------------------------------------------
-
-// Translate black-preserving intents to ICC ones
-static
-int TranslateNonICCIntents(int Intent)
-{
-    switch (Intent) {
-        case INTENT_PRESERVE_K_ONLY_PERCEPTUAL:
-        case INTENT_PRESERVE_K_PLANE_PERCEPTUAL:
-            return INTENT_PERCEPTUAL; 
-
-        case INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC:
-        case INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC:
-            return INTENT_RELATIVE_COLORIMETRIC;
-
-        case INTENT_PRESERVE_K_ONLY_SATURATION:
-        case INTENT_PRESERVE_K_PLANE_SATURATION:
-            return INTENT_SATURATION;
-
-        default: return Intent;
-    }
-}
-
-// Sampler for Black-only preserving CMYK->CMYK transforms
-
-typedef struct {
-    cmsPipeline*    cmyk2cmyk;      // The original transform
-    cmsToneCurve*   KTone;          // Black-to-black tone curve
-
-} GrayOnlyParams;
-
-
-// Preserve black only if that is the only ink used
-static
-int BlackPreservingGrayOnlySampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    GrayOnlyParams* bp = (GrayOnlyParams*) Cargo;
-
-    // If going across black only, keep black only
-    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {
-
-        // TAC does not apply because it is black ink!
-        Out[0] = Out[1] = Out[2] = 0;
-        Out[3] = cmsEvalToneCurve16(bp->KTone, In[3]);
-        return TRUE;
-    }
-
-    // Keep normal transform for other colors
-    bp ->cmyk2cmyk ->Eval16Fn(In, Out, bp ->cmyk2cmyk->Data);
-    return TRUE;
-}
-
-// This is the entry for black-preserving K-only intents, which are non-ICC
-static
-cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID, 
-                                          cmsUInt32Number nProfiles,
-                                          cmsUInt32Number TheIntents[], 
-                                          cmsHPROFILE     hProfiles[], 
-                                          cmsBool         BPC[],
-                                          cmsFloat64Number AdaptationStates[],
-                                          cmsUInt32Number dwFlags)
-{
-    GrayOnlyParams  bp;
-    cmsPipeline*    Result;
-    cmsUInt32Number ICCIntents[256];
-    cmsStage*         CLUT;
-    cmsUInt32Number i, nGridPoints;
-
-
-    // Sanity check
-    if (nProfiles < 1 || nProfiles > 255) return NULL;
-
-    // Translate black-preserving intents to ICC ones
-    for (i=0; i < nProfiles; i++) 
-        ICCIntents[i] = TranslateNonICCIntents(TheIntents[i]); 
-
-    // Check for non-cmyk profiles
-    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||
-        cmsGetColorSpace(hProfiles[nProfiles-1]) != cmsSigCmykData) 
-           return DefaultICCintents(ContextID, nProfiles, ICCIntents, hProfiles, BPC, AdaptationStates, dwFlags);
-
-    memset(&bp, 0, sizeof(bp));
-
-    // Allocate an empty LUT for holding the result
-    Result = cmsPipelineAlloc(ContextID, 4, 4);
-    if (Result == NULL) return NULL;
-
-    // Create a LUT holding normal ICC transform
-    bp.cmyk2cmyk = DefaultICCintents(ContextID, 
-        nProfiles,
-        ICCIntents, 
-        hProfiles, 
-        BPC,
-        AdaptationStates,
-        dwFlags);
-
-    if (bp.cmyk2cmyk == NULL) goto Error;
-    
-    // Now, compute the tone curve
-    bp.KTone = _cmsBuildKToneCurve(ContextID, 
-        4096, 
-        nProfiles,
-        ICCIntents, 
-        hProfiles, 
-        BPC,
-        AdaptationStates,
-        dwFlags);
-    
-    if (bp.KTone == NULL) goto Error;
-
-    
-    // How many gridpoints are we going to use?
-    nGridPoints = _cmsReasonableGridpointsByColorspace(cmsSigCmykData, dwFlags);
-    
-    // Create the CLUT. 16 bits
-    CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
-    if (CLUT == NULL) goto Error;
-
-    // This is the one and only MPE in this LUT
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
-
-    // Sample it. We cannot afford pre/post linearization this time.
-    if (!cmsStageSampleCLut16bit(CLUT, BlackPreservingGrayOnlySampler, (void*) &bp, 0)) 
-        goto Error;
-    
-    // Get rid of xform and tone curve
-    cmsPipelineFree(bp.cmyk2cmyk);
-    cmsFreeToneCurve(bp.KTone);
-
-    return Result;
-
-Error:
-
-    if (bp.cmyk2cmyk != NULL) cmsPipelineFree(bp.cmyk2cmyk);
-    if (bp.KTone != NULL)  cmsFreeToneCurve(bp.KTone);
-    if (Result != NULL) cmsPipelineFree(Result);
-    return NULL;
-
-}
-
-// K Plane-preserving CMYK to CMYK ------------------------------------------------------------------------------------
-
-typedef struct {
-
-    cmsPipeline*     cmyk2cmyk;     // The original transform
-    cmsHTRANSFORM    hProofOutput;  // Output CMYK to Lab (last profile)
-    cmsHTRANSFORM    cmyk2Lab;      // The input chain
-    cmsToneCurve*    KTone;         // Black-to-black tone curve
-    cmsPipeline*     LabK2cmyk;     // The output profile
-    cmsFloat64Number MaxError;
-
-    cmsHTRANSFORM    hRoundTrip;               
-    cmsFloat64Number MaxTAC;
-    
-
-} PreserveKPlaneParams;
-
-
-// The CLUT will be stored at 16 bits, but calculations are performed at cmsFloat32Number precision
-static
-int BlackPreservingSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    int i;
-    cmsFloat32Number Inf[4], Outf[4];
-    cmsFloat32Number LabK[4];   
-    cmsFloat64Number SumCMY, SumCMYK, Error, Ratio;
-    cmsCIELab ColorimetricLab, BlackPreservingLab;
-    PreserveKPlaneParams* bp = (PreserveKPlaneParams*) Cargo;
-    
-    // Convert from 16 bits to floating point
-    for (i=0; i < 4; i++) 
-        Inf[i] = (cmsFloat32Number) (In[i] / 65535.0);
-
-    // Get the K across Tone curve
-    LabK[3] = cmsEvalToneCurveFloat(bp ->KTone, Inf[3]);
-    
-    // If going across black only, keep black only
-    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {
-
-        Out[0] = Out[1] = Out[2] = 0;
-        Out[3] = _cmsQuickSaturateWord(LabK[3] * 65535.0);
-        return TRUE;
-    }
-    
-    // Try the original transform, 
-    cmsPipelineEvalFloat( Inf, Outf, bp ->cmyk2cmyk);  
-    
-    // Store a copy of the floating point result into 16-bit
-    for (i=0; i < 4; i++) 
-            Out[i] = _cmsQuickSaturateWord(Outf[i] * 65535.0);
-
-    // Maybe K is already ok (mostly on K=0)
-    if ( fabs(Outf[3] - LabK[3]) < (3.0 / 65535.0) ) {
-        return TRUE;
-    }
-    
-    // K differ, mesure and keep Lab measurement for further usage
-    // this is done in relative colorimetric intent
-    cmsDoTransform(bp->hProofOutput, Out, &ColorimetricLab, 1);
-    
-    // Is not black only and the transform doesn't keep black.
-    // Obtain the Lab of output CMYK. After that we have Lab + K
-    cmsDoTransform(bp ->cmyk2Lab, Outf, LabK, 1);
-
-    // Obtain the corresponding CMY using reverse interpolation 
-    // (K is fixed in LabK[3])
-    if (!cmsPipelineEvalReverseFloat(LabK, Outf, Outf, bp ->LabK2cmyk)) {
-
-        // Cannot find a suitable value, so use colorimetric xform
-        // which is already stored in Out[]
-        return TRUE;
-    }
-
-    // Make sure to pass thru K (which now is fixed)
-    Outf[3] = LabK[3];
-       
-    // Apply TAC if needed    
-    SumCMY   = Outf[0]  + Outf[1] + Outf[2];
-    SumCMYK  = SumCMY + Outf[3];      
-
-    if (SumCMYK > bp ->MaxTAC) {
-
-        Ratio = 1 - ((SumCMYK - bp->MaxTAC) / SumCMY);
-        if (Ratio < 0)
-            Ratio = 0;
-    }
-    else
-       Ratio = 1.0;
-
-    Out[0] = _cmsQuickSaturateWord(Outf[0] * Ratio * 65535.0);     // C
-    Out[1] = _cmsQuickSaturateWord(Outf[1] * Ratio * 65535.0);     // M
-    Out[2] = _cmsQuickSaturateWord(Outf[2] * Ratio * 65535.0);     // Y
-    Out[3] = _cmsQuickSaturateWord(Outf[3] * 65535.0);
-
-    // Estimate the error (this goes 16 bits to Lab DBL)
-    cmsDoTransform(bp->hProofOutput, Out, &BlackPreservingLab, 1);  
-    Error = cmsDeltaE(&ColorimetricLab, &BlackPreservingLab);                   
-    if (Error > bp -> MaxError) 
-        bp->MaxError = Error;
-
-    return TRUE;
-}
-
-// This is the entry for black-plane preserving, which are non-ICC
-static
-cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID, 
-                                          cmsUInt32Number nProfiles,
-                                          cmsUInt32Number TheIntents[], 
-                                          cmsHPROFILE     hProfiles[], 
-                                          cmsBool         BPC[],
-                                          cmsFloat64Number AdaptationStates[],
-                                          cmsUInt32Number dwFlags)
-{
-    PreserveKPlaneParams bp;
-    cmsPipeline*    Result = NULL;
-    cmsUInt32Number ICCIntents[256];
-    cmsStage*         CLUT;
-    cmsUInt32Number i, nGridPoints;    
-    cmsHPROFILE hLab;
-
-    // Sanity check
-    if (nProfiles < 1 || nProfiles > 255) return NULL;
-
-    // Translate black-preserving intents to ICC ones
-    for (i=0; i < nProfiles; i++) 
-        ICCIntents[i] = TranslateNonICCIntents(TheIntents[i]); 
-
-    // Check for non-cmyk profiles
-    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||
-        cmsGetColorSpace(hProfiles[nProfiles-1]) != cmsSigCmykData) 
-           return  DefaultICCintents(ContextID, nProfiles, ICCIntents, hProfiles, BPC, AdaptationStates, dwFlags);
-
-    // Allocate an empty LUT for holding the result
-    Result = cmsPipelineAlloc(ContextID, 4, 4);
-    if (Result == NULL) return NULL;
-
-   
-    memset(&bp, 0, sizeof(bp));
-
-    // We need the input LUT of the last profile, assuming this one is responsible of
-    // black generation. This LUT will be seached in inverse order.
-    bp.LabK2cmyk = _cmsReadInputLUT(hProfiles[nProfiles-1], INTENT_RELATIVE_COLORIMETRIC);
-    if (bp.LabK2cmyk == NULL) goto Cleanup;
-
-    // Get total area coverage (in 0..1 domain)
-    bp.MaxTAC = cmsDetectTAC(hProfiles[nProfiles-1]) / 100.0;
-
-    // Create a LUT holding normal ICC transform
-    bp.cmyk2cmyk = DefaultICCintents(ContextID,
-                                         nProfiles,
-                                         ICCIntents, 
-                                         hProfiles, 
-                                         BPC,
-                                         AdaptationStates,
-                                         dwFlags);
-
-    // Now the tone curve
-    bp.KTone = _cmsBuildKToneCurve(ContextID, 4096, nProfiles,
-                                   ICCIntents, 
-                                   hProfiles, 
-                                   BPC, 
-                                   AdaptationStates,
-                                   dwFlags);
-
-
-    // To measure the output, Last profile to Lab
-    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    bp.hProofOutput = cmsCreateTransformTHR(ContextID, hProfiles[nProfiles-1], 
-                                         CHANNELS_SH(4)|BYTES_SH(2), hLab, TYPE_Lab_DBL, 
-                                         INTENT_RELATIVE_COLORIMETRIC, 
-                                         cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);
-
-    // Same as anterior, but lab in the 0..1 range
-    bp.cmyk2Lab = cmsCreateTransformTHR(ContextID, hProfiles[nProfiles-1], 
-                                         FLOAT_SH(1)|CHANNELS_SH(4)|BYTES_SH(4), hLab, 
-										 FLOAT_SH(1)|CHANNELS_SH(3)|BYTES_SH(4), 
-                                         INTENT_RELATIVE_COLORIMETRIC, 
-                                         cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);
-    cmsCloseProfile(hLab);
-
-    // Error estimation (for debug only)
-    bp.MaxError = 0;
-
-    // How many gridpoints are we going to use?
-    nGridPoints = _cmsReasonableGridpointsByColorspace(cmsSigCmykData, dwFlags);
-
-    
-    CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
-    if (CLUT == NULL) goto Cleanup;
-
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
-
-    cmsStageSampleCLut16bit(CLUT, BlackPreservingSampler, (void*) &bp, 0);
-
-Cleanup:
-
-    if (bp.cmyk2cmyk) cmsPipelineFree(bp.cmyk2cmyk);
-    if (bp.cmyk2Lab) cmsDeleteTransform(bp.cmyk2Lab);       
-    if (bp.hProofOutput) cmsDeleteTransform(bp.hProofOutput);
-    
-    if (bp.KTone) cmsFreeToneCurve(bp.KTone);   
-    if (bp.LabK2cmyk) cmsPipelineFree(bp.LabK2cmyk);
-
-    return Result;
-}
-
-// Link routines ------------------------------------------------------------------------------------------------------
-
-// Chain several profiles into a single LUT. It just checks the parameters and then calls the handler
-// for the first intent in chain. The handler may be user-defined. Is up to the handler to deal with the 
-// rest of intents in chain. A maximum of 255 profiles at time are supported, which is pretty reasonable.
-cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID, 
-                              cmsUInt32Number nProfiles,
-                              cmsUInt32Number TheIntents[], 
-                              cmsHPROFILE     hProfiles[], 
-                              cmsBool         BPC[],
-                              cmsFloat64Number AdaptationStates[],
-                              cmsUInt32Number dwFlags)
-{
-    cmsUInt32Number i;
-    cmsIntentsList* Intent;
-
-    // Make sure a reasonable number of profiles is provided
-    if (nProfiles <= 0 || nProfiles > 255) {
-         cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't link '%d' profiles", nProfiles);
-        return NULL;
-    }
-
-    for (i=0; i < nProfiles; i++) {
-
-        // Check if black point is really needed or allowed. Note that 
-        // following Adobe's document:
-        // BPC does not apply to devicelink profiles, nor to abs colorimetric, 
-        // and applies always on V4 perceptual and saturation.
-
-        if (TheIntents[i] == INTENT_ABSOLUTE_COLORIMETRIC)
-            BPC[i] = FALSE;
-
-        if (TheIntents[i] == INTENT_PERCEPTUAL || TheIntents[i] == INTENT_SATURATION) {
-
-            // Force BPC for V4 profiles in perceptual and saturation
-            if (cmsGetProfileVersion(hProfiles[i]) >= 4.0)
-                BPC[i] = TRUE;
-        }      
-    }
-
-    // Search for a handler. The first intent in the chain defines the handler. That would
-    // prevent using multiple custom intents in a multiintent chain, but the behaviour of
-    // this case would present some issues if the custom intent tries to do things like
-    // preserve primaries. This solution is not perfect, but works well on most cases.
-
-    Intent = SearchIntent(TheIntents[0]);
-	if (Intent == NULL) {
-		cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported intent '%d'", TheIntents[0]);
-		return NULL;
-	}
-
-    // Call the handler
-    return Intent ->Link(ContextID, nProfiles, TheIntents, hProfiles, BPC, AdaptationStates, dwFlags);
-}
-
-// -------------------------------------------------------------------------------------------------
-
-// Get information about available intents. nMax is the maximum space for the supplied "Codes" 
-// and "Descriptions" the function returns the total number of intents, which may be greater 
-// than nMax, although the matrices are not populated beyond this level.
-cmsUInt32Number CMSEXPORT cmsGetSupportedIntents(cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions)
-{
-    cmsIntentsList* pt;
-    cmsUInt32Number nIntents;
-
-    for (nIntents=0, pt = Intents; pt != NULL; pt = pt -> Next)
-    {
-        if (nIntents < nMax) {
-            if (Codes != NULL) 
-                Codes[nIntents] = pt ->Intent;
-
-            if (Descriptions != NULL) 
-                Descriptions[nIntents] = pt ->Description;
-        }
-
-        nIntents++;
-    }
-
-    return nIntents;
-}
-
-// The plug-in registration. User can add new intents or override default routines
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Data)
-{
-    cmsPluginRenderingIntent* Plugin = (cmsPluginRenderingIntent*) Data;
-    cmsIntentsList* fl;
-
-    // Do we have to reset the intents?
-    if (Data == NULL) {
-    
-       Intents = DefaultIntents;
-       return TRUE;
-    }
-
-    fl = SearchIntent(Plugin ->Intent);
-
-    if (fl == NULL) {
-        fl = (cmsIntentsList*) _cmsPluginMalloc(sizeof(cmsIntentsList));
-        if (fl == NULL) return FALSE;
-    }
-
-    fl ->Intent  = Plugin ->Intent;
-    strncpy(fl ->Description, Plugin ->Description, 255);
-    fl ->Description[255] = 0;
-
-    fl ->Link    = Plugin ->Link;
-
-    fl ->Next = Intents;
-    Intents = fl;
-
-    return TRUE;
-}
-
diff --git a/thirdparty/liblcms2/src/cmserr.c b/thirdparty/liblcms2/src/cmserr.c
deleted file mode 100644
index 55f0358..0000000
--- a/thirdparty/liblcms2/src/cmserr.c
+++ /dev/null
@@ -1,428 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-
-#include "lcms2_internal.h"
-
-// I am so tired about incompatibilities on those functions that here are some replacements
-// that hopefully would be fully portable.
-
-// compare two strings ignoring case
-int CMSEXPORT cmsstrcasecmp(const char* s1, const char* s2)
-{
-         register const unsigned char *us1 = (const unsigned char *)s1,
-                                      *us2 = (const unsigned char *)s2;
-
-        while (toupper(*us1) == toupper(*us2++))
-                if (*us1++ == '\0')
-                        return (0);
-        return (toupper(*us1) - toupper(*--us2));
-}
-
-// long int because C99 specifies ftell in such way (7.19.9.2)
-long int CMSEXPORT cmsfilelength(FILE* f)
-{
-    long int p , n; 
-
-    p = ftell(f); // register current file position 
-
-	if (fseek(f, 0, SEEK_END) != 0) {		
-		return -1;
-	}
-
-    n = ftell(f);
-    fseek(f, p, SEEK_SET); // file position restored 
-
-    return n;    
-}
-
-
-// Memory handling ------------------------------------------------------------------
-//
-// This is the interface to low-level memory management routines. By default a simple
-// wrapping to malloc/free/realloc is provided, although there is a limit on the max
-// amount of memoy that can be reclaimed. This is mostly as a safety feature to 
-// prevent bogus or malintentionated code to allocate huge blocks that otherwise lcms
-// would never need.
-
-#define MAX_MEMORY_FOR_ALLOC  ((cmsUInt32Number)(1024U*1024U*512U))
-
-// User may override this behaviour by using a memory plug-in, which basically replaces
-// the default memory management functions. In this case, no check is performed and it 
-// is up to the plug-in writter to keep in the safe side. There are only three functions 
-// required to be implemented: malloc, realloc and free, although the user may want to 
-// replace the optional mallocZero, calloc and dup as well.
-
-cmsBool   _cmsRegisterMemHandlerPlugin(cmsPluginBase* Plugin);
-
-// *********************************************************************************
-
-// This is the default memory allocation function. It does a very coarse 
-// check of amout of memory, just to prevent exploits
-static
-void* _cmsMallocDefaultFn(cmsContext ContextID, cmsUInt32Number size)
-{
-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never allow over maximum
-
-    return (void*) malloc(size);
-
-    cmsUNUSED_PARAMETER(ContextID);
-}
-
-// Generic allocate & zero
-static
-void* _cmsMallocZeroDefaultFn(cmsContext ContextID, cmsUInt32Number size)
-{
-    void *pt = _cmsMalloc(ContextID, size);
-    if (pt == NULL) return NULL;
-
-    memset(pt, 0, size);
-    return pt;
-}
-
-
-// The default free function. The only check proformed is against NULL pointers
-static
-void _cmsFreeDefaultFn(cmsContext ContextID, void *Ptr)
-{
-    // free(NULL) is defined a no-op by C99, therefore it is safe to
-    // avoid the check, but it is here just in case...
-
-    if (Ptr) free(Ptr); 
-
-    cmsUNUSED_PARAMETER(ContextID);
-}
-
-// The default realloc function. Again it check for exploits. If Ptr is NULL, 
-// realloc behaves the same way as malloc and allocates a new block of size bytes. 
-static
-void* _cmsReallocDefaultFn(cmsContext ContextID, void* Ptr, cmsUInt32Number size)
-{
-
-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never realloc over 512Mb
-
-    return realloc(Ptr, size);
-
-    cmsUNUSED_PARAMETER(ContextID);
-}
-
-
-// The default calloc function. Allocates an array of num elements, each one of size bytes
-// all memory is initialized to zero.
-static
-void* _cmsCallocDefaultFn(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)
-{
-    cmsUInt32Number Total = num * size;
-
-    // Preserve calloc behaviour
-    if (Total == 0) return NULL;
-
-    // Safe check for overflow.
-    if (num >= UINT_MAX / size) return NULL; 
-
-    // Check for overflow
-    if (Total < num || Total < size) {
-        return NULL;
-    }
-    
-    if (Total > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never alloc over 512Mb
-
-    return _cmsMallocZero(ContextID, Total);
-}
-
-// Generic block duplication
-static
-void* _cmsDupDefaultFn(cmsContext ContextID, const void* Org, cmsUInt32Number size)
-{
-    void* mem;
-    
-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never dup over 512Mb
-
-    mem = _cmsMalloc(ContextID, size);
-
-    if (mem != NULL && Org != NULL)
-        memmove(mem, Org, size);
-
-    return mem;
-}
-
-// Pointers to malloc and _cmsFree functions in current environment
-static void * (* MallocPtr)(cmsContext ContextID, cmsUInt32Number size)                     = _cmsMallocDefaultFn;
-static void * (* MallocZeroPtr)(cmsContext ContextID, cmsUInt32Number size)                 = _cmsMallocZeroDefaultFn;
-static void   (* FreePtr)(cmsContext ContextID, void *Ptr)                                  = _cmsFreeDefaultFn;
-static void * (* ReallocPtr)(cmsContext ContextID, void *Ptr, cmsUInt32Number NewSize)      = _cmsReallocDefaultFn; 
-static void * (* CallocPtr)(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)= _cmsCallocDefaultFn;
-static void * (* DupPtr)(cmsContext ContextID, const void* Org, cmsUInt32Number size)       = _cmsDupDefaultFn;
-
-// Plug-in replacement entry
-cmsBool  _cmsRegisterMemHandlerPlugin(cmsPluginBase *Data)
-{
-    cmsPluginMemHandler* Plugin = (cmsPluginMemHandler*) Data;
-
-    // NULL forces to reset to defaults
-    if (Data == NULL) {
-
-        MallocPtr    = _cmsMallocDefaultFn;
-        MallocZeroPtr= _cmsMallocZeroDefaultFn;
-        FreePtr      = _cmsFreeDefaultFn;
-        ReallocPtr   = _cmsReallocDefaultFn; 
-        CallocPtr    = _cmsCallocDefaultFn;
-        DupPtr       = _cmsDupDefaultFn;
-        return TRUE;
-    }
-
-	// Check for required callbacks
-	if (Plugin -> MallocPtr == NULL ||
-        Plugin -> FreePtr == NULL ||
-		Plugin -> ReallocPtr == NULL) return FALSE;
-
-    // Set replacement functions
-    MallocPtr  = Plugin -> MallocPtr;
-    FreePtr    = Plugin -> FreePtr;
-    ReallocPtr = Plugin -> ReallocPtr;
-
-    if (Plugin ->MallocZeroPtr != NULL) MallocZeroPtr = Plugin ->MallocZeroPtr;
-    if (Plugin ->CallocPtr != NULL)     CallocPtr     = Plugin -> CallocPtr;
-    if (Plugin ->DupPtr != NULL)        DupPtr        = Plugin -> DupPtr;
-
-    return TRUE;
-}
-
-// Generic allocate
-void* CMSEXPORT _cmsMalloc(cmsContext ContextID, cmsUInt32Number size)
-{
-    return MallocPtr(ContextID, size);
-}
-
-// Generic allocate & zero
-void* CMSEXPORT _cmsMallocZero(cmsContext ContextID, cmsUInt32Number size)
-{
-    return MallocZeroPtr(ContextID, size);
-}
-
-// Generic calloc
-void* CMSEXPORT _cmsCalloc(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)
-{
-    return CallocPtr(ContextID, num, size);
-}
-
-// Generic reallocate
-void* CMSEXPORT _cmsRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number size)
-{
-    return ReallocPtr(ContextID, Ptr, size);
-}
-
-// Generic free memory
-void CMSEXPORT _cmsFree(cmsContext ContextID, void* Ptr)
-{
-    if (Ptr != NULL) FreePtr(ContextID, Ptr);
-}
-
-// Generic block duplication
-void* CMSEXPORT _cmsDupMem(cmsContext ContextID, const void* Org, cmsUInt32Number size)
-{
-    return DupPtr(ContextID, Org, size);
-}
-
-// ********************************************************************************************
-
-// Sub allocation takes care of many pointers of small size. The memory allocated in
-// this way have be freed at once. Next function allocates a single chunk for linked list
-// I prefer this method over realloc due to the big inpact on xput realloc may have if 
-// memory is being swapped to disk. This approach is safer (although thats not true on any platform)
-static
-_cmsSubAllocator_chunk* _cmsCreateSubAllocChunk(cmsContext ContextID, cmsUInt32Number Initial)
-{
-    _cmsSubAllocator_chunk* chunk;
-
-    // Create the container
-    chunk = (_cmsSubAllocator_chunk*) _cmsMallocZero(ContextID, sizeof(_cmsSubAllocator_chunk));
-    if (chunk == NULL) return NULL;
-
-    // Initialize values
-    chunk ->Block     = (cmsUInt8Number*) _cmsMalloc(ContextID, Initial);
-    if (chunk ->Block == NULL) {
-
-        // Something went wrong
-        _cmsFree(ContextID, chunk);
-        return NULL;
-    }
-
-    // 20K by default
-    if (Initial == 0)
-        Initial = 20*1024;
-
-    chunk ->BlockSize = Initial;
-    chunk ->Used      = 0;
-    chunk ->next      = NULL;
-
-    return chunk;
-}
-
-// The suballocated is nothing but a pointer to the first element in the list. We also keep
-// the thread ID in this structure.
-_cmsSubAllocator* _cmsCreateSubAlloc(cmsContext ContextID, cmsUInt32Number Initial)
-{
-    _cmsSubAllocator* sub;
-
-    // Create the container
-    sub = (_cmsSubAllocator*) _cmsMallocZero(ContextID, sizeof(_cmsSubAllocator));
-    if (sub == NULL) return NULL;
-
-    sub ->ContextID = ContextID;
-
-    sub ->h = _cmsCreateSubAllocChunk(ContextID, Initial);
-    if (sub ->h == NULL) {
-        _cmsFree(ContextID, sub);
-        return NULL;
-    }
-
-    return sub;
-}
-
-
-// Get rid of whole linked list
-void _cmsSubAllocDestroy(_cmsSubAllocator* sub)
-{
-    _cmsSubAllocator_chunk *chunk, *n;
-
-    for (chunk = sub ->h; chunk != NULL; chunk = n) {
-
-        n = chunk->next;
-        if (chunk->Block != NULL) _cmsFree(sub ->ContextID, chunk->Block);
-        _cmsFree(sub ->ContextID, chunk);
-    }
-
-    // Free the header
-    _cmsFree(sub ->ContextID, sub);
-}
-
-
-// Get a pointer to small memory block.
-void*  _cmsSubAlloc(_cmsSubAllocator* sub, cmsUInt32Number size)
-{
-    cmsUInt32Number Free = sub -> h ->BlockSize - sub -> h -> Used;
-    cmsUInt8Number* ptr;
-
-    size = _cmsALIGNLONG(size);
-
-    // Check for memory. If there is no room, allocate a new chunk of double memory size.   
-    if (size > Free) {
-
-        _cmsSubAllocator_chunk* chunk;
-        cmsUInt32Number newSize;
-
-        newSize = sub -> h ->BlockSize * 2;
-        if (newSize < size) newSize = size;
-
-        chunk = _cmsCreateSubAllocChunk(sub -> ContextID, newSize);
-        if (chunk == NULL) return NULL;
-
-        // Link list
-        chunk ->next = sub ->h;
-        sub ->h    = chunk;
-
-    }
-            
-    ptr =  sub -> h ->Block + sub -> h ->Used;
-    sub -> h -> Used += size;
-
-    return (void*) ptr;
-}
-
-// Error logging ******************************************************************
-
-// There is no error handling at all. When a funtion fails, it returns proper value.
-// For example, all create functions does return NULL on failure. Other return FALSE
-// It may be interesting, for the developer, to know why the function is failing.
-// for that reason, lcms2 does offer a logging function. This function does recive
-// a ENGLISH string with some clues on what is going wrong. You can show this 
-// info to the end user, or just create some sort of log.
-// The logging function should NOT terminate the program, as this obviously can leave
-// resources. It is the programmer's responsability to check each function return code
-// to make sure it didn't fail.
-
-// Error messages are limited to MAX_ERROR_MESSAGE_LEN
-
-#define MAX_ERROR_MESSAGE_LEN   1024
-
-// ---------------------------------------------------------------------------------------------------------
-
-// This is our default log error
-static void DefaultLogErrorHandlerFunction(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text);
-
-// The current handler in actual environment
-static cmsLogErrorHandlerFunction LogErrorHandler   = DefaultLogErrorHandlerFunction;
-
-// The default error logger does nothing.
-static
-void DefaultLogErrorHandlerFunction(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)
-{
-    // fprintf(stderr, "[lcms]: %s\n", Text);
-    // fflush(stderr);
-   
-     cmsUNUSED_PARAMETER(ContextID);
-     cmsUNUSED_PARAMETER(ErrorCode);
-	 cmsUNUSED_PARAMETER(Text);
-}
-
-// Change log error
-void CMSEXPORT cmsSetLogErrorHandler(cmsLogErrorHandlerFunction Fn)
-{
-    if (Fn == NULL) 
-        LogErrorHandler = DefaultLogErrorHandlerFunction;
-    else
-        LogErrorHandler = Fn;
-}
-
-// Log an error 
-// ErrorText is a text holding an english description of error.
-void CMSEXPORT cmsSignalError(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *ErrorText, ...)
-{
-    va_list args;
-    char Buffer[MAX_ERROR_MESSAGE_LEN];
-
-    va_start(args, ErrorText);
-    vsnprintf(Buffer, MAX_ERROR_MESSAGE_LEN-1, ErrorText, args);
-    va_end(args);   
-
-    // Call handler
-    LogErrorHandler(ContextID, ErrorCode, Buffer);
-}
-
-// Utility function to print signatures
-void _cmsTagSignature2String(char String[5], cmsTagSignature sig)
-{
-    cmsUInt32Number be;
-
-    // Convert to big endian
-    be = _cmsAdjustEndianess32((cmsUInt32Number) sig);
-
-    // Move chars 
-    memmove(String, &be, 4);
-
-    // Make sure of terminator
-    String[4] = 0;
-}
-
diff --git a/thirdparty/liblcms2/src/cmsgamma.c b/thirdparty/liblcms2/src/cmsgamma.c
deleted file mode 100644
index db156c7..0000000
--- a/thirdparty/liblcms2/src/cmsgamma.c
+++ /dev/null
@@ -1,1138 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-#include "lcms2_internal.h"
-
-// Tone curves are powerful constructs that can contain curves specified in diverse ways. 
-// The curve is stored in segments, where each segment can be sampled or specified by parameters.
-// a 16.bit simplification of the *whole* curve is kept for optimization purposes. For float operation, 
-// each segment is evaluated separately. Plug-ins may be used to define new parametric schemes, 
-// each plug-in may define up to MAX_TYPES_IN_LCMS_PLUGIN functions types. For defining a function, 
-// the plug-in should provide the type id, how many parameters each type has, and a pointer to
-// a procedure that evaluates the function. In the case of reverse evaluation, the evaluator will 
-// be called with the type id as a negative value, and a sampled version of the reversed curve 
-// will be built.
-
-// ----------------------------------------------------------------- Implementation
-// Maxim number of nodes 
-#define MAX_NODES_IN_CURVE   4097
-#define MINUS_INF            (-1E22F)
-#define PLUS_INF             (+1E22F)
-
-// The list of supported parametric curves
-typedef struct _cmsParametricCurvesCollection_st {
-
-    int nFunctions;                                     // Number of supported functions in this chunk
-    int FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types
-    int ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function
-    cmsParametricCurveEvaluator    Evaluator;           // The evaluator
-
-    struct _cmsParametricCurvesCollection_st* Next; // Next in list
-
-} _cmsParametricCurvesCollection;
-
-
-// This is the default (built-in) evaluator 
-static cmsFloat64Number DefaultEvalParametricFn(cmsInt32Number Type, const cmsFloat64Number Params[], cmsFloat64Number R);
-
-// The built-in list
-static _cmsParametricCurvesCollection DefaultCurves = { 
-    9,                                  // # of curve types
-    { 1, 2, 3, 4, 5, 6, 7, 8, 108 },    // Parametric curve ID
-    { 1, 3, 4, 5, 7, 4, 5, 5, 1 },      // Parameters by type
-    DefaultEvalParametricFn,            // Evaluator
-    NULL                                // Next in chain
-};
-
-// The linked list head
-static _cmsParametricCurvesCollection* ParametricCurves = &DefaultCurves;
-
-// As a way to install new parametric curves
-cmsBool _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Data)
-{
-    cmsPluginParametricCurves* Plugin = (cmsPluginParametricCurves*) Data;
-    _cmsParametricCurvesCollection* fl;
-    
-    if (Data == NULL) {
-    
-          ParametricCurves =  &DefaultCurves;
-          return TRUE;
-    }
-
-    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(sizeof(_cmsParametricCurvesCollection));
-    if (fl == NULL) return FALSE;
-
-    // Copy the parameters
-    fl ->Evaluator  = Plugin ->Evaluator;
-    fl ->nFunctions = Plugin ->nFunctions;
-
-    // Make sure no mem overwrites
-    if (fl ->nFunctions > MAX_TYPES_IN_LCMS_PLUGIN)
-        fl ->nFunctions = MAX_TYPES_IN_LCMS_PLUGIN;
-
-    // Copy the data
-    memmove(fl->FunctionTypes,  Plugin ->FunctionTypes,   fl->nFunctions * sizeof(cmsUInt32Number));
-    memmove(fl->ParameterCount, Plugin ->ParameterCount,  fl->nFunctions * sizeof(cmsUInt32Number));
-
-    // Keep linked list
-    fl ->Next = ParametricCurves;
-    ParametricCurves = fl;
-
-    // All is ok
-    return TRUE;
-}
-
-
-// Search in type list, return position or -1 if not found
-static
-int IsInSet(int Type, _cmsParametricCurvesCollection* c)
-{
-    int i;
-
-    for (i=0; i < c ->nFunctions; i++)
-        if (abs(Type) == c ->FunctionTypes[i]) return i;
-
-    return -1;
-}
-
-
-// Search for the collection which contains a specific type
-static
-_cmsParametricCurvesCollection *GetParametricCurveByType(int Type, int* index)
-{
-    _cmsParametricCurvesCollection* c;
-    int Position;
-
-    for (c = ParametricCurves; c != NULL; c = c ->Next) {
-
-        Position = IsInSet(Type, c);
-
-        if (Position != -1) {
-            if (index != NULL) 
-                *index = Position;
-            return c;
-        }
-    }
-
-    return NULL;
-}
-
-// Low level allocate, which takes care of memory details. nEntries may be zero, and in this case 
-// no optimation curve is computed. nSegments may also be zero in the inverse case, where only the
-// optimization curve is given. Both features simultaneously is an error
-static
-cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntries, 
-                                      cmsInt32Number nSegments, const cmsCurveSegment* Segments, 
-                                      const cmsUInt16Number* Values)
-{
-    cmsToneCurve* p;
-    int i;
-
-    // We allow huge tables, which are then restricted for smoothing operations
-    if (nEntries > 65530 || nEntries < 0) {
-        cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't create tone curve of more than 65530 entries");
-        return NULL;
-    }
-
-    if (nEntries <= 0 && nSegments <= 0) {
-        cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't create tone curve with zero segments and no table");
-        return NULL;
-    }
-
-    // Allocate all required pointers, etc.
-    p = (cmsToneCurve*) _cmsMallocZero(ContextID, sizeof(cmsToneCurve));
-    if (!p) return NULL;
-
-    // In this case, there are no segments
-    if (nSegments <= 0) {
-        p ->Segments = NULL;
-        p ->Evals = NULL;
-    }
-    else {
-        p ->Segments = (cmsCurveSegment*) _cmsCalloc(ContextID, nSegments, sizeof(cmsCurveSegment));
-        if (p ->Segments == NULL) goto Error;
-
-        p ->Evals    = (cmsParametricCurveEvaluator*) _cmsCalloc(ContextID, nSegments, sizeof(cmsParametricCurveEvaluator));
-        if (p ->Evals == NULL) goto Error;
-    }
-
-    p -> nSegments = nSegments;
-    
-    // This 16-bit table contains a limited precision representation of the whole curve and is kept for
-    // increasing xput on certain operations.
-    if (nEntries <= 0) {
-        p ->Table16 = NULL;
-    }
-    else {
-       p ->Table16 = (cmsUInt16Number*)  _cmsCalloc(ContextID, nEntries, sizeof(cmsUInt16Number));
-       if (p ->Table16 == NULL) goto Error;
-    }
-   
-    p -> nEntries  = nEntries;
-    
-    // Initialize members if requested
-    if (Values != NULL && (nEntries > 0)) {
-
-        for (i=0; i < nEntries; i++) 
-            p ->Table16[i] = Values[i];
-    }
-
-    // Initialize the segments stuff. The evaluator for each segment is located and a pointer to it
-    // is placed in advance to maximize performance.
-    if (Segments != NULL && (nSegments > 0)) {
-
-        _cmsParametricCurvesCollection *c;
-
-        p ->SegInterp = (cmsInterpParams**) _cmsCalloc(ContextID, nSegments, sizeof(cmsInterpParams*));
-        if (p ->SegInterp == NULL) goto Error;
-
-        for (i=0; i< nSegments; i++) {
-
-            // Type 0 is a special marker for table-based curves
-            if (Segments[i].Type == 0)
-                p ->SegInterp[i] = _cmsComputeInterpParams(ContextID, Segments[i].nGridPoints, 1, 1, NULL, CMS_LERP_FLAGS_FLOAT);
-
-            memmove(&p ->Segments[i], &Segments[i], sizeof(cmsCurveSegment));
-
-            if (Segments[i].Type == 0 && Segments[i].SampledPoints != NULL)
-                p ->Segments[i].SampledPoints = (cmsFloat32Number*) _cmsDupMem(ContextID, Segments[i].SampledPoints, sizeof(cmsFloat32Number) * Segments[i].nGridPoints);
-            else
-                p ->Segments[i].SampledPoints = NULL;
-
-
-            c = GetParametricCurveByType(Segments[i].Type, NULL);
-            if (c != NULL)
-                    p ->Evals[i] = c ->Evaluator;
-        }
-    }
-    
-    p ->InterpParams = _cmsComputeInterpParams(ContextID, p ->nEntries, 1, 1, p->Table16, CMS_LERP_FLAGS_16BITS);
-    return p;
-
-Error:
-    if (p -> Segments) _cmsFree(ContextID, p ->Segments);
-    if (p -> Evals) _cmsFree(ContextID, p -> Evals);
-    if (p ->Table16) _cmsFree(ContextID, p ->Table16);
-    _cmsFree(ContextID, p);
-    return NULL;
-}
-
-
-// Parametric Fn using floating point
-static
-cmsFloat64Number DefaultEvalParametricFn(cmsInt32Number Type, const cmsFloat64Number Params[], cmsFloat64Number R)
-{
-    cmsFloat64Number e, Val, disc;
-
-    switch (Type) {
-
-    // X = Y ^ Gamma
-    case 1:
-        if (R < 0) 
-            Val = 0;
-        else
-            Val = pow(R, Params[0]);
-        break;
-
-    // Type 1 Reversed: X = Y ^1/gamma
-    case -1:
-        if (R < 0)
-            Val = 0;
-        else
-            Val = pow(R, 1/Params[0]);
-        break;
-
-    // CIE 122-1966
-    // Y = (aX + b)^Gamma  | X >= -b/a
-    // Y = 0               | else
-    case 2:
-        disc = -Params[2] / Params[1];
-
-        if (R >= disc ) {
-
-            e = Params[1]*R + Params[2];
-
-            if (e > 0)
-                Val = pow(e, Params[0]);
-            else
-                Val = 0;
-        }
-        else
-            Val = 0;
-        break;
-
-     // Type 2 Reversed
-     // X = (Y ^1/g  - b) / a
-     case -2: 
-         if (R < 0)
-             Val = 0;
-         else
-             Val = (pow(R, 1.0/Params[0]) - Params[2]) / Params[1];
-
-         if (Val < 0)
-              Val = 0;                            
-         break;
-
-
-    // IEC 61966-3
-    // Y = (aX + b)^Gamma | X <= -b/a
-    // Y = c              | else
-    case 3:
-        disc = -Params[2] / Params[1];
-        if (disc < 0)
-            disc = 0;
-
-        if (R >= disc) {
-
-            e = Params[1]*R + Params[2];  
-
-            if (e > 0)
-                Val = pow(e, Params[0]) + Params[3];
-            else
-                Val = 0;
-        }
-        else
-            Val = Params[3];
-        break;
-
-
-    // Type 3 reversed
-    // X=((Y-c)^1/g - b)/a      | (Y>=c)
-    // X=-b/a                   | (Y<c) 
-    case -3:
-        if (R >= Params[3])  {
-            
-            e = R - Params[3];
-
-            if (e > 0)
-                Val = (pow(e, 1/Params[0]) - Params[2]) / Params[1];
-            else 
-                Val = 0;
-        }
-        else {
-            Val = -Params[2] / Params[1];
-        }
-        break;
-
-
-    // IEC 61966-2.1 (sRGB)
-    // Y = (aX + b)^Gamma | X >= d
-    // Y = cX             | X < d
-    case 4:
-        if (R >= Params[4]) {
-
-            e = Params[1]*R + Params[2];
-
-            if (e > 0)
-                Val = pow(e, Params[0]);
-            else
-                Val = 0;
-        }
-        else
-            Val = R * Params[3];
-        break;
-
-    // Type 4 reversed
-    // X=((Y^1/g-b)/a)    | Y >= (ad+b)^g
-    // X=Y/c              | Y< (ad+b)^g
-    case -4:
-        e = Params[1] * Params[4] + Params[2];
-        if (e < 0)
-            disc = 0;
-        else
-            disc = pow(e, Params[0]);
-
-        if (R >= disc) {
-
-            Val = (pow(R, 1.0/Params[0]) - Params[2]) / Params[1];
-        }
-        else {
-            Val = R / Params[3];
-        }
-        break;
-
-
-    // Y = (aX + b)^Gamma + e | X >= d
-    // Y = cX + f             | X < d
-    case 5:
-        if (R >= Params[4]) {
-
-            e = Params[1]*R + Params[2];
-
-            if (e > 0)
-                Val = pow(e, Params[0]) + Params[5];
-            else
-                Val = 0;
-        }        
-        else
-            Val = R*Params[3] + Params[6];
-        break;
-
-
-    // Reversed type 5
-    // X=((Y-e)1/g-b)/a   | Y >=(ad+b)^g+e), cd+f
-    // X=(Y-f)/c          | else
-    case -5:
-
-        disc = Params[3] * Params[4] + Params[6];
-        if (R >= disc) {
-
-            e = R - Params[5];
-            if (e < 0) 
-                Val = 0;
-            else
-                Val = (pow(e, 1.0/Params[0]) - Params[2]) / Params[1];
-        }
-        else {
-            Val = (R - Params[6]) / Params[3];
-        }
-        break;
-
-
-    // Types 6,7,8 comes from segmented curves as described in ICCSpecRevision_02_11_06_Float.pdf
-    // Type 6 is basically identical to type 5 without d
-    
-    // Y = (a * X + b) ^ Gamma + c
-    case 6:    
-        e = Params[1]*R + Params[2];
-
-        if (e < 0) 
-            Val = 0;
-        else 
-            Val = pow(e, Params[0]) + Params[3];
-        break;
-
-    // ((Y - c) ^1/Gamma - b) / a                        
-    case -6:
-        e = R - Params[3];
-        if (e < 0)
-            Val = 0;
-        else 
-        Val = (pow(e, 1.0/Params[0]) - Params[2]) / Params[1];
-        break;
-
-
-    // Y = a * log (b * X^Gamma + c) + d
-    case 7:                   
-
-       e = Params[2] * pow(R, Params[0]) + Params[3];
-       if (e <= 0)
-           Val = 0;
-       else
-           Val = Params[1]*log10(e) + Params[4];
-       break;
-
-    // (Y - d) / a = log(b * X ^Gamma + c)
-    // pow(10, (Y-d) / a) = b * X ^Gamma + c
-    // pow((pow(10, (Y-d) / a) - c) / b, 1/g) = X 
-    case -7:
-       Val = pow((pow(10.0, (R-Params[4]) / Params[1]) - Params[3]) / Params[2], 1.0 / Params[0]);
-       break;
-
-
-   //Y = a * b^(c*X+d) + e          
-   case 8:
-       Val = (Params[0] * pow(Params[1], Params[2] * R + Params[3]) + Params[4]);
-       break;
-
-
-   // Y = (log((y-e) / a) / log(b) - d ) / c
-   // a=0, b=1, c=2, d=3, e=4,
-   case -8:
-             
-       disc = R - Params[4];
-       if (disc < 0) Val = 0;
-       else 
-           Val = (log(disc / Params[0]) / log(Params[1]) - Params[3]) / Params[2];         
-       break;
-
-   // S-Shaped: (1 - (1-x)^1/g)^1/g                    
-   case 108:
-      Val = pow(1.0 - pow(1 - R, 1/Params[0]), 1/Params[0]);
-      break;
-
-    // y = (1 - (1-x)^1/g)^1/g
-    // y^g = (1 - (1-x)^1/g)
-    // 1 - y^g = (1-x)^1/g
-    // (1 - y^g)^g = 1 - x
-    // 1 - (1 - y^g)^g
-    case -108:
-        Val = 1 - pow(1 - pow(R, Params[0]), Params[0]);
-        break;
-
-    default:
-        // Unsupported parametric curve. Should never reach here
-        return 0;
-    }
-
-    return Val;
-}
-
-// Evaluate a segmented funtion for a single value. Return -1 if no valid segment found .
-// If fn type is 0, perform an interpolation on the table 
-static
-cmsFloat64Number EvalSegmentedFn(const cmsToneCurve *g, cmsFloat64Number R)
-{
-    int i;
-
-    for (i = g ->nSegments-1; i >= 0 ; --i) {
-
-        // Check for domain
-        if ((R > g ->Segments[i].x0) && (R <= g ->Segments[i].x1)) {
-
-            // Type == 0 means segment is sampled
-            if (g ->Segments[i].Type == 0) {
-
-                cmsFloat32Number R1 = (cmsFloat32Number) (R - g ->Segments[i].x0);
-                cmsFloat32Number Out;
-
-                // Setup the table (TODO: clean that)
-                g ->SegInterp[i]-> Table = g ->Segments[i].SampledPoints; 
-
-                g ->SegInterp[i] -> Interpolation.LerpFloat(&R1, &Out, g ->SegInterp[i]);
-                
-                return Out;
-            }
-            else
-                return g ->Evals[i](g->Segments[i].Type, g ->Segments[i].Params, R);
-        }
-    }
-
-    return MINUS_INF;
-}
-
-
-// Create an empty gamma curve, by using tables. This specifies only the limited-precision part, and leaves the
-// floating point description empty.
-cmsToneCurve* CMSEXPORT cmsBuildTabulatedToneCurve16(cmsContext ContextID, cmsInt32Number nEntries, const cmsUInt16Number Values[])
-{
-    return AllocateToneCurveStruct(ContextID, nEntries, 0, NULL, Values);
-}
-
-static
-int EntriesByGamma(cmsFloat64Number Gamma)
-{
-    if (fabs(Gamma - 1.0) < 0.001) return 2;
-    return 4096;
-}
-
-
-// Create a segmented gamma, fill the table
-cmsToneCurve* CMSEXPORT cmsBuildSegmentedToneCurve(cmsContext ContextID, 
-                                                   cmsInt32Number nSegments, const cmsCurveSegment Segments[])
-{
-    int i;
-    cmsFloat64Number R, Val;
-    cmsToneCurve* g;
-    int nGridPoints = 4096;
-        
-    _cmsAssert(Segments != NULL);
-
-    // Optimizatin for identity curves. 
-    if (nSegments == 1 && Segments[0].Type == 1) {
-
-        nGridPoints = EntriesByGamma(Segments[0].Params[0]);
-    }
-
-    g = AllocateToneCurveStruct(ContextID, nGridPoints, nSegments, Segments, NULL);
-    if (g == NULL) return NULL;
-
-    // Once we have the floating point version, we can approximate a 16 bit table of 4096 entries
-    // for performance reasons. This table would normally not be used except on 8/16 bits transforms.
-    for (i=0; i < nGridPoints; i++) {
-
-        R   = (cmsFloat64Number) i / (nGridPoints-1);
-
-        Val = EvalSegmentedFn(g, R);
-
-        // Round and saturate
-        g ->Table16[i] = _cmsQuickSaturateWord(Val * 65535.0);
-    }
-
-    return g;
-}
-
-// Use a segmented curve to store the floating point table
-cmsToneCurve* CMSEXPORT cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[])
-{
-    cmsCurveSegment Seg[2];
-
-    // Initialize segmented curve part up to 0
-    Seg[0].x0 = -1;
-    Seg[0].x1 = 0;
-    Seg[0].Type = 6;
-
-    Seg[0].Params[0] = 1;
-    Seg[0].Params[1] = 0;
-    Seg[0].Params[2] = 0;
-    Seg[0].Params[3] = 0;
-    Seg[0].Params[4] = 0;
-
-    // From zero to any
-    Seg[1].x0 = 0;
-    Seg[1].x1 = 1.0;   
-    Seg[1].Type = 0;
-
-    Seg[1].nGridPoints = nEntries;
-    Seg[1].SampledPoints = (cmsFloat32Number*) values;
-
-    return cmsBuildSegmentedToneCurve(ContextID, 2, Seg);
-}
-
-// Parametric curves
-//
-// Parameters goes as: Curve, a, b, c, d, e, f
-// Type is the ICC type +1
-// if type is negative, then the curve is analyticaly inverted
-cmsToneCurve* CMSEXPORT cmsBuildParametricToneCurve(cmsContext ContextID, cmsInt32Number Type, const cmsFloat64Number Params[])
-{
-    cmsCurveSegment Seg0;
-    int Pos = 0;
-    cmsUInt32Number size;
-    _cmsParametricCurvesCollection* c = GetParametricCurveByType(Type, &Pos);
-
-    _cmsAssert(Params != NULL);
-
-    if (c == NULL) {
-         cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Invalid parametric curve type %d", Type);     
-        return NULL;
-    }
-
-    memset(&Seg0, 0, sizeof(Seg0));
-
-    Seg0.x0   = MINUS_INF;
-    Seg0.x1   = PLUS_INF;
-    Seg0.Type = Type;
-
-    size = c->ParameterCount[Pos] * sizeof(cmsFloat64Number);
-    memmove(Seg0.Params, Params, size);
-
-    return cmsBuildSegmentedToneCurve(ContextID, 1, &Seg0);
-}
-
-
-
-// Build a gamma table based on gamma constant
-cmsToneCurve* CMSEXPORT cmsBuildGamma(cmsContext ContextID, cmsFloat64Number Gamma)
-{
-    return cmsBuildParametricToneCurve(ContextID, 1, &Gamma);
-}
-
-
-// Free all memory taken by the gamma curve
-void CMSEXPORT cmsFreeToneCurve(cmsToneCurve* Curve)
-{
-    cmsContext ContextID;
-    
-    if (Curve == NULL) return;
-
-    ContextID = Curve ->InterpParams->ContextID;
-
-    _cmsFreeInterpParams(Curve ->InterpParams);
-    
-    if (Curve -> Table16)
-        _cmsFree(ContextID, Curve ->Table16);
-
-    if (Curve ->Segments) {
-
-        cmsUInt32Number i;
-        
-        for (i=0; i < Curve ->nSegments; i++) {
-
-            if (Curve ->Segments[i].SampledPoints) {
-                _cmsFree(ContextID, Curve ->Segments[i].SampledPoints);
-            }
-
-            if (Curve ->SegInterp[i] != 0) 
-                _cmsFreeInterpParams(Curve->SegInterp[i]);
-        }
-
-        _cmsFree(ContextID, Curve ->Segments);
-        _cmsFree(ContextID, Curve ->SegInterp);
-    }
-
-    if (Curve -> Evals)
-        _cmsFree(ContextID, Curve -> Evals);
-
-    if (Curve) _cmsFree(ContextID, Curve);
-}
-
-// Utility function, free 3 gamma tables
-void CMSEXPORT cmsFreeToneCurveTriple(cmsToneCurve* Curve[3])
-{
-
-    _cmsAssert(Curve != NULL);
-
-    if (Curve[0] != NULL) cmsFreeToneCurve(Curve[0]);
-    if (Curve[1] != NULL) cmsFreeToneCurve(Curve[1]);
-    if (Curve[2] != NULL) cmsFreeToneCurve(Curve[2]);
-
-    Curve[0] = Curve[1] = Curve[2] = NULL;
-}
-
-
-// Duplicate a gamma table
-cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)
-{   
-    if (In == NULL) return NULL;
-
-    return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);
-}
-
-// Joins two curves for X and Y. Curves should be monotonic.
-// We want to get 
-//
-//      y = Y^-1(X(t)) 
-//
-cmsToneCurve* CMSEXPORT cmsJoinToneCurve(cmsContext ContextID, 
-                                      const cmsToneCurve* X,
-                                      const cmsToneCurve* Y, cmsUInt32Number nResultingPoints)
-{
-    cmsToneCurve* out = NULL;
-    cmsToneCurve* Yreversed = NULL;
-    cmsFloat32Number t, x;
-    cmsFloat32Number* Res = NULL;
-    cmsUInt32Number i;
-
-
-    _cmsAssert(X != NULL);
-    _cmsAssert(Y != NULL);
-
-    Yreversed = cmsReverseToneCurveEx(nResultingPoints, Y);
-    if (Yreversed == NULL) goto Error;
-
-    Res = (cmsFloat32Number*) _cmsCalloc(ContextID, nResultingPoints, sizeof(cmsFloat32Number));
-    if (Res == NULL) goto Error;
-    
-    //Iterate
-    for (i=0; i <  nResultingPoints; i++) {
-
-        t = (cmsFloat32Number) i / (nResultingPoints-1);
-        x = cmsEvalToneCurveFloat(X,  t);
-        Res[i] = cmsEvalToneCurveFloat(Yreversed, x);
-    }
-
-    // Allocate space for output
-    out = cmsBuildTabulatedToneCurveFloat(ContextID, nResultingPoints, Res);
-    
-Error:
-
-    if (Res != NULL) _cmsFree(ContextID, Res);
-    if (Yreversed != NULL) cmsFreeToneCurve(Yreversed);
-
-    return out;
-}
-
-
-
-// Get the surrounding nodes. This is tricky on non-monotonic tables 
-static
-int GetInterval(cmsFloat64Number In, const cmsUInt16Number LutTable[], const struct _cms_interp_struc* p)
-{   
-    int i;
-    int y0, y1;
-    
-    // A 1 point table is not allowed
-    if (p -> Domain[0] < 1) return -1;
-
-    // Let's see if ascending or descending. 
-    if (LutTable[0] < LutTable[p ->Domain[0]]) {
-
-        // Table is overall ascending
-        for (i=p->Domain[0]-1; i >=0; --i) {
-
-            y0 = LutTable[i]; 
-            y1 = LutTable[i+1];
-            
-            if (y0 <= y1) { // Increasing
-                if (In >= y0 && In <= y1) return i;
-            }
-            else
-                if (y1 < y0) { // Decreasing
-                    if (In >= y1 && In <= y0) return i;
-                }
-        }
-    }
-    else {
-        // Table is overall descending
-        for (i=0; i < (int) p -> Domain[0]; i++) {
-
-            y0 = LutTable[i]; 
-            y1 = LutTable[i+1];
-
-            if (y0 <= y1) { // Increasing
-                if (In >= y0 && In <= y1) return i;
-            }
-            else
-                if (y1 < y0) { // Decreasing
-                    if (In >= y1 && In <= y0) return i;
-                }
-        }
-    }
-
-    return -1;
-}
-
-// Reverse a gamma table
-cmsToneCurve* CMSEXPORT cmsReverseToneCurveEx(cmsInt32Number nResultSamples, const cmsToneCurve* InCurve)
-{
-    cmsToneCurve *out;
-    cmsFloat64Number a = 0, b = 0, y, x1, y1, x2, y2;
-    int i, j;
-    int Ascending;
-    
-    _cmsAssert(InCurve != NULL);
-
-    // Try to reverse it analytically whatever possible
-    if (InCurve ->nSegments == 1 && InCurve ->Segments[0].Type > 0 && InCurve -> Segments[0].Type <= 5) {
-
-        return cmsBuildParametricToneCurve(InCurve ->InterpParams->ContextID, 
-                                       -(InCurve -> Segments[0].Type), 
-                                       InCurve -> Segments[0].Params);
-    }
-
-    // Nope, reverse the table. 
-    out = cmsBuildTabulatedToneCurve16(InCurve ->InterpParams->ContextID, nResultSamples, NULL);
-    if (out == NULL)
-        return NULL;
-
-    // We want to know if this is an ascending or descending table
-    Ascending = !cmsIsToneCurveDescending(InCurve);
-
-    // Iterate across Y axis
-    for (i=0; i <  nResultSamples; i++) {
-
-        y = (cmsFloat64Number) i * 65535.0 / (nResultSamples - 1);
-
-        // Find interval in which y is within. 
-        j = GetInterval(y, InCurve->Table16, InCurve->InterpParams);
-        if (j >= 0) {
-
-
-            // Get limits of interval
-            x1 = InCurve ->Table16[j]; 
-            x2 = InCurve ->Table16[j+1];
-
-            y1 = (cmsFloat64Number) (j * 65535.0) / (InCurve ->nEntries - 1);
-            y2 = (cmsFloat64Number) ((j+1) * 65535.0 ) / (InCurve ->nEntries - 1);
-    
-            // If collapsed, then use any
-            if (x1 == x2) {
-
-                out ->Table16[i] = _cmsQuickSaturateWord(Ascending ? y2 : y1);
-                continue;
-
-            } else {
-
-                // Interpolate      
-                a = (y2 - y1) / (x2 - x1);
-                b = y2 - a * x2;
-            }
-        }
-           
-        out ->Table16[i] = _cmsQuickSaturateWord(a* y + b);
-    }
-
-
-    return out;
-}
-
-// Reverse a gamma table
-cmsToneCurve* CMSEXPORT cmsReverseToneCurve(const cmsToneCurve* InGamma)
-{
-    _cmsAssert(InGamma != NULL);
-
-    return cmsReverseToneCurveEx(4096, InGamma);
-}
-
-// From: Eilers, P.H.C. (1994) Smoothing and interpolation with finite
-// differences. in: Graphic Gems IV, Heckbert, P.S. (ed.), Academic press.
-//
-// Smoothing and interpolation with second differences.
-//
-//   Input:  weights (w), data (y): vector from 1 to m.
-//   Input:  smoothing parameter (lambda), length (m).
-//   Output: smoothed vector (z): vector from 1 to m.
-
-static
-cmsBool smooth2(cmsContext ContextID, cmsFloat32Number w[], cmsFloat32Number y[], cmsFloat32Number z[], cmsFloat32Number lambda, int m)
-{
-    int i, i1, i2;
-    cmsFloat32Number *c, *d, *e;
-    cmsBool st;
-
-
-    c = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));
-    d = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));
-    e = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));
-    
-    if (c != NULL && d != NULL && e != NULL) {
-
-
-    d[1] = w[1] + lambda;
-    c[1] = -2 * lambda / d[1];
-    e[1] = lambda /d[1];
-    z[1] = w[1] * y[1];
-    d[2] = w[2] + 5 * lambda - d[1] * c[1] *  c[1];
-    c[2] = (-4 * lambda - d[1] * c[1] * e[1]) / d[2];
-    e[2] = lambda / d[2];
-    z[2] = w[2] * y[2] - c[1] * z[1];
-    
-    for (i = 3; i < m - 1; i++) {
-        i1 = i - 1; i2 = i - 2;
-        d[i]= w[i] + 6 * lambda - c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];
-        c[i] = (-4 * lambda -d[i1] * c[i1] * e[i1])/ d[i];
-        e[i] = lambda / d[i];
-        z[i] = w[i] * y[i] - c[i1] * z[i1] - e[i2] * z[i2];
-    }
-    
-    i1 = m - 2; i2 = m - 3;
-    
-    d[m - 1] = w[m - 1] + 5 * lambda -c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];
-    c[m - 1] = (-2 * lambda - d[i1] * c[i1] * e[i1]) / d[m - 1];
-    z[m - 1] = w[m - 1] * y[m - 1] - c[i1] * z[i1] - e[i2] * z[i2];
-    i1 = m - 1; i2 = m - 2;
-    
-    d[m] = w[m] + lambda - c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];
-    z[m] = (w[m] * y[m] - c[i1] * z[i1] - e[i2] * z[i2]) / d[m];
-    z[m - 1] = z[m - 1] / d[m - 1] - c[m - 1] * z[m];
-    
-    for (i = m - 2; 1<= i; i--)
-        z[i] = z[i] / d[i] - c[i] * z[i + 1] - e[i] * z[i + 2];
-
-      st = TRUE;
-    }
-    else st = FALSE;
-
-    if (c != NULL) _cmsFree(ContextID, c);
-    if (d != NULL) _cmsFree(ContextID, d);
-    if (e != NULL) _cmsFree(ContextID, e);
-
-    return st;
-}
-
-// Smooths a curve sampled at regular intervals. 
-cmsBool  CMSEXPORT cmsSmoothToneCurve(cmsToneCurve* Tab, cmsFloat64Number lambda)
-{
-    cmsFloat32Number w[MAX_NODES_IN_CURVE], y[MAX_NODES_IN_CURVE], z[MAX_NODES_IN_CURVE];
-    int i, nItems, Zeros, Poles;
-
-    if (Tab == NULL) return FALSE;
-
-    if (cmsIsToneCurveLinear(Tab)) return FALSE; // Nothing to do
-
-    nItems = Tab -> nEntries;
-
-    if (nItems >= MAX_NODES_IN_CURVE) {
-        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: too many points.");
-        return FALSE;
-    }
-
-    memset(w, 0, nItems * sizeof(cmsFloat32Number));
-    memset(y, 0, nItems * sizeof(cmsFloat32Number));
-    memset(z, 0, nItems * sizeof(cmsFloat32Number));
-
-    for (i=0; i < nItems; i++)
-    {
-        y[i+1] = (cmsFloat32Number) Tab -> Table16[i];
-        w[i+1] = 1.0;
-    }
-
-    if (!smooth2(Tab ->InterpParams->ContextID, w, y, z, (cmsFloat32Number) lambda, nItems)) return FALSE;
-
-    // Do some reality - checking...
-    Zeros = Poles = 0;
-    for (i=nItems; i > 1; --i) {
-
-        if (z[i] == 0.) Zeros++;
-        if (z[i] >= 65535.) Poles++;
-        if (z[i] < z[i-1]) return FALSE; // Non-Monotonic
-    }
-
-    if (Zeros > (nItems / 3)) return FALSE;  // Degenerated, mostly zeros
-    if (Poles > (nItems / 3)) return FALSE;  // Degenerated, mostly poles
-
-    // Seems ok
-    for (i=0; i < nItems; i++) {
-
-        // Clamp to cmsUInt16Number
-        Tab -> Table16[i] = _cmsQuickSaturateWord(z[i+1]);
-    }
-
-    return TRUE;
-}
-
-// Is a table linear? Do not use parametric since we cannot guarantee some weird parameters resulting
-// in a linear table. This way assures it is linear in 12 bits, which should be enought in most cases.
-cmsBool CMSEXPORT cmsIsToneCurveLinear(const cmsToneCurve* Curve)
-{
-    cmsUInt32Number i;
-    int diff;
-
-    _cmsAssert(Curve != NULL);
-
-    for (i=0; i < Curve ->nEntries; i++) {
-
-        diff = abs((int) Curve->Table16[i] - (int) _cmsQuantizeVal(i, Curve ->nEntries));
-        if (diff > 0x0f)
-            return FALSE;
-    }
-
-    return TRUE;
-}
-
-// Same, but for monotonicity
-cmsBool  CMSEXPORT cmsIsToneCurveMonotonic(const cmsToneCurve* t)
-{
-    int n;
-    int i, last;
-
-    _cmsAssert(t != NULL);
-
-    n    = t ->nEntries;
-    last = t ->Table16[n-1];
-
-    for (i = n-2; i >= 0; --i) {
-
-        if (t ->Table16[i] > last)
-
-            return FALSE;
-        else
-            last = t ->Table16[i];
-
-    }
-
-    return TRUE;
-}
-
-// Same, but for descending tables
-cmsBool  CMSEXPORT cmsIsToneCurveDescending(const cmsToneCurve* t)
-{
-    _cmsAssert(t != NULL);
-
-    return t ->Table16[0] > t ->Table16[t ->nEntries-1];
-}
-
-
-// Another info fn: is out gamma table multisegment?
-cmsBool  CMSEXPORT cmsIsToneCurveMultisegment(const cmsToneCurve* t)
-{
-    _cmsAssert(t != NULL);
-
-    return t -> nSegments > 1;
-}
-
-cmsInt32Number  CMSEXPORT cmsGetToneCurveParametricType(const cmsToneCurve* t)
-{
-    _cmsAssert(t != NULL);
-
-    if (t -> nSegments != 1) return 0;
-    return t ->Segments[0].Type;
-}
-
-// We need accuracy this time
-cmsFloat32Number CMSEXPORT cmsEvalToneCurveFloat(const cmsToneCurve* Curve, cmsFloat32Number v)
-{
-    _cmsAssert(Curve != NULL);
-
-    // Check for 16 bits table. If so, this is a limited-precision tone curve
-    if (Curve ->nSegments == 0) {
-
-        cmsUInt16Number In, Out;
-        
-        In = (cmsUInt16Number) _cmsQuickSaturateWord(v * 65535.0);
-        Out = cmsEvalToneCurve16(Curve, In);
-        
-        return (cmsFloat32Number) (Out / 65535.0);
-    }
-
-    return (cmsFloat32Number) EvalSegmentedFn(Curve, v);
-}
-
-// We need xput over here
-cmsUInt16Number CMSEXPORT cmsEvalToneCurve16(const cmsToneCurve* Curve, cmsUInt16Number v)
-{
-    cmsUInt16Number out;
-
-    _cmsAssert(Curve != NULL);
-
-    Curve ->InterpParams ->Interpolation.Lerp16(&v, &out, Curve ->InterpParams);
-    return out;
-}
-
-
-// Least squares fitting.
-// A mathematical procedure for finding the best-fitting curve to a given set of points by 
-// minimizing the sum of the squares of the offsets ("the residuals") of the points from the curve. 
-// The sum of the squares of the offsets is used instead of the offset absolute values because 
-// this allows the residuals to be treated as a continuous differentiable quantity. 
-//
-// y = f(x) = x ^ g
-//
-// R  = (yi - (xi^g))
-// R2 = (yi - (xi^g))2
-// SUM R2 = SUM (yi - (xi^g))2
-// 
-// dR2/dg = -2 SUM x^g log(x)(y - x^g)    
-// solving for dR2/dg = 0 
-// 
-// g = 1/n * SUM(log(y) / log(x)) 
-
-cmsFloat64Number CMSEXPORT cmsEstimateGamma(const cmsToneCurve* t, cmsFloat64Number Precision)
-{
-    cmsFloat64Number gamma, sum, sum2;
-    cmsFloat64Number n, x, y, Std;
-    cmsUInt32Number i;
-
-    _cmsAssert(t != NULL);
-
-    sum = sum2 = n = 0;
-
-    // Excluding endpoints   
-    for (i=1; i < (MAX_NODES_IN_CURVE-1); i++) {
-
-        x = (cmsFloat64Number) i / (MAX_NODES_IN_CURVE-1);
-        y = (cmsFloat64Number) cmsEvalToneCurveFloat(t, (cmsFloat32Number) x);
-
-        // Avoid 7% on lower part to prevent 
-        // artifacts due to linear ramps
-
-        if (y > 0. && y < 1. && x > 0.07) {
-
-            gamma = log(y) / log(x);
-            sum  += gamma;
-            sum2 += gamma * gamma;
-            n++;
-        }
-    }
-
-    // Take a look on SD to see if gamma isn't exponential at all
-    Std = sqrt((n * sum2 - sum * sum) / (n*(n-1)));
-
-    if (Std > Precision)
-        return -1.0;
-
-    return (sum / n);   // The mean
-}
diff --git a/thirdparty/liblcms2/src/cmsgmt.c b/thirdparty/liblcms2/src/cmsgmt.c
deleted file mode 100644
index c2f3a9a..0000000
--- a/thirdparty/liblcms2/src/cmsgmt.c
+++ /dev/null
@@ -1,591 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// Auxiliar: append a Lab identity after the given sequence of profiles
-// and return the transform. Lab profile is closed, rest of profiles are kept open.
-cmsHTRANSFORM _cmsChain2Lab(cmsContext            ContextID,
-                            cmsUInt32Number        nProfiles,
-                            cmsUInt32Number        InputFormat,
-                            cmsUInt32Number        OutputFormat,
-                            const cmsUInt32Number  Intents[], 
-                            const cmsHPROFILE      hProfiles[], 
-                            const cmsBool          BPC[],
-                            const cmsFloat64Number AdaptationStates[],
-                            cmsUInt32Number        dwFlags)
-{
-    cmsHTRANSFORM xform;
-    cmsHPROFILE   hLab;
-    cmsHPROFILE   ProfileList[256];
-    cmsBool       BPCList[256];
-    cmsFloat64Number AdaptationList[256];
-    cmsUInt32Number IntentList[256];
-    cmsUInt32Number i;
-
-    // This is a rather big number and there is no need of dynamic memory
-    // since we are adding a profile, 254 + 1 = 255 and this is the limit
-    if (nProfiles > 254) return NULL;
-    
-    // The output space
-    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) return NULL;
-
-    // Create a copy of parameters
-    for (i=0; i < nProfiles; i++) {
-
-        ProfileList[i]    = hProfiles[i];
-        BPCList[i]        = BPC[i];
-        AdaptationList[i] = AdaptationStates[i];
-        IntentList[i]     = Intents[i];
-    }
-
-    // Place Lab identity at chain's end.
-    ProfileList[nProfiles]    = hLab;
-    BPCList[nProfiles]        = 0;
-    AdaptationList[nProfiles] = 1.0;
-    IntentList[nProfiles]     = INTENT_RELATIVE_COLORIMETRIC;
-   
-    // Create the transform
-    xform = cmsCreateExtendedTransform(ContextID, nProfiles + 1, ProfileList, 
-                                       BPCList, 
-                                       IntentList, 
-                                       AdaptationList, 
-                                       NULL, 0, 
-                                       InputFormat, 
-                                       OutputFormat, 
-                                       dwFlags);
-    
-    cmsCloseProfile(hLab);
-
-    return xform;
-}
-
-
-// Compute K -> L* relationship. Flags may include black point compensation. In this case, 
-// the relationship is assumed from the profile with BPC to a black point zero.
-static
-cmsToneCurve* ComputeKToLstar(cmsContext            ContextID,
-                               cmsUInt32Number       nPoints,
-                               cmsUInt32Number       nProfiles,
-                               const cmsUInt32Number Intents[], 
-                               const cmsHPROFILE     hProfiles[], 
-                               const cmsBool         BPC[],
-                               const cmsFloat64Number AdaptationStates[],
-                               cmsUInt32Number dwFlags)
-{
-    cmsToneCurve* out = NULL;   
-    cmsUInt32Number i;
-    cmsHTRANSFORM xform;
-    cmsCIELab Lab;
-    cmsFloat32Number cmyk[4];
-    cmsFloat32Number* SampledPoints;
-    
-    xform = _cmsChain2Lab(ContextID, nProfiles, TYPE_CMYK_FLT, TYPE_Lab_DBL, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
-    if (xform == NULL) return NULL;
-        
-    SampledPoints = (cmsFloat32Number*) _cmsCalloc(ContextID, nPoints, sizeof(cmsFloat32Number));
-    if (SampledPoints  == NULL) goto Error;
-        
-    for (i=0; i < nPoints; i++) {
-
-        cmyk[0] = 0;
-        cmyk[1] = 0;
-        cmyk[2] = 0;
-        cmyk[3] = (cmsFloat32Number) ((i * 100.0) / (nPoints-1));
-
-        cmsDoTransform(xform, cmyk, &Lab, 1);
-        SampledPoints[i]= (cmsFloat32Number) (1.0 - Lab.L / 100.0); // Negate K for easier operation
-    }
-        
-    out = cmsBuildTabulatedToneCurveFloat(ContextID, nPoints, SampledPoints);
-
-Error:
-
-    cmsDeleteTransform(xform);  
-    if (SampledPoints) _cmsFree(ContextID, SampledPoints);
-
-    return out;
-}
-
-
-// Compute Black tone curve on a CMYK -> CMYK transform. This is done by
-// using the proof direction on both profiles to find K->L* relationship
-// then joining both curves. dwFlags may include black point compensation.
-cmsToneCurve* _cmsBuildKToneCurve(cmsContext        ContextID,
-                                   cmsUInt32Number   nPoints,
-                                   cmsUInt32Number   nProfiles,
-                                   const cmsUInt32Number Intents[], 
-                                   const cmsHPROFILE hProfiles[], 
-                                   const cmsBool     BPC[],
-                                   const cmsFloat64Number AdaptationStates[],
-                                   cmsUInt32Number   dwFlags)
-{
-    cmsToneCurve *in, *out, *KTone;       
- 
-    // Make sure CMYK -> CMYK
-    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||
-        cmsGetColorSpace(hProfiles[nProfiles-1])!= cmsSigCmykData) return NULL;
-
-    
-    // Make sure last is an output profile
-    if (cmsGetDeviceClass(hProfiles[nProfiles - 1]) != cmsSigOutputClass) return NULL;
-
-    // Create individual curves. BPC works also as each K to L* is
-    // computed as a BPC to zero black point in case of L*
-    in  = ComputeKToLstar(ContextID, nPoints, nProfiles - 1, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
-    if (in == NULL) return NULL;
-    
-    out = ComputeKToLstar(ContextID, nPoints, 1,             
-                            Intents + (nProfiles - 1), 
-                            hProfiles + (nProfiles - 1), 
-                            BPC + (nProfiles - 1),  
-                            AdaptationStates + (nProfiles - 1), 
-                            dwFlags);
-    if (out == NULL) {
-        cmsFreeToneCurve(in);
-        return NULL;
-    }
-
-    // Build the relationship. This effectively limits the maximum accuracy to 16 bits, but 
-    // since this is used on black-preserving LUTs, we are not loosing  accuracy in any case 
-    KTone = cmsJoinToneCurve(ContextID, in, out, nPoints);
-
-    // Get rid of components
-    cmsFreeToneCurve(in); cmsFreeToneCurve(out);
-
-    // Something went wrong...
-    if (KTone == NULL) return NULL;
-
-    // Make sure it is monotonic    
-    if (!cmsIsToneCurveMonotonic(KTone)) {
-
-        cmsFreeToneCurve(KTone);
-        return NULL;
-    }
-    
-    return KTone;
-}
-
-
-// Gamut LUT Creation -----------------------------------------------------------------------------------------
-
-// Used by gamut & softproofing
-
-typedef struct {
-
-    cmsHTRANSFORM hInput;               // From whatever input color space. 16 bits to DBL
-    cmsHTRANSFORM hForward, hReverse;   // Transforms going from Lab to colorant and back
-    cmsFloat64Number Thereshold;        // The thereshold after which is considered out of gamut
-    
-    } GAMUTCHAIN;
-
-// This sampler does compute gamut boundaries by comparing original
-// values with a transform going back and forth. Values above ERR_THERESHOLD 
-// of maximum are considered out of gamut.
-
-#define ERR_THERESHOLD      5 
-
-
-static
-int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;          
-    cmsCIELab LabIn1, LabOut1;  
-    cmsCIELab LabIn2, LabOut2;      
-    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];
-    cmsFloat64Number dE1, dE2, ErrorRatio;
-
-    // Assume in-gamut by default.
-    dE1 = 0.;
-    dE2 = 0;
-    ErrorRatio = 1.0;
-
-    // Convert input to Lab
-    if (t -> hInput != NULL) 
-        cmsDoTransform(t -> hInput, In, &LabIn1, 1);
-
-    // converts from PCS to colorant. This always
-    // does return in-gamut values, 
-    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);
-
-    // Now, do the inverse, from colorant to PCS.
-    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);
-
-    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));
-
-    // Try again, but this time taking Check as input
-    cmsDoTransform(t -> hForward, &LabOut1, Proof2,  1);
-    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);
-    
-    // Take difference of direct value
-    dE1 = cmsDeltaE(&LabIn1, &LabOut1);        
-
-    // Take difference of converted value
-    dE2 = cmsDeltaE(&LabIn2, &LabOut2);                 
-
-
-    // if dE1 is small and dE2 is small, value is likely to be in gamut
-    if (dE1 < t->Thereshold && dE2 < t->Thereshold) 
-        Out[0] = 0;
-    else {
-
-        // if dE1 is small and dE2 is big, undefined. Assume in gamut
-        if (dE1 < t->Thereshold && dE2 > t->Thereshold)
-            Out[0] = 0;
-        else
-            // dE1 is big and dE2 is small, clearly out of gamut
-            if (dE1 > t->Thereshold && dE2 < t->Thereshold)
-                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);
-            else  {
-
-                // dE1 is big and dE2 is also big, could be due to perceptual mapping
-                // so take error ratio
-                if (dE2 == 0.0)
-                    ErrorRatio = dE1;
-                else
-                    ErrorRatio = dE1 / dE2;
-
-                if (ErrorRatio > t->Thereshold) 
-                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);
-                else
-                    Out[0] = 0;
-            }
-    }
-
-
-    return TRUE;
-}
-
-// Does compute a gamut LUT going back and forth across pcs -> relativ. colorimetric intent -> pcs
-// the dE obtained is then annotated on the LUT. Values truely out of gamut are clipped to dE = 0xFFFE
-// and values changed are supposed to be handled by any gamut remapping, so, are out of gamut as well.
-//
-// **WARNING: This algorithm does assume that gamut remapping algorithms does NOT move in-gamut colors,
-// of course, many perceptual and saturation intents does not work in such way, but relativ. ones should.
-
-cmsPipeline* _cmsCreateGamutCheckPipeline(cmsContext ContextID,
-										  cmsHPROFILE hProfiles[], 
-										  cmsBool  BPC[], 
-										  cmsUInt32Number Intents[], 
-										  cmsFloat64Number AdaptationStates[],
-										  cmsUInt32Number nGamutPCSposition, 
-										  cmsHPROFILE hGamut)
-{
-	cmsHPROFILE hLab;
-	cmsPipeline* Gamut;
-	cmsStage* CLUT;
-	cmsUInt32Number dwFormat;
-	GAMUTCHAIN Chain;
-	int nChannels, nGridpoints;
-	cmsColorSpaceSignature ColorSpace;
-	cmsUInt32Number i;    
-	cmsHPROFILE ProfileList[256];
-	cmsBool     BPCList[256];
-	cmsFloat64Number AdaptationList[256];
-	cmsUInt32Number IntentList[256];
-
-	memset(&Chain, 0, sizeof(GAMUTCHAIN)); 
-
-
-	if (nGamutPCSposition <= 0 || nGamutPCSposition > 255) {
-		cmsSignalError(ContextID, cmsERROR_RANGE, "Wrong position of PCS. 1..255 expected, %d found.", nGamutPCSposition);
-		return NULL;
-	}
-
-	hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-	if (hLab == NULL) return NULL;
-
-
-	// The figure of merit. On matrix-shaper profiles, should be almost zero as
-	// the conversion is pretty exact. On LUT based profiles, different resolutions
-	// of input and output CLUT may result in differences. 
-
-	if (cmsIsMatrixShaper(hGamut)) {
-
-		Chain.Thereshold = 1.0;
-	}
-	else {
-		Chain.Thereshold = ERR_THERESHOLD;
-	}
-
-
-	// Create a copy of parameters
-	for (i=0; i < nGamutPCSposition; i++) {
-		ProfileList[i]    = hProfiles[i];
-		BPCList[i]        = BPC[i];
-		AdaptationList[i] = AdaptationStates[i];
-		IntentList[i]     = Intents[i];
-	}
-
-	// Fill Lab identity
-	ProfileList[nGamutPCSposition] = hLab;
-	BPCList[nGamutPCSposition] = 0;
-	AdaptationList[nGamutPCSposition] = 1.0;
-	Intents[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
-
-
-	ColorSpace  = cmsGetColorSpace(hGamut);  
-
-	nChannels   = cmsChannelsOf(ColorSpace);     
-	nGridpoints = _cmsReasonableGridpointsByColorspace(ColorSpace, cmsFLAGS_HIGHRESPRECALC);
-	dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
-
-	// 16 bits to Lab double
-	Chain.hInput = cmsCreateExtendedTransform(ContextID, 
-		nGamutPCSposition + 1, 
-		ProfileList, 
-		BPCList, 
-		Intents, 
-		AdaptationList, 
-		NULL, 0, 
-		dwFormat, TYPE_Lab_DBL, 
-		cmsFLAGS_NOCACHE);
-
-
-	// Does create the forward step. Lab double to device
-	dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
-	Chain.hForward = cmsCreateTransformTHR(ContextID,
-		hLab, TYPE_Lab_DBL, 
-		hGamut, dwFormat, 
-		INTENT_RELATIVE_COLORIMETRIC,
-		cmsFLAGS_NOCACHE);
-
-	// Does create the backwards step
-	Chain.hReverse = cmsCreateTransformTHR(ContextID, hGamut, dwFormat, 
-		hLab, TYPE_Lab_DBL,                                      
-		INTENT_RELATIVE_COLORIMETRIC,
-		cmsFLAGS_NOCACHE);
-
-
-	// All ok?
-	if (Chain.hForward && Chain.hReverse) {
-
-		// Go on, try to compute gamut LUT from PCS. This consist on a single channel containing 
-		// dE when doing a transform back and forth on the colorimetric intent. 
-
-		Gamut = cmsPipelineAlloc(ContextID, 3, 1);
-
-		if (Gamut != NULL) {
-
-			CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
-			cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT);
-
-			cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
-		}
-	}
-	else 
-		Gamut = NULL;   // Didn't work...
-
-	// Free all needed stuff.
-	if (Chain.hInput)   cmsDeleteTransform(Chain.hInput);
-	if (Chain.hForward) cmsDeleteTransform(Chain.hForward);
-	if (Chain.hReverse) cmsDeleteTransform(Chain.hReverse);
-	if (hLab) cmsCloseProfile(hLab);
-
-	// And return computed hull
-	return Gamut;
-}
-
-// Total Area Coverage estimation ----------------------------------------------------------------
-
-typedef struct {
-    cmsUInt32Number  nOutputChans;
-    cmsHTRANSFORM    hRoundTrip;               
-    cmsFloat32Number MaxTAC;
-    cmsFloat32Number MaxInput[cmsMAXCHANNELS];
-
-} cmsTACestimator;
-
-
-// This callback just accounts the maximum ink dropped in the given node. It does not populate any
-// memory, as the destination table is NULL. Its only purpose it to know the global maximum.
-static
-int EstimateTAC(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void * Cargo)
-{
-    cmsTACestimator* bp = (cmsTACestimator*) Cargo;
-    cmsFloat32Number RoundTrip[cmsMAXCHANNELS];
-    cmsUInt32Number i;
-    cmsFloat32Number Sum;
-
-    
-    // Evaluate the xform
-    cmsDoTransform(bp->hRoundTrip, In, RoundTrip, 1);
-    
-    // All all amounts of ink
-    for (Sum=0, i=0; i < bp ->nOutputChans; i++) 
-            Sum += RoundTrip[i];
-
-    // If above maximum, keep track of input values
-    if (Sum > bp ->MaxTAC) {
-
-            bp ->MaxTAC = Sum;
-
-            for (i=0; i < bp ->nOutputChans; i++) {
-                bp ->MaxInput[i] = In[i];
-            }
-    }
-    
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(Out);
-}
-
-
-// Detect Total area coverage of the profile
-cmsFloat64Number CMSEXPORT cmsDetectTAC(cmsHPROFILE hProfile)
-{
-    cmsTACestimator bp;
-    cmsUInt32Number dwFormatter;
-    cmsUInt32Number GridPoints[MAX_INPUT_DIMENSIONS];        
-    cmsHPROFILE hLab;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    // TAC only works on output profiles
-    if (cmsGetDeviceClass(hProfile) != cmsSigOutputClass) {        
-        return 0;       
-    }
-
-    // Create a fake formatter for result
-    dwFormatter = cmsFormatterForColorspaceOfProfile(hProfile, 4, TRUE);
-
-    bp.nOutputChans = T_CHANNELS(dwFormatter);
-    bp.MaxTAC = 0;    // Initial TAC is 0
-
-    //  for safety
-    if (bp.nOutputChans >= cmsMAXCHANNELS) return 0;
-
-    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) return 0;
-    // Setup a roundtrip on perceptual intent in output profile for TAC estimation
-    bp.hRoundTrip = cmsCreateTransformTHR(ContextID, hLab, TYPE_Lab_16, 
-                                          hProfile, dwFormatter, INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);
-
-    cmsCloseProfile(hLab);  
-    if (bp.hRoundTrip == NULL) return 0;
-
-    // For L* we only need black and white. For C* we need many points
-    GridPoints[0] = 6;
-    GridPoints[1] = 74;
-    GridPoints[2] = 74; 
-
-    
-	if (!cmsSliceSpace16(3, GridPoints, EstimateTAC, &bp)) {
-		bp.MaxTAC = 0;
-	}
-
-    cmsDeleteTransform(bp.hRoundTrip);
-
-    // Results in %
-    return bp.MaxTAC;
-}
-
-
-// Carefully,  clamp on CIELab space.
-
-cmsBool CMSEXPORT cmsDesaturateLab(cmsCIELab* Lab, 
-                                   double amax, double amin,
-                                   double bmax, double bmin)
-{
-
-    // Whole Luma surface to zero
-
-    if (Lab -> L < 0) {
-
-        Lab-> L = Lab->a = Lab-> b = 0.0;
-        return FALSE;
-    }
-
-    // Clamp white, DISCARD HIGHLIGHTS. This is done
-    // in such way because icc spec doesn't allow the
-    // use of L>100 as a highlight means.
-
-    if (Lab->L > 100)
-        Lab -> L = 100;
-
-    // Check out gamut prism, on a, b faces
-
-    if (Lab -> a < amin || Lab->a > amax||
-        Lab -> b < bmin || Lab->b > bmax) {
-
-            cmsCIELCh LCh;
-            double h, slope;
-
-            // Falls outside a, b limits. Transports to LCh space,
-            // and then do the clipping
-
-
-            if (Lab -> a == 0.0) { // Is hue exactly 90?
-
-                // atan will not work, so clamp here
-                Lab -> b = Lab->b < 0 ? bmin : bmax;
-                return TRUE;
-            }
-
-            cmsLab2LCh(&LCh, Lab);
-
-            slope = Lab -> b / Lab -> a;
-            h = LCh.h;
-
-            // There are 4 zones
-
-            if ((h >= 0. && h < 45.) ||
-                (h >= 315 && h <= 360.)) {
-
-                    // clip by amax
-                    Lab -> a = amax;
-                    Lab -> b = amax * slope;
-            }
-            else
-                if (h >= 45. && h < 135.)
-                {
-                    // clip by bmax
-                    Lab -> b = bmax;
-                    Lab -> a = bmax / slope;
-                }
-                else
-                    if (h >= 135. && h < 225.) {
-                        // clip by amin
-                        Lab -> a = amin;
-                        Lab -> b = amin * slope;
-
-                    }
-                    else
-                        if (h >= 225. && h < 315.) {
-                            // clip by bmin
-                            Lab -> b = bmin;
-                            Lab -> a = bmin / slope;
-                        }
-                        else  {
-                            cmsSignalError(0, cmsERROR_RANGE, "Invalid angle");
-                            return FALSE;
-                        }
-
-    }
-
-    return TRUE;
-}
diff --git a/thirdparty/liblcms2/src/cmsintrp.c b/thirdparty/liblcms2/src/cmsintrp.c
deleted file mode 100644
index 9aced86..0000000
--- a/thirdparty/liblcms2/src/cmsintrp.c
+++ /dev/null
@@ -1,1463 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// This module incorporates several interpolation routines, for 1 to 8 channels on input and
-// up to 65535 channels on output. The user may change those by using the interpolation plug-in
-
-// Interpolation routines by default
-static cmsInterpFunction DefaultInterpolatorsFactory(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags);
-
-// This is the default factory
-static cmsInterpFnFactory Interpolators = DefaultInterpolatorsFactory;
-
-
-// Main plug-in entry
-cmsBool  _cmsRegisterInterpPlugin(cmsPluginBase* Data)
-{
-    cmsPluginInterpolation* Plugin = (cmsPluginInterpolation*) Data;
-
-    if (Data == NULL) {
-    
-        Interpolators = DefaultInterpolatorsFactory;
-        return TRUE;
-    }
-
-    // Set replacement functions
-    Interpolators = Plugin ->InterpolatorsFactory;  
-    return TRUE;
-}
-
-
-// Set the interpolation method
-
-cmsBool _cmsSetInterpolationRoutine(cmsInterpParams* p)
-{
-    // Invoke factory, possibly in the Plug-in
-    p ->Interpolation = Interpolators(p -> nInputs, p ->nOutputs, p ->dwFlags);
-
-    // If unsupported by the plug-in, go for the LittleCMS default. 
-    // If happens only if an extern plug-in is being used
-    if (p ->Interpolation.Lerp16 == NULL)
-        p ->Interpolation = DefaultInterpolatorsFactory(p ->nInputs, p ->nOutputs, p ->dwFlags);
-
-    // Check for valid interpolator (we just check one member of the union)
-    if (p ->Interpolation.Lerp16 == NULL) {    
-            return FALSE;
-    }
-    return TRUE;
-}
-
-
-// This function precalculates as many parameters as possible to speed up the interpolation.
-cmsInterpParams* _cmsComputeInterpParamsEx(cmsContext ContextID,
-                                           const cmsUInt32Number nSamples[], 
-                                           int InputChan, int OutputChan, 
-                                           const void *Table,
-                                           cmsUInt32Number dwFlags)
-{        
-    cmsInterpParams* p;
-    int i;
-    
-    // Check for maximum inputs
-    if (InputChan > MAX_INPUT_DIMENSIONS) {
-             cmsSignalError(ContextID, cmsERROR_RANGE, "Too many input channels (%d channels, max=%d)", InputChan, MAX_INPUT_DIMENSIONS);            
-            return NULL;
-    }
-
-    // Creates an empty object
-    p = (cmsInterpParams*) _cmsMallocZero(ContextID, sizeof(cmsInterpParams));
-    if (p == NULL) return NULL;
-
-    // Keep original parameters
-    p -> dwFlags  = dwFlags;
-    p -> nInputs  = InputChan;
-    p -> nOutputs = OutputChan;
-    p ->Table     = Table;
-    p ->ContextID  = ContextID;
-
-    // Fill samples per input direction and domain (which is number of nodes minus one)
-    for (i=0; i < InputChan; i++) {
-
-        p -> nSamples[i] = nSamples[i];
-        p -> Domain[i]   = nSamples[i] - 1;     
-    }
-
-    // Compute factors to apply to each component to index the grid array
-    p -> opta[0] = p -> nOutputs;  
-    for (i=1; i < InputChan; i++)
-        p ->opta[i] = p ->opta[i-1] * nSamples[InputChan-i];
-
-
-    if (!_cmsSetInterpolationRoutine(p)) {
-         cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported interpolation (%d->%d channels)", InputChan, OutputChan);            
-        _cmsFree(ContextID, p);
-        return NULL;
-    }
-
-    // All seems ok
-    return p;
-}
-
-
-// This one is a wrapper on the anterior, but assuming all directions have same number of nodes
-cmsInterpParams* _cmsComputeInterpParams(cmsContext ContextID, int nSamples, int InputChan, int OutputChan, const void* Table, cmsUInt32Number dwFlags)
-{
-    int i;
-    cmsUInt32Number Samples[MAX_INPUT_DIMENSIONS];
-
-    // Fill the auxiliar array
-    for (i=0; i < MAX_INPUT_DIMENSIONS; i++) 
-        Samples[i] = nSamples;
-
-    // Call the extended function
-    return _cmsComputeInterpParamsEx(ContextID, Samples, InputChan, OutputChan, Table, dwFlags);
-}
-
-
-// Free all associated memory
-void _cmsFreeInterpParams(cmsInterpParams* p)
-{
-    if (p != NULL) _cmsFree(p ->ContextID, p);
-}
-
-
-// Inline fixed point interpolation 
-cmsINLINE cmsUInt16Number LinearInterp(cmsS15Fixed16Number a, cmsS15Fixed16Number l, cmsS15Fixed16Number h)
-{
-    cmsUInt32Number dif = (cmsUInt32Number) (h - l) * a + 0x8000;           
-    dif = (dif >> 16) + l;        
-    return (cmsUInt16Number) (dif);
-}
-
-
-//  Linear interpolation (Fixed-point optimized)
-static
-void LinLerp1D(register const cmsUInt16Number Value[], 
-               register cmsUInt16Number Output[], 
-               register const cmsInterpParams* p)
-{
-    cmsUInt16Number y1, y0; 
-    int cell0, rest;
-    int val3;
-    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table;
-
-    // if last value... 
-    if (Value[0] == 0xffff) {
-
-        Output[0] = LutTable[p -> Domain[0]];
-        return;
-    }
-
-    val3 = p -> Domain[0] * Value[0];
-    val3 = _cmsToFixedDomain(val3);    // To fixed 15.16
-
-    cell0 = FIXED_TO_INT(val3);             // Cell is 16 MSB bits
-    rest  = FIXED_REST_TO_INT(val3);        // Rest is 16 LSB bits
-
-    y0 = LutTable[cell0];
-    y1 = LutTable[cell0+1];
-
-    
-    Output[0] = LinearInterp(rest, y0, y1);
-}
-
-
-// Floating-point version of 1D interpolation
-static
-void LinLerp1Dfloat(const cmsFloat32Number Value[], 
-                    cmsFloat32Number Output[],  
-                    const cmsInterpParams* p)
-{
-       cmsFloat32Number y1, y0;
-       cmsFloat32Number val2, rest;
-       int cell0, cell1;
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;
-
-       // if last value...
-       if (Value[0] == 1.0) {
-           Output[0] = LutTable[p -> Domain[0]];
-           return;
-       }
-
-       val2 = p -> Domain[0] * Value[0];
-
-       cell0 = (int) floor(val2);
-       cell1 = (int) ceil(val2);
-
-       // Rest is 16 LSB bits
-       rest = val2 - cell0;
-
-       y0 = LutTable[cell0] ;
-       y1 = LutTable[cell1] ;
-
-       Output[0] = y0 + (y1 - y0) * rest;     
-}
-
-
-
-// Eval gray LUT having only one input channel 
-static
-void Eval1Input(register const cmsUInt16Number Input[], 
-                register cmsUInt16Number Output[], 
-                register const cmsInterpParams* p16)
-{
-       cmsS15Fixed16Number fk;
-       cmsS15Fixed16Number k0, k1, rk, K0, K1;
-       int v;
-       cmsUInt32Number OutChan;
-       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table;
-
-       v = Input[0] * p16 -> Domain[0];
-       fk = _cmsToFixedDomain(v);
-
-       k0 = FIXED_TO_INT(fk);
-       rk = (cmsUInt16Number) FIXED_REST_TO_INT(fk);
-
-       k1 = k0 + (Input[0] != 0xFFFFU ? 1 : 0);
-
-       K0 = p16 -> opta[0] * k0;
-       K1 = p16 -> opta[0] * k1;
-
-       for (OutChan=0; OutChan < p16->nOutputs; OutChan++) {
-
-           Output[OutChan] = LinearInterp(rk, LutTable[K0+OutChan], LutTable[K1+OutChan]);
-       }
-}
-
-
-
-// Eval gray LUT having only one input channel 
-static
-void Eval1InputFloat(const cmsFloat32Number Value[], 
-                     cmsFloat32Number Output[], 
-                     const cmsInterpParams* p)
-{
-    cmsFloat32Number y1, y0;
-    cmsFloat32Number val2, rest;
-    int cell0, cell1;
-    cmsUInt32Number OutChan;
-    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table; 
-
-        // if last value...
-       if (Value[0] == 1.0) {
-           Output[0] = LutTable[p -> Domain[0]];
-           return;
-       }
-
-       val2 = p -> Domain[0] * Value[0];
-
-       cell0 = (int) floor(val2);
-       cell1 = (int) ceil(val2);
-
-       // Rest is 16 LSB bits
-       rest = val2 - cell0;
-       
-       cell0 *= p -> opta[0];
-       cell1 *= p -> opta[0];
-
-       for (OutChan=0; OutChan < p->nOutputs; OutChan++) {
-
-            y0 = LutTable[cell0 + OutChan] ;
-            y1 = LutTable[cell1 + OutChan] ;
-
-            Output[OutChan] = y0 + (y1 - y0) * rest;              
-       }
-}
-
-// Bilinear interpolation (16 bits) - cmsFloat32Number version
-static
-void BilinearInterpFloat(const cmsFloat32Number Input[], 
-                         cmsFloat32Number Output[],                          
-                         const cmsInterpParams* p)
-
-{
-#   define LERP(a,l,h)    (cmsFloat32Number) ((l)+(((h)-(l))*(a)))
-#   define DENS(i,j)      (LutTable[(i)+(j)+OutChan])
-
-    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table; 
-    cmsFloat32Number      px, py;
-    int        x0, y0,
-               X0, Y0, X1, Y1;
-    int        TotalOut, OutChan;
-    cmsFloat32Number      fx, fy,
-        d00, d01, d10, d11,
-        dx0, dx1,
-        dxy;
-    
-    TotalOut   = p -> nOutputs;
-    px = Input[0] * p->Domain[0];
-    py = Input[1] * p->Domain[1];
-
-    x0 = (int) _cmsQuickFloor(px); fx = px - (cmsFloat32Number) x0;
-    y0 = (int) _cmsQuickFloor(py); fy = py - (cmsFloat32Number) y0;
-    
-    X0 = p -> opta[1] * x0;
-    X1 = X0 + (Input[0] >= 1.0 ? 0 : p->opta[1]);
-
-    Y0 = p -> opta[0] * y0;
-    Y1 = Y0 + (Input[1] >= 1.0 ? 0 : p->opta[0]);
-   
-    for (OutChan = 0; OutChan < TotalOut; OutChan++) {
-       
-        d00 = DENS(X0, Y0);
-        d01 = DENS(X0, Y1);
-        d10 = DENS(X1, Y0);
-        d11 = DENS(X1, Y1);
-
-        dx0 = LERP(fx, d00, d10);
-        dx1 = LERP(fx, d01, d11);
-
-        dxy = LERP(fy, dx0, dx1);
-
-        Output[OutChan] = dxy;
-    }
-
-
-#   undef LERP
-#   undef DENS
-}
-
-// Bilinear interpolation (16 bits) - optimized version
-static
-void BilinearInterp16(register const cmsUInt16Number Input[], 
-                      register cmsUInt16Number Output[],
-                      register const cmsInterpParams* p)
-
-{
-#define DENS(i,j) (LutTable[(i)+(j)+OutChan])
-#define LERP(a,l,h)     (cmsUInt16Number) (l + ROUND_FIXED_TO_INT(((h-l)*a)))
-
-           const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table; 
-           int        OutChan, TotalOut;
-           cmsS15Fixed16Number    fx, fy;
-  register int        rx, ry;
-           int        x0, y0;
-  register int        X0, X1, Y0, Y1;
-           int        d00, d01, d10, d11,
-                      dx0, dx1,
-                      dxy;
-
-    TotalOut   = p -> nOutputs;
-
-    fx = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);
-    x0  = FIXED_TO_INT(fx);
-    rx  = FIXED_REST_TO_INT(fx);    // Rest in 0..1.0 domain
-
-
-    fy = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);
-    y0  = FIXED_TO_INT(fy);
-    ry  = FIXED_REST_TO_INT(fy);
-
-
-    X0 = p -> opta[1] * x0;
-    X1 = X0 + (Input[0] == 0xFFFFU ? 0 : p->opta[1]);
-
-    Y0 = p -> opta[0] * y0;
-    Y1 = Y0 + (Input[1] == 0xFFFFU ? 0 : p->opta[0]);
-   
-    for (OutChan = 0; OutChan < TotalOut; OutChan++) {
-
-        d00 = DENS(X0, Y0);
-        d01 = DENS(X0, Y1);
-        d10 = DENS(X1, Y0);
-        d11 = DENS(X1, Y1);
-
-        dx0 = LERP(rx, d00, d10);
-        dx1 = LERP(rx, d01, d11);
-
-        dxy = LERP(ry, dx0, dx1);
-
-        Output[OutChan] = (cmsUInt16Number) dxy;
-    }
-
-
-#   undef LERP
-#   undef DENS
-}
-
-
-// Trilinear interpolation (16 bits) - cmsFloat32Number version
-static
-void TrilinearInterpFloat(const cmsFloat32Number Input[], 
-                          cmsFloat32Number Output[],                          
-                          const cmsInterpParams* p)
-
-{
-#   define LERP(a,l,h)      (cmsFloat32Number) ((l)+(((h)-(l))*(a)))
-#   define DENS(i,j,k)      (LutTable[(i)+(j)+(k)+OutChan])
-
-    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table; 
-    cmsFloat32Number      px, py, pz;
-    int        x0, y0, z0,
-               X0, Y0, Z0, X1, Y1, Z1;
-    int        TotalOut, OutChan;
-    cmsFloat32Number      fx, fy, fz,
-        d000, d001, d010, d011,
-        d100, d101, d110, d111,
-        dx00, dx01, dx10, dx11,
-        dxy0, dxy1, dxyz;
-    
-    TotalOut   = p -> nOutputs;
-    
-    // We need some clipping here
-    px = Input[0];
-    py = Input[1];
-    pz = Input[2];
-
-    if (px < 0) px = 0; 
-    if (px > 1) px = 1;
-    if (py < 0) py = 0; 
-    if (py > 1) py = 1;
-    if (pz < 0) pz = 0; 
-    if (pz > 1) pz = 1;
-
-    px *= p->Domain[0];
-    py *= p->Domain[1];
-    pz *= p->Domain[2];
-
-    x0 = (int) _cmsQuickFloor(px); fx = px - (cmsFloat32Number) x0;
-    y0 = (int) _cmsQuickFloor(py); fy = py - (cmsFloat32Number) y0;
-    z0 = (int) _cmsQuickFloor(pz); fz = pz - (cmsFloat32Number) z0;
-    
-    X0 = p -> opta[2] * x0;
-    X1 = X0 + (Input[0] >= 1.0 ? 0 : p->opta[2]);
-
-    Y0 = p -> opta[1] * y0;
-    Y1 = Y0 + (Input[1] >= 1.0 ? 0 : p->opta[1]);
-   
-    Z0 = p -> opta[0] * z0;
-    Z1 = Z0 + (Input[2] >= 1.0 ? 0 : p->opta[0]);
-   
-    for (OutChan = 0; OutChan < TotalOut; OutChan++) {
-
-        d000 = DENS(X0, Y0, Z0);
-        d001 = DENS(X0, Y0, Z1);
-        d010 = DENS(X0, Y1, Z0);
-        d011 = DENS(X0, Y1, Z1);
-
-        d100 = DENS(X1, Y0, Z0);
-        d101 = DENS(X1, Y0, Z1);
-        d110 = DENS(X1, Y1, Z0);
-        d111 = DENS(X1, Y1, Z1);
-
-
-        dx00 = LERP(fx, d000, d100);
-        dx01 = LERP(fx, d001, d101);
-        dx10 = LERP(fx, d010, d110);
-        dx11 = LERP(fx, d011, d111);
-
-        dxy0 = LERP(fy, dx00, dx10);
-        dxy1 = LERP(fy, dx01, dx11);
-
-        dxyz = LERP(fz, dxy0, dxy1);
-
-        Output[OutChan] = dxyz;
-    }
-
-
-#   undef LERP
-#   undef DENS
-}
-
-// Trilinear interpolation (16 bits) - optimized version
-static
-void TrilinearInterp16(register const cmsUInt16Number Input[], 
-                       register cmsUInt16Number Output[],
-                       register const cmsInterpParams* p)
-
-{
-#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])
-#define LERP(a,l,h)     (cmsUInt16Number) (l + ROUND_FIXED_TO_INT(((h-l)*a)))
-
-           const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table; 
-           int        OutChan, TotalOut;
-           cmsS15Fixed16Number    fx, fy, fz;
-  register int        rx, ry, rz;
-           int        x0, y0, z0;
-  register int        X0, X1, Y0, Y1, Z0, Z1;
-           int        d000, d001, d010, d011,
-                      d100, d101, d110, d111,
-                      dx00, dx01, dx10, dx11,
-                      dxy0, dxy1, dxyz;
-
-    TotalOut   = p -> nOutputs;
-
-    fx = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);
-    x0  = FIXED_TO_INT(fx);
-    rx  = FIXED_REST_TO_INT(fx);    // Rest in 0..1.0 domain
-
-
-    fy = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);
-    y0  = FIXED_TO_INT(fy);
-    ry  = FIXED_REST_TO_INT(fy);
-
-    fz = _cmsToFixedDomain((int) Input[2] * p -> Domain[2]);
-    z0 = FIXED_TO_INT(fz);
-    rz = FIXED_REST_TO_INT(fz);
-
-
-    X0 = p -> opta[2] * x0;
-    X1 = X0 + (Input[0] == 0xFFFFU ? 0 : p->opta[2]);
-
-    Y0 = p -> opta[1] * y0;
-    Y1 = Y0 + (Input[1] == 0xFFFFU ? 0 : p->opta[1]);
-   
-    Z0 = p -> opta[0] * z0;
-    Z1 = Z0 + (Input[2] == 0xFFFFU ? 0 : p->opta[0]);
-
-    for (OutChan = 0; OutChan < TotalOut; OutChan++) {
-
-        d000 = DENS(X0, Y0, Z0);
-        d001 = DENS(X0, Y0, Z1);
-        d010 = DENS(X0, Y1, Z0);
-        d011 = DENS(X0, Y1, Z1);
-
-        d100 = DENS(X1, Y0, Z0);
-        d101 = DENS(X1, Y0, Z1);
-        d110 = DENS(X1, Y1, Z0);
-        d111 = DENS(X1, Y1, Z1);
-
-
-        dx00 = LERP(rx, d000, d100);
-        dx01 = LERP(rx, d001, d101);
-        dx10 = LERP(rx, d010, d110);
-        dx11 = LERP(rx, d011, d111);
-
-        dxy0 = LERP(ry, dx00, dx10);
-        dxy1 = LERP(ry, dx01, dx11);
-
-        dxyz = LERP(rz, dxy0, dxy1);
-
-        Output[OutChan] = (cmsUInt16Number) dxyz;
-    }
-
-
-#   undef LERP
-#   undef DENS
-}
-
-
-// Tetrahedral interpolation, using Sakamoto algorithm. 
-#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])
-static
-void TetrahedralInterpFloat(const cmsFloat32Number Input[], 
-                            cmsFloat32Number Output[],                          
-                            const cmsInterpParams* p)
-{
-    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-    cmsFloat32Number     px, py, pz;
-    int        x0, y0, z0,
-               X0, Y0, Z0, X1, Y1, Z1;
-    cmsFloat32Number     rx, ry, rz;
-    cmsFloat32Number     c0, c1=0, c2=0, c3=0;
-    int                  OutChan, TotalOut;
-
-    TotalOut   = p -> nOutputs;
-
-    // We need some clipping here
-    px = Input[0];
-    py = Input[1];
-    pz = Input[2];
-
-    if (px < 0) px = 0; 
-    if (px > 1) px = 1;
-    if (py < 0) py = 0; 
-    if (py > 1) py = 1;
-    if (pz < 0) pz = 0; 
-    if (pz > 1) pz = 1;
-
-    px *= p->Domain[0];
-    py *= p->Domain[1];
-    pz *= p->Domain[2];
-
-    x0 = (int) _cmsQuickFloor(px); rx = (px - (cmsFloat32Number) x0);
-    y0 = (int) _cmsQuickFloor(py); ry = (py - (cmsFloat32Number) y0);
-    z0 = (int) _cmsQuickFloor(pz); rz = (pz - (cmsFloat32Number) z0);
-
-
-    X0 = p -> opta[2] * x0;
-    X1 = X0 + (Input[0] >= 1.0 ? 0 : p->opta[2]);
-
-    Y0 = p -> opta[1] * y0;
-    Y1 = Y0 + (Input[1] >= 1.0 ? 0 : p->opta[1]);
-   
-    Z0 = p -> opta[0] * z0;
-    Z1 = Z0 + (Input[2] >= 1.0 ? 0 : p->opta[0]);
-   
-    for (OutChan=0; OutChan < TotalOut; OutChan++) {
-
-       // These are the 6 Tetrahedral
-
-        c0 = DENS(X0, Y0, Z0);
-
-        if (rx >= ry && ry >= rz) {
-
-            c1 = DENS(X1, Y0, Z0) - c0;
-            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);
-            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-        }
-        else
-            if (rx >= rz && rz >= ry) {            
-
-                c1 = DENS(X1, Y0, Z0) - c0;
-                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);
-
-            }
-            else
-                if (rz >= rx && rx >= ry) {
-
-                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);
-                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                    c3 = DENS(X0, Y0, Z1) - c0;                            
-
-                }
-                else
-                    if (ry >= rx && rx >= rz) {
-
-                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);
-                        c2 = DENS(X0, Y1, Z0) - c0;
-                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-                    }
-                    else
-                        if (ry >= rz && rz >= rx) {
-
-                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                            c2 = DENS(X0, Y1, Z0) - c0;
-                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);
-
-                        }
-                        else
-                            if (rz >= ry && ry >= rx) {             
-
-                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);
-                                c3 = DENS(X0, Y0, Z1) - c0;
-
-                            }
-                            else  {
-                                c1 = c2 = c3 = 0;                               
-                            }
-
-       Output[OutChan] = c0 + c1 * rx + c2 * ry + c3 * rz;
-       }
-
-}
-
-#undef DENS
-
-
-
-#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])
-
-static
-void TetrahedralInterp16(register const cmsUInt16Number Input[],
-                         register cmsUInt16Number Output[],
-                         register const cmsInterpParams* p)
-{
-    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p -> Table;
-    cmsS15Fixed16Number    fx, fy, fz;
-    cmsS15Fixed16Number    rx, ry, rz;
-    int                    x0, y0, z0;
-    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;       
-    cmsUInt32Number        OutChan;
-    cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;
-    cmsUInt32Number        TotalOut = p -> nOutputs;
-    
-
-    fx  = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);
-    fy  = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);
-    fz  = _cmsToFixedDomain((int) Input[2] * p -> Domain[2]);
-
-    x0  = FIXED_TO_INT(fx);
-    y0  = FIXED_TO_INT(fy); 
-    z0  = FIXED_TO_INT(fz);
-
-    rx  = FIXED_REST_TO_INT(fx);   
-    ry  = FIXED_REST_TO_INT(fy);      
-    rz  = FIXED_REST_TO_INT(fz);
-
-    X0 = p -> opta[2] * x0;
-    X1 = X0 + (Input[0] == 0xFFFFU ? 0 : p->opta[2]);
-
-    Y0 = p -> opta[1] * y0;
-    Y1 = Y0 + (Input[1] == 0xFFFFU ? 0 : p->opta[1]);
-
-    Z0 = p -> opta[0] * z0;
-    Z1 = Z0 + (Input[2] == 0xFFFFU ? 0 : p->opta[0]);
-
-    // These are the 6 Tetrahedral
-    for (OutChan=0; OutChan < TotalOut; OutChan++) {
-
-        c0 = DENS(X0, Y0, Z0);
-
-        if (rx >= ry && ry >= rz) {
-
-            c1 = DENS(X1, Y0, Z0) - c0;
-            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);
-            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-        }
-        else
-            if (rx >= rz && rz >= ry) {            
-
-                c1 = DENS(X1, Y0, Z0) - c0;
-                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);
-
-            }
-            else
-                if (rz >= rx && rx >= ry) {
-
-                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);
-                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                    c3 = DENS(X0, Y0, Z1) - c0;                            
-
-                }
-                else
-                    if (ry >= rx && rx >= rz) {
-
-                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);
-                        c2 = DENS(X0, Y1, Z0) - c0;
-                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-                    }
-                    else
-                        if (ry >= rz && rz >= rx) {
-
-                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                            c2 = DENS(X0, Y1, Z0) - c0;
-                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);
-
-                        }
-                        else
-                            if (rz >= ry && ry >= rx) {             
-
-                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);
-                                c3 = DENS(X0, Y0, Z1) - c0;
-
-                            }
-                            else  {
-                                c1 = c2 = c3 = 0;                               
-                            }
-
-                            Rest = c1 * rx + c2 * ry + c3 * rz;                
-
-                            Output[OutChan] = (cmsUInt16Number) c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest));
-    }
-
-}
-#undef DENS
-
-
-#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])
-static
-void Eval4Inputs(register const cmsUInt16Number Input[], 
-                     register cmsUInt16Number Output[], 
-                     register const cmsInterpParams* p16)
-{                        
-    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table; 
-    cmsS15Fixed16Number fk;
-    cmsS15Fixed16Number k0, rk;
-    int K0, K1;
-    cmsS15Fixed16Number    fx, fy, fz;
-    cmsS15Fixed16Number    rx, ry, rz;
-    int                    x0, y0, z0;
-    cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;
-    cmsUInt32Number i;
-    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;       
-    cmsUInt32Number        OutChan;
-    cmsUInt16Number        Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-
-
-    fk  = _cmsToFixedDomain((int) Input[0] * p16 -> Domain[0]);
-    fx  = _cmsToFixedDomain((int) Input[1] * p16 -> Domain[1]);
-    fy  = _cmsToFixedDomain((int) Input[2] * p16 -> Domain[2]);
-    fz  = _cmsToFixedDomain((int) Input[3] * p16 -> Domain[3]);
-
-    k0  = FIXED_TO_INT(fk);     
-    x0  = FIXED_TO_INT(fx);
-    y0  = FIXED_TO_INT(fy); 
-    z0  = FIXED_TO_INT(fz);
-
-    rk  = FIXED_REST_TO_INT(fk);
-    rx  = FIXED_REST_TO_INT(fx);   
-    ry  = FIXED_REST_TO_INT(fy);      
-    rz  = FIXED_REST_TO_INT(fz);
-
-    K0 = p16 -> opta[3] * k0;
-    K1 = K0 + (Input[0] == 0xFFFFU ? 0 : p16->opta[3]);
-
-    X0 = p16 -> opta[2] * x0;
-    X1 = X0 + (Input[1] == 0xFFFFU ? 0 : p16->opta[2]);
-
-    Y0 = p16 -> opta[1] * y0;
-    Y1 = Y0 + (Input[2] == 0xFFFFU ? 0 : p16->opta[1]);
-
-    Z0 = p16 -> opta[0] * z0;
-    Z1 = Z0 + (Input[3] == 0xFFFFU ? 0 : p16->opta[0]);
-
-    LutTable = (cmsUInt16Number*) p16 -> Table;
-    LutTable += K0;
-
-    for (OutChan=0; OutChan < p16 -> nOutputs; OutChan++) {
-
-        c0 = DENS(X0, Y0, Z0);
-
-        if (rx >= ry && ry >= rz) {
-
-            c1 = DENS(X1, Y0, Z0) - c0;
-            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);
-            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-        }
-        else
-            if (rx >= rz && rz >= ry) {            
-
-                c1 = DENS(X1, Y0, Z0) - c0;
-                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);
-
-            }
-            else
-                if (rz >= rx && rx >= ry) {
-
-                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);
-                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                    c3 = DENS(X0, Y0, Z1) - c0;                            
-
-                }
-                else
-                    if (ry >= rx && rx >= rz) {
-
-                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);
-                        c2 = DENS(X0, Y1, Z0) - c0;
-                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-                    }
-                    else
-                        if (ry >= rz && rz >= rx) {
-
-                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                            c2 = DENS(X0, Y1, Z0) - c0;
-                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);
-
-                        }
-                        else
-                            if (rz >= ry && ry >= rx) {             
-
-                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);
-                                c3 = DENS(X0, Y0, Z1) - c0;
-
-                            }
-                            else  {
-                                c1 = c2 = c3 = 0;                               
-                            }
-
-                            Rest = c1 * rx + c2 * ry + c3 * rz;                
-
-                            Tmp1[OutChan] = (cmsUInt16Number) c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest));
-    }
-
-
-    LutTable = (cmsUInt16Number*) p16 -> Table;
-    LutTable += K1;
-
-    for (OutChan=0; OutChan < p16 -> nOutputs; OutChan++) {
-
-        c0 = DENS(X0, Y0, Z0);
-
-        if (rx >= ry && ry >= rz) {
-
-            c1 = DENS(X1, Y0, Z0) - c0;
-            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);
-            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-        }
-        else
-            if (rx >= rz && rz >= ry) {            
-
-                c1 = DENS(X1, Y0, Z0) - c0;
-                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);
-
-            }
-            else
-                if (rz >= rx && rx >= ry) {
-
-                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);
-                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                    c3 = DENS(X0, Y0, Z1) - c0;                            
-
-                }
-                else
-                    if (ry >= rx && rx >= rz) {
-
-                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);
-                        c2 = DENS(X0, Y1, Z0) - c0;
-                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);
-
-                    }
-                    else
-                        if (ry >= rz && rz >= rx) {
-
-                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                            c2 = DENS(X0, Y1, Z0) - c0;
-                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);
-
-                        }
-                        else
-                            if (rz >= ry && ry >= rx) {             
-
-                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);
-                                c3 = DENS(X0, Y0, Z1) - c0;
-
-                            }
-                            else  {
-                                c1 = c2 = c3 = 0;                               
-                            }
-
-                            Rest = c1 * rx + c2 * ry + c3 * rz;                
-
-                            Tmp2[OutChan] = (cmsUInt16Number) c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest));
-    }
-
-
-
-    for (i=0; i < p16 -> nOutputs; i++) {
-        Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);              
-    }
-}
-#undef DENS
-
-
-// For more that 3 inputs (i.e., CMYK)
-// evaluate two 3-dimensional interpolations and then linearly interpolate between them.
-
-
-static
-void Eval4InputsFloat(const cmsFloat32Number Input[], 
-                      cmsFloat32Number Output[], 
-                      const cmsInterpParams* p)
-{                             
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-       cmsFloat32Number rest;
-       cmsFloat32Number pk;
-       int k0, K0, K1;
-       const cmsFloat32Number* T;
-       cmsUInt32Number i;
-       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       
-       pk = Input[0] * p->Domain[0];    
-       k0 = _cmsQuickFloor(pk); 
-       rest = pk - (cmsFloat32Number) k0;
-
-       K0 = p -> opta[3] * k0;
-       K1 = K0 + (Input[0] >= 1.0 ? 0 : p->opta[3]);
-
-       p1 = *p;
-       memmove(&p1.Domain[0], &p ->Domain[1], 3*sizeof(cmsUInt32Number));
-       
-       T = LutTable + K0;
-       p1.Table = T;
-
-       TetrahedralInterpFloat(Input + 1,  Tmp1, &p1);
-
-       T = LutTable + K1;
-       p1.Table = T;
-       TetrahedralInterpFloat(Input + 1,  Tmp2, &p1);
-
-       for (i=0; i < p -> nOutputs; i++)
-       {
-              cmsFloat32Number y0 = Tmp1[i];
-              cmsFloat32Number y1 = Tmp2[i];
-
-              Output[i] = y0 + (y1 - y0) * rest;               
-       }
-}
-
-
-static
-void Eval5Inputs(register const cmsUInt16Number Input[], 
-                 register cmsUInt16Number Output[], 
-
-                 register const cmsInterpParams* p16)
-{       
-       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table;  
-       cmsS15Fixed16Number fk;
-       cmsS15Fixed16Number k0, rk;
-       int K0, K1;
-       const cmsUInt16Number* T;
-       cmsUInt32Number i;
-       cmsUInt16Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       
-       fk = _cmsToFixedDomain((cmsS15Fixed16Number) Input[0] * p16 -> Domain[0]);
-       k0 = FIXED_TO_INT(fk);
-       rk = FIXED_REST_TO_INT(fk);
-
-       K0 = p16 -> opta[4] * k0;
-       K1 = p16 -> opta[4] * (k0 + (Input[0] != 0xFFFFU ? 1 : 0));
-
-       p1 = *p16;
-       memmove(&p1.Domain[0], &p16 ->Domain[1], 4*sizeof(cmsUInt32Number));
-
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval4Inputs(Input + 1, Tmp1, &p1);
-
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval4Inputs(Input + 1, Tmp2, &p1);
-
-       for (i=0; i < p16 -> nOutputs; i++) {
-
-              Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);                         
-       }
-
-}
-
-
-static
-void Eval5InputsFloat(const cmsFloat32Number Input[], 
-                      cmsFloat32Number Output[], 
-                      const cmsInterpParams* p)
-{                             
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-       cmsFloat32Number rest;
-       cmsFloat32Number pk;
-       int k0, K0, K1;
-       const cmsFloat32Number* T;
-       cmsUInt32Number i;
-       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       pk = Input[0] * p->Domain[0];    
-       k0 = _cmsQuickFloor(pk); 
-       rest = pk - (cmsFloat32Number) k0;
-
-       K0 = p -> opta[4] * k0;
-       K1 = K0 + (Input[0] >= 1.0 ? 0 : p->opta[4]);
-
-       p1 = *p;
-       memmove(&p1.Domain[0], &p ->Domain[1], 4*sizeof(cmsUInt32Number));
-
-       T = LutTable + K0;
-       p1.Table = T;
-       
-       Eval4InputsFloat(Input + 1,  Tmp1, &p1);
-      
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval4InputsFloat(Input + 1,  Tmp2, &p1);
-      
-       for (i=0; i < p -> nOutputs; i++) {
-
-              cmsFloat32Number y0 = Tmp1[i];
-              cmsFloat32Number y1 = Tmp2[i];
-
-              Output[i] = y0 + (y1 - y0) * rest;             
-       }
-}
-
-
-
-static
-void Eval6Inputs(register const cmsUInt16Number Input[], 
-                 register cmsUInt16Number Output[], 
-                 register const cmsInterpParams* p16)
-{       
-       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table; 
-       cmsS15Fixed16Number fk;
-       cmsS15Fixed16Number k0, rk;
-       int K0, K1;
-       const cmsUInt16Number* T;
-       cmsUInt32Number i;
-       cmsUInt16Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-       
-       fk = _cmsToFixedDomain((cmsS15Fixed16Number) Input[0] * p16 -> Domain[0]);
-       k0 = FIXED_TO_INT(fk);
-       rk = FIXED_REST_TO_INT(fk);
-
-       K0 = p16 -> opta[5] * k0;
-       K1 = p16 -> opta[5] * (k0 + (Input[0] != 0xFFFFU ? 1 : 0));
-
-       p1 = *p16;
-       memmove(&p1.Domain[0], &p16 ->Domain[1], 5*sizeof(cmsUInt32Number));
-
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval5Inputs(Input + 1, Tmp1, &p1);
-
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval5Inputs(Input + 1, Tmp2, &p1);
-
-       for (i=0; i < p16 -> nOutputs; i++) {
-
-              Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);
-       }
-
-}
-
-
-static
-void Eval6InputsFloat(const cmsFloat32Number Input[], 
-                      cmsFloat32Number Output[], 
-                      const cmsInterpParams* p)
-{                             
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-       cmsFloat32Number rest;
-       cmsFloat32Number pk;
-       int k0, K0, K1;
-       const cmsFloat32Number* T;
-       cmsUInt32Number i;
-       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       pk = Input[0] * p->Domain[0];    
-       k0 = _cmsQuickFloor(pk); 
-       rest = pk - (cmsFloat32Number) k0;
-
-       K0 = p -> opta[5] * k0;
-       K1 = K0 + (Input[0] >= 1.0 ? 0 : p->opta[5]);
-
-       p1 = *p;
-       memmove(&p1.Domain[0], &p ->Domain[1], 5*sizeof(cmsUInt32Number));
-       
-       T = LutTable + K0;
-       p1.Table = T;
-  
-       Eval5InputsFloat(Input + 1,  Tmp1, &p1);
-      
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval5InputsFloat(Input + 1,  Tmp2, &p1);
-      
-       for (i=0; i < p -> nOutputs; i++) {
-
-              cmsFloat32Number y0 = Tmp1[i];
-              cmsFloat32Number y1 = Tmp2[i];
-
-              Output[i] = y0 + (y1 - y0) * rest;                   
-       }
-}
-
-
-static
-void Eval7Inputs(register const cmsUInt16Number Input[], 
-                 register cmsUInt16Number Output[], 
-                 register const cmsInterpParams* p16)
-{       
-       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table; 
-       cmsS15Fixed16Number fk;
-       cmsS15Fixed16Number k0, rk;
-       int K0, K1;
-       const cmsUInt16Number* T;
-       cmsUInt32Number i;
-       cmsUInt16Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       
-       fk = _cmsToFixedDomain((cmsS15Fixed16Number) Input[0] * p16 -> Domain[0]);
-       k0 = FIXED_TO_INT(fk);
-       rk = FIXED_REST_TO_INT(fk);
-
-       K0 = p16 -> opta[6] * k0;
-       K1 = p16 -> opta[6] * (k0 + (Input[0] != 0xFFFFU ? 1 : 0));
-
-       p1 = *p16;
-       memmove(&p1.Domain[0], &p16 ->Domain[1], 5*sizeof(cmsUInt32Number));
-       
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval6Inputs(Input + 1, Tmp1, &p1);
-
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval6Inputs(Input + 1, Tmp2, &p1);
-
-       for (i=0; i < p16 -> nOutputs; i++) {
-              Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);
-       }
-}
-
-
-static
-void Eval7InputsFloat(const cmsFloat32Number Input[], 
-                      cmsFloat32Number Output[], 
-                      const cmsInterpParams* p)
-{                             
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-       cmsFloat32Number rest;
-       cmsFloat32Number pk;
-       int k0, K0, K1;
-       const cmsFloat32Number* T;
-       cmsUInt32Number i;
-       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-
-       pk = Input[0] * p->Domain[0];    
-       k0 = _cmsQuickFloor(pk); 
-       rest = pk - (cmsFloat32Number) k0;
-
-       K0 = p -> opta[6] * k0;
-       K1 = K0 + (Input[0] >= 1.0 ? 0 : p->opta[6]);
-
-       p1 = *p;
-       memmove(&p1.Domain[0], &p ->Domain[1], 6*sizeof(cmsUInt32Number));
-       
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval6InputsFloat(Input + 1,  Tmp1, &p1);
-      
-       T = LutTable + K1;
-       p1.Table = T;
-       
-       Eval6InputsFloat(Input + 1,  Tmp2, &p1);
-      
-       
-       for (i=0; i < p -> nOutputs; i++) {
-
-              cmsFloat32Number y0 = Tmp1[i];
-              cmsFloat32Number y1 = Tmp2[i];
-
-              Output[i] = y0 + (y1 - y0) * rest;     
-              
-       }
-}
-
-static
-void Eval8Inputs(register const cmsUInt16Number Input[], 
-                 register cmsUInt16Number Output[], 
-                 register const cmsInterpParams* p16)
-{       
-       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table; 
-       cmsS15Fixed16Number fk;
-       cmsS15Fixed16Number k0, rk;
-       int K0, K1;
-       const cmsUInt16Number* T;
-       cmsUInt32Number i;
-       cmsUInt16Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-       
-       fk = _cmsToFixedDomain((cmsS15Fixed16Number) Input[0] * p16 -> Domain[0]);
-       k0 = FIXED_TO_INT(fk);
-       rk = FIXED_REST_TO_INT(fk);
-
-       K0 = p16 -> opta[7] * k0;
-       K1 = p16 -> opta[7] * (k0 + (Input[0] != 0xFFFFU ? 1 : 0));
-
-       p1 = *p16;
-       memmove(&p1.Domain[0], &p16 ->Domain[1], 7*sizeof(cmsUInt32Number));
-       
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval7Inputs(Input + 1, Tmp1, &p1);
-
-       T = LutTable + K1;
-       p1.Table = T;
-       Eval7Inputs(Input + 1, Tmp2, &p1);
-
-       for (i=0; i < p16 -> nOutputs; i++) {
-              Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);
-       }
-}
-
-
-
-static
-void Eval8InputsFloat(const cmsFloat32Number Input[], 
-                      cmsFloat32Number Output[], 
-                      const cmsInterpParams* p)
-{                             
-       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table; 
-       cmsFloat32Number rest;
-       cmsFloat32Number pk;
-       int k0, K0, K1;
-       const cmsFloat32Number* T;
-       cmsUInt32Number i;
-       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
-       cmsInterpParams p1;
-       
-       pk = Input[0] * p->Domain[0];    
-       k0 = _cmsQuickFloor(pk); 
-       rest = pk - (cmsFloat32Number) k0;
-
-       K0 = p -> opta[7] * k0;
-       K1 = K0 + (Input[0] >= 1.0 ? 0 : p->opta[7]);
-
-       p1 = *p;
-       memmove(&p1.Domain[0], &p ->Domain[1], 7*sizeof(cmsUInt32Number));
-
-       T = LutTable + K0;
-       p1.Table = T;
-
-       Eval7InputsFloat(Input + 1,  Tmp1, &p1);
-      
-       T = LutTable + K1;
-       p1.Table = T;
-
-       Eval7InputsFloat(Input + 1,  Tmp2, &p1);
-      
-
-       for (i=0; i < p -> nOutputs; i++) {
-
-              cmsFloat32Number y0 = Tmp1[i];
-              cmsFloat32Number y1 = Tmp2[i];
-
-              Output[i] = y0 + (y1 - y0) * rest;                   
-       }
-}
-
-// The default factory
-static 
-cmsInterpFunction DefaultInterpolatorsFactory(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags)
-{
-
-    cmsInterpFunction Interpolation;
-    cmsBool  IsFloat     = (dwFlags & CMS_LERP_FLAGS_FLOAT);
-    cmsBool  IsTrilinear = (dwFlags & CMS_LERP_FLAGS_TRILINEAR);
-
-    memset(&Interpolation, 0, sizeof(Interpolation));
-
-    // Safety check
-    if (nInputChannels >= 4 && nOutputChannels >= MAX_STAGE_CHANNELS) 
-        return Interpolation;
-
-    switch (nInputChannels) {
-
-           case 1: // Gray LUT / linear
-
-               if (nOutputChannels == 1) {
-
-                   if (IsFloat) 
-                       Interpolation.LerpFloat = LinLerp1Dfloat;
-                   else
-                       Interpolation.Lerp16 = LinLerp1D;
-
-               }
-               else {
-
-                   if (IsFloat)
-                       Interpolation.LerpFloat = Eval1InputFloat;               
-                   else
-                       Interpolation.Lerp16 = Eval1Input;               
-               }
-               break;
-
-           case 2: // Duotone
-               if (IsFloat) 
-                      Interpolation.LerpFloat =  BilinearInterpFloat;
-               else
-                      Interpolation.Lerp16    =  BilinearInterp16;
-               break;
-
-           case 3:  // RGB et al   
-
-               if (IsTrilinear) {
-
-                   if (IsFloat) 
-                       Interpolation.LerpFloat = TrilinearInterpFloat;
-                   else
-                       Interpolation.Lerp16 = TrilinearInterp16;
-               }
-               else {
-
-                   if (IsFloat) 
-                       Interpolation.LerpFloat = TetrahedralInterpFloat;
-                   else {
-
-                       Interpolation.Lerp16 = TetrahedralInterp16;
-                   }
-               }
-               break;
-
-           case 4:  // CMYK lut             
-
-               if (IsFloat) 
-                   Interpolation.LerpFloat =  Eval4InputsFloat;
-               else
-                   Interpolation.Lerp16    =  Eval4Inputs;
-               break;
-
-           case 5: // 5 Inks
-               if (IsFloat) 
-                   Interpolation.LerpFloat =  Eval5InputsFloat;
-               else
-                   Interpolation.Lerp16    =  Eval5Inputs;
-               break;              
-
-           case 6: // 6 Inks
-               if (IsFloat) 
-                   Interpolation.LerpFloat =  Eval6InputsFloat;
-               else
-                   Interpolation.Lerp16    =  Eval6Inputs;
-               break;
-
-           case 7: // 7 inks
-               if (IsFloat) 
-                   Interpolation.LerpFloat =  Eval7InputsFloat;
-               else
-                   Interpolation.Lerp16    =  Eval7Inputs;
-               break;
-
-           case 8: // 8 inks
-               if (IsFloat) 
-                   Interpolation.LerpFloat =  Eval8InputsFloat;
-               else
-                   Interpolation.Lerp16    =  Eval8Inputs;
-               break;
-
-               break;
-
-           default:
-               Interpolation.Lerp16 = NULL;
-    }
-
-    return Interpolation;
-}
diff --git a/thirdparty/liblcms2/src/cmsio0.c b/thirdparty/liblcms2/src/cmsio0.c
deleted file mode 100644
index 589ea6a..0000000
--- a/thirdparty/liblcms2/src/cmsio0.c
+++ /dev/null
@@ -1,1720 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Generic I/O, tag dictionary management, profile struct
-
-// IOhandlers are abstractions used by littleCMS to read from whatever file, stream,
-// memory block or any storage. Each IOhandler provides implementations for read,
-// write, seek and tell functions. LittleCMS code deals with IO across those objects.
-// In this way, is easier to add support for new storage media.
-
-// NULL stream, for taking care of used space -------------------------------------
-
-// NULL IOhandler basically does nothing but keep track on how many bytes have been
-// written. This is handy when creating profiles, where the file size is needed in the
-// header. Then, whole profile is serialized across NULL IOhandler and a second pass 
-// writes the bytes to the pertinent IOhandler.
-
-typedef struct {        
-    cmsUInt32Number Pointer;         // Points to current location
-} FILENULL;
-
-static
-cmsUInt32Number NULLRead(cmsIOHANDLER* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)
-{   
-    FILENULL* ResData = (FILENULL*) iohandler ->stream;
-    
-    cmsUInt32Number len = size * count;
-    ResData -> Pointer += len;
-    return count;
-
-    cmsUNUSED_PARAMETER(Buffer);
-}
-
-static
-cmsBool  NULLSeek(cmsIOHANDLER* iohandler, cmsUInt32Number offset)
-{
-    FILENULL* ResData = (FILENULL*) iohandler ->stream;
-
-    ResData ->Pointer = offset; 
-    return TRUE; 
-}
-
-static
-cmsUInt32Number NULLTell(cmsIOHANDLER* iohandler)
-{
-    FILENULL* ResData = (FILENULL*) iohandler ->stream;
-    return ResData -> Pointer;     
-}
-
-static
-cmsBool  NULLWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void *Ptr)
-{
-    FILENULL* ResData = (FILENULL*) iohandler ->stream;
-
-    ResData ->Pointer += size;
-    if (ResData ->Pointer > iohandler->UsedSpace)
-        iohandler->UsedSpace = ResData ->Pointer;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(Ptr);
-}
-
-static
-cmsBool  NULLClose(cmsIOHANDLER* iohandler)
-{   
-    FILENULL* ResData = (FILENULL*) iohandler ->stream;
-    
-    _cmsFree(iohandler ->ContextID, ResData);
-    _cmsFree(iohandler ->ContextID, iohandler);
-    return TRUE;
-}
-
-// The NULL IOhandler creator
-cmsIOHANDLER*  CMSEXPORT cmsOpenIOhandlerFromNULL(cmsContext ContextID)
-{
-    struct _cms_io_handler* iohandler = NULL;
-    FILENULL* fm = NULL;
-        
-    iohandler = (struct _cms_io_handler*) _cmsMallocZero(ContextID, sizeof(struct _cms_io_handler));
-    if (iohandler == NULL) return NULL;
-
-    fm = (FILENULL*) _cmsMallocZero(ContextID, sizeof(FILENULL));
-    if (fm == NULL) goto Error;
-    
-    fm ->Pointer = 0;
-
-    iohandler ->ContextID = ContextID;
-    iohandler ->stream  = (void*) fm;   
-    iohandler ->UsedSpace = 0;
-    iohandler ->ReportedSize = 0;
-    iohandler ->PhysicalFile[0] = 0;
-
-    iohandler ->Read    = NULLRead;
-    iohandler ->Seek    = NULLSeek;
-    iohandler ->Close   = NULLClose;
-    iohandler ->Tell    = NULLTell;
-    iohandler ->Write   = NULLWrite;
-
-    return iohandler;
-
-Error:
-    if (fm) _cmsFree(ContextID, fm);
-    if (iohandler) _cmsFree(ContextID, iohandler);
-    return NULL;
-
-}
-
-
-// Memory-based stream --------------------------------------------------------------
-
-// Those functions implements an iohandler which takes a block of memory as storage medium.
-
-typedef struct {
-    cmsUInt8Number* Block;    // Points to allocated memory
-    cmsUInt32Number Size;     // Size of allocated memory
-    cmsUInt32Number Pointer;  // Points to current location
-    int FreeBlockOnClose;     // As title
-
-} FILEMEM;
-
-static
-cmsUInt32Number MemoryRead(struct _cms_io_handler* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)
-{   
-    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
-    cmsUInt8Number* Ptr;
-    cmsUInt32Number len = size * count;
-
-    if (ResData -> Pointer + len > ResData -> Size){
-
-        len = (ResData -> Size - ResData -> Pointer);
-        cmsSignalError(iohandler ->ContextID, cmsERROR_READ, "Read from memory error. Got %d bytes, block should be of %d bytes", len, count * size);
-        return 0;
-    }
-
-    Ptr  = ResData -> Block;
-    Ptr += ResData -> Pointer;
-    memmove(Buffer, Ptr, len);        
-    ResData -> Pointer += len;
-
-    return count;
-}
-
-// SEEK_CUR is assumed
-static
-cmsBool  MemorySeek(struct _cms_io_handler* iohandler, cmsUInt32Number offset)
-{
-    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
-
-    if (offset > ResData ->Size) {
-        cmsSignalError(iohandler ->ContextID, cmsERROR_SEEK,  "Too few data; probably corrupted profile");        
-        return FALSE;
-    }
-
-    ResData ->Pointer = offset; 
-    return TRUE; 
-}
-
-// Tell for memory
-static
-cmsUInt32Number MemoryTell(struct _cms_io_handler* iohandler)
-{
-    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
-
-	if (ResData == NULL) return 0;
-    return ResData -> Pointer;     
-}
-
-
-// Writes data to memory, also keeps used space for further reference. 
-static
-cmsBool  MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)
-{
-    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
-
-	if (ResData == NULL) return FALSE; // Housekeeping
-
-    if (size == 0) return TRUE;     // Write zero bytes is ok, but does nothing
-
-    memmove(ResData ->Block + ResData ->Pointer, Ptr, size);
-    ResData ->Pointer += size;
-
-    if (ResData ->Pointer > iohandler->UsedSpace)
-        iohandler->UsedSpace = ResData ->Pointer;
-
-    
-    iohandler->UsedSpace += size;    
-
-    return TRUE;
-}
-
-
-static
-cmsBool  MemoryClose(struct _cms_io_handler* iohandler)
-{   
-    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
-
-    if (ResData ->FreeBlockOnClose) {
-
-        if (ResData ->Block) _cmsFree(iohandler ->ContextID, ResData ->Block);
-    }
-    
-    _cmsFree(iohandler ->ContextID, ResData);
-    _cmsFree(iohandler ->ContextID, iohandler);
-
-    return TRUE;
-}
-
-// Create a iohandler for memory block. AccessMode=='r' assumes the iohandler is going to read, and makes
-// a copy of the memory block for letting user to free the memory after invoking open profile. In write 
-// mode ("w"), Buffere points to the begin of memory block to be written.
-cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromMem(cmsContext ContextID, void *Buffer, cmsUInt32Number size, const char* AccessMode)
-{
-    cmsIOHANDLER* iohandler = NULL;
-    FILEMEM* fm = NULL;
-
-	_cmsAssert(AccessMode != NULL);
-
-    iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
-    if (iohandler == NULL) return NULL;
-
-    switch (*AccessMode) {
-
-    case 'r':
-        fm = (FILEMEM*) _cmsMallocZero(ContextID, sizeof(FILEMEM));
-        if (fm == NULL) goto Error;
-
-        if (Buffer == NULL) {
-            cmsSignalError(ContextID, cmsERROR_READ, "Couldn't read profile from NULL pointer");
-            goto Error;
-        }
-
-        fm ->Block = (cmsUInt8Number*) _cmsMalloc(ContextID, size);
-        if (fm ->Block == NULL) {
-
-            _cmsFree(ContextID, fm);
-            _cmsFree(ContextID, iohandler);
-            cmsSignalError(ContextID, cmsERROR_READ, "Couldn't allocate %ld bytes for profile", size);
-            return NULL;
-        }
-
-
-        memmove(fm->Block, Buffer, size);
-        fm ->FreeBlockOnClose = TRUE;
-        fm ->Size    = size;
-        fm ->Pointer = 0;
-        iohandler -> ReportedSize = size;
-        break;
-
-    case 'w': 
-        fm = (FILEMEM*) _cmsMallocZero(ContextID, sizeof(FILEMEM));
-        if (fm == NULL) goto Error;
-
-        fm ->Block = (cmsUInt8Number*) Buffer;
-        fm ->FreeBlockOnClose = FALSE;
-        fm ->Size    = size;
-        fm ->Pointer = 0;     
-        iohandler -> ReportedSize = 0;
-        break;
-
-    default:
-        cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown access mode '%c'", *AccessMode);
-        return NULL;
-    }
-
-    iohandler ->ContextID = ContextID;
-    iohandler ->stream  = (void*) fm;   
-    iohandler ->UsedSpace = 0;
-    iohandler ->PhysicalFile[0] = 0;
-
-    iohandler ->Read    = MemoryRead;
-    iohandler ->Seek    = MemorySeek;
-    iohandler ->Close   = MemoryClose;
-    iohandler ->Tell    = MemoryTell;
-    iohandler ->Write   = MemoryWrite;
-
-    return iohandler;
-
-Error:
-    if (fm) _cmsFree(ContextID, fm);
-    if (iohandler) _cmsFree(ContextID, iohandler);
-    return NULL;
-}
-
-// File-based stream -------------------------------------------------------
-
-// Read count elements of size bytes each. Return number of elements read
-static
-cmsUInt32Number FileRead(cmsIOHANDLER* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)
-{
-    cmsUInt32Number nReaded = (cmsUInt32Number) fread(Buffer, size, count, (FILE*) iohandler->stream);
-
-    if (nReaded != count) {
-            cmsSignalError(iohandler ->ContextID, cmsERROR_FILE, "Read error. Got %d bytes, block should be of %d bytes", nReaded * size, count * size);
-            return 0;
-    }
-
-    return nReaded;
-}
-
-// Postion file pointer in the file
-static
-cmsBool  FileSeek(cmsIOHANDLER* iohandler, cmsUInt32Number offset)
-{
-    if (fseek((FILE*) iohandler ->stream, (long) offset, SEEK_SET) != 0) {
-
-       cmsSignalError(iohandler ->ContextID, cmsERROR_FILE, "Seek error; probably corrupted file");
-       return FALSE;
-    }
-
-    return TRUE;
-}
-
-// Returns file pointer position
-static
-cmsUInt32Number FileTell(cmsIOHANDLER* iohandler)
-{       
-    return ftell((FILE*)iohandler ->stream);
-}
-
-// Writes data to stream, also keeps used space for further reference. Returns TRUE on success, FALSE on error
-static
-cmsBool  FileWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void* Buffer)
-{
-       if (size == 0) return TRUE;  // We allow to write 0 bytes, but nothing is written
-
-       iohandler->UsedSpace += size;
-       return (fwrite(Buffer, size, 1, (FILE*) iohandler->stream) == 1);
-}
-
-// Closes the file
-static
-cmsBool  FileClose(cmsIOHANDLER* iohandler)
-{   
-    if (fclose((FILE*) iohandler ->stream) != 0) return FALSE;
-    _cmsFree(iohandler ->ContextID, iohandler);
-    return TRUE;
-}
-
-// Create a iohandler for disk based files. if FileName is NULL, then 'stream' member is also set
-// to NULL and no real writting is performed. This only happens in writting access mode
-cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode)
-{
-    cmsIOHANDLER* iohandler = NULL;
-    FILE* fm = NULL;
-
-    iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
-    if (iohandler == NULL) return NULL;
-
-    switch (*AccessMode) {
-
-    case 'r':
-        fm = fopen(FileName, "rb");
-        if (fm == NULL) {
-            _cmsFree(ContextID, iohandler);
-             cmsSignalError(ContextID, cmsERROR_FILE, "File '%s' not found", FileName);
-            return NULL;
-        }
-        iohandler -> ReportedSize = cmsfilelength(fm);
-        break;
-
-    case 'w':
-        fm = fopen(FileName, "wb");
-        if (fm == NULL) {
-            _cmsFree(ContextID, iohandler);
-             cmsSignalError(ContextID, cmsERROR_FILE, "Couldn't create '%s'", FileName);
-            return NULL;
-        }
-        iohandler -> ReportedSize = 0;
-        break;
-
-    default:
-        _cmsFree(ContextID, iohandler);
-         cmsSignalError(ContextID, cmsERROR_FILE, "Unknown access mode '%c'", *AccessMode);
-        return NULL;
-    }
-
-    iohandler ->ContextID = ContextID;
-    iohandler ->stream = (void*) fm;
-    iohandler ->UsedSpace = 0;
-
-    // Keep track of the original file
-    if (FileName != NULL)  {
-
-        strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);
-        iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;
-    }
-
-    iohandler ->Read    = FileRead;
-    iohandler ->Seek    = FileSeek;
-    iohandler ->Close   = FileClose;
-    iohandler ->Tell    = FileTell;
-    iohandler ->Write   = FileWrite;
-
-    return iohandler;
-}
-
-// Create a iohandler for stream based files 
-cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromStream(cmsContext ContextID, FILE* Stream)
-{
-    cmsIOHANDLER* iohandler = NULL;
-    
-    iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
-    if (iohandler == NULL) return NULL;
-
-    iohandler -> ContextID = ContextID;
-    iohandler -> stream = (void*) Stream;
-    iohandler -> UsedSpace = 0;
-    iohandler -> ReportedSize = cmsfilelength(Stream);
-    iohandler -> PhysicalFile[0] = 0;
-    
-    iohandler ->Read    = FileRead;
-    iohandler ->Seek    = FileSeek;
-    iohandler ->Close   = FileClose;
-    iohandler ->Tell    = FileTell;
-    iohandler ->Write   = FileWrite;
-
-    return iohandler;
-}
-
-
-
-// Close an open IO handler
-cmsBool CMSEXPORT cmsCloseIOhandler(cmsIOHANDLER* io)
-{
-    return io -> Close(io);
-}
-
-// -------------------------------------------------------------------------------------------------------
-
-// Creates an empty structure holding all required parameters
-cmsHPROFILE CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID)
-{
-    time_t now = time(NULL);
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));
-    if (Icc == NULL) return NULL;
-
-    Icc ->ContextID = ContextID;
-
-    // Set it to empty
-    Icc -> TagCount   = 0;
-
-    // Set default version 
-    Icc ->Version =  0x02100000;
-
-    // Set creation date/time
-    memmove(&Icc ->Created, gmtime(&now), sizeof(Icc ->Created));
-
-    // Return the handle
-    return (cmsHPROFILE) Icc;
-}
-
-cmsContext CMSEXPORT cmsGetProfileContextID(cmsHPROFILE hProfile)
-{
-     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-
-    if (Icc == NULL) return NULL;
-    return Icc -> ContextID;
-}
-
-
-// Return the number of tags
-cmsInt32Number CMSEXPORT cmsGetTagCount(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-	if (Icc == NULL) return -1;
-
-    return  Icc->TagCount;
-}
-
-// Return the tag signature of a given tag number
-cmsTagSignature CMSEXPORT cmsGetTagSignature(cmsHPROFILE hProfile, cmsUInt32Number n)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;    
-
-    if (n > Icc->TagCount) return (cmsTagSignature) 0;  // Mark as not available     
-    if (n >= MAX_TABLE_TAG) return (cmsTagSignature) 0; // As double check
-
-    return Icc ->TagNames[n];
-}
-
-
-static
-int SearchOneTag(_cmsICCPROFILE* Profile, cmsTagSignature sig)
-{
-	cmsUInt32Number i;
-
-	for (i=0; i < Profile -> TagCount; i++) {
-
-		if (sig == Profile -> TagNames[i])
-			return i;
-	}
-
-	return -1;
-}
-
-// Search for a specific tag in tag dictionary. Returns position or -1 if tag not found.
-// If followlinks is turned on, then the position of the linked tag is returned
-int _cmsSearchTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, cmsBool lFollowLinks)
-{
-	int n;
-	cmsTagSignature LinkedSig;
-
-	do {
-
-		// Search for given tag in ICC profile directory
-		n = SearchOneTag(Icc, sig);
-		if (n < 0) 
-			return -1;        // Not found
-
-		if (!lFollowLinks) 
-			return n;         // Found, don't follow links
-
-		// Is this a linked tag?
-		LinkedSig = Icc ->TagLinked[n];
-
-		// Yes, follow link
-		if (LinkedSig != (cmsTagSignature) 0) {
-			sig = LinkedSig;
-		}
-
-	} while (LinkedSig != (cmsTagSignature) 0);
-
-	return n;
-}
-
-
-// Create a new tag entry
-
-static
-cmsBool _cmsNewTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, int* NewPos)
-{
-	int i;
-
-	// Search for the tag
-    i = _cmsSearchTag(Icc, sig, FALSE);
-
-    // Now let's do it easy. If the tag has been already written, that's an error
-    if (i >= 0) {
-        cmsSignalError(Icc ->ContextID, cmsERROR_ALREADY_DEFINED, "Tag '%x' already exists", sig);
-        return FALSE;
-    }
-    else  {
-
-        // New one
-        
-        if (Icc -> TagCount >= MAX_TABLE_TAG) {
-            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", MAX_TABLE_TAG);
-            return FALSE;
-        }
-
-		*NewPos = Icc ->TagCount;
-        Icc -> TagCount++;
-    }
-
-	return TRUE;
-}
-
-
-// Check existance
-cmsBool CMSEXPORT cmsIsTag(cmsHPROFILE hProfile, cmsTagSignature sig)
-{
-       _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) (void*) hProfile;
-       return _cmsSearchTag(Icc, sig, FALSE) >= 0;
-}
-
-
-// Read profile header and validate it
-cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)
-{
-    cmsTagEntry Tag;
-    cmsICCHeader Header;
-    cmsUInt32Number i, j;
-    cmsUInt32Number HeaderSize;
-    cmsIOHANDLER* io = Icc ->IOhandler;
-    cmsUInt32Number TagCount;
-
-
-    // Read the header
-    if (io -> Read(io, &Header, sizeof(cmsICCHeader), 1) != 1) {        
-        return FALSE; 
-    }
-
-    // Validate file as an ICC profile
-    if (_cmsAdjustEndianess32(Header.magic) != cmsMagicNumber) {
-        cmsSignalError(Icc ->ContextID, cmsERROR_BAD_SIGNATURE, "not an ICC profile, invalid signature");
-        return FALSE; 
-    }
-
-    // Adjust endianess of the used parameters
-    Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);
-    Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);
-    Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);
-    Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);
-    Icc -> flags           = _cmsAdjustEndianess32(Header.flags);
-    Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);
-    Icc -> model           = _cmsAdjustEndianess32(Header.model);
-    _cmsAdjustEndianess64(&Icc -> attributes, Header.attributes);
-    Icc -> Version         = _cmsAdjustEndianess32(Header.version);
-
-    // Get size as reported in header
-    HeaderSize = _cmsAdjustEndianess32(Header.size);
-
-    // Make sure HeaderSize is lower than profile size
-    if (HeaderSize >= Icc ->IOhandler ->ReportedSize)
-            HeaderSize = Icc ->IOhandler ->ReportedSize;
-
-   
-    // Get creation date/time
-    _cmsDecodeDateTimeNumber(&Header.date, &Icc ->Created);
-
-    // The profile ID are 32 raw bytes
-    memmove(Icc ->ProfileID.ID32, Header.profileID.ID32, 16);
-
-
-    // Read tag directory
-    if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;                          
-    if (TagCount > MAX_TABLE_TAG) {
-
-        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", TagCount);
-        return FALSE;
-    }
-
-
-    // Read tag directory
-    Icc -> TagCount = 0;
-    for (i=0; i < TagCount; i++) {
-
-        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *) &Tag.sig)) return FALSE;
-        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;
-        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;
-
-        // Perform some sanity check. Offset + size should fall inside file.
-        if (Tag.offset + Tag.size > HeaderSize ||
-            Tag.offset + Tag.size < Tag.offset)       
-                  continue;
-
-        Icc -> TagNames[Icc ->TagCount]   = Tag.sig;
-        Icc -> TagOffsets[Icc ->TagCount] = Tag.offset;
-        Icc -> TagSizes[Icc ->TagCount]   = Tag.size;
-
-       // Search for links
-        for (j=0; j < Icc ->TagCount; j++) {
-
-            if ((Icc ->TagOffsets[j] == Tag.offset) &&
-                (Icc ->TagSizes[j]   == Tag.size)) {
-
-                Icc ->TagLinked[Icc ->TagCount] = Icc ->TagNames[j];   
-            }
-
-        }
-
-        Icc ->TagCount++;
-    }
-  
-    return TRUE;
-}
-
-// Saves profile header
-cmsBool _cmsWriteHeader(_cmsICCPROFILE* Icc, cmsUInt32Number UsedSpace)
-{
-    cmsICCHeader Header;    
-    cmsUInt32Number i;
-    cmsTagEntry Tag;       
-    cmsInt32Number Count = 0;
-
-    Header.size        = _cmsAdjustEndianess32(UsedSpace);
-    Header.cmmId       = _cmsAdjustEndianess32(lcmsSignature);
-    Header.version     = _cmsAdjustEndianess32(Icc ->Version);
-
-    Header.deviceClass = (cmsProfileClassSignature) _cmsAdjustEndianess32(Icc -> DeviceClass);
-    Header.colorSpace  = (cmsColorSpaceSignature) _cmsAdjustEndianess32(Icc -> ColorSpace);
-    Header.pcs         = (cmsColorSpaceSignature) _cmsAdjustEndianess32(Icc -> PCS);
-
-    //   NOTE: in v4 Timestamp must be in UTC rather than in local time
-    _cmsEncodeDateTimeNumber(&Header.date, &Icc ->Created);
-
-    Header.magic       = _cmsAdjustEndianess32(cmsMagicNumber);
-
-#ifdef CMS_IS_WINDOWS_
-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMicrosoft);  
-#else
-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMacintosh);  
-#endif
-
-    Header.flags        = _cmsAdjustEndianess32(Icc -> flags);
-    Header.manufacturer = _cmsAdjustEndianess32(Icc -> manufacturer);
-    Header.model        = _cmsAdjustEndianess32(Icc -> model);
-
-    _cmsAdjustEndianess64(&Header.attributes, Icc -> attributes);              
-    
-    // Rendering intent in the header (for embedded profiles)
-    Header.renderingIntent = _cmsAdjustEndianess32(Icc -> RenderingIntent);
-
-    // Illuminant is always D50
-    Header.illuminant.X = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(cmsD50_XYZ()->X));
-    Header.illuminant.Y = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(cmsD50_XYZ()->Y));
-    Header.illuminant.Z = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(cmsD50_XYZ()->Z));
-
-    // Created by LittleCMS (that's me!)
-    Header.creator      = _cmsAdjustEndianess32(lcmsSignature);
-
-    memset(&Header.reserved, 0, sizeof(Header.reserved));
-
-    // Set profile ID. Endianess is always big endian   
-    memmove(&Header.profileID, &Icc ->ProfileID, 16);
-
-    // Dump the header
-    if (!Icc -> IOhandler->Write(Icc->IOhandler, sizeof(cmsICCHeader), &Header)) return FALSE;
-
-    // Saves Tag directory
-
-    // Get true count
-    for (i=0;  i < Icc -> TagCount; i++) {
-        if (Icc ->TagNames[i] != 0)
-            Count++;
-    }
-
-    // Store number of tags
-    if (!_cmsWriteUInt32Number(Icc ->IOhandler, Count)) return FALSE;   
-
-    for (i=0; i < Icc -> TagCount; i++) {
-
-        if (Icc ->TagNames[i] == 0) continue;   // It is just a placeholder
-
-        Tag.sig    = (cmsTagSignature) _cmsAdjustEndianess32((cmsInt32Number) Icc -> TagNames[i]);
-        Tag.offset = _cmsAdjustEndianess32((cmsInt32Number) Icc -> TagOffsets[i]);
-        Tag.size   = _cmsAdjustEndianess32((cmsInt32Number) Icc -> TagSizes[i]);
-
-        if (!Icc ->IOhandler -> Write(Icc-> IOhandler, sizeof(cmsTagEntry), &Tag)) return FALSE;
-    }
-
-    return TRUE;
-}
-
-// ----------------------------------------------------------------------- Set/Get several struct members
-
-
-cmsUInt32Number CMSEXPORT cmsGetHeaderRenderingIntent(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return Icc -> RenderingIntent;
-}
-
-void CMSEXPORT cmsSetHeaderRenderingIntent(cmsHPROFILE hProfile, cmsUInt32Number RenderingIntent)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> RenderingIntent = RenderingIntent;
-}
-
-cmsUInt32Number CMSEXPORT cmsGetHeaderFlags(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc -> flags;
-}
-
-void CMSEXPORT cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> flags = (cmsUInt32Number) Flags;
-}
-
-cmsUInt32Number CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->manufacturer;
-}
-
-void CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> manufacturer = (cmsUInt32Number) manufacturer;
-}
-
-cmsUInt32Number CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->model;
-}
-
-void CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> manufacturer = (cmsUInt32Number) model;
-}
-
-
-void CMSEXPORT cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    memmove(Flags, &Icc -> attributes, sizeof(cmsUInt64Number));
-}
-
-void CMSEXPORT cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    memmove(&Icc -> attributes, &Flags, sizeof(cmsUInt64Number));
-}
-
-void CMSEXPORT cmsGetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;    
-    memmove(ProfileID, Icc ->ProfileID.ID8, 16);    
-}
-
-void CMSEXPORT cmsSetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    memmove(&Icc -> ProfileID, ProfileID, 16);
-}
-
-cmsBool  CMSEXPORT cmsGetHeaderCreationDateTime(cmsHPROFILE hProfile, struct tm *Dest)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;    
-    memmove(Dest, &Icc ->Created, sizeof(struct tm));    
-    return TRUE;
-}
-
-cmsColorSpaceSignature CMSEXPORT cmsGetPCS(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return Icc -> PCS;
-}
-
-void CMSEXPORT cmsSetPCS(cmsHPROFILE hProfile, cmsColorSpaceSignature pcs)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> PCS = pcs;
-}
-
-cmsColorSpaceSignature CMSEXPORT cmsGetColorSpace(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return Icc -> ColorSpace;
-}
-
-void CMSEXPORT cmsSetColorSpace(cmsHPROFILE hProfile, cmsColorSpaceSignature sig)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> ColorSpace = sig;
-}
-
-cmsProfileClassSignature CMSEXPORT cmsGetDeviceClass(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return Icc -> DeviceClass;
-}
-
-void CMSEXPORT cmsSetDeviceClass(cmsHPROFILE hProfile, cmsProfileClassSignature sig)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> DeviceClass = sig;
-}
-
-cmsUInt32Number CMSEXPORT cmsGetEncodedICCversion(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return Icc -> Version;
-}
-
-void CMSEXPORT cmsSetEncodedICCversion(cmsHPROFILE hProfile, cmsUInt32Number Version)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> Version = Version;
-}
-
-// Get an hexadecimal number with same digits as v
-static
-cmsUInt32Number BaseToBase(cmsUInt32Number in, int BaseIn, int BaseOut)
-{
-    char Buff[100];
-    int i, len;
-    cmsUInt32Number out;
-    
-    for (len=0; in > 0 && len < 100; len++) {
-    
-        Buff[len] = (char) (in % BaseIn);
-        in /= BaseIn;
-    }
-
-    for (i=len-1, out=0; i >= 0; --i) {
-        out = out * BaseOut + Buff[i];
-    }
-
-    return out;
-}
-
-void  CMSEXPORT cmsSetProfileVersion(cmsHPROFILE hProfile, cmsFloat64Number Version)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-
-    // 4.2 -> 0x4200000
-
-    Icc -> Version = BaseToBase((cmsUInt32Number) floor(Version * 100.0), 10, 16) << 16;
-}
-
-cmsFloat64Number CMSEXPORT cmsGetProfileVersion(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    cmsUInt32Number n = Icc -> Version >> 16;
-
-    return BaseToBase(n, 16, 10) / 100.0;
-}
-// --------------------------------------------------------------------------------------------------------------
-
-
-// Create profile from IOhandler
-cmsHPROFILE CMSEXPORT cmsOpenProfileFromIOhandlerTHR(cmsContext ContextID, cmsIOHANDLER* io)
-{
-    _cmsICCPROFILE* NewIcc;
-    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);
-
-    if (hEmpty == NULL) return NULL;
-
-    NewIcc = (_cmsICCPROFILE*) hEmpty;
-
-    NewIcc ->IOhandler = io;
-    if (!_cmsReadHeader(NewIcc)) goto Error;    
-    return hEmpty;
-
-Error:
-    cmsCloseProfile(hEmpty);
-    return NULL;
-}
-
-// Create profile from disk file
-cmsHPROFILE CMSEXPORT cmsOpenProfileFromFileTHR(cmsContext ContextID, const char *lpFileName, const char *sAccess)
-{
-    _cmsICCPROFILE* NewIcc;
-    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);
-
-    if (hEmpty == NULL) return NULL;
-
-    NewIcc = (_cmsICCPROFILE*) hEmpty;
-
-    NewIcc ->IOhandler = cmsOpenIOhandlerFromFile(ContextID, lpFileName, sAccess);
-    if (NewIcc ->IOhandler == NULL) goto Error;
-
-    if (*sAccess == 'W' || *sAccess == 'w') {
-
-        NewIcc -> IsWrite = TRUE;
-        
-        return hEmpty;
-    }
-
-    if (!_cmsReadHeader(NewIcc)) goto Error;
-    return hEmpty;
-
-Error:
-    cmsCloseProfile(hEmpty);
-    return NULL;
-}
-
-
-cmsHPROFILE CMSEXPORT cmsOpenProfileFromFile(const char *ICCProfile, const char *sAccess)
-{
-    return cmsOpenProfileFromFileTHR(NULL, ICCProfile, sAccess);
-}
-
-
-cmsHPROFILE  CMSEXPORT cmsOpenProfileFromStreamTHR(cmsContext ContextID, FILE* ICCProfile, const char *sAccess)
-{
-    _cmsICCPROFILE* NewIcc;
-    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);
-
-    if (hEmpty == NULL) return NULL;
-
-    NewIcc = (_cmsICCPROFILE*) hEmpty;
-
-    NewIcc ->IOhandler = cmsOpenIOhandlerFromStream(ContextID, ICCProfile);
-    if (NewIcc ->IOhandler == NULL) goto Error;
-
-    if (*sAccess == 'w') {
-
-        NewIcc -> IsWrite = TRUE;       
-        return hEmpty;
-    }
-
-    if (!_cmsReadHeader(NewIcc)) goto Error;    
-    return hEmpty;
-
-Error:
-    cmsCloseProfile(hEmpty);
-    return NULL;
-
-}
-
-cmsHPROFILE  CMSEXPORT cmsOpenProfileFromStream(FILE* ICCProfile, const char *sAccess)
-{
-    return cmsOpenProfileFromStreamTHR(NULL, ICCProfile, sAccess);
-}
-
-
-// Open from memory block
-cmsHPROFILE CMSEXPORT cmsOpenProfileFromMemTHR(cmsContext ContextID, const void* MemPtr, cmsUInt32Number dwSize)
-{
-    _cmsICCPROFILE* NewIcc;
-    cmsHPROFILE hEmpty;
-
-    hEmpty = cmsCreateProfilePlaceholder(ContextID);
-    if (hEmpty == NULL) return NULL;
-
-    NewIcc = (_cmsICCPROFILE*) hEmpty;
-
-	// Ok, in this case const void* is casted to void* just because open IO handler 
-	// shares read and writting modes. Don't abuse this feature!
-    NewIcc ->IOhandler = cmsOpenIOhandlerFromMem(ContextID, (void*) MemPtr, dwSize, "r");
-    if (NewIcc ->IOhandler == NULL) goto Error;
-
-    if (!_cmsReadHeader(NewIcc)) goto Error;
-
-    return hEmpty;
-
-Error:
-    cmsCloseProfile(hEmpty);
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsOpenProfileFromMem(const void* MemPtr, cmsUInt32Number dwSize)
-{
-    return cmsOpenProfileFromMemTHR(NULL, MemPtr, dwSize);
-}
-
-
-
-// Dump tag contents. If the profile is being modified, untouched tags are copied from FileOrig
-static
-cmsBool SaveTags(_cmsICCPROFILE* Icc, _cmsICCPROFILE* FileOrig)
-{
-    cmsUInt8Number* Data;
-    cmsUInt32Number i;
-    cmsUInt32Number Begin;
-    cmsIOHANDLER* io = Icc ->IOhandler;
-    cmsTagDescriptor* TagDescriptor;
-    cmsTagTypeSignature TypeBase;
-    cmsTagTypeHandler* TypeHandler;
-
-
-    for (i=0; i < Icc -> TagCount; i++) {
-
-       
-        if (Icc ->TagNames[i] == 0) continue;
-
-        // Linked tags are not written
-        if (Icc ->TagLinked[i] != (cmsTagSignature) 0) continue;
-
-        Icc -> TagOffsets[i] = Begin = io ->UsedSpace;
-
-        Data = (cmsUInt8Number*)  Icc -> TagPtrs[i];
-
-        if (!Data) {
-
-            // Reach here if we are copying a tag from a disk-based ICC profile which has not been modified by user. 
-            // In this case a blind copy of the block data is performed
-            if (FileOrig != NULL && Icc -> TagOffsets[i]) {
-
-                cmsUInt32Number TagSize   = FileOrig -> TagSizes[i];
-                cmsUInt32Number TagOffset = FileOrig -> TagOffsets[i];
-                void* Mem;
-
-                if (!FileOrig ->IOhandler->Seek(FileOrig ->IOhandler, TagOffset)) return FALSE;
-
-                Mem = _cmsMalloc(Icc ->ContextID, TagSize);                  
-                if (Mem == NULL) return FALSE;
-
-                if (FileOrig ->IOhandler->Read(FileOrig->IOhandler, Mem, TagSize, 1) != 1) return FALSE;
-                if (!io ->Write(io, TagSize, Mem)) return FALSE;
-                _cmsFree(Icc ->ContextID, Mem);
-
-                Icc -> TagSizes[i] = (io ->UsedSpace - Begin);
-                
-
-                // Align to 32 bit boundary.
-                if (! _cmsWriteAlignment(io)) 
-                    return FALSE;                   
-            }
-
-            continue;
-        }
-
-
-        // Should this tag be saved as RAW? If so, tagsizes should be specified in advance (no further cooking is done)
-        if (Icc ->TagSaveAsRaw[i]) {
-
-            if (io -> Write(io, Icc ->TagSizes[i], Data) != 1) return FALSE;
-        }
-        else {
-
-            // Search for support on this tag
-            TagDescriptor = _cmsGetTagDescriptor(Icc -> TagNames[i]);
-            if (TagDescriptor == NULL) continue;                        // Unsupported, ignore it
-
-            TypeHandler = Icc ->TagTypeHandlers[i];
-
-            if (TypeHandler == NULL) {
-                cmsSignalError(Icc ->ContextID, cmsERROR_INTERNAL, "(Internal) no handler for tag %x", Icc -> TagNames[i]);
-                continue;
-            }
-
-            TypeBase    = TypeHandler ->Signature;
-            if (!_cmsWriteTypeBase(io, TypeBase)) 
-                return FALSE;
-
-            TypeHandler ->ContextID  = Icc ->ContextID;
-            TypeHandler ->ICCVersion = Icc ->Version;
-            if (!TypeHandler ->WritePtr(TypeHandler, io, Data, TagDescriptor ->ElemCount)) {
-
-				char String[5];
-
-				 _cmsTagSignature2String(String, (cmsTagSignature) TypeBase);
-                cmsSignalError(Icc ->ContextID, cmsERROR_WRITE, "Couldn't write type '%s'", String);
-                return FALSE;   
-            }
-        }
-
-
-        Icc -> TagSizes[i] = (io ->UsedSpace - Begin);      
-
-        // Align to 32 bit boundary.
-        if (! _cmsWriteAlignment(io)) 
-            return FALSE;                   
-    }
-
-
-    return TRUE;
-}
-
-
-// Fill the offset and size fields for all linked tags
-static
-cmsBool SetLinks( _cmsICCPROFILE* Icc)
-{
-    cmsUInt32Number i;
-
-    for (i=0; i < Icc -> TagCount; i++) {
-
-        cmsTagSignature lnk = Icc ->TagLinked[i];
-        if (lnk != (cmsTagSignature) 0) {
-
-            int j = _cmsSearchTag(Icc, lnk, FALSE);
-            if (j >= 0) {
-
-                Icc ->TagOffsets[i] = Icc ->TagOffsets[j];
-                Icc ->TagSizes[i]   = Icc ->TagSizes[j];
-            }
-
-        }
-    }
-
-    return TRUE;
-}
-
-// Low-level save to IOHANDLER. It returns the number of bytes used to
-// store the profile, or zero on error. io may be NULL and in this case
-// no data is written--only sizes are calculated
-cmsUInt32Number CMSEXPORT cmsSaveProfileToIOhandler(cmsHPROFILE hProfile, cmsIOHANDLER* io)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
-    _cmsICCPROFILE Keep;              
-    cmsIOHANDLER* PrevIO;
-    cmsUInt32Number UsedSpace;
-    cmsContext ContextID;
-
-    memmove(&Keep, Icc, sizeof(_cmsICCPROFILE));
-
-    ContextID = cmsGetProfileContextID(hProfile);
-    PrevIO = Icc ->IOhandler = cmsOpenIOhandlerFromNULL(ContextID);
-    if (PrevIO == NULL) return 0;
-
-    // Pass #1 does compute offsets
-
-    if (!_cmsWriteHeader(Icc, 0)) return 0;
-    if (!SaveTags(Icc, &Keep)) return 0;
-
-    UsedSpace = PrevIO ->UsedSpace;
-
-    // Pass #2 does save to iohandler
-
-    if (io != NULL) {
-        Icc ->IOhandler = io;     
-        if (!SetLinks(Icc)) goto CleanUp;
-        if (!_cmsWriteHeader(Icc, UsedSpace)) goto CleanUp;
-        if (!SaveTags(Icc, &Keep)) goto CleanUp;
-    }
-
-    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
-    if (!cmsCloseIOhandler(PrevIO)) return 0;
-
-    return UsedSpace;
-
-
-CleanUp:     
-    cmsCloseIOhandler(PrevIO);      
-    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
-    return 0;
-}
-
-
-// Low-level save to disk. 
-cmsBool  CMSEXPORT cmsSaveProfileToFile(cmsHPROFILE hProfile, const char* FileName)
-{   
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    cmsIOHANDLER* io = cmsOpenIOhandlerFromFile(ContextID, FileName, "w");
-    cmsBool rc;
-    
-    if (io == NULL) return FALSE;
-
-    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);
-    rc &= cmsCloseIOhandler(io);
-
-    if (rc == FALSE) {          // remove() is C99 per 7.19.4.1
-            remove(FileName);   // We have to IGNORE return value in this case
-    }
-    return rc;
-}
-
-// Same as anterior, but for streams
-cmsBool CMSEXPORT cmsSaveProfileToStream(cmsHPROFILE hProfile, FILE* Stream)
-{
-    cmsBool rc;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    cmsIOHANDLER* io = cmsOpenIOhandlerFromStream(ContextID, Stream);
-    
-    if (io == NULL) return FALSE;
-
-    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);
-    rc &= cmsCloseIOhandler(io);
-
-    return rc;
-}
-
-
-// Same as anterior, but for memory blocks. In this case, a NULL as MemPtr means calculate needed space only
-cmsBool CMSEXPORT cmsSaveProfileToMem(cmsHPROFILE hProfile, void *MemPtr, cmsUInt32Number* BytesNeeded)
-{
-    cmsBool rc;
-    cmsIOHANDLER* io;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    
-    // Should we just calculate the needed space?
-    if (MemPtr == NULL) {   
-
-           *BytesNeeded =  cmsSaveProfileToIOhandler(hProfile, NULL);
-            return TRUE;
-    }
-
-    // That is a real write operation
-    io =  cmsOpenIOhandlerFromMem(ContextID, MemPtr, *BytesNeeded, "w");
-    if (io == NULL) return FALSE;
-
-    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);
-    rc &= cmsCloseIOhandler(io);
-
-    return rc;
-}
-
-
-
-// Closes a profile freeing any involved resources
-cmsBool  CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
-    cmsBool  rc = TRUE;
-    cmsUInt32Number i;         
-
-    if (!Icc) return FALSE;
-
-    // Was open in write mode?   
-    if (Icc ->IsWrite) {
-
-        Icc ->IsWrite = FALSE;      // Assure no further writting
-        rc &= cmsSaveProfileToFile(hProfile, Icc ->IOhandler->PhysicalFile);        
-    }
-
-    for (i=0; i < Icc -> TagCount; i++) {
-
-        if (Icc -> TagPtrs[i]) {
-
-            cmsTagTypeHandler* TypeHandler = Icc ->TagTypeHandlers[i];
-
-            if (TypeHandler != NULL) {
-
-                TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameters
-                TypeHandler ->ICCVersion = Icc ->Version;
-                TypeHandler ->FreePtr(TypeHandler, Icc -> TagPtrs[i]);       
-            }
-            else
-                _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);
-        }
-    }
-
-    if (Icc ->IOhandler != NULL) {      
-        rc &= cmsCloseIOhandler(Icc->IOhandler);   
-    }       
-
-    _cmsFree(Icc ->ContextID, Icc);   // Free placeholder memory
-
-    return rc;
-}
-
-
-// -------------------------------------------------------------------------------------------------------------------
-
-
-// Returns TRUE if a given tag is supported by a plug-in
-static
-cmsBool IsTypeSupported(cmsTagDescriptor* TagDescriptor, cmsTagTypeSignature Type)
-{
-    cmsUInt32Number i, nMaxTypes;
-
-    nMaxTypes = TagDescriptor->nSupportedTypes;
-    if (nMaxTypes >= MAX_TYPES_IN_LCMS_PLUGIN)
-        nMaxTypes = MAX_TYPES_IN_LCMS_PLUGIN;
-    
-    for (i=0; i < nMaxTypes; i++) {
-        if (Type == TagDescriptor ->SupportedTypes[i]) return TRUE; 
-    }
-
-    return FALSE;
-}
-
-
-// That's the main read function
-void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile; 
-    cmsIOHANDLER* io = Icc ->IOhandler;
-    cmsTagTypeHandler* TypeHandler;
-    cmsTagDescriptor*  TagDescriptor;
-    cmsTagTypeSignature BaseType;
-    cmsUInt32Number Offset, TagSize;
-    cmsUInt32Number ElemCount;
-    int n;
-
-	n = _cmsSearchTag(Icc, sig, TRUE);
-	if (n < 0) return NULL;                 // Not found, return NULL
-
-
-
-	// If the element is already in memory, return the pointer
-	if (Icc -> TagPtrs[n]) {
-
-		if (Icc ->TagSaveAsRaw[n]) return NULL;  // We don't support read raw tags as cooked
-		return Icc -> TagPtrs[n];
-	}
-
-	// We need to read it. Get the offset and size to the file
-    Offset    = Icc -> TagOffsets[n];
-    TagSize   = Icc -> TagSizes[n]; 
-    
-    // Seek to its location
-    if (!io -> Seek(io, Offset))
-            return NULL;
-
-    // Search for support on this tag
-    TagDescriptor = _cmsGetTagDescriptor(sig);
-    if (TagDescriptor == NULL) return NULL;     // Unsupported. 
-
-    // if supported, get type and check if in list
-    BaseType = _cmsReadTypeBase(io);
-    if (BaseType == 0) return NULL;
-
-    if (!IsTypeSupported(TagDescriptor, BaseType)) return NULL;
-
-    TagSize  -= 8;                      // Alredy read by the type base logic
-
-    // Get type handler
-    TypeHandler = _cmsGetTagTypeHandler(BaseType);
-    if (TypeHandler == NULL) return NULL;
-
-
-    // Read the tag
-    Icc -> TagTypeHandlers[n] = TypeHandler;
-
-    TypeHandler ->ContextID = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc -> TagPtrs[n] = TypeHandler ->ReadPtr(TypeHandler, io, &ElemCount, TagSize);
-
-    // The tag type is supported, but something wrong happend and we cannot read the tag.
-    // let know the user about this (although it is just a warning)
-    if (Icc -> TagPtrs[n] == NULL) {
-
-        char String[5];
-
-        _cmsTagSignature2String(String, sig);
-        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Corrupted tag '%s'", String);
-        return NULL;
-    }
-
-    // This is a weird error that may be a symptom of something more serious, the number of
-    // stored item is actually less than the number of required elements. 
-    if (ElemCount < TagDescriptor ->ElemCount) {
-
-        char String[5];
-
-        _cmsTagSignature2String(String, sig);
-        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "'%s' Inconsistent number of items: expected %d, got %d", 
-                                                             String, TagDescriptor ->ElemCount, ElemCount);
-    }
-
-    
-    // Return the data
-    return Icc -> TagPtrs[n];
-}
-
-
-// Get true type of data
-cmsTagTypeSignature _cmsGetTagTrueType(cmsHPROFILE hProfile, cmsTagSignature sig)
-{
-	_cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile; 
-	cmsTagTypeHandler* TypeHandler;	
-	int n;
-
-	// Search for given tag in ICC profile directory
-	n = _cmsSearchTag(Icc, sig, TRUE);
-	if (n < 0) return (cmsTagTypeSignature) 0;                // Not found, return NULL
-
-	// Get the handler. The true type is there
-	TypeHandler =  Icc -> TagTypeHandlers[n];
-	return TypeHandler ->Signature;
-}
-
-
-// Write a single tag. This just keeps track of the tak into a list of "to be written". If the tag is already
-// in that list, the previous version is deleted.
-cmsBool CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-    cmsTagTypeHandler* TypeHandler = NULL;
-    cmsTagDescriptor* TagDescriptor = NULL;
-    cmsTagTypeSignature Type;
-    int i;
-    cmsFloat64Number Version;
-    char TypeString[5], SigString[5];
-
-
-    if (data == NULL) {
-
-         cmsSignalError(cmsGetProfileContextID(hProfile), cmsERROR_NULL, "couldn't wite NULL to tag");
-         return FALSE;
-    }
-
-    i = _cmsSearchTag(Icc, sig, FALSE);
-    if (i >=0) {
-
-        if (Icc -> TagPtrs[i] != NULL) {
-
-            // Already exists. Free previous version
-            if (Icc ->TagSaveAsRaw[i]) {
-                _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);
-            }
-            else {
-                TypeHandler = Icc ->TagTypeHandlers[i];
-
-                if (TypeHandler != NULL) {
-
-                    TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameter
-                    TypeHandler ->ICCVersion = Icc ->Version;
-                TypeHandler->FreePtr(TypeHandler, Icc -> TagPtrs[i]);       
-            }
-        }
-    }
-    }
-    else  {
-        // New one
-        i = Icc -> TagCount;
-
-        if (i >= MAX_TABLE_TAG) {
-            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", MAX_TABLE_TAG);
-            return FALSE;
-        }
-
-        Icc -> TagCount++;
-    }
-
-    // This is not raw
-    Icc ->TagSaveAsRaw[i] = FALSE;
-
-    // This is not a link
-    Icc ->TagLinked[i] = (cmsTagSignature) 0;
-
-    // Get information about the TAG. 
-    TagDescriptor = _cmsGetTagDescriptor(sig);
-    if (TagDescriptor == NULL){
-         cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported tag '%x'", sig);
-        return FALSE;
-    }
-
-    
-    // Now we need to know which type to use. It depends on the version. 
-    Version = cmsGetProfileVersion(hProfile);
-
-    if (TagDescriptor ->DecideType != NULL) {
-
-        // Let the tag descriptor to decide the type base on depending on
-        // the data. This is useful for example on parametric curves, where 
-        // curves specified by a table cannot be saved as parametric and needs
-        // to be revented to single v2-curves, even on v4 profiles.
-
-        Type = TagDescriptor ->DecideType(Version, data);
-    }
-    else {
-
-
-        Type = TagDescriptor ->SupportedTypes[0];
-    }
-
-    // Does the tag support this type?
-    if (!IsTypeSupported(TagDescriptor, Type)) {
-               
-        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
-        _cmsTagSignature2String(SigString,  sig);
-
-        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported type '%s' for tag '%s'", TypeString, SigString);
-        return FALSE;
-    }
-
-    // Does we have a handler for this type?
-    TypeHandler =  _cmsGetTagTypeHandler(Type);
-    if (TypeHandler == NULL) {
-
-        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
-        _cmsTagSignature2String(SigString,  sig);
-
-        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported type '%s' for tag '%s'", TypeString, SigString);
-        return FALSE;           // Should never happen
-    }
-
-
-    // Fill fields on icc structure
-    Icc ->TagTypeHandlers[i]  = TypeHandler;
-    Icc ->TagNames[i]         = sig;
-    Icc ->TagSizes[i]         = 0;
-    Icc ->TagOffsets[i]       = 0;
-
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc ->TagPtrs[i]          = TypeHandler ->DupPtr(TypeHandler, data, TagDescriptor ->ElemCount); 
-
-    if (Icc ->TagPtrs[i] == NULL)  {
-
-        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);
-        _cmsTagSignature2String(SigString,  sig);
-        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "Malformed struct in type '%s' for tag '%s'", TypeString, SigString);
-        
-        return FALSE;
-    }
-    
-    return TRUE;
-}
-
-// Read and write raw data. The only way those function would work and keep consistence with normal read and write 
-// is to do an additional step of serialization. That means, readRaw would issue a normal read and then convert the obtained
-// data to raw bytes by using the "write" serialization logic. And vice-versa. I know this may end in situations where
-// raw data written does not exactly correspond with the raw data proposed to cmsWriteRaw data, but this approach allows
-// to write a tag as raw data and the read it as handled.
-
-cmsInt32Number CMSEXPORT cmsReadRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, void* data, cmsUInt32Number BufferSize)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-    void *Object; 
-    int i;
-    cmsIOHANDLER* MemIO;
-    cmsTagTypeHandler* TypeHandler = NULL;
-    cmsTagDescriptor* TagDescriptor = NULL;
-    cmsUInt32Number rc;
-    cmsUInt32Number Offset, TagSize;
-
-	// Search for given tag in ICC profile directory
-	i = _cmsSearchTag(Icc, sig, TRUE);
-	if (i < 0) return 0;                 // Not found, return 0
-
-	// It is already read?
-    if (Icc -> TagPtrs[i] == NULL) {
-
-        // No yet, get original position
-        Offset   = Icc ->TagOffsets[i];
-        TagSize  = Icc ->TagSizes[i];
-
-        
-        // read the data directly, don't keep copy
-		if (data != NULL) {
-
-			if (BufferSize < TagSize)
-                 TagSize = BufferSize;
-
-            if (!Icc ->IOhandler ->Seek(Icc ->IOhandler, Offset)) return 0;
-            if (!Icc ->IOhandler ->Read(Icc ->IOhandler, data, 1, TagSize)) return 0;
-		}
-
-        return Icc ->TagSizes[i];
-    }
-
-    // The data has been already read, or written. But wait!, maybe the user choosed to save as
-    // raw data. In this case, return the raw data directly
-    if (Icc ->TagSaveAsRaw[i]) {
-               
-		if (data != NULL)  {
-
-			 TagSize  = Icc ->TagSizes[i];
-			if (BufferSize < TagSize)
-                       TagSize = BufferSize;
-
-            memmove(data, Icc ->TagPtrs[i], TagSize);
-		}
-
-        return Icc ->TagSizes[i];
-    }
-
-    // Already readed, or previously set by cmsWriteTag(). We need to serialize that 
-    // data to raw in order to maintain consistency.
-    Object = cmsReadTag(hProfile, sig);
-    if (Object == NULL) return 0;
-
-    // Now we need to serialize to a memory block: just use a memory iohandler
-
-	if (data == NULL) {
-		  MemIO = cmsOpenIOhandlerFromNULL(cmsGetProfileContextID(hProfile));
-	} else{
-          MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, "w");
-	}
-    if (MemIO == NULL) return 0;
-
-    // Obtain type handling for the tag
-    TypeHandler = Icc ->TagTypeHandlers[i];
-    TagDescriptor = _cmsGetTagDescriptor(sig);
-
-    // Serialize
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    if (!TypeHandler ->WritePtr(TypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) return 0;
-
-    // Get Size and close
-    rc = MemIO ->Tell(MemIO);
-    cmsCloseIOhandler(MemIO);      // Ignore return code this time
-
-    return rc;
-}
-
-// Similar to the anterior. This function allows to write directly to the ICC profile any data, without
-// checking anything. As a rule, mixing Raw with cooked doesn't work, so writting a tag as raw and then reading 
-// it as cooked without serializing does result into an error. If that is wha you want, you will need to dump
-// the profile to memry or disk and then reopen it.
-cmsBool CMSEXPORT cmsWriteRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data, cmsUInt32Number Size)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-    int i;
-
-	if (!_cmsNewTag(Icc, sig, &i)) return FALSE;
-
-    // Mark the tag as being written as RAW
-    Icc ->TagSaveAsRaw[i] = TRUE;
-    Icc ->TagNames[i]     = sig;
-    Icc ->TagLinked[i]    = (cmsTagSignature) 0;
-
-    // Keep a copy of the block
-    Icc ->TagPtrs[i]  = _cmsDupMem(Icc ->ContextID, data, Size);
-    Icc ->TagSizes[i] = Size;
-
-    return TRUE;
-}
-
-// Using this function you can collapse several tag entries to the same block in the profile
-cmsBool CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest)
-{
-     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-    int i;
-
-	if (!_cmsNewTag(Icc, sig, &i)) return FALSE;
-
-    // Keep necessary information
-    Icc ->TagSaveAsRaw[i] = FALSE;
-    Icc ->TagNames[i]     = sig;
-    Icc ->TagLinked[i]    = dest;
-    
-    Icc ->TagPtrs[i]    = NULL;
-    Icc ->TagSizes[i]   = 0;
-    Icc ->TagOffsets[i] = 0;
-
-    return TRUE;
-}
-
-
-// Returns the tag linked to sig, in the case two tags are sharing same resource
-cmsTagSignature  CMSEXPORT cmsTagLinkedTo(cmsHPROFILE hProfile, cmsTagSignature sig)
-{
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;  
-    int i;
-
-    // Search for given tag in ICC profile directory
-	i = _cmsSearchTag(Icc, sig, FALSE);
-	if (i < 0) return (cmsTagSignature) 0;                 // Not found, return 0
-
-    return Icc -> TagLinked[i];
-}
diff --git a/thirdparty/liblcms2/src/cmsio1.c b/thirdparty/liblcms2/src/cmsio1.c
deleted file mode 100644
index c93eaa8..0000000
--- a/thirdparty/liblcms2/src/cmsio1.c
+++ /dev/null
@@ -1,760 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Read tags using low-level functions, provides necessary glue code to adapt versions, etc.
-
-// LUT tags
-static const cmsTagSignature Device2PCS16[]   =  {cmsSigAToB0Tag,     // Perceptual
-                                                  cmsSigAToB1Tag,     // Relative colorimetric
-                                                  cmsSigAToB2Tag,     // Saturation
-                                                  cmsSigAToB1Tag };   // Absolute colorimetric
-
-static const cmsTagSignature Device2PCSFloat[] = {cmsSigDToB0Tag,     // Perceptual
-                                                  cmsSigDToB1Tag,     // Relative colorimetric
-                                                  cmsSigDToB2Tag,     // Saturation
-                                                  cmsSigDToB3Tag };   // Absolute colorimetric
-
-static const cmsTagSignature PCS2Device16[]    = {cmsSigBToA0Tag,     // Perceptual
-                                                  cmsSigBToA1Tag,     // Relative colorimetric
-                                                  cmsSigBToA2Tag,     // Saturation
-                                                  cmsSigBToA1Tag };   // Absolute colorimetric
-
-static const cmsTagSignature PCS2DeviceFloat[] = {cmsSigBToD0Tag,     // Perceptual
-                                                  cmsSigBToD1Tag,     // Relative colorimetric
-                                                  cmsSigBToD2Tag,     // Saturation
-                                                  cmsSigBToD3Tag };   // Absolute colorimetric
-
-
-// Factors to convert from 1.15 fixed point to 0..1.0 range and vice-versa
-#define InpAdj   (1.0/MAX_ENCODEABLE_XYZ)     // (65536.0/(65535.0*2.0))
-#define OutpAdj  (MAX_ENCODEABLE_XYZ)         // ((2.0*65535.0)/65536.0)
-
-// Several resources for gray conversions.
-static const cmsFloat64Number GrayInputMatrix[] = { (InpAdj*cmsD50X),  (InpAdj*cmsD50Y),  (InpAdj*cmsD50Z) };
-static const cmsFloat64Number OneToThreeInputMatrix[] = { 1, 1, 1 };   
-static const cmsFloat64Number PickYMatrix[] = { 0, (OutpAdj*cmsD50Y), 0 };   
-static const cmsFloat64Number PickLstarMatrix[] = { 1, 0, 0 };   
-
-// Get a media white point fixing some issues found in certain old profiles
-cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
-{
-    cmsCIEXYZ* Tag;
-
-    _cmsAssert(Dest != NULL);
-
-    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);   
-
-    // If no wp, take D50
-    if (Tag == NULL) {
-        *Dest = *cmsD50_XYZ();
-        return TRUE;
-    }
-
-    // V2 display profiles should give D50
-    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
-
-        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
-            *Dest = *cmsD50_XYZ();
-            return TRUE;            
-        }
-    }
-
-    // All seems ok
-    *Dest = *Tag;
-    return TRUE;
-}
-
-
-// Chromatic adaptation matrix. Fix some issues as well
-cmsBool  _cmsReadCHAD(cmsMAT3* Dest, cmsHPROFILE hProfile)
-{
-    cmsMAT3* Tag;
-
-    _cmsAssert(Dest != NULL);
-
-    Tag = (cmsMAT3*) cmsReadTag(hProfile, cmsSigChromaticAdaptationTag);
-
-    if (Tag != NULL) {
-
-        *Dest = *Tag;
-        return TRUE;
-    }
-
-    // No CHAD available, default it to identity
-    _cmsMAT3identity(Dest);
-
-    // V2 display profiles should give D50
-    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
-
-        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
-
-            cmsCIEXYZ* White = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);   
-
-            if (White == NULL) {
-
-                _cmsMAT3identity(Dest);
-                return TRUE;
-            }
-
-            return _cmsAdaptationMatrix(Dest, NULL, cmsD50_XYZ(), White);
-        }
-    }
-
-    return TRUE;
-}
-
-
-// Auxiliar, read colorants as a MAT3 structure. Used by any function that needs a matrix-shaper
-static
-cmsBool ReadICCMatrixRGB2XYZ(cmsMAT3* r, cmsHPROFILE hProfile)
-{
-    cmsCIEXYZ *PtrRed, *PtrGreen, *PtrBlue;
-
-    _cmsAssert(r != NULL);
-
-    PtrRed   = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigRedColorantTag);
-    PtrGreen = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigGreenColorantTag);
-    PtrBlue  = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigBlueColorantTag);
-
-    if (PtrRed == NULL || PtrGreen == NULL || PtrBlue == NULL) 
-        return FALSE;
-
-    _cmsVEC3init(&r -> v[0], PtrRed -> X, PtrGreen -> X,  PtrBlue -> X);
-    _cmsVEC3init(&r -> v[1], PtrRed -> Y, PtrGreen -> Y,  PtrBlue -> Y);
-    _cmsVEC3init(&r -> v[2], PtrRed -> Z, PtrGreen -> Z,  PtrBlue -> Z);
-
-    return TRUE;
-}
-
-
-// Gray input pipeline
-static
-cmsPipeline* BuildGrayInputMatrixPipeline(cmsHPROFILE hProfile)
-{
-    cmsToneCurve *GrayTRC;
-    cmsPipeline* Lut;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    
-    GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);
-    if (GrayTRC == NULL) return NULL;
-
-    Lut = cmsPipelineAlloc(ContextID, 1, 3);
-    if (Lut == NULL) return NULL;
-
-    if (cmsGetPCS(hProfile) == cmsSigLabData) {
-
-        // In this case we implement the profile as an  identity matrix plus 3 tone curves
-        cmsUInt16Number Zero[2] = { 0x8080, 0x8080 };
-        cmsToneCurve* EmptyTab;
-        cmsToneCurve* LabCurves[3];
-        
-        EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero); 
-
-        if (EmptyTab == NULL) {
-
-                 cmsPipelineFree(Lut);
-                 return NULL;
-        }
-
-        LabCurves[0] = GrayTRC;
-        LabCurves[1] = EmptyTab;
-        LabCurves[2] = EmptyTab;
-
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves));
-        
-        cmsFreeToneCurve(EmptyTab);
-
-    }
-    else  {
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC));
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL));
-    }
-  
-    return Lut;
-}
-
-// RGB Matrix shaper
-static
-cmsPipeline* BuildRGBInputMatrixShaper(cmsHPROFILE hProfile)
-{
-    cmsPipeline* Lut;
-    cmsMAT3 Mat;
-    cmsToneCurve *Shapes[3];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    int i, j;
-
-    if (!ReadICCMatrixRGB2XYZ(&Mat, hProfile)) return NULL;
-
-    // XYZ PCS in encoded in 1.15 format, and the matrix output comes in 0..0xffff range, so
-    // we need to adjust the output by a factor of (0x10000/0xffff) to put data in 
-    // a 1.16 range, and then a >> 1 to obtain 1.15. The total factor is (65536.0)/(65535.0*2)
-    
-    for (i=0; i < 3; i++)
-        for (j=0; j < 3; j++)
-            Mat.v[i].n[j] *= InpAdj;
-    
-
-    Shapes[0] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigRedTRCTag);        
-    Shapes[1] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGreenTRCTag);
-    Shapes[2] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigBlueTRCTag);
-
-    if (!Shapes[0] || !Shapes[1] || !Shapes[2])
-        return NULL;
-
-    Lut = cmsPipelineAlloc(ContextID, 3, 3);
-    if (Lut != NULL) {
-
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL));
-    }
-
-    return Lut;
-}
-
-// Read and create a BRAND NEW MPE LUT from a given profile. All stuff dependent of version, etc
-// is adjusted here in order to create a LUT that takes care of all those details
-cmsPipeline* _cmsReadInputLUT(cmsHPROFILE hProfile, int Intent)
-{
-    cmsTagTypeSignature OriginalType;
-    cmsTagSignature tag16    = Device2PCS16[Intent];
-    cmsTagSignature tagFloat = Device2PCSFloat[Intent];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    if (cmsIsTag(hProfile, tagFloat)) {  // Float tag takes precedence
-
-        // Floating point LUT are always V4, so no adjustment is required
-        return cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    }
-
-    // Revert to perceptual if no tag is found
-    if (!cmsIsTag(hProfile, tag16)) {
-        tag16 = Device2PCS16[0];
-    }
-
-    if (cmsIsTag(hProfile, tag16)) { // Is there any LUT-Based table?
-
-        // Check profile version and LUT type. Do the necessary adjustments if needed
-
-        // First read the tag
-        cmsPipeline* Lut = (cmsPipeline*) cmsReadTag(hProfile, tag16);
-        if (Lut == NULL) return NULL;
-
-        // After reading it, we have now info about the original type
-        OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
-
-        // The profile owns the Lut, so we need to copy it
-        Lut = cmsPipelineDup(Lut);
-
-        // We need to adjust data only for Lab16 on output
-        if (OriginalType != cmsSigLut16Type || cmsGetPCS(hProfile) != cmsSigLabData) 
-            return Lut;
-
-        // Add a matrix for conversion V2 to V4 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
-        return Lut;
-    }   
-
-    // Lut was not found, try to create a matrix-shaper
-
-    // Check if this is a grayscale profile.
-    if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
-
-        // if so, build appropiate conversion tables. 
-        // The tables are the PCS iluminant, scaled across GrayTRC
-        return BuildGrayInputMatrixPipeline(hProfile);              
-    }
-
-    // Not gray, create a normal matrix-shaper 
-    return BuildRGBInputMatrixShaper(hProfile);
-}
-
-// ---------------------------------------------------------------------------------------------------------------
-
-// Gray output pipeline. 
-// XYZ -> Gray or Lab -> Gray. Since we only know the GrayTRC, we need to do some assumptions. Gray component will be
-// given by Y on XYZ PCS and by L* on Lab PCS, Both across inverse TRC curve.
-// The complete pipeline on XYZ is Matrix[3:1] -> Tone curve and in Lab Matrix[3:1] -> Tone Curve as well.
-
-static
-cmsPipeline* BuildGrayOutputPipeline(cmsHPROFILE hProfile)
-{
-    cmsToneCurve *GrayTRC, *RevGrayTRC;
-    cmsPipeline* Lut;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);       
-    if (GrayTRC == NULL) return NULL;
-
-    RevGrayTRC = cmsReverseToneCurve(GrayTRC);
-    if (RevGrayTRC == NULL) return NULL;
-
-    Lut = cmsPipelineAlloc(ContextID, 3, 1);
-    if (Lut == NULL) {
-        cmsFreeToneCurve(RevGrayTRC);
-        return NULL;
-    }
-
-    if (cmsGetPCS(hProfile) == cmsSigLabData) {
-
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL));
-    }
-    else  {
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL));
-    }
-
-    cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC));
-    cmsFreeToneCurve(RevGrayTRC);
-
-    return Lut;
-}
-
-
-
-
-static
-cmsPipeline* BuildRGBOutputMatrixShaper(cmsHPROFILE hProfile)
-{
-    cmsPipeline* Lut;
-    cmsToneCurve *Shapes[3], *InvShapes[3];
-    cmsMAT3 Mat, Inv;
-    int i, j;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    if (!ReadICCMatrixRGB2XYZ(&Mat, hProfile))
-        return NULL;
-
-    if (!_cmsMAT3inverse(&Mat, &Inv))
-        return NULL;
-
-    // XYZ PCS in encoded in 1.15 format, and the matrix input should come in 0..0xffff range, so
-    // we need to adjust the input by a << 1 to obtain a 1.16 fixed and then by a factor of 
-    // (0xffff/0x10000) to put data in 0..0xffff range. Total factor is (2.0*65535.0)/65536.0;
-
-    for (i=0; i < 3; i++)
-        for (j=0; j < 3; j++)
-            Inv.v[i].n[j] *= OutpAdj;
-
-    Shapes[0] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigRedTRCTag);        
-    Shapes[1] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGreenTRCTag);
-    Shapes[2] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigBlueTRCTag);
-
-    if (!Shapes[0] || !Shapes[1] || !Shapes[2])
-        return NULL;
-
-    InvShapes[0] = cmsReverseToneCurve(Shapes[0]);
-    InvShapes[1] = cmsReverseToneCurve(Shapes[1]);
-    InvShapes[2] = cmsReverseToneCurve(Shapes[2]);
-
-    if (!InvShapes[0] || !InvShapes[1] || !InvShapes[2]) {      
-        return NULL;
-    }
-
-    Lut = cmsPipelineAlloc(ContextID, 3, 3);
-    if (Lut != NULL) {
-
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes));
-    }
-
-    cmsFreeToneCurveTriple(InvShapes);
-    return Lut;
-}
-
-
-// Change CLUT interpolation to trilinear
-static
-void ChangeInterpolationToTrilinear(cmsPipeline* Lut)
-{
-    cmsStage* Stage;
-
-    for (Stage = cmsPipelineGetPtrToFirstStage(Lut);
-        Stage != NULL;
-        Stage = cmsStageNext(Stage)) {
-
-            if (cmsStageType(Stage) == cmsSigCLutElemType) {
-
-                _cmsStageCLutData* CLUT = (_cmsStageCLutData*) Stage ->Data;
-
-                CLUT ->Params->dwFlags |= CMS_LERP_FLAGS_TRILINEAR;
-                _cmsSetInterpolationRoutine(CLUT ->Params);
-            }
-    }
-}
-
-// Create an output MPE LUT from agiven profile. Version mismatches are handled here
-cmsPipeline* _cmsReadOutputLUT(cmsHPROFILE hProfile, int Intent)
-{
-    cmsTagTypeSignature OriginalType;
-    cmsTagSignature tag16    = PCS2Device16[Intent];
-    cmsTagSignature tagFloat = PCS2DeviceFloat[Intent];
-    cmsContext ContextID     = cmsGetProfileContextID(hProfile);
-
-    if (cmsIsTag(hProfile, tagFloat)) {  // Float tag takes precedence
-
-        // Floating point LUT are always V4, so no adjustment is required
-        return cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    }
-
-    // Revert to perceptual if no tag is found
-    if (!cmsIsTag(hProfile, tag16)) {
-        tag16 = PCS2Device16[0];
-    }
-
-    if (cmsIsTag(hProfile, tag16)) { // Is there any LUT-Based table?
-
-        // Check profile version and LUT type. Do the necessary adjustments if needed
-
-        // First read the tag
-        cmsPipeline* Lut = (cmsPipeline*) cmsReadTag(hProfile, tag16);
-        if (Lut == NULL) return NULL;
-
-        // After reading it, we have info about the original type
-        OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
-
-        // The profile owns the Lut, so we need to copy it
-        Lut = cmsPipelineDup(Lut);
-        if (Lut == NULL) return NULL;
-
-        // Now it is time for a controversial stuff. I found that for 3D LUTS using 
-        // Lab used as indexer space,  trilinear interpolation should be used         
-        if (cmsGetPCS(hProfile) == cmsSigLabData)
-                             ChangeInterpolationToTrilinear(Lut);       
-
-        // We need to adjust data only for Lab and Lut16 type
-        if (OriginalType != cmsSigLut16Type || cmsGetPCS(hProfile) != cmsSigLabData) 
-            return Lut;
-
-        // Add a matrix for conversion V4 to V2 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
-        return Lut;
-    }   
-
-    // Lut not found, try to create a matrix-shaper
-
-    // Check if this is a grayscale profile.
-     if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
-
-              // if so, build appropiate conversion tables. 
-              // The tables are the PCS iluminant, scaled across GrayTRC
-              return BuildGrayOutputPipeline(hProfile);              
-    }
-
-    // Not gray, create a normal matrix-shaper 
-    return BuildRGBOutputMatrixShaper(hProfile);
-}
-
-// ---------------------------------------------------------------------------------------------------------------
-
-// This one includes abstract profiles as well. Matrix-shaper cannot be obtained on that device class. The 
-// tag name here may default to AToB0
-cmsPipeline* _cmsReadDevicelinkLUT(cmsHPROFILE hProfile, int Intent)
-{
-    cmsPipeline* Lut;
-    cmsTagTypeSignature OriginalType;
-    cmsTagSignature tag16    = Device2PCS16[Intent];
-    cmsTagSignature tagFloat = Device2PCSFloat[Intent];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    if (cmsIsTag(hProfile, tagFloat)) {  // Float tag takes precedence
-
-        // Floating point LUT are always V4, no adjustment is required
-        return cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    }
-
-    tagFloat = Device2PCSFloat[0];
-    if (cmsIsTag(hProfile, tagFloat)) {  
-        
-        return cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    }
-
-    if (!cmsIsTag(hProfile, tag16)) {  // Is there any LUT-Based table?
-        
-        tag16    = Device2PCS16[0];
-        if (!cmsIsTag(hProfile, tag16)) return NULL;        
-    }
-
-    // Check profile version and LUT type. Do the necessary adjustments if needed
-
-    // Read the tag
-    Lut = (cmsPipeline*) cmsReadTag(hProfile, tag16);
-    if (Lut == NULL) return NULL;
-
-    // The profile owns the Lut, so we need to copy it
-    Lut = cmsPipelineDup(Lut);
-    if (Lut == NULL) return NULL;
-
-     // Now it is time for a controversial stuff. I found that for 3D LUTS using 
-     // Lab used as indexer space,  trilinear interpolation should be used         
-    if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-                        ChangeInterpolationToTrilinear(Lut);    
-
-    // After reading it, we have info about the original type
-    OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
-
-    // We need to adjust data for Lab16 on output
-    if (OriginalType != cmsSigLut16Type) return Lut;
-        
-    // Here it is possible to get Lab on both sides
-
-    if (cmsGetPCS(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
-    }
-
-    if (cmsGetColorSpace(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
-    }
-
-    return Lut;
-
-
-}
-
-// ---------------------------------------------------------------------------------------------------------------
-
-// Returns TRUE if the profile is implemented as matrix-shaper
-cmsBool  CMSEXPORT cmsIsMatrixShaper(cmsHPROFILE hProfile)
-{    
-    switch (cmsGetColorSpace(hProfile)) {
-
-    case cmsSigGrayData:
-        
-        return cmsIsTag(hProfile, cmsSigGrayTRCTag);
-
-    case cmsSigRgbData:
-
-        return (cmsIsTag(hProfile, cmsSigRedColorantTag) &&
-                cmsIsTag(hProfile, cmsSigGreenColorantTag) &&
-                cmsIsTag(hProfile, cmsSigBlueColorantTag) &&
-                cmsIsTag(hProfile, cmsSigRedTRCTag) &&
-                cmsIsTag(hProfile, cmsSigGreenTRCTag) &&
-                cmsIsTag(hProfile, cmsSigBlueTRCTag));
-
-    default:
-
-        return FALSE;
-    }
-}
-
-// Returns TRUE if the intent is implemented as CLUT
-cmsBool  CMSEXPORT cmsIsCLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection)
-{    
-    const cmsTagSignature* TagTable;
-
-    // For devicelinks, the supported intent is that one stated in the header
-    if (cmsGetDeviceClass(hProfile) == cmsSigLinkClass) {
-            return (cmsGetHeaderRenderingIntent(hProfile) == Intent);
-    }
-
-    switch (UsedDirection) {
-
-       case LCMS_USED_AS_INPUT: TagTable = Device2PCS16; break;
-       case LCMS_USED_AS_OUTPUT:TagTable = PCS2Device16; break; 
-
-       // For proofing, we need rel. colorimetric in output. Let's do some recursion
-       case LCMS_USED_AS_PROOF: 
-           return cmsIsIntentSupported(hProfile, Intent, LCMS_USED_AS_INPUT) &&
-                  cmsIsIntentSupported(hProfile, INTENT_RELATIVE_COLORIMETRIC, LCMS_USED_AS_OUTPUT);
-
-       default:
-           cmsSignalError(cmsGetProfileContextID(hProfile), cmsERROR_RANGE, "Unexpected direction (%d)", UsedDirection);
-           return FALSE;
-    }
-
-    return cmsIsTag(hProfile, TagTable[Intent]);
-
-}
-
-
-// Return info about supported intents
-cmsBool  CMSEXPORT cmsIsIntentSupported(cmsHPROFILE hProfile,
-                                        cmsUInt32Number Intent, cmsUInt32Number UsedDirection)
-{
-
-    if (cmsIsCLUT(hProfile, Intent, UsedDirection)) return TRUE;
-
-    // Is there any matrix-shaper? If so, the intent is supported. This is a bit odd, since V2 matrix shaper
-    // does not fully support relative colorimetric because they cannot deal with non-zero black points, but
-    // many profiles claims that, and this is certainly not true for V4 profiles. Lets answer "yes" no matter
-    // the accuracy would be less than optimal in rel.col and v2 case.
-
-    return cmsIsMatrixShaper(hProfile);
-}
-
-
-// ---------------------------------------------------------------------------------------------------------------
-
-// Read both, profile sequence description and profile sequence id if present. Then combine both to
-// create qa unique structure holding both. Shame on ICC to store things in such complicated way.
-
-cmsSEQ* _cmsReadProfileSequence(cmsHPROFILE hProfile)
-{
-    cmsSEQ* ProfileSeq;
-    cmsSEQ* ProfileId;
-    cmsSEQ* NewSeq;
-    cmsUInt32Number i;
-
-    // Take profile sequence description first
-    ProfileSeq = (cmsSEQ*) cmsReadTag(hProfile, cmsSigProfileSequenceDescTag);
-    
-    // Take profile sequence ID
-    ProfileId  = (cmsSEQ*) cmsReadTag(hProfile, cmsSigProfileSequenceIdTag);
-
-    if (ProfileSeq == NULL && ProfileId == NULL) return NULL;
-
-    if (ProfileSeq == NULL) return cmsDupProfileSequenceDescription(ProfileId);
-    if (ProfileId  == NULL) return cmsDupProfileSequenceDescription(ProfileSeq);
-
-    // We have to mix both together. For that they must agree 
-    if (ProfileSeq ->n != ProfileId ->n) return cmsDupProfileSequenceDescription(ProfileSeq);
-
-    NewSeq = cmsDupProfileSequenceDescription(ProfileSeq);
-    
-    // Ok, proceed to the mixing
-    for (i=0; i < ProfileSeq ->n; i++) {
-    
-        memmove(&NewSeq ->seq[i].ProfileID, &ProfileId ->seq[i].ProfileID, sizeof(cmsProfileID));
-        NewSeq ->seq[i].Description = cmsMLUdup(ProfileId ->seq[i].Description);
-    }
-
-    return NewSeq;
-}
-
-// Dump the contents of profile sequence in both tags (if v4 available)
-cmsBool _cmsWriteProfileSequence(cmsHPROFILE hProfile, const cmsSEQ* seq)
-{
-    if (!cmsWriteTag(hProfile, cmsSigProfileSequenceDescTag, seq)) return FALSE;
-
-    if (cmsGetProfileVersion(hProfile) >= 4.0) {
-
-            if (!cmsWriteTag(hProfile, cmsSigProfileSequenceIdTag, seq)) return FALSE;
-    }
-
-    return TRUE;
-}
-
-
-// Auxiliar, read and duplicate a MLU if found.
-static
-cmsMLU* GetMLUFromProfile(cmsHPROFILE h, cmsTagSignature sig)
-{
-    cmsMLU* mlu = (cmsMLU*) cmsReadTag(h, sig);
-    if (mlu == NULL) return NULL;
-
-    return cmsMLUdup(mlu);
-}
-
-// Create a sequence description out of an array of profiles
-cmsSEQ* _cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[])
-{
-    cmsUInt32Number i;
-    cmsSEQ* seq = cmsAllocProfileSequenceDescription(ContextID, nProfiles);
-
-    if (seq == NULL) return NULL;
-
-    for (i=0; i < nProfiles; i++) {
-
-        cmsPSEQDESC* ps = &seq ->seq[i];
-        cmsHPROFILE h = hProfiles[i];
-        cmsTechnologySignature* techpt;
-        
-        cmsGetHeaderAttributes(h, &ps ->attributes);
-        cmsGetHeaderProfileID(h, ps ->ProfileID.ID8);       
-        ps ->deviceMfg   = cmsGetHeaderManufacturer(h);
-        ps ->deviceModel = cmsGetHeaderModel(h);
-        
-        techpt = (cmsTechnologySignature*) cmsReadTag(h, cmsSigTechnologyTag);
-        if (techpt == NULL)
-            ps ->technology   =  (cmsTechnologySignature) 0;
-        else
-            ps ->technology   = *techpt;
-                
-        ps ->Manufacturer = GetMLUFromProfile(h,  cmsSigDeviceMfgDescTag);
-        ps ->Model        = GetMLUFromProfile(h,  cmsSigDeviceModelDescTag);        
-        ps ->Description  = GetMLUFromProfile(h, cmsSigProfileDescriptionTag);
-        
-    }
-
-    return seq;
-}
-
-// -------------------------------------------------------------------------------------------------------------------
-
-
-static
-const cmsMLU* GetInfo(cmsHPROFILE hProfile, cmsInfoType Info)
-{
-    cmsTagSignature sig;
-
-    switch (Info) {
-
-    case cmsInfoDescription:
-        sig = cmsSigProfileDescriptionTag; 
-        break;
-
-    case cmsInfoManufacturer:
-        sig = cmsSigDeviceMfgDescTag;
-        break;
-
-    case cmsInfoModel:
-        sig = cmsSigDeviceModelDescTag;
-         break;
-
-    case cmsInfoCopyright:
-        sig = cmsSigCopyrightTag;
-        break;
-
-    default: return NULL;
-    }
-
-
-    return (cmsMLU*) cmsReadTag(hProfile, sig);
-}
-
-
-
-cmsUInt32Number CMSEXPORT cmsGetProfileInfo(cmsHPROFILE hProfile, cmsInfoType Info, 
-                                            const char LanguageCode[3], const char CountryCode[3], 
-                                            wchar_t* Buffer, cmsUInt32Number BufferSize)
-{
-    const cmsMLU* mlu = GetInfo(hProfile, Info);
-    if (mlu == NULL) return 0;
-
-    return cmsMLUgetWide(mlu, LanguageCode, CountryCode, Buffer, BufferSize);
-}
-
-
-cmsUInt32Number  CMSEXPORT cmsGetProfileInfoASCII(cmsHPROFILE hProfile, cmsInfoType Info, 
-                                                          const char LanguageCode[3], const char CountryCode[3], 
-                                                          char* Buffer, cmsUInt32Number BufferSize)
-{
-    const cmsMLU* mlu = GetInfo(hProfile, Info);
-    if (mlu == NULL) return 0;
-
-    return cmsMLUgetASCII(mlu, LanguageCode, CountryCode, Buffer, BufferSize);
-}
diff --git a/thirdparty/liblcms2/src/cmslut.c b/thirdparty/liblcms2/src/cmslut.c
deleted file mode 100644
index d0fe9c8..0000000
--- a/thirdparty/liblcms2/src/cmslut.c
+++ /dev/null
@@ -1,1665 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// Allocates an empty multi profile element
-cmsStage* CMSEXPORT _cmsStageAllocPlaceholder(cmsContext ContextID, 
-                                cmsStageSignature Type,
-                                cmsUInt32Number InputChannels, 
-                                cmsUInt32Number OutputChannels,
-                                _cmsStageEvalFn     EvalPtr,           
-                                _cmsStageDupElemFn  DupElemPtr,        
-                                _cmsStageFreeElemFn FreePtr,           
-                                void*             Data)             
-{
-    cmsStage* ph = (cmsStage*) _cmsMallocZero(ContextID, sizeof(cmsStage));
-
-    if (ph == NULL) return NULL;
-    
-    
-    ph ->ContextID = ContextID;
-
-    ph ->Type       = Type;
-    ph ->Implements = Type;   // By default, no clue on what is implementing
-
-    ph ->InputChannels  = InputChannels;
-    ph ->OutputChannels = OutputChannels;
-    ph ->EvalPtr        = EvalPtr;      
-    ph ->DupElemPtr     = DupElemPtr;   
-    ph ->FreePtr        = FreePtr;               
-    ph ->Data           = Data;
-
-    return ph; 
-}
-
-
-static
-void EvaluateIdentity(const cmsFloat32Number In[], 
-                            cmsFloat32Number Out[], 
-                      const cmsStage *mpe)
-{
-    memmove(Out, In, mpe ->InputChannels * sizeof(cmsFloat32Number));
-}
-
-
-cmsStage* CMSEXPORT cmsStageAllocIdentity(cmsContext ContextID, cmsUInt32Number nChannels)
-{
-    return _cmsStageAllocPlaceholder(ContextID, 
-                                   cmsSigIdentityElemType, 
-                                   nChannels, nChannels,
-                                   EvaluateIdentity,                            
-                                   NULL,
-                                   NULL,
-                                   NULL);
- }
-
-// Conversion functions. From floating point to 16 bits
-static
-void FromFloatTo16(const cmsFloat32Number In[], cmsUInt16Number Out[], cmsUInt32Number n)
-{
-    cmsUInt32Number i;
-
-    for (i=0; i < n; i++) {     
-        Out[i] = _cmsQuickSaturateWord(In[i] * 65535.0);        
-    }
-}
-
-// From 16 bits to floating point
-static
-void From16ToFloat(const cmsUInt16Number In[], cmsFloat32Number Out[], cmsUInt32Number n)
-{
-    cmsUInt32Number i;
-
-    for (i=0; i < n; i++) {
-        Out[i] = (cmsFloat32Number) In[i] / 65535.0F;
-    }
-}
-
-
-// This function is quite useful to analyze the structure of a LUT and retrieve the MPE elements
-// that conform the LUT. It should be called with the LUT, the number of expected elements and
-// then a list of expected types followed with a list of cmsFloat64Number pointers to MPE elements. If
-// the function founds a match with current pipeline, it fills the pointers and returns TRUE
-// if not, returns FALSE without touching anything. Setting pointers to NULL does bypass 
-// the storage process.
-cmsBool  CMSEXPORT cmsPipelineCheckAndRetreiveStages(const cmsPipeline* Lut, cmsUInt32Number n, ...)
-{
-    va_list args;
-    cmsUInt32Number i;
-    cmsStage* mpe;
-    cmsStageSignature Type;
-    void** ElemPtr;
-
-    // Make sure same number of elements
-    if (cmsPipelineStageCount(Lut) != n) return FALSE;
-
-    va_start(args, n);
-
-    // Iterate across asked types
-    mpe = Lut ->Elements;
-    for (i=0; i < n; i++) {
-
-        // Get asked type
-        Type  = va_arg(args, cmsStageSignature);      
-        if (mpe ->Type != Type) {
-
-            va_end(args);       // Mismatch. We are done.
-            return FALSE;       
-        }
-        mpe = mpe ->Next;
-    }
-
-    // Found a combination, fill pointers if not NULL
-    mpe = Lut ->Elements;
-    for (i=0; i < n; i++) {
-
-        ElemPtr = va_arg(args, void**);     
-        if (ElemPtr != NULL) 
-            *ElemPtr = mpe;
-
-        mpe = mpe ->Next;
-    }
-
-    va_end(args);   
-    return TRUE;
-}
-
-// Below there are implementations for several types of elements. Each type may be implemented by a
-// evaluation function, a duplication function, a function to free resources and a constructor.
-
-// *************************************************************************************************
-// Type cmsSigCurveSetElemType (curves)
-// *************************************************************************************************
-
-cmsToneCurve** _cmsStageGetPtrToCurveSet(const cmsStage* mpe)
-{
-    _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) mpe ->Data;
-
-    return Data ->TheCurves;
-}
-
-static
-void EvaluateCurves(const cmsFloat32Number In[], 
-                    cmsFloat32Number Out[], 
-                    const cmsStage *mpe)
-{
-    _cmsStageToneCurvesData* Data;
-    cmsUInt32Number i;
-
-    _cmsAssert(mpe != NULL);
-
-    Data = (_cmsStageToneCurvesData*) mpe ->Data;
-    if (Data == NULL) return;
-
-    if (Data ->TheCurves == NULL) return;
-
-    for (i=0; i < Data ->nCurves; i++) {
-        Out[i] = cmsEvalToneCurveFloat(Data ->TheCurves[i], In[i]);
-    }
-}
-
-static
-void CurveSetElemTypeFree(cmsStage* mpe)
-{
-    _cmsStageToneCurvesData* Data;
-    cmsUInt32Number i;
-
-    _cmsAssert(mpe != NULL);
-
-    Data = (_cmsStageToneCurvesData*) mpe ->Data;
-    if (Data == NULL) return;
-
-    if (Data ->TheCurves != NULL) {
-        for (i=0; i < Data ->nCurves; i++) {
-            if (Data ->TheCurves[i] != NULL) 
-                cmsFreeToneCurve(Data ->TheCurves[i]);
-        }
-    }
-    _cmsFree(mpe ->ContextID, Data ->TheCurves);
-    _cmsFree(mpe ->ContextID, Data);
-}
-
-
-static
-void* CurveSetDup(cmsStage* mpe)
-{
-    _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) mpe ->Data;
-    _cmsStageToneCurvesData* NewElem;
-    cmsUInt32Number i;
-
-    NewElem = (_cmsStageToneCurvesData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageToneCurvesData));
-    if (NewElem == NULL) return NULL;
-
-    NewElem ->nCurves   = Data ->nCurves;
-    NewElem ->TheCurves = (cmsToneCurve**) _cmsCalloc(mpe ->ContextID, NewElem ->nCurves, sizeof(cmsToneCurve*));
-
-    if (NewElem ->TheCurves == NULL) goto Error;
-
-    for (i=0; i < NewElem ->nCurves; i++) {
-
-        // Duplicate each curve. It may fail.
-        NewElem ->TheCurves[i] = cmsDupToneCurve(Data ->TheCurves[i]);
-        if (NewElem ->TheCurves[i] == NULL) goto Error;
-
-
-    }
-    return (void*) NewElem;
-
-Error:
-
-    if (NewElem ->TheCurves != NULL) { 
-        for (i=0; i < NewElem ->nCurves; i++) {
-            if (NewElem ->TheCurves[i])
-                cmsFreeToneCurve(Data ->TheCurves[i]);
-        }
-    }
-    _cmsFree(mpe ->ContextID, Data ->TheCurves);
-    _cmsFree(mpe ->ContextID, NewElem);
-    return NULL;
-}
-
-
-// Curves == NULL forces identity curves
-cmsStage* CMSEXPORT cmsStageAllocToneCurves(cmsContext ContextID, cmsUInt32Number nChannels, cmsToneCurve* const Curves[])
-{
-    cmsUInt32Number i;
-    _cmsStageToneCurvesData* NewElem;
-    cmsStage* NewMPE;
-    
-    
-    NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCurveSetElemType, nChannels, nChannels,
-                                     EvaluateCurves, CurveSetDup, CurveSetElemTypeFree, NULL );
-    if (NewMPE == NULL) return NULL;
-
-    NewElem = (_cmsStageToneCurvesData*) _cmsMalloc(ContextID, sizeof(_cmsStageToneCurvesData));
-    if (NewElem == NULL) {
-        cmsStageFree(NewMPE); 
-        return NULL;
-    }
-
-    NewMPE ->Data  = (void*) NewElem;
-
-    NewElem ->nCurves   = nChannels;
-    NewElem ->TheCurves = (cmsToneCurve**) _cmsCalloc(ContextID, nChannels, sizeof(cmsToneCurve*));
-    if (NewElem ->TheCurves == NULL) {
-        cmsStageFree(NewMPE); 
-        return NULL;
-    }
-
-    for (i=0; i < nChannels; i++) {
-
-        if (Curves == NULL) {
-            NewElem ->TheCurves[i] = cmsBuildGamma(ContextID, 1.0);
-        }
-        else {
-            NewElem ->TheCurves[i] = cmsDupToneCurve(Curves[i]);
-        }
-
-        if (NewElem ->TheCurves[i] == NULL) {
-            cmsStageFree(NewMPE); 
-            return NULL;
-        }
-    }
-
-    return NewMPE;
-}
-
-
-// Create a bunch of identity curves
-cmsStage* _cmsStageAllocIdentityCurves(cmsContext ContextID, int nChannels)
-{
-    cmsStage* mpe = cmsStageAllocToneCurves(ContextID, nChannels, NULL);
-    
-    if (mpe == NULL) return NULL;
-    mpe ->Implements = cmsSigIdentityElemType;
-    return mpe;
-}
-
-
-// *************************************************************************************************
-// Type cmsSigMatrixElemType (Matrices)
-// *************************************************************************************************
-
-
-// Special care should be taken here because precision loss. A temporary cmsFloat64Number buffer is being used
-static
-void EvaluateMatrix(const cmsFloat32Number In[], 
-                    cmsFloat32Number Out[], 
-                    const cmsStage *mpe)
-{
-    cmsUInt32Number i, j;
-    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
-    cmsFloat64Number Tmp;
-
-    // Input is already in 0..1.0 notation
-    for (i=0; i < mpe ->OutputChannels; i++) {
-
-        Tmp = 0;
-        for (j=0; j < mpe->InputChannels; j++) {
-            Tmp += In[j] * Data->Double[i*mpe->InputChannels + j];
-        }
-
-        if (Data ->Offset != NULL) 
-            Tmp += Data->Offset[i];
-
-        Out[i] = (cmsFloat32Number) Tmp;     
-    }
-
-
-    // Output in 0..1.0 domain
-}
-
-
-// Duplicate a yet-existing matrix element
-static
-void* MatrixElemDup(cmsStage* mpe)
-{
-    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
-    _cmsStageMatrixData* NewElem;
-    cmsUInt32Number sz;
-    
-    NewElem = (_cmsStageMatrixData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageMatrixData));
-    if (NewElem == NULL) return NULL;
-
-    sz = mpe ->InputChannels * mpe ->OutputChannels;
-
-    NewElem ->Double = (cmsFloat64Number*) _cmsDupMem(mpe ->ContextID, Data ->Double, sz * sizeof(cmsFloat64Number)) ;
-
-    if (Data ->Offset)
-        NewElem ->Offset = (cmsFloat64Number*) _cmsDupMem(mpe ->ContextID, 
-                                                Data ->Offset, mpe -> OutputChannels * sizeof(cmsFloat64Number)) ;
-
-    return (void*) NewElem;
-}
-
-
-static
-void MatrixElemTypeFree(cmsStage* mpe)
-{
-    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
-    if (Data ->Double)
-        _cmsFree(mpe ->ContextID, Data ->Double);
-
-    if (Data ->Offset)
-        _cmsFree(mpe ->ContextID, Data ->Offset);
-
-    _cmsFree(mpe ->ContextID, mpe ->Data);
-}
-
-
-
-cmsStage*  CMSEXPORT cmsStageAllocMatrix(cmsContext ContextID, cmsUInt32Number Rows, cmsUInt32Number Cols, 
-                                     const cmsFloat64Number* Matrix, const cmsFloat64Number* Offset)
-{
-    cmsUInt32Number i, n;
-    _cmsStageMatrixData* NewElem;
-    cmsStage* NewMPE;
-
-    n = Rows * Cols;
-
-    // Check for overflow
-    if (n == 0) return NULL;
-    if (n >= UINT_MAX / Cols) return NULL;
-    if (n >= UINT_MAX / Rows) return NULL;
-    if (n < Rows || n < Cols) return NULL;
-
-    NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigMatrixElemType, Cols, Rows,
-                                     EvaluateMatrix, MatrixElemDup, MatrixElemTypeFree, NULL );
-    if (NewMPE == NULL) return NULL;
-
-   
-    NewElem = (_cmsStageMatrixData*) _cmsMallocZero(ContextID, sizeof(_cmsStageMatrixData));
-    if (NewElem == NULL) return NULL;
-  
-
-    NewElem ->Double = (cmsFloat64Number*) _cmsCalloc(ContextID, n, sizeof(cmsFloat64Number));
-
-    if (NewElem->Double == NULL) {
-        MatrixElemTypeFree(NewMPE);
-        return NULL;
-    }
-
-    for (i=0; i < n; i++) {
-        NewElem ->Double[i] = Matrix[i];
-    }
-
-
-    if (Offset != NULL) {
-    
-        NewElem ->Offset = (cmsFloat64Number*) _cmsCalloc(ContextID, Cols, sizeof(cmsFloat64Number));
-        if (NewElem->Offset == NULL) {
-           MatrixElemTypeFree(NewMPE);
-           return NULL;
-        }
-
-        for (i=0; i < Cols; i++) {
-                NewElem ->Offset[i] = Offset[i];
-        }
-
-    }
-    
-    NewMPE ->Data  = (void*) NewElem;
-    return NewMPE;
-}
-
-
-// *************************************************************************************************
-// Type cmsSigCLutElemType
-// *************************************************************************************************
-
-
-// Evaluate in true floating point
-static
-void EvaluateCLUTfloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)
-{
-    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;  
-
-    Data -> Params ->Interpolation.LerpFloat(In, Out, Data->Params);
-}
-
-
-// Convert to 16 bits, evaluate, and back to floating point
-static
-void EvaluateCLUTfloatIn16(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)
-{
-    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;
-    cmsUInt16Number In16[MAX_STAGE_CHANNELS], Out16[MAX_STAGE_CHANNELS];
-    
-    _cmsAssert(mpe ->InputChannels  <= MAX_STAGE_CHANNELS);
-    _cmsAssert(mpe ->OutputChannels <= MAX_STAGE_CHANNELS);
-
-    FromFloatTo16(In, In16, mpe ->InputChannels);   
-    Data -> Params ->Interpolation.Lerp16(In16, Out16, Data->Params);
-    From16ToFloat(Out16, Out,  mpe ->OutputChannels);
-}
-
-
-// Given an hypercube of b dimensions, with Dims[] number of nodes by dimension, calculate the total amount of nodes
-static
-cmsUInt32Number CubeSize(const cmsUInt32Number Dims[], cmsUInt32Number b)
-{
-    cmsUInt32Number rv, dim;
-
-    _cmsAssert(Dims != NULL);
-
-    for (rv = 1; b > 0; b--) {
-
-        dim = Dims[b-1];
-        if (dim == 0) return 0;  // Error
-
-        rv *= dim;
-
-        // Check for overflow
-        if (rv > UINT_MAX / dim) return 0;
-    }
-
-    return rv;
-}
-
-static
-void* CLUTElemDup(cmsStage* mpe)
-{
-    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;
-    _cmsStageCLutData* NewElem;
-    
-    
-    NewElem = (_cmsStageCLutData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) return NULL;
-
-    NewElem ->nEntries       = Data ->nEntries;
-    NewElem ->HasFloatValues = Data ->HasFloatValues;
-
-    if (Data ->Tab.T) {
-
-        if (Data ->HasFloatValues)
-            NewElem ->Tab.TFloat = (cmsFloat32Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.TFloat, Data ->nEntries * sizeof (cmsFloat32Number));
-        else
-            NewElem ->Tab.T = (cmsUInt16Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.T, Data ->nEntries * sizeof (cmsUInt16Number));
-    }
-    
-    NewElem ->Params   = _cmsComputeInterpParamsEx(mpe ->ContextID,
-                                                   Data ->Params ->nSamples, 
-                                                   Data ->Params ->nInputs,
-                                                   Data ->Params ->nOutputs, 
-                                                   NewElem ->Tab.T,
-                                                   Data ->Params ->dwFlags);
-
-    return (void*) NewElem;
-}
-
-
-static
-void CLutElemTypeFree(cmsStage* mpe)
-{
-
-    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;
-    
-    // Already empty
-    if (Data == NULL) return;
-
-    // This works for both types
-    if (Data -> Tab.T)
-        _cmsFree(mpe ->ContextID, Data -> Tab.T);
-
-    _cmsFreeInterpParams(Data ->Params);    
-    _cmsFree(mpe ->ContextID, mpe ->Data);
-}
-
-
-// Allocates a 16-bit multidimensional CLUT. This is evaluated at 16-bit precision. Table may have different
-// granularity on each dimension.
-cmsStage* CMSEXPORT cmsStageAllocCLut16bitGranular(cmsContext ContextID, 
-                                         const cmsUInt32Number clutPoints[], 
-                                         cmsUInt32Number inputChan, 
-                                         cmsUInt32Number outputChan, 
-                                         const cmsUInt16Number* Table)
-{
-    cmsUInt32Number i, n;
-    _cmsStageCLutData* NewElem;
-    cmsStage* NewMPE;
-    
-    NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCLutElemType, inputChan, outputChan,
-                                     EvaluateCLUTfloatIn16, CLUTElemDup, CLutElemTypeFree, NULL );
-
-    if (NewMPE == NULL) return NULL;
-
-    NewElem = (_cmsStageCLutData*) _cmsMalloc(ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    NewMPE ->Data  = (void*) NewElem;
-
-    NewElem -> nEntries = n = outputChan * CubeSize(clutPoints, inputChan);
-    NewElem -> HasFloatValues = FALSE;
-
-    if (n == 0) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-
-    NewElem ->Tab.T  = (cmsUInt16Number*) _cmsCalloc(ContextID, n, sizeof(cmsUInt16Number));
-    if (NewElem ->Tab.T == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    if (Table != NULL) {
-        for (i=0; i < n; i++) {
-            NewElem ->Tab.T[i] = Table[i];
-        }
-    }
-
-    NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints, inputChan, outputChan, NewElem ->Tab.T, CMS_LERP_FLAGS_16BITS);
-    if (NewElem ->Params == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    return NewMPE;
-}
-
-cmsStage* CMSEXPORT cmsStageAllocCLut16bit(cmsContext ContextID, 
-                                    cmsUInt32Number nGridPoints, 
-                                    cmsUInt32Number inputChan, 
-                                    cmsUInt32Number outputChan, 
-                                    const cmsUInt16Number* Table)
-{
-    cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-    int i;
-
-   // Our resulting LUT would be same gridpoints on all dimensions
-    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
-        Dimensions[i] = nGridPoints;
-
-
-    return cmsStageAllocCLut16bitGranular(ContextID, Dimensions, inputChan, outputChan, Table);
-}
-
-
-cmsStage* CMSEXPORT cmsStageAllocCLutFloat(cmsContext ContextID, 
-                                       cmsUInt32Number nGridPoints, 
-                                       cmsUInt32Number inputChan, 
-                                       cmsUInt32Number outputChan, 
-                                       const cmsFloat32Number* Table)
-{
-   cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-   int i;
-
-    // Our resulting LUT would be same gridpoints on all dimensions
-    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
-        Dimensions[i] = nGridPoints;
-
-    return cmsStageAllocCLutFloatGranular(ContextID, Dimensions, inputChan, outputChan, Table);
-}
-
-
-
-cmsStage* CMSEXPORT cmsStageAllocCLutFloatGranular(cmsContext ContextID, const cmsUInt32Number clutPoints[], cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsFloat32Number* Table)
-{
-    cmsUInt32Number i, n;
-    _cmsStageCLutData* NewElem;
-    cmsStage* NewMPE;
-    
-    _cmsAssert(clutPoints != NULL);
-
-    NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCLutElemType, inputChan, outputChan,
-                                             EvaluateCLUTfloat, CLUTElemDup, CLutElemTypeFree, NULL);
-    if (NewMPE == NULL) return NULL;
-
-  
-    NewElem = (_cmsStageCLutData*) _cmsMalloc(ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    NewMPE ->Data  = (void*) NewElem;
-
-    // There is a potential integer overflow on conputing n and nEntries.
-    NewElem -> nEntries = n = outputChan * CubeSize( clutPoints, inputChan);
-    NewElem -> HasFloatValues = TRUE;
-
-    if (n == 0) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    NewElem ->Tab.TFloat  = (cmsFloat32Number*) _cmsCalloc(ContextID, n, sizeof(cmsFloat32Number));
-    if (NewElem ->Tab.TFloat == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-    if (Table != NULL) {
-        for (i=0; i < n; i++) {
-            NewElem ->Tab.TFloat[i] = Table[i];
-        }
-    }
-
-
-    
-    NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints,  inputChan, outputChan, NewElem ->Tab.TFloat, CMS_LERP_FLAGS_FLOAT);
-    if (NewElem ->Params == NULL) {
-        cmsStageFree(NewMPE);
-        return NULL;
-    }
-
-
-
-    return NewMPE;
-}
-
-
-static
-int IdentitySampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void * Cargo)
-{
-    int nChan = *(int*) Cargo;
-    int i;
-
-    for (i=0; i < nChan; i++) 
-        Out[i] = In[i];
-
-    return 1;
-}
-
-// Creates an MPE that just copies input to output
-cmsStage* _cmsStageAllocIdentityCLut(cmsContext ContextID, int nChan)
-{
-    cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-    cmsStage* mpe ;
-    int i;
-        
-    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
-        Dimensions[i] = 2;
-
-    mpe = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, nChan, nChan, NULL);
-    if (mpe == NULL) return NULL;
-    
-    if (!cmsStageSampleCLut16bit(mpe, IdentitySampler, &nChan, 0)) {
-        cmsStageFree(mpe);
-        return NULL;
-    }
-
-    mpe ->Implements = cmsSigIdentityElemType;
-    return mpe;
-}
-
-
-
-// Quantize a value 0 <= i < MaxSamples to 0..0xffff
-cmsUInt16Number _cmsQuantizeVal(cmsFloat64Number i, int MaxSamples)
-{
-    cmsFloat64Number x;
-
-    x = ((cmsFloat64Number) i * 65535.) / (cmsFloat64Number) (MaxSamples - 1);
-    return _cmsQuickSaturateWord(x);
-}
-
-
-// This routine does a sweep on whole input space, and calls its callback
-// function on knots. returns TRUE if all ok, FALSE otherwise.
-cmsBool CMSEXPORT cmsStageSampleCLut16bit(cmsStage* mpe, cmsSAMPLER16 Sampler, void * Cargo, cmsUInt32Number dwFlags)
-{
-    int i, t, nTotalPoints, index, rest;
-    int nInputs, nOutputs;  
-    cmsUInt32Number* nSamples;
-    cmsUInt16Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];
-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data; 
-
-
-    nSamples = clut->Params ->nSamples;
-    nInputs  = clut->Params ->nInputs;
-    nOutputs = clut->Params ->nOutputs;
-
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
-    if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
-
-    nTotalPoints = CubeSize(nSamples, nInputs);
-    if (nTotalPoints == 0) return FALSE;
-
-    index = 0;
-    for (i = 0; i < nTotalPoints; i++) {
-
-        rest = i;
-        for (t = nInputs-1; t >=0; --t) {
-
-            cmsUInt32Number  Colorant = rest % nSamples[t];
-
-            rest /= nSamples[t];
-
-            In[t] = _cmsQuantizeVal(Colorant, nSamples[t]);                         
-        }
-
-        if (clut ->Tab.T != NULL) {
-            for (t=0; t < nOutputs; t++)
-                Out[t] = clut->Tab.T[index + t];
-        }
-
-        if (!Sampler(In, Out, Cargo))
-            return FALSE;
-
-        if (!(dwFlags & SAMPLER_INSPECT)) {
-
-            if (clut ->Tab.T != NULL) {
-                for (t=0; t < nOutputs; t++)
-                    clut->Tab.T[index + t] = Out[t];
-            }
-        }
-
-        index += nOutputs;
-    }
-
-    return TRUE;
-}
-
-// Same as anterior, but for floting point
-cmsBool CMSEXPORT cmsStageSampleCLutFloat(cmsStage* mpe, cmsSAMPLERFLOAT Sampler, void * Cargo, cmsUInt32Number dwFlags)
-{
-    int i, t, nTotalPoints, index, rest;
-    int nInputs, nOutputs;
-    cmsUInt32Number* nSamples;
-    cmsFloat32Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];   
-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data; 
-
-    nSamples = clut->Params ->nSamples;
-    nInputs  = clut->Params ->nInputs;
-    nOutputs = clut->Params ->nOutputs;
-
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
-    if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
-
-    nTotalPoints = CubeSize(nSamples, nInputs);
-    if (nTotalPoints == 0) return FALSE;
-
-    index = 0;
-    for (i = 0; i < nTotalPoints; i++) {
-
-        rest = i;
-        for (t = nInputs-1; t >=0; --t) {
-         
-            cmsUInt32Number  Colorant = rest % nSamples[t];
-
-            rest /= nSamples[t];
-
-            In[t] =  (cmsFloat32Number) (_cmsQuantizeVal(Colorant, nSamples[t]) / 65535.0);                         
-        }
-
-        if (clut ->Tab.TFloat != NULL) {
-            for (t=0; t < nOutputs; t++)
-                Out[t] = clut->Tab.TFloat[index + t];
-        }
-
-        if (!Sampler(In, Out, Cargo))
-            return FALSE;
-
-        if (!(dwFlags & SAMPLER_INSPECT)) {
-
-            if (clut ->Tab.TFloat != NULL) {
-                for (t=0; t < nOutputs; t++)
-                    clut->Tab.TFloat[index + t] = Out[t];
-            }
-        }
-
-        index += nOutputs;
-    }
-
-    return TRUE;
-}
-
-
-
-// This routine does a sweep on whole input space, and calls its callback
-// function on knots. returns TRUE if all ok, FALSE otherwise.
-cmsBool CMSEXPORT cmsSliceSpace16(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],
-                                         cmsSAMPLER16 Sampler, void * Cargo)
-{
-    int i, t, nTotalPoints, rest;
-    cmsUInt16Number In[cmsMAXCHANNELS];
-
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
-
-    nTotalPoints = CubeSize(clutPoints, nInputs);
-    if (nTotalPoints == 0) return FALSE;
-
-    for (i = 0; i < nTotalPoints; i++) {
-
-        rest = i;
-        for (t = nInputs-1; t >=0; --t) {
-
-            cmsUInt32Number  Colorant = rest % clutPoints[t];
-
-            rest /= clutPoints[t];
-            In[t] = _cmsQuantizeVal(Colorant, clutPoints[t]);   
-
-        }
-
-        if (!Sampler(In, NULL, Cargo))
-            return FALSE;
-    }
-
-    return TRUE;
-}
-
-cmsInt32Number CMSEXPORT cmsSliceSpaceFloat(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],
-                                            cmsSAMPLERFLOAT Sampler, void * Cargo)
-{
-    int i, t, nTotalPoints, rest;
-    cmsFloat32Number In[cmsMAXCHANNELS];
-
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
-
-    nTotalPoints = CubeSize(clutPoints, nInputs);
-    if (nTotalPoints == 0) return FALSE;
-
-    for (i = 0; i < nTotalPoints; i++) {
-
-        rest = i;
-        for (t = nInputs-1; t >=0; --t) {
-
-            cmsUInt32Number  Colorant = rest % clutPoints[t];
-
-            rest /= clutPoints[t];
-            In[t] =  (cmsFloat32Number) (_cmsQuantizeVal(Colorant, clutPoints[t]) / 65535.0);    
-
-        }
-
-        if (!Sampler(In, NULL, Cargo))
-            return FALSE;
-    }
-
-    return TRUE;
-}
-
-// ********************************************************************************
-// Type cmsSigLab2XYZElemType
-// ********************************************************************************
-
-
-static
-void EvaluateLab2XYZ(const cmsFloat32Number In[], 
-                     cmsFloat32Number Out[], 
-                     const cmsStage *mpe)
-{
-    cmsCIELab Lab;
-    cmsCIEXYZ XYZ;
-    const cmsFloat64Number XYZadj = MAX_ENCODEABLE_XYZ;
-
-    // V4 rules
-    Lab.L = In[0] * 100.0;        
-    Lab.a = In[1] * 255.0 - 128.0;
-    Lab.b = In[2] * 255.0 - 128.0;
-
-    cmsLab2XYZ(NULL, &XYZ, &Lab);
-
-    // From XYZ, range 0..19997 to 0..1.0, note that 1.99997 comes from 0xffff 
-    // encoded as 1.15 fixed point, so 1 + (32767.0 / 32768.0)
-
-    Out[0] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.X / XYZadj); 
-    Out[1] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.Y / XYZadj); 
-    Out[2] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.Z / XYZadj); 
-    return;
-
-    cmsUNUSED_PARAMETER(mpe);
-}
-
-
-// No dup or free routines needed, as the structure has no pointers in it.
-cmsStage* _cmsStageAllocLab2XYZ(cmsContext ContextID)
-{
-    return _cmsStageAllocPlaceholder(ContextID, cmsSigLab2XYZElemType, 3, 3, EvaluateLab2XYZ, NULL, NULL, NULL);
-}
-
-// ********************************************************************************
-
-// v2 L=100 is supposed to be placed on 0xFF00. There is no reasonable 
-// number of gridpoints that would make exact match. However, a prelinearization
-// of 258 entries, would map 0xFF00 exactly on entry 257, and this is good to avoid scum dot. 
-// Almost all what we need but unfortunately, the rest of entries should be scaled by
-// (255*257/256) and this is not exact.
-
-cmsStage* _cmsStageAllocLabV2ToV4curves(cmsContext ContextID)
-{
-    cmsStage* mpe;
-    cmsToneCurve* LabTable[3];
-    int i, j;
-
-    LabTable[0] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);
-    LabTable[1] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);
-    LabTable[2] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);
-
-    for (j=0; j < 3; j++) {
-    
-        if (LabTable[j] == NULL) {
-            cmsFreeToneCurveTriple(LabTable);
-            return NULL;
-        }
-        
-        // We need to map * (0xffff / 0xff00), thats same as (257 / 256) 
-        // So we can use 258-entry tables to do the trick (i / 257) * (255 * 257) * (257 / 256);
-        for (i=0; i < 257; i++)  {
-
-            LabTable[j]->Table16[i] = (cmsUInt16Number) ((i * 0xffff + 0x80) >> 8);
-        }
-
-        LabTable[j] ->Table16[257] = 0xffff;
-    }
-
-    mpe = cmsStageAllocToneCurves(ContextID, 3, LabTable);
-    cmsFreeToneCurveTriple(LabTable);
-
-    mpe ->Implements = cmsSigLabV2toV4;
-    return mpe;
-}
-
-// ********************************************************************************
-
-// Matrix-based conversion, which is more accurate, but slower and cannot properly be saved in devicelink profiles
-cmsStage* _cmsStageAllocLabV2ToV4(cmsContext ContextID)
-{
-    static const cmsFloat64Number V2ToV4[] = { 65535.0/65280.0, 0, 0,
-                                     0, 65535.0/65280.0, 0, 
-                                     0, 0, 65535.0/65280.0 
-                                     };
-
-    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, V2ToV4, NULL);
-
-    if (mpe == NULL) return mpe;
-    mpe ->Implements = cmsSigLabV2toV4;
-    return mpe;
-}
-
-
-// Reverse direction
-cmsStage* _cmsStageAllocLabV4ToV2(cmsContext ContextID)
-{
-    static const cmsFloat64Number V4ToV2[] = { 65280.0/65535.0, 0, 0,
-                                     0, 65280.0/65535.0, 0, 
-                                     0, 0, 65280.0/65535.0 
-                                     };
-
-     cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, V4ToV2, NULL);
-
-    if (mpe == NULL) return mpe;
-    mpe ->Implements = cmsSigLabV4toV2;
-    return mpe;
-}
-
-
-// ********************************************************************************
-// Type cmsSigXYZ2LabElemType
-// ********************************************************************************
-
-static
-void EvaluateXYZ2Lab(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)
-{
-    cmsCIELab Lab;
-    cmsCIEXYZ XYZ;
-    const cmsFloat64Number XYZadj = MAX_ENCODEABLE_XYZ; 
-
-    // From 0..1.0 to XYZ
-
-    XYZ.X = In[0] * XYZadj; 
-    XYZ.Y = In[1] * XYZadj; 
-    XYZ.Z = In[2] * XYZadj;
-
-    cmsXYZ2Lab(NULL, &Lab, &XYZ);
-    
-    // From V4 Lab to 0..1.0
-
-    Out[0] = (cmsFloat32Number) (Lab.L / 100.0); 
-    Out[1] = (cmsFloat32Number) ((Lab.a + 128.0) / 255.0); 
-    Out[2] = (cmsFloat32Number) ((Lab.b + 128.0) / 255.0);
-    return;
-
-    cmsUNUSED_PARAMETER(mpe);
-}
-
-cmsStage* _cmsStageAllocXYZ2Lab(cmsContext ContextID)
-{    
-    return _cmsStageAllocPlaceholder(ContextID, cmsSigXYZ2LabElemType, 3, 3, EvaluateXYZ2Lab, NULL, NULL, NULL);
- 
-}
-
-// ********************************************************************************
-
-// For v4, S-Shaped curves are placed in a/b axis to increase resolution near gray
-
-cmsStage* _cmsStageAllocLabPrelin(cmsContext ContextID)
-{
-    cmsToneCurve* LabTable[3];
-    cmsFloat64Number Params[1] =  {2.4} ;
-
-    LabTable[0] = cmsBuildGamma(ContextID, 1.0);
-    LabTable[1] = cmsBuildParametricToneCurve(ContextID, 108, Params);
-    LabTable[2] = cmsBuildParametricToneCurve(ContextID, 108, Params);
-
-    return cmsStageAllocToneCurves(ContextID, 3, LabTable);
-}
-
-
-// Free a single MPE 
-void CMSEXPORT cmsStageFree(cmsStage* mpe)
-{
-    if (mpe ->FreePtr) 
-        mpe ->FreePtr(mpe);
-
-    _cmsFree(mpe ->ContextID, mpe);
-}
-
-
-cmsUInt32Number  CMSEXPORT cmsStageInputChannels(const cmsStage* mpe)
-{
-    return mpe ->InputChannels;
-}
-
-cmsUInt32Number  CMSEXPORT cmsStageOutputChannels(const cmsStage* mpe)
-{
-    return mpe ->OutputChannels;
-}
-
-cmsStageSignature CMSEXPORT cmsStageType(const cmsStage* mpe)
-{
-    return mpe -> Type;
-}
-
-void* CMSEXPORT cmsStageData(const cmsStage* mpe)
-{
-    return mpe -> Data;
-}
-
-cmsStage*  CMSEXPORT cmsStageNext(const cmsStage* mpe)
-{
-    return mpe -> Next;
-}
-
-
-// Duplicates an MPE
-cmsStage* CMSEXPORT cmsStageDup(cmsStage* mpe)
-{
-    cmsStage* NewMPE;
-    
-    if (mpe == NULL) return NULL;
-    NewMPE = _cmsStageAllocPlaceholder(mpe ->ContextID, 
-                                     mpe ->Type, 
-                                     mpe ->InputChannels, 
-                                     mpe ->OutputChannels,
-                                     mpe ->EvalPtr,
-                                     mpe ->DupElemPtr,
-                                     mpe ->FreePtr,
-                                     NULL);
-    if (NewMPE == NULL) return NULL;
-  
-    NewMPE ->Implements     = mpe ->Implements;
- 
-    if (mpe ->DupElemPtr) 
-        NewMPE ->Data       = mpe ->DupElemPtr(mpe);
-    else
-        NewMPE ->Data       = NULL;
-
-    return NewMPE;
-}
-
-
-// ***********************************************************************************************************
-
-// This function sets up the channel count
-
-static
-void BlessLUT(cmsPipeline* lut)
-{
-    // We can set the input/ouput channels only if we have elements. 
-    if (lut ->Elements != NULL) {
-
-        cmsStage *First, *Last;
-
-        First  = cmsPipelineGetPtrToFirstStage(lut);
-        Last   = cmsPipelineGetPtrToLastStage(lut);
-
-        if (First != NULL)lut ->InputChannels = First ->InputChannels;
-        if (Last != NULL) lut ->OutputChannels = Last ->OutputChannels;
-    }
-}
-
-
-// Default to evaluate the LUT on 16 bit-basis. Precision is retained. 
-static
-void _LUTeval16(register const cmsUInt16Number In[], register cmsUInt16Number Out[],  register const void* D)
-{
-    cmsPipeline* lut = (cmsPipeline*) D;
-    cmsStage *mpe;   
-    cmsFloat32Number Storage[2][MAX_STAGE_CHANNELS];
-    int Phase = 0, NextPhase;
-    
-    From16ToFloat(In, &Storage[Phase][0], lut ->InputChannels);
-
-    for (mpe = lut ->Elements; 
-         mpe != NULL; 
-         mpe = mpe ->Next) {
-
-             NextPhase = Phase ^ 1;            
-             mpe ->EvalPtr(&Storage[Phase][0], &Storage[NextPhase][0], mpe);
-             Phase = NextPhase;
-    }
-    
-
-    FromFloatTo16(&Storage[Phase][0], Out, lut ->OutputChannels);
-}
-
-
-
-// Does evaluate the LUT on cmsFloat32Number-basis. 
-static
-void _LUTevalFloat(register const cmsFloat32Number In[], register cmsFloat32Number Out[], const void* D)
-{
-    cmsPipeline* lut = (cmsPipeline*) D;
-    cmsStage *mpe;   
-    cmsFloat32Number Storage[2][MAX_STAGE_CHANNELS];
-    int Phase = 0, NextPhase;
-    
-    memmove(&Storage[Phase][0], In, lut ->InputChannels  * sizeof(cmsFloat32Number));
-
-    for (mpe = lut ->Elements; 
-         mpe != NULL; 
-         mpe = mpe ->Next) {
-
-              NextPhase = Phase ^ 1;
-              mpe ->EvalPtr(&Storage[Phase][0], &Storage[NextPhase][0], mpe);
-              Phase = NextPhase;          
-    }
-
-    memmove(Out, &Storage[Phase][0], lut ->OutputChannels * sizeof(cmsFloat32Number));
-}
-
-
-
-
-// LUT Creation & Destruction
-
-cmsPipeline* CMSEXPORT cmsPipelineAlloc(cmsContext ContextID, cmsUInt32Number InputChannels, cmsUInt32Number OutputChannels)
-{
-       cmsPipeline* NewLUT;
-
-       if (InputChannels >= cmsMAXCHANNELS ||
-           OutputChannels >= cmsMAXCHANNELS) return NULL;
-
-       NewLUT = (cmsPipeline*) _cmsMallocZero(ContextID, sizeof(cmsPipeline));
-       if (NewLUT == NULL) return NULL;
-
-
-       NewLUT -> InputChannels  = InputChannels;
-       NewLUT -> OutputChannels = OutputChannels;
-
-       NewLUT ->Eval16Fn    = _LUTeval16;
-       NewLUT ->EvalFloatFn = _LUTevalFloat;
-       NewLUT ->DupDataFn   = NULL;
-       NewLUT ->FreeDataFn  = NULL;
-       NewLUT ->Data        = NewLUT;     
-       NewLUT ->ContextID   = ContextID;
-
-       BlessLUT(NewLUT);
-
-       return NewLUT;
-}
-
-
-cmsUInt32Number CMSEXPORT cmsPipelineInputChannels(const cmsPipeline* lut)
-{
-    return lut ->InputChannels;
-}
-
-cmsUInt32Number CMSEXPORT cmsPipelineOutputChannels(const cmsPipeline* lut)
-{
-    return lut ->OutputChannels;
-}
-
-// Free a profile elements LUT
-void CMSEXPORT cmsPipelineFree(cmsPipeline* lut)
-{
-    cmsStage *mpe, *Next;   
-
-    if (lut == NULL) return;
-
-    for (mpe = lut ->Elements; 
-        mpe != NULL; 
-        mpe = Next) {
-
-            Next = mpe ->Next;
-            cmsStageFree(mpe);            
-    }
-
-    if (lut ->FreeDataFn) lut ->FreeDataFn(lut ->ContextID, lut ->Data);
-
-    _cmsFree(lut ->ContextID, lut);
-}
-
-
-// Default to evaluate the LUT on 16 bit-basis. 
-void CMSEXPORT cmsPipelineEval16(const cmsUInt16Number In[], cmsUInt16Number Out[],  const cmsPipeline* lut)
-{
-    lut ->Eval16Fn(In, Out, lut->Data);
-}
-
-
-// Does evaluate the LUT on cmsFloat32Number-basis. 
-void CMSEXPORT cmsPipelineEvalFloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsPipeline* lut)
-{
-    lut ->EvalFloatFn(In, Out, lut);
-}
-
-
-
-// Duplicates a LUT
-cmsPipeline* CMSEXPORT cmsPipelineDup(const cmsPipeline* lut)
-{
-    cmsPipeline* NewLUT;
-    cmsStage *NewMPE, *Anterior = NULL, *mpe;   
-    cmsBool  First = TRUE;
-
-    if (lut == NULL) return NULL;
-
-    NewLUT = cmsPipelineAlloc(lut ->ContextID, lut ->InputChannels, lut ->OutputChannels);  
-    for (mpe = lut ->Elements; 
-         mpe != NULL; 
-         mpe = mpe ->Next) {
-
-             NewMPE = cmsStageDup(mpe);
-
-             if (NewMPE == NULL) {
-                 cmsPipelineFree(NewLUT);
-                 return NULL;
-             }
-    
-             if (First) {
-                 NewLUT ->Elements = NewMPE;
-                 First = FALSE;
-             }
-             else {
-                Anterior ->Next = NewMPE;               
-             }
-
-            Anterior = NewMPE;
-    }
-
-    NewLUT ->DupDataFn  = lut ->DupDataFn;
-    NewLUT ->FreeDataFn = lut ->FreeDataFn;
-
-    if (NewLUT ->DupDataFn != NULL) 
-        NewLUT ->Data = NewLUT ->DupDataFn(lut ->ContextID, lut->Data);
-
-
-    NewLUT ->SaveAs8Bits    = lut ->SaveAs8Bits;
-
-    BlessLUT(NewLUT);
-    return NewLUT;
-}
-
-
-void CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
-{
-    cmsStage* Anterior = NULL, *pt;
-
-    _cmsAssert(lut != NULL);
-    _cmsAssert(mpe != NULL);
-
-    switch (loc) {
-
-        case cmsAT_BEGIN:
-            mpe ->Next = lut ->Elements;
-            lut ->Elements = mpe;
-            break;
-
-        case cmsAT_END:
-
-            if (lut ->Elements == NULL) 
-                lut ->Elements = mpe;
-            else {
-            
-                for (pt = lut ->Elements;
-                     pt != NULL;
-                     pt = pt -> Next) Anterior = pt;
-
-                Anterior ->Next = mpe;
-                mpe ->Next = NULL;
-            }
-            break;
-        default:;
-    }
-
-    BlessLUT(lut);
-}
-
-// Unlink an element and return the pointer to it
-void CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe)
-{
-    cmsStage *Anterior, *pt, *Last;
-    cmsStage *Unlinked = NULL;
-
-    
-    // If empty LUT, there is nothing to remove
-    if (lut ->Elements == NULL) {
-        if (mpe) *mpe = NULL;
-        return;
-    }
-
-    // On depending on the strategy...
-    switch (loc) {
-
-        case cmsAT_BEGIN: 
-            {
-                cmsStage* elem = lut ->Elements;
-             
-                lut ->Elements = elem -> Next;
-                elem ->Next = NULL;
-                Unlinked = elem;
-                           
-            }
-            break;
-
-        case cmsAT_END:
-            Anterior = Last = NULL;
-            for (pt = lut ->Elements;
-                pt != NULL;
-                pt = pt -> Next) {
-                    Anterior = Last;
-                    Last = pt;              
-            }
-
-            Unlinked = Last;  // Next already points to NULL
-
-            // Truncate the chain
-            if (Anterior) 
-                Anterior ->Next = NULL;
-            else 
-                lut ->Elements = NULL;
-            break;
-        default:;
-    }
-
-    if (mpe) 
-        *mpe = Unlinked;
-    else
-        cmsStageFree(Unlinked);
-
-    BlessLUT(lut);
-}
-
-
-// Concatenate two LUT into a new single one
-cmsBool  CMSEXPORT cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2)
-{
-    cmsStage* mpe, *NewMPE;
-
-    // If both LUTS does not have elements, we need to inherit 
-    // the number of channels
-    if (l1 ->Elements == NULL && l2 ->Elements == NULL) {
-        l1 ->InputChannels  = l2 ->InputChannels;
-        l1 ->OutputChannels = l2 ->OutputChannels;
-    }
-
-    // Cat second
-    for (mpe = l2 ->Elements; 
-         mpe != NULL; 
-         mpe = mpe ->Next) {
-
-            // We have to dup each element
-             NewMPE = cmsStageDup(mpe);
-
-             if (NewMPE == NULL) {
-                 return FALSE;
-             }
-    
-             cmsPipelineInsertStage(l1, cmsAT_END, NewMPE);
-    }
-
-  BlessLUT(l1);
-  return TRUE;
-}
-
-
-cmsBool CMSEXPORT cmsPipelineSetSaveAs8bitsFlag(cmsPipeline* lut, cmsBool On)
-{
-    cmsBool Anterior = lut ->SaveAs8Bits;
-
-    lut ->SaveAs8Bits = On;
-    return Anterior;
-}
-
-
-cmsStage* CMSEXPORT cmsPipelineGetPtrToFirstStage(const cmsPipeline* lut)
-{
-    return lut ->Elements;
-}
-
-cmsStage* CMSEXPORT cmsPipelineGetPtrToLastStage(const cmsPipeline* lut)
-{
-    cmsStage *mpe, *Anterior = NULL;
-
-    for (mpe = lut ->Elements; mpe != NULL; mpe = mpe ->Next)
-        Anterior = mpe;
-
-    return Anterior;
-}
-
-cmsUInt32Number CMSEXPORT cmsPipelineStageCount(const cmsPipeline* lut)
-{
-    cmsStage *mpe;
-    cmsUInt32Number n;
-
-    for (n=0, mpe = lut ->Elements; mpe != NULL; mpe = mpe ->Next)
-            n++;
-
-    return n;
-}
-
-// This function may be used to set the optional evalueator and a block of private data. If private data is being used, an optional
-// duplicator and free functions should also be specified in order to duplicate the LUT construct. Use NULL to inhibit such functionality.
-void CMSEXPORT _cmsPipelineSetOptimizationParameters(cmsPipeline* Lut, 
-                                        _cmsOPTeval16Fn Eval16, 
-                                        void* PrivateData, 
-                                        _cmsOPTfreeDataFn FreePrivateDataFn, 
-                                        _cmsOPTdupDataFn DupPrivateDataFn)
-{
-
-    Lut ->Eval16Fn = Eval16;
-    Lut ->DupDataFn = DupPrivateDataFn;
-    Lut ->FreeDataFn = FreePrivateDataFn;   
-    Lut ->Data = PrivateData;
-}
-
-
-// ----------------------------------------------------------- Reverse interpolation
-// Here's how it goes. The derivative Df(x) of the function f is the linear 
-// transformation that best approximates f near the point x. It can be represented 
-// by a matrix A whose entries are the partial derivatives of the components of f 
-// with respect to all the coordinates. This is know as the Jacobian
-//
-// The best linear approximation to f is given by the matrix equation: 
-// 
-// y-y0 = A (x-x0) 
-// 
-// So, if x0 is a good "guess" for the zero of f, then solving for the zero of this 
-// linear approximation will give a "better guess" for the zero of f. Thus let y=0, 
-// and since y0=f(x0) one can solve the above equation for x. This leads to the 
-// Newton's method formula: 
-//
-// xn+1 = xn - A-1 f(xn) 
-// 
-// where xn+1 denotes the (n+1)-st guess, obtained from the n-th guess xn in the 
-// fashion described above. Iterating this will give better and better approximations 
-// if you have a "good enough" initial guess. 
-
-
-#define JACOBIAN_EPSILON            0.001f
-#define INVERSION_MAX_ITERATIONS    30
-
-// Increment with reflexion on boundary
-static 
-void IncDelta(cmsFloat32Number *Val)
-{
-    if (*Val < (1.0 - JACOBIAN_EPSILON)) 
-
-        *Val += JACOBIAN_EPSILON;
-    
-    else 
-        *Val -= JACOBIAN_EPSILON;
-    
-}
-
-
-
-// Euclidean distance between two vectors of n elements each one
-static
-cmsFloat32Number EuclideanDistance(cmsFloat32Number a[], cmsFloat32Number b[], int n)
-{
-    cmsFloat32Number sum = 0;
-    int i;
-
-    for (i=0; i < n; i++) {
-        cmsFloat32Number dif = b[i] - a[i];
-        sum +=  dif * dif;
-    }
-
-    return sqrtf(sum);
-}
-
-
-// Evaluate a LUT in reverse direction. It only searches on 3->3 LUT. Uses Newton method
-//
-// x1 <- x - [J(x)]^-1 * f(x)
-// 
-// lut: The LUT on where to do the search
-// Target: LabK, 3 values of Lab plus destination K which is fixed
-// Result: The obtained CMYK
-// Hint:   Location where begin the search
-
-cmsBool CMSEXPORT cmsPipelineEvalReverseFloat(cmsFloat32Number Target[],
-                                              cmsFloat32Number Result[],
-                                              cmsFloat32Number Hint[],
-                                              const cmsPipeline* lut)
-{
-    cmsUInt32Number  i, j;
-    cmsFloat64Number  error, LastError = 1E20;    
-    cmsFloat32Number  fx[4], x[4], xd[4], fxd[4];
-    cmsVEC3 tmp, tmp2;
-    cmsMAT3 Jacobian;    
-    cmsFloat64Number LastResult[4];
-
-
-    // Only 3->3 and 4->3 are supported
-    if (lut ->InputChannels != 3 && lut ->InputChannels != 4) return FALSE;
-    if (lut ->OutputChannels != 3) return FALSE;
-
-    // Mark result of -1
-    LastResult[0] = LastResult[1] = LastResult[2] = -1.0f;
-
-    // Take the hint as starting point if specified
-    if (Hint == NULL) {
-
-        // Begin at any point, we choose 1/3 of CMY axis
-        x[0] = x[1] = x[2] = 0.3f;
-    }
-    else {
-
-        // Only copy 3 channels from hint...
-        for (j=0; j < 3; j++) 
-            x[j] = Hint[j];         
-    }
-    
-    // If Lut is 4-dimensions, then grab target[3], which is fixed
-    if (lut ->InputChannels == 4) {
-        x[3] = Target[3];
-    }
-    else x[3] = 0; // To keep lint happy
-
-
-    // Iterate    
-    for (i = 0; i < INVERSION_MAX_ITERATIONS; i++) {
-
-        // Get beginning fx
-        cmsPipelineEvalFloat(x, fx, lut);
-
-        // Compute error
-        error = EuclideanDistance(fx, Target, 3);
-
-        // If not convergent, return last safe value
-        if (error >= LastError) 
-            break;
-
-        // Keep latest values
-        LastError     = error;
-        for (j=0; j < lut ->InputChannels; j++) 
-                Result[j] = x[j]; 
-
-        // Found an exact match?
-        if (error <= 0) 
-            break;
-
-        // Obtain slope (the Jacobian)              
-        for (j = 0; j < 3; j++) {
-
-            xd[0] = x[0];
-            xd[1] = x[1];
-            xd[2] = x[2];
-            xd[3] = x[3];  // Keep fixed channel
-
-            IncDelta(&xd[j]);
-
-            cmsPipelineEvalFloat(xd, fxd, lut);
-
-            Jacobian.v[0].n[j] = ((fxd[0] - fx[0]) / JACOBIAN_EPSILON);
-            Jacobian.v[1].n[j] = ((fxd[1] - fx[1]) / JACOBIAN_EPSILON);
-            Jacobian.v[2].n[j] = ((fxd[2] - fx[2]) / JACOBIAN_EPSILON);        
-        }
-
-        // Solve system
-        tmp2.n[0] = fx[0] - Target[0];
-        tmp2.n[1] = fx[1] - Target[1];
-        tmp2.n[2] = fx[2] - Target[2];
-
-        if (!_cmsMAT3solve(&tmp, &Jacobian, &tmp2))
-            return FALSE;
-
-        // Move our guess
-        x[0] -= (cmsFloat32Number) tmp.n[0];
-        x[1] -= (cmsFloat32Number) tmp.n[1];
-        x[2] -= (cmsFloat32Number) tmp.n[2];
-
-        // Some clipping....
-        for (j=0; j < 3; j++) {
-            if (x[j] < 0) x[j] = 0;
-            else
-                if (x[j] > 1.0) x[j] = 1.0;
-        }
-    }
-
-    return TRUE;
-}
-
diff --git a/thirdparty/liblcms2/src/cmsmd5.c b/thirdparty/liblcms2/src/cmsmd5.c
deleted file mode 100644
index ecf3d90..0000000
--- a/thirdparty/liblcms2/src/cmsmd5.c
+++ /dev/null
@@ -1,317 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-
-
-#include "lcms2_internal.h"
-
-#ifdef CMS_USE_BIG_ENDIAN
-
-static
-void byteReverse(cmsUInt8Number * buf, cmsUInt32Number longs)
-{
-    do {
-
-        cmsUInt32Number t = _cmsAdjustEndianess32(*(cmsUInt32Number *) buf);
-        *(cmsUInt32Number *) buf = t;
-        buf += sizeof(cmsUInt32Number);
-
-    } while (--longs);
-
-}
-
-#else
-#define byteReverse(buf, len)   
-#endif
-
-
-typedef struct {
-
-    cmsUInt32Number buf[4];
-    cmsUInt32Number bits[2];
-    cmsUInt8Number in[64];
-    cmsContext ContextID;
-
-} _cmsMD5;
-
-#define F1(x, y, z) (z ^ (x & (y ^ z)))
-#define F2(x, y, z) F1(z, x, y)
-#define F3(x, y, z) (x ^ y ^ z)
-#define F4(x, y, z) (y ^ (x | ~z))
-
-#define STEP(f, w, x, y, z, data, s) \
-    ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-
-static
-void MD5_Transform(cmsUInt32Number buf[4], cmsUInt32Number in[16])
-    
-{
-    register cmsUInt32Number a, b, c, d;
-
-    a = buf[0];
-    b = buf[1];
-    c = buf[2];
-    d = buf[3];
-
-    STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
-    STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
-    STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
-    STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
-    STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
-    STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
-    STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
-    STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
-    STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
-    STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
-    STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
-    STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
-    STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
-    STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
-    STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
-    STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
-
-    STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
-    STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
-    STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
-    STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
-    STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
-    STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
-    STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
-    STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
-    STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
-    STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
-    STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
-    STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
-    STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
-    STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
-    STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
-    STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
-
-    STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
-    STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
-    STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
-    STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
-    STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
-    STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
-    STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
-    STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
-    STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
-    STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
-    STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
-    STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
-    STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
-    STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
-    STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
-    STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
-
-    STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
-    STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
-    STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
-    STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
-    STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
-    STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
-    STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
-    STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
-    STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
-    STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
-    STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
-    STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
-    STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
-    STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
-    STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
-    STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
-
-    buf[0] += a;
-    buf[1] += b;
-    buf[2] += c;
-    buf[3] += d;
-}
-
-
-// Create a MD5 object
-static
-cmsHANDLE  MD5alloc(cmsContext ContextID)
-{
-    _cmsMD5* ctx = (_cmsMD5*) _cmsMallocZero(ContextID, sizeof(_cmsMD5));
-    if (ctx == NULL) return NULL;
-
-    ctx ->ContextID = ContextID;
-
-    ctx->buf[0] = 0x67452301;
-    ctx->buf[1] = 0xefcdab89;
-    ctx->buf[2] = 0x98badcfe;
-    ctx->buf[3] = 0x10325476;
-
-    ctx->bits[0] = 0;
-    ctx->bits[1] = 0;
-
-    return (cmsHANDLE) ctx;
-}
-
-
-static
-void MD5add(cmsHANDLE Handle, cmsUInt8Number* buf, cmsUInt32Number len)
-{
-    _cmsMD5* ctx = (_cmsMD5*) Handle;
-    cmsUInt32Number t;
-    
-    t = ctx->bits[0];
-    if ((ctx->bits[0] = t + (len << 3)) < t)
-        ctx->bits[1]++; 
-
-    ctx->bits[1] += len >> 29;
-
-    t = (t >> 3) & 0x3f;    
-
-    if (t) {
-
-        cmsUInt8Number *p = (cmsUInt8Number *) ctx->in + t;
-
-        t = 64 - t;
-        if (len < t) {
-            memmove(p, buf, len);
-            return;
-        }
-
-        memmove(p, buf, t);
-        byteReverse(ctx->in, 16);
-
-        MD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);
-        buf += t;
-        len -= t;
-    }
-
-    while (len >= 64) {
-        memmove(ctx->in, buf, 64);
-        byteReverse(ctx->in, 16);
-        MD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);
-        buf += 64;
-        len -= 64;
-    }
-
-    memmove(ctx->in, buf, len);
-}
-
-// Destroy the object and return the checksum
-static
-void MD5finish(cmsProfileID* ProfileID,  cmsHANDLE Handle)
-{
-    _cmsMD5* ctx = (_cmsMD5*) Handle;
-    cmsUInt32Number count;
-    cmsUInt8Number *p;
-
-    count = (ctx->bits[0] >> 3) & 0x3F;
-
-    p = ctx->in + count;
-    *p++ = 0x80;
-
-    count = 64 - 1 - count;
-
-    if (count < 8) {
-
-        memset(p, 0, count);
-        byteReverse(ctx->in, 16);
-        MD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);
-
-        memset(ctx->in, 0, 56);
-    } else {
-        memset(p, 0, count - 8);
-    }
-    byteReverse(ctx->in, 14);
-
-    ((cmsUInt32Number *) ctx->in)[14] = ctx->bits[0];
-    ((cmsUInt32Number *) ctx->in)[15] = ctx->bits[1];
-
-    MD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);
-
-    byteReverse((cmsUInt8Number *) ctx->buf, 4);
-    memmove(ProfileID ->ID8, ctx->buf, 16);
-
-    _cmsFree(ctx ->ContextID, ctx);
-}
-
-
-
-// Assuming io points to an ICC profile, compute and store MD5 checksum
-// In the header, rendering intentent, attributes and ID should be set to zero
-// before computing MD5 checksum (per 6.1.13 in ICC spec)
-
-cmsBool CMSEXPORT cmsMD5computeID(cmsHPROFILE hProfile)
-{
-    cmsContext   ContextID;
-    cmsUInt32Number BytesNeeded;
-    cmsUInt8Number* Mem = NULL;
-    cmsHANDLE  MD5 = NULL;
-    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
-    _cmsICCPROFILE Keep;              
-
-	_cmsAssert(hProfile != NULL);
-
-    ContextID = cmsGetProfileContextID(hProfile);
-
-    // Save a copy of the profile header
-    memmove(&Keep, Icc, sizeof(_cmsICCPROFILE));
-    
-    // Set RI, attributes and ID
-    memset(&Icc ->attributes, 0, sizeof(Icc ->attributes));
-    Icc ->RenderingIntent = 0;
-    memset(&Icc ->ProfileID, 0, sizeof(Icc ->ProfileID));
-
-    // Compute needed storage
-    if (!cmsSaveProfileToMem(hProfile, NULL, &BytesNeeded)) goto Error;
-
-    // Allocate memory
-    Mem = (cmsUInt8Number*) _cmsMalloc(ContextID, BytesNeeded);
-    if (Mem == NULL) goto Error;
-
-    // Save to temporary storage
-    if (!cmsSaveProfileToMem(hProfile, Mem, &BytesNeeded)) goto Error;
-     
-    // Create MD5 object
-    MD5 = MD5alloc(ContextID);
-    if (MD5 == NULL) goto Error;
-
-    // Add all bytes
-    MD5add(MD5, Mem, BytesNeeded);
-
-    // Temp storage is no longer needed
-    _cmsFree(ContextID, Mem);
-    
-    // Restore header
-    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
-
-    // And store the ID
-    MD5finish(&Icc ->ProfileID,  MD5);
-    return TRUE;
-
-Error:
-
-    // Free resources as something went wrong
-    if (MD5 != NULL) _cmsFree(ContextID, MD5);
-    if (Mem != NULL) _cmsFree(ContextID, Mem);
-    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
-    return FALSE;
-}
-
diff --git a/thirdparty/liblcms2/src/cmsmtrx.c b/thirdparty/liblcms2/src/cmsmtrx.c
deleted file mode 100644
index 84035c9..0000000
--- a/thirdparty/liblcms2/src/cmsmtrx.c
+++ /dev/null
@@ -1,176 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-#define DSWAP(x, y)     {cmsFloat64Number tmp = (x); (x)=(y); (y)=tmp;}
-
-
-// Initiate a vector 
-void CMSEXPORT _cmsVEC3init(cmsVEC3* r, cmsFloat64Number x, cmsFloat64Number y, cmsFloat64Number z)
-{
-    r -> n[VX] = x;
-    r -> n[VY] = y;
-    r -> n[VZ] = z;
-}
-
-// Vector substraction
-void CMSEXPORT _cmsVEC3minus(cmsVEC3* r, const cmsVEC3* a, const cmsVEC3* b)
-{
-  r -> n[VX] = a -> n[VX] - b -> n[VX];
-  r -> n[VY] = a -> n[VY] - b -> n[VY];
-  r -> n[VZ] = a -> n[VZ] - b -> n[VZ];
-}
-
-// Vector cross product
-void CMSEXPORT _cmsVEC3cross(cmsVEC3* r, const cmsVEC3* u, const cmsVEC3* v)
-{
-    r ->n[VX] = u->n[VY] * v->n[VZ] - v->n[VY] * u->n[VZ];
-    r ->n[VY] = u->n[VZ] * v->n[VX] - v->n[VZ] * u->n[VX];
-    r ->n[VZ] = u->n[VX] * v->n[VY] - v->n[VX] * u->n[VY];
-}
-
-// Vector dot product
-cmsFloat64Number CMSEXPORT _cmsVEC3dot(const cmsVEC3* u, const cmsVEC3* v)
-{
-    return u->n[VX] * v->n[VX] + u->n[VY] * v->n[VY] + u->n[VZ] * v->n[VZ];
-}
-
-// Euclidean length 
-cmsFloat64Number CMSEXPORT _cmsVEC3length(const cmsVEC3* a)
-{
-    return sqrt(a ->n[VX] * a ->n[VX] +
-                a ->n[VY] * a ->n[VY] +
-                a ->n[VZ] * a ->n[VZ]);
-}
-
-// Euclidean distance
-cmsFloat64Number CMSEXPORT _cmsVEC3distance(const cmsVEC3* a, const cmsVEC3* b)
-{
-    cmsFloat64Number d1 = a ->n[VX] - b ->n[VX];
-    cmsFloat64Number d2 = a ->n[VY] - b ->n[VY];
-    cmsFloat64Number d3 = a ->n[VZ] - b ->n[VZ];
-
-    return sqrt(d1*d1 + d2*d2 + d3*d3);
-}
-
-
-
-// 3x3 Identity
-void CMSEXPORT _cmsMAT3identity(cmsMAT3* a)
-{
-    _cmsVEC3init(&a-> v[0], 1.0, 0.0, 0.0);
-    _cmsVEC3init(&a-> v[1], 0.0, 1.0, 0.0);
-    _cmsVEC3init(&a-> v[2], 0.0, 0.0, 1.0);
-}
-
-static
-cmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)
-{
-    return fabs(b - a) < (1.0 / 65535.0);
-}
-
-
-cmsBool CMSEXPORT _cmsMAT3isIdentity(const cmsMAT3* a)
-{
-	cmsMAT3 Identity;
-	int i, j;
-
-	_cmsMAT3identity(&Identity);
-
-	for (i=0; i < 3; i++)
-		for (j=0; j < 3; j++)
-			if (!CloseEnough(a ->v[i].n[j], Identity.v[i].n[j])) return FALSE;
-
-	return TRUE;
-}
-
-
-// Multiply two matrices
-void CMSEXPORT _cmsMAT3per(cmsMAT3* r, const cmsMAT3* a, const cmsMAT3* b)
-{
-#define ROWCOL(i, j) \
-    a->v[i].n[0]*b->v[0].n[j] + a->v[i].n[1]*b->v[1].n[j] + a->v[i].n[2]*b->v[2].n[j]
-
-    _cmsVEC3init(&r-> v[0], ROWCOL(0,0), ROWCOL(0,1), ROWCOL(0,2));
-    _cmsVEC3init(&r-> v[1], ROWCOL(1,0), ROWCOL(1,1), ROWCOL(1,2));
-    _cmsVEC3init(&r-> v[2], ROWCOL(2,0), ROWCOL(2,1), ROWCOL(2,2));
-
-#undef ROWCOL //(i, j)
-}
-
-
-
-// Inverse of a matrix b = a^(-1)
-cmsBool  CMSEXPORT _cmsMAT3inverse(const cmsMAT3* a, cmsMAT3* b)
-{
-   cmsFloat64Number det, c0, c1, c2;
-
-   c0 =  a -> v[1].n[1]*a -> v[2].n[2] - a -> v[1].n[2]*a -> v[2].n[1];
-   c1 = -a -> v[1].n[0]*a -> v[2].n[2] + a -> v[1].n[2]*a -> v[2].n[0];
-   c2 =  a -> v[1].n[0]*a -> v[2].n[1] - a -> v[1].n[1]*a -> v[2].n[0];
-
-   det = a -> v[0].n[0]*c0 + a -> v[0].n[1]*c1 + a -> v[0].n[2]*c2;
-
-   if (fabs(det) < MATRIX_DET_TOLERANCE) return FALSE;  // singular matrix; can't invert
-
-   b -> v[0].n[0] = c0/det;
-   b -> v[0].n[1] = (a -> v[0].n[2]*a -> v[2].n[1] - a -> v[0].n[1]*a -> v[2].n[2])/det;
-   b -> v[0].n[2] = (a -> v[0].n[1]*a -> v[1].n[2] - a -> v[0].n[2]*a -> v[1].n[1])/det;
-   b -> v[1].n[0] = c1/det;
-   b -> v[1].n[1] = (a -> v[0].n[0]*a -> v[2].n[2] - a -> v[0].n[2]*a -> v[2].n[0])/det;
-   b -> v[1].n[2] = (a -> v[0].n[2]*a -> v[1].n[0] - a -> v[0].n[0]*a -> v[1].n[2])/det;
-   b -> v[2].n[0] = c2/det;
-   b -> v[2].n[1] = (a -> v[0].n[1]*a -> v[2].n[0] - a -> v[0].n[0]*a -> v[2].n[1])/det;
-   b -> v[2].n[2] = (a -> v[0].n[0]*a -> v[1].n[1] - a -> v[0].n[1]*a -> v[1].n[0])/det;
-
-   return TRUE;
-}
-
-
-// Solve a system in the form Ax = b
-cmsBool  CMSEXPORT _cmsMAT3solve(cmsVEC3* x, cmsMAT3* a, cmsVEC3* b)
-{
-    cmsMAT3 m, a_1;
-
-    memmove(&m, a, sizeof(cmsMAT3));
-
-    if (!_cmsMAT3inverse(&m, &a_1)) return FALSE;  // Singular matrix
-
-    _cmsMAT3eval(x, &a_1, b);
-    return TRUE;
-}
-
-// Evaluate a vector across a matrix
-void CMSEXPORT _cmsMAT3eval(cmsVEC3* r, const cmsMAT3* a, const cmsVEC3* v)
-{
-    r->n[VX] = a->v[0].n[VX]*v->n[VX] + a->v[0].n[VY]*v->n[VY] + a->v[0].n[VZ]*v->n[VZ];
-    r->n[VY] = a->v[1].n[VX]*v->n[VX] + a->v[1].n[VY]*v->n[VY] + a->v[1].n[VZ]*v->n[VZ];
-    r->n[VZ] = a->v[2].n[VX]*v->n[VX] + a->v[2].n[VY]*v->n[VY] + a->v[2].n[VZ]*v->n[VZ];
-}
-
-
diff --git a/thirdparty/liblcms2/src/cmsnamed.c b/thirdparty/liblcms2/src/cmsnamed.c
deleted file mode 100644
index d1a86b6..0000000
--- a/thirdparty/liblcms2/src/cmsnamed.c
+++ /dev/null
@@ -1,750 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Multilocalized unicode objects. That is an attempt to encapsulate i18n.
-
-
-// Allocates an empty multi localizad unicode object
-cmsMLU* CMSEXPORT cmsMLUalloc(cmsContext ContextID, cmsUInt32Number nItems)
-{
-	cmsMLU* mlu;
-
-	// nItems should be positive if given
-	if (nItems <= 0) nItems = 2;
-
-	// Create the container
-	mlu = (cmsMLU*) _cmsMallocZero(ContextID, sizeof(cmsMLU));
-	if (mlu == NULL) return NULL;
-
-	mlu ->ContextID = ContextID;
-
-	// Create entry array
-	mlu ->Entries = (_cmsMLUentry*) _cmsCalloc(ContextID, nItems, sizeof(_cmsMLUentry));
-	if (mlu ->Entries == NULL) {
-		_cmsFree(ContextID, mlu);
-		return NULL;
-	}
-
-	// Ok, keep indexes up to date
-	mlu ->AllocatedEntries    = nItems;
-	mlu ->UsedEntries         = 0;
-
-	return mlu;
-}
-
-
-// Grows a mempool table for a MLU. Each time this function is called, mempool size is multiplied times two. 
-static
-cmsBool GrowMLUpool(cmsMLU* mlu)
-{
-	cmsUInt32Number size;
-	void *NewPtr;
-
-	// Sanity check
-	if (mlu == NULL) return FALSE;
-
-	if (mlu ->PoolSize == 0)
-		size = 256;
-	else 
-		size = mlu ->PoolSize * 2;
-
-	// Check for overflow
-	if (size < mlu ->PoolSize) return FALSE;
-
-	// Reallocate the pool
-	NewPtr = _cmsRealloc(mlu ->ContextID, mlu ->MemPool, size);
-	if (NewPtr == NULL) return FALSE;
-
-
-	mlu ->MemPool  = NewPtr;
-	mlu ->PoolSize = size;
-
-	return TRUE;
-}
-
-
-// Grows a ntry table for a MLU. Each time this function is called, table size is multiplied times two. 
-static
-cmsBool GrowMLUtable(cmsMLU* mlu)
-{
-    int AllocatedEntries;
-    _cmsMLUentry *NewPtr;
-	
-	// Sanity check
-	if (mlu == NULL) return FALSE;
-
-    AllocatedEntries = mlu ->AllocatedEntries * 2;
-
-	// Check for overflow
-	if (AllocatedEntries / 2 != mlu ->AllocatedEntries) return FALSE;
-
-	// Reallocate the memory
-    NewPtr = (_cmsMLUentry*)_cmsRealloc(mlu ->ContextID, mlu ->Entries, AllocatedEntries*sizeof(_cmsMLUentry));
-    if (NewPtr == NULL) return FALSE;
-    
-    mlu ->Entries          = NewPtr;
-    mlu ->AllocatedEntries = AllocatedEntries;
-
-    return TRUE;
-}
-
-
-// Search for a specific entry in the structure. Language and Country are used. 
-static
-int SearchMLUEntry(cmsMLU* mlu, cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode)
-{
-    int i;
-	
-	// Sanity check
-	if (mlu == NULL) return -1;
-
-	// Iterate whole table
-    for (i=0; i < mlu ->UsedEntries; i++) {
-
-        if (mlu ->Entries[i].Country  == CountryCode && 
-            mlu ->Entries[i].Language == LanguageCode) return i;
-    }
-
-	// Not found
-    return -1;
-}
-
-// Add a block of characters to the intended MLU. Language and country are specified. 
-// Only one entry for Language/country pair is allowed.
-static
-cmsBool AddMLUBlock(cmsMLU* mlu, cmsUInt32Number size, const wchar_t *Block, 
-                     cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode)
-{
-    cmsUInt32Number Offset;
-    cmsUInt8Number* Ptr;
-
-	// Sanity check
-	if (mlu == NULL) return FALSE;
-
-    // Is there any room available?
-    if (mlu ->UsedEntries >= mlu ->AllocatedEntries) {
-        if (!GrowMLUtable(mlu)) return FALSE;
-    }
-
-    // Only one ASCII string
-    if (SearchMLUEntry(mlu, LanguageCode, CountryCode) >= 0) return FALSE;  // Only one  is allowed!
-
-    // Check for size
-	while ((mlu ->PoolSize - mlu ->PoolUsed) < size) {
-
-            if (!GrowMLUpool(mlu)) return FALSE;
-	}
-
-    Offset = mlu ->PoolUsed;
-    
-	Ptr = (cmsUInt8Number*) mlu ->MemPool;
-	if (Ptr == NULL) return FALSE;
-
-	// Set the entry
-    memmove(Ptr + Offset, Block, size);
-    mlu ->PoolUsed += size;
-    
-    mlu ->Entries[mlu ->UsedEntries].StrW     = Offset;
-    mlu ->Entries[mlu ->UsedEntries].Len      = size;
-    mlu ->Entries[mlu ->UsedEntries].Country  = CountryCode;
-    mlu ->Entries[mlu ->UsedEntries].Language = LanguageCode;
-    mlu ->UsedEntries++;
-
-    return TRUE;
-}
-
-
-// Add an ASCII entry. 
-cmsBool CMSEXPORT cmsMLUsetASCII(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* ASCIIString)
-{
-    cmsUInt32Number i, len = (cmsUInt32Number) strlen(ASCIIString)+1;
-    wchar_t* WStr;
-    cmsBool  rc;
-    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
-    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
-
-    if (mlu == NULL) return FALSE;
-
-    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));
-    if (WStr == NULL) return FALSE;
-
-    for (i=0; i < len; i++)
-        WStr[i] = (wchar_t) ASCIIString[i];
-    
-    rc = AddMLUBlock(mlu, len  * sizeof(wchar_t), WStr, Lang, Cntry);
-
-    _cmsFree(mlu ->ContextID, WStr);
-    return rc;
-    
-}
-
-// We don't need any wcs support library
-static 
-cmsUInt32Number mywcslen(const wchar_t *s)
-{
-    const wchar_t *p;
-
-	p = s;
-    while (*p)
-        p++;
-
-    return (cmsUInt32Number)(p - s);
-}
-
-
-// Add a wide entry
-cmsBool  CMSEXPORT cmsMLUsetWide(cmsMLU* mlu, const char Language[3], const char Country[3], const wchar_t* WideString)
-{
-    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) Language);
-    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) Country);
-    cmsUInt32Number len;
-    
-    if (mlu == NULL) return FALSE;
-	if (WideString == NULL) return FALSE;
-
-    len = (cmsUInt32Number) (mywcslen(WideString) + 1) * sizeof(wchar_t);
-    return AddMLUBlock(mlu, len, WideString, Lang, Cntry);
-}
-
-// Duplicating a MLU is as easy as copying all members
-cmsMLU* CMSEXPORT cmsMLUdup(const cmsMLU* mlu)
-{
-	cmsMLU* NewMlu = NULL;
-
-	// Duplicating a NULL obtains a NULL
-	if (mlu == NULL) return NULL;
-
-	NewMlu = cmsMLUalloc(mlu ->ContextID, mlu ->UsedEntries);
-	if (NewMlu == NULL) return NULL;
-
-	// Should never happen
-	if (NewMlu ->AllocatedEntries < mlu ->UsedEntries)
-		goto Error;
-
-	// Sanitize...
-	if (NewMlu ->Entries == NULL || mlu ->Entries == NULL)  goto Error;
-
-	memmove(NewMlu ->Entries, mlu ->Entries, mlu ->UsedEntries * sizeof(_cmsMLUentry));
-	NewMlu ->UsedEntries = mlu ->UsedEntries;
-
-	// The MLU may be empty
-	if (mlu ->PoolUsed == 0) {
-		NewMlu ->MemPool = NULL;
-	}
-	else {
-		// It is not empty
-		NewMlu ->MemPool = _cmsMalloc(mlu ->ContextID, mlu ->PoolUsed);
-		if (NewMlu ->MemPool == NULL) goto Error;
-	}
-
-	NewMlu ->PoolSize = mlu ->PoolUsed;
-
-	if (NewMlu ->MemPool == NULL || mlu ->MemPool == NULL) goto Error;
-
-	memmove(NewMlu ->MemPool, mlu->MemPool, mlu ->PoolUsed);
-	NewMlu ->PoolUsed = mlu ->PoolUsed;
-
-	return NewMlu;
-
-Error:
-
-	if (NewMlu != NULL) cmsMLUfree(NewMlu);
-	return NULL;
-}
-
-// Free any used memory
-void CMSEXPORT cmsMLUfree(cmsMLU* mlu)
-{
-	if (mlu) {
-
-		if (mlu -> Entries) _cmsFree(mlu ->ContextID, mlu->Entries);
-		if (mlu -> MemPool) _cmsFree(mlu ->ContextID, mlu->MemPool);
-
-		_cmsFree(mlu ->ContextID, mlu);
-	}
-}
-
-
-// The algorithm first searches for an exact match of country and language, if not found it uses 
-// the Language. If none is found, first entry is used instead.
-static
-const wchar_t* _cmsMLUgetWide(const cmsMLU* mlu, 
-							  cmsUInt32Number *len, 
-							  cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode,
-							  cmsUInt16Number* UsedLanguageCode, cmsUInt16Number* UsedCountryCode)
-{
-    int i;
-    int Best = -1;
-	_cmsMLUentry* v;
-
-    if (mlu == NULL) return NULL;
-
-    if (mlu -> AllocatedEntries <= 0) return NULL;
-
-    for (i=0; i < mlu ->UsedEntries; i++) {
-
-        v = mlu ->Entries + i;
-
-        if (v -> Language == LanguageCode) {
-
-            if (Best == -1) Best = i;
-
-            if (v -> Country == CountryCode) {
-
-				if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
-				if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;
-
-                if (len != NULL) *len = v ->Len;
-
-                return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v -> StrW);        // Found exact match                       
-            }
-        }
-    }
-
-    // No string found. Return First one
-    if (Best == -1)
-        Best = 0;
-
-	 v = mlu ->Entries + Best;
-
-	 if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
-	if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;
-
-    if (len != NULL) *len   = v ->Len;
-
-	return(wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);
-}
-
-
-// Obtain an ASCII representation of the wide string. Setting buffer to NULL returns the len
-cmsUInt32Number CMSEXPORT cmsMLUgetASCII(const cmsMLU* mlu, 
-									   const char LanguageCode[3], const char CountryCode[3], 
-									   char* Buffer, cmsUInt32Number BufferSize)
-{
-    const wchar_t *Wide;
-    cmsUInt32Number  StrLen = 0;
-    cmsUInt32Number ASCIIlen, i;
-
-	cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
-    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
-
-	// Sanitize
-    if (mlu == NULL) return 0;
-
-    // Get WideChar
-    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
-    if (Wide == NULL) return 0;
-
-    ASCIIlen = StrLen / sizeof(wchar_t);
-
-    // Maybe we want only to know the len?
-    if (Buffer == NULL) return ASCIIlen + 1; // Note the zero at the end
-
-    // No buffer size means no data
-    if (BufferSize <= 0) return 0;
-
-    // Some clipping may be required
-    if (BufferSize < ASCIIlen + 1)
-        ASCIIlen = BufferSize - 1;
-
-    // Precess each character
-    for (i=0; i < ASCIIlen; i++) { 
-
-        if (Wide[i] == 0)
-            Buffer[i] = 0;
-        else
-            Buffer[i] = (char) Wide[i];
-    }
-
-	// We put a termination "\0"
-    Buffer[ASCIIlen] = 0;
-    return ASCIIlen + 1;
-}
-
-// Obtain a wide representation of the MLU, on depending on current locale settings 
-cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu, 
-									  const char LanguageCode[3], const char CountryCode[3], 
-									  wchar_t* Buffer, cmsUInt32Number BufferSize)
-{
-    const wchar_t *Wide;
-    cmsUInt32Number  StrLen = 0;
-
-	cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
-    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
-
-	// Sanitize
-    if (mlu == NULL) return 0;
-
-    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
-    if (Wide == NULL) return 0;
-    
-    // Maybe we want only to know the len?
-    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
-
-  // No buffer size means no data
-    if (BufferSize <= 0) return 0;
-
-    // Some clipping may be required
-    if (BufferSize < StrLen + sizeof(wchar_t))
-        StrLen = BufferSize - + sizeof(wchar_t);
-
-    memmove(Buffer, Wide, StrLen);
-	Buffer[StrLen / sizeof(wchar_t)] = 0;
-
-    return StrLen + sizeof(wchar_t);
-}
-
-
-// Get also the language and country
-CMSAPI cmsBool CMSEXPORT cmsMLUgetTranslation(const cmsMLU* mlu,   
-		                    		          const char LanguageCode[3], const char CountryCode[3], 
-										      char ObtainedLanguage[3], char ObtainedCountry[3])
-{
-	const wchar_t *Wide;
- 
-	cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
-    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
-    cmsUInt16Number ObtLang, ObtCode; 
-
-	// Sanitize
-    if (mlu == NULL) return FALSE;
-
-    Wide = _cmsMLUgetWide(mlu, NULL, Lang, Cntry, &ObtLang, &ObtCode);
-	if (Wide == NULL) return FALSE;
-    
-	// Get used language and code
-    *(cmsUInt16Number *)ObtainedLanguage = _cmsAdjustEndianess16(ObtLang);
-	*(cmsUInt16Number *)ObtainedCountry  = _cmsAdjustEndianess16(ObtCode);	
-
-	ObtainedLanguage[2] = ObtainedCountry[2] = 0;    	
-	return TRUE;
-}
-
-
-// Named color lists --------------------------------------------------------------------------------------------
-
-// Grow the list to keep at least NumElements
-static
-cmsBool  GrowNamedColorList(cmsNAMEDCOLORLIST* v)
-{           
-    cmsUInt32Number size;
-    _cmsNAMEDCOLOR * NewPtr;
-
-    if (v == NULL) return FALSE;
-
-    if (v ->Allocated == 0)
-        size = 64;   // Initial guess
-    else
-        size = v ->Allocated * 2;
-
-    // Keep a maximum color lists can grow, 100K entries seems reasonable
-    if (size > 1024*100) return FALSE;
-
-    NewPtr = (_cmsNAMEDCOLOR*) _cmsRealloc(v ->ContextID, v ->List, size * sizeof(_cmsNAMEDCOLOR));
-    if (NewPtr == NULL) 
-        return FALSE;
-        
-    v ->List      = NewPtr;
-    v ->Allocated = size;
-    return TRUE;
-}
-
-// Allocate a list for n elements
-cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
-{
-    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));
-   
-    if (v == NULL) return NULL;
-    
-    v ->List      = NULL;
-    v ->nColors   = 0;
-    v ->ContextID  = ContextID;
-
-    while (v -> Allocated < n)
-        GrowNamedColorList(v);
-
-    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
-    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
-    v -> ColorantCount = ColorantCount;
-
-    return v;
-}
-
-// Free a list
-void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)
-{               
-    if (v ->List) _cmsFree(v ->ContextID, v ->List);
-    if (v) _cmsFree(v ->ContextID, v);
-}   
-
-cmsNAMEDCOLORLIST* CMSEXPORT cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v)
-{
-    cmsNAMEDCOLORLIST* NewNC;
-        
-    if (v == NULL) return NULL;
-
-    NewNC= cmsAllocNamedColorList(v ->ContextID, v -> nColors, v ->ColorantCount, v ->Prefix, v ->Suffix);
-    if (NewNC == NULL) return NULL;
-
-    // For really large tables we need this
-    while (NewNC ->Allocated < v ->Allocated)
-        GrowNamedColorList(NewNC);
-
-    memmove(NewNC ->Prefix, v ->Prefix, sizeof(v ->Prefix));
-    memmove(NewNC ->Suffix, v ->Suffix, sizeof(v ->Suffix));
-    NewNC ->ColorantCount = v ->ColorantCount;
-    memmove(NewNC->List, v ->List, v->nColors * sizeof(_cmsNAMEDCOLOR));
-    NewNC ->nColors = v ->nColors;
-    return NewNC;
-}
-
-
-// Append a color to a list. List pointer may change if reallocated
-cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList, 
-                                       const char* Name, 
-                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])
-{    
-    cmsUInt32Number i;
-
-    if (NamedColorList == NULL) return FALSE;
-
-    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {
-        if (!GrowNamedColorList(NamedColorList)) return FALSE;
-    }
-
-    for (i=0; i < NamedColorList ->ColorantCount; i++)
-        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];
-
-    for (i=0; i < 3; i++)
-        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];
-
-    if (Name != NULL)
-        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, 
-                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));
-    else
-        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;
-
-
-    NamedColorList ->nColors++;
-    return TRUE;
-}
-
-// Returns number of elements 
-cmsUInt32Number CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* NamedColorList)
-{    
-     if (NamedColorList == NULL) return 0;
-     return NamedColorList ->nColors;
-}
-
-// Info aboout a given color
-cmsBool  CMSEXPORT cmsNamedColorInfo(const cmsNAMEDCOLORLIST* NamedColorList, cmsUInt32Number nColor, 
-                                     char* Name, 
-                                     char* Prefix, 
-                                     char* Suffix,
-                                     cmsUInt16Number* PCS, 
-                                     cmsUInt16Number* Colorant)
-{    
-    if (NamedColorList == NULL) return FALSE;
-
-    if (nColor >= cmsNamedColorCount(NamedColorList)) return FALSE;
-
-    if (Name) strcpy(Name, NamedColorList->List[nColor].Name);
-    if (Prefix) strcpy(Prefix, NamedColorList->Prefix);
-    if (Suffix) strcpy(Suffix, NamedColorList->Suffix);
-    if (PCS) 
-        memmove(PCS, NamedColorList ->List[nColor].PCS, 3*sizeof(cmsUInt16Number));
-
-    if (Colorant) 
-        memmove(Colorant, NamedColorList ->List[nColor].DeviceColorant, 
-                                sizeof(cmsUInt16Number) * NamedColorList ->ColorantCount);
-
-
-    return TRUE;
-}
-
-// Search for a given color name (no prefix or suffix)
-cmsInt32Number CMSEXPORT cmsNamedColorIndex(const cmsNAMEDCOLORLIST* NamedColorList, const char* Name)
-{    
-    int i, n;
-
-    if (NamedColorList == NULL) return -1;
-    n = cmsNamedColorCount(NamedColorList);
-    for (i=0; i < n; i++) {
-        if (cmsstrcasecmp(Name,  NamedColorList->List[i].Name) == 0)
-            return i;
-    }
-
-    return -1;
-}
-
-// MPE support -----------------------------------------------------------------------------------------------------------------
-
-static
-void FreeNamedColorList(cmsStage* mpe)
-{
-    cmsNAMEDCOLORLIST* List = (cmsNAMEDCOLORLIST*) mpe ->Data;
-    cmsFreeNamedColorList(List);
-}
-
-static
-void* DupNamedColorList(cmsStage* mpe)
-{
-    cmsNAMEDCOLORLIST* List = (cmsNAMEDCOLORLIST*) mpe ->Data;
-    return cmsDupNamedColorList(List);
-}
-
-static
-void EvalNamedColor(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)
-{
-    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) mpe ->Data;
-    cmsUInt16Number index = (cmsUInt16Number) _cmsQuickSaturateWord(In[0] * 65535.0);
-    cmsUInt32Number j;
-
-    if (index >= NamedColorList-> nColors) {
-        cmsSignalError(NamedColorList ->ContextID, cmsERROR_RANGE, "Color %d out of range; ignored", index);
-    }
-    else {
-        for (j=0; j < NamedColorList ->ColorantCount; j++) 
-            Out[j] = (cmsFloat32Number) (NamedColorList->List[index].DeviceColorant[j] / 65535.0);      
-    }
-}
-
-
-// Named color lookup element
-cmsStage* _cmsStageAllocNamedColor(cmsNAMEDCOLORLIST* NamedColorList)
-{
-    return _cmsStageAllocPlaceholder(NamedColorList ->ContextID, 
-		                           cmsSigNamedColorElemType, 
-								   1, 3,
-								   EvalNamedColor,
-								   DupNamedColorList,
-								   FreeNamedColorList,
-								   cmsDupNamedColorList(NamedColorList));
-  
-}
-
-
-// Retrieve the named color list from a transform. Should be first element in the LUT
-cmsNAMEDCOLORLIST* CMSEXPORT cmsGetNamedColorList(cmsHTRANSFORM xform)
-{
-    _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;
-    cmsStage* mpe  = v ->Lut->Elements;
-
-    if (mpe ->Type != cmsSigNamedColorElemType) return NULL;
-    return (cmsNAMEDCOLORLIST*) mpe ->Data;
-}
-
-
-// Profile sequence description routines -------------------------------------------------------------------------------------
-
-cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)
-{
-    cmsSEQ* Seq;
-    cmsUInt32Number i;
-
-    if (n == 0) return NULL;
-
-    // In a absolutely arbitrary way, I hereby decide to allow a maxim of 255 profiles linked
-    // in a devicelink. It makes not sense anyway and may be used for exploits, so let's close the door!
-    if (n > 255) return NULL;
-
-    Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));
-    if (Seq == NULL) return NULL;   
-    
-    Seq -> ContextID = ContextID;
-    Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));
-    Seq -> n        = n;
-
-    
-    for (i=0; i < n; i++) {
-        Seq -> seq[i].Manufacturer = NULL;
-        Seq -> seq[i].Model        = NULL;
-        Seq -> seq[i].Description  = NULL;
-    }
-    
-    return Seq;
-}
-
-void CMSEXPORT cmsFreeProfileSequenceDescription(cmsSEQ* pseq)
-{
-    cmsUInt32Number i;
-
-    for (i=0; i < pseq ->n; i++) {
-        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);
-        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);
-        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);
-    }
-
-    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);
-    _cmsFree(pseq -> ContextID, pseq);
-}
-
-cmsSEQ* CMSEXPORT cmsDupProfileSequenceDescription(const cmsSEQ* pseq)
-{
-    cmsSEQ *NewSeq;
-    cmsUInt32Number i;
-
-    if (pseq == NULL)
-        return NULL;
-
-    NewSeq = (cmsSEQ*) _cmsMalloc(pseq -> ContextID, sizeof(cmsSEQ));
-    if (NewSeq == NULL) return NULL;
-
-    
-    NewSeq -> seq      = (cmsPSEQDESC*) _cmsCalloc(pseq ->ContextID, pseq ->n, sizeof(cmsPSEQDESC));
-    if (NewSeq ->seq == NULL) goto Error;
-    
-    NewSeq -> ContextID = pseq ->ContextID;
-    NewSeq -> n        = pseq ->n;
-
-    for (i=0; i < pseq->n; i++) {
-
-        memmove(&NewSeq ->seq[i].attributes, &pseq ->seq[i].attributes, sizeof(cmsUInt64Number));
-
-        NewSeq ->seq[i].deviceMfg   = pseq ->seq[i].deviceMfg;
-        NewSeq ->seq[i].deviceModel = pseq ->seq[i].deviceModel;
-        memmove(&NewSeq ->seq[i].ProfileID, &pseq ->seq[i].ProfileID, sizeof(cmsProfileID));
-        NewSeq ->seq[i].technology  = pseq ->seq[i].technology;
-
-        NewSeq ->seq[i].Manufacturer = cmsMLUdup(pseq ->seq[i].Manufacturer);
-        NewSeq ->seq[i].Model        = cmsMLUdup(pseq ->seq[i].Model);
-        NewSeq ->seq[i].Description  = cmsMLUdup(pseq ->seq[i].Description);
-    
-    }
-
-    return NewSeq;
-
-Error:
-
-    cmsFreeProfileSequenceDescription(NewSeq);
-    return NULL;
-}
-
-
-
-
diff --git a/thirdparty/liblcms2/src/cmsopt.c b/thirdparty/liblcms2/src/cmsopt.c
deleted file mode 100644
index b1ce98e..0000000
--- a/thirdparty/liblcms2/src/cmsopt.c
+++ /dev/null
@@ -1,1631 +0,0 @@
-
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-//----------------------------------------------------------------------------------
-
-// Optimization for 8 bits, Shaper-CLUT (3 inputs only)
-typedef struct {
-
-    cmsContext ContextID;
-
-    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.
-
-    cmsUInt16Number rx[256], ry[256], rz[256];
-    cmsUInt32Number X0[256], Y0[256], Z0[256];  // Precomputed nodes and offsets for 8-bit input data
-    
-
-} Prelin8Data;
-
-
-// Generic optimization for 16 bits Shaper-CLUT-Shaper (any inputs)
-typedef struct {
-
-    cmsContext ContextID;
-
-    // Number of channels
-    int nInputs;
-    int nOutputs;
-    
-    // Since there is no limitation of the output number of channels, this buffer holding the connexion CLUT-shaper
-    // has to be dynamically allocated. This is not the case of first step shaper-CLUT, which is limited to max inputs
-    cmsUInt16Number* StageDEF;
-
-    _cmsInterpFn16 EvalCurveIn16[MAX_INPUT_DIMENSIONS];       // The maximum number of input channels is known in advance 
-    cmsInterpParams*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS];  
-    
-    _cmsInterpFn16 EvalCLUT;            // The evaluator for 3D grid
-    const cmsInterpParams* CLUTparams;  // (not-owned pointer)
-
-    
-    _cmsInterpFn16* EvalCurveOut16;       // Points to an array of curve evaluators in 16 bits (not-owned pointer)
-    cmsInterpParams**  ParamsCurveOut16;  // Points to an array of references to interpolation params (not-owned pointer)
-    
-
-} Prelin16Data;
-
-
-// Optimization for matrix-shaper in 8 bits. Numbers are operated in n.14 signed, tables are stored in 1.14 fixed 
-
-typedef cmsInt32Number cmsS1Fixed14Number;   // Note that this may hold more than 16 bits!
-
-#define DOUBLE_TO_1FIXED14(x) ((cmsS1Fixed14Number) floor((x) * 16384.0 + 0.5))
-
-typedef struct {
- 
-    cmsContext ContextID;
-
-    cmsS1Fixed14Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)
-    cmsS1Fixed14Number Shaper1G[256];
-    cmsS1Fixed14Number Shaper1B[256];
-
-    cmsS1Fixed14Number Mat[3][3];     // n.14 to n.14 (needs a saturation after that)
-    cmsS1Fixed14Number Off[3];
-
-    cmsUInt16Number Shaper2R[16385];    // 1.14 to 0..255 
-    cmsUInt16Number Shaper2G[16385];
-    cmsUInt16Number Shaper2B[16385];
-
-} MatShaper8Data;
-
-// Curves, optimization is shared between 8 and 16 bits
-typedef struct {
-
-    cmsContext ContextID;
-
-    int nCurves;                  // Number of curves
-    int nElements;                // Elements in curves
-    cmsUInt16Number** Curves;     // Points to a dynamically  allocated array
-
-} Curves16Data;
-
-
-// Simple optimizations ----------------------------------------------------------------------------------------------------------
-
-
-// Remove an element in linked chain
-static
-void _RemoveElement(cmsStage** head)
-{
-    cmsStage* mpe = *head;
-    cmsStage* next = mpe ->Next;
-    *head = next;
-    cmsStageFree(mpe);
-}
-
-// Remove all identities in chain. Note that pt actually is a double pointer to the element that holds the pointer. 
-static
-cmsBool _Remove1Op(cmsPipeline* Lut, cmsStageSignature UnaryOp)
-{   
-    cmsStage** pt = &Lut ->Elements;
-    cmsBool AnyOpt = FALSE;
-
-    while (*pt != NULL) {
-
-        if ((*pt) ->Implements == UnaryOp) {
-            _RemoveElement(pt);
-            AnyOpt = TRUE;
-        }
-        else  
-            pt = &((*pt) -> Next);
-    }
-
-    return AnyOpt;
-}
-
-// Same, but only if two adjacent elements are found
-static
-cmsBool _Remove2Op(cmsPipeline* Lut, cmsStageSignature Op1, cmsStageSignature Op2)
-{   
-    cmsStage** pt1;
-    cmsStage** pt2;
-    cmsBool AnyOpt = FALSE;
-
-    pt1 = &Lut ->Elements;
-    if (*pt1 == NULL) return AnyOpt;
-    
-    while (*pt1 != NULL) {
-
-        pt2 = &((*pt1) -> Next);
-        if (*pt2 == NULL) return AnyOpt;
-
-        if ((*pt1) ->Implements == Op1 && (*pt2) ->Implements == Op2) {
-            _RemoveElement(pt2);
-            _RemoveElement(pt1);
-            AnyOpt = TRUE;
-        }
-        else  
-            pt1 = &((*pt1) -> Next);            
-    }
-
-    return AnyOpt;
-}
-
-// Preoptimize just gets rif of no-ops coming paired. Conversion from v2 to v4 followed 
-// by a v4 to v2 and vice-versa. The elements are then discarded.
-static
-cmsBool PreOptimize(cmsPipeline* Lut)
-{    
-    cmsBool AnyOpt = FALSE, Opt;
-
-    AnyOpt = FALSE;
-
-    do {
-
-        Opt = FALSE;
-
-        // Remove all identities
-        Opt |= _Remove1Op(Lut, cmsSigIdentityElemType);
-
-        // Remove XYZ2Lab followed by Lab2XYZ
-        Opt |= _Remove2Op(Lut, cmsSigXYZ2LabElemType, cmsSigLab2XYZElemType);
-
-        // Remove Lab2XYZ followed by XYZ2Lab
-        Opt |= _Remove2Op(Lut, cmsSigLab2XYZElemType, cmsSigXYZ2LabElemType);
-
-        // Remove V4 to V2 followed by V2 to V4
-        Opt |= _Remove2Op(Lut, cmsSigLabV4toV2, cmsSigLabV2toV4);
-
-        // Remove V2 to V4 followed by V4 to V2
-        Opt |= _Remove2Op(Lut, cmsSigLabV2toV4, cmsSigLabV4toV2);
-
-        if (Opt) AnyOpt = TRUE;
-
-    } while (Opt);
-
-    return AnyOpt;
-}
-
-static
-void Eval16nop1D(register const cmsUInt16Number Input[],
-                 register cmsUInt16Number Output[],                               
-                 register const struct _cms_interp_struc* p)
-{
-    Output[0] = Input[0];
-
-    cmsUNUSED_PARAMETER(p);  
-}
-
-static
-void PrelinEval16(register const cmsUInt16Number Input[],
-                  register cmsUInt16Number Output[],
-                  register const void* D)
-{
-    Prelin16Data* p16 = (Prelin16Data*) D;
-    cmsUInt16Number  StageABC[MAX_INPUT_DIMENSIONS];
-    int i;
-
-    for (i=0; i < p16 ->nInputs; i++) {
-    
-        p16 ->EvalCurveIn16[i](&Input[i], &StageABC[i], p16 ->ParamsCurveIn16[i]);
-    }
-
-    p16 ->EvalCLUT(StageABC, p16 ->StageDEF, p16 ->CLUTparams);
-
-    for (i=0; i < p16 ->nOutputs; i++) {
-    
-        p16 ->EvalCurveOut16[i](&p16->StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);
-    }
-}
-
-
-static
-void PrelinOpt16free(cmsContext ContextID, void* ptr)
-{
-    Prelin16Data* p16 = (Prelin16Data*) ptr;
-
-    _cmsFree(ContextID, p16 ->StageDEF);
-    _cmsFree(ContextID, p16 ->EvalCurveOut16);
-    _cmsFree(ContextID, p16 ->ParamsCurveOut16);
-
-    _cmsFree(ContextID, p16);
-}
-
-static
-void* Prelin16dup(cmsContext ContextID, const void* ptr)
-{   
-    Prelin16Data* p16 = (Prelin16Data*) ptr;
-    Prelin16Data* Duped = _cmsDupMem(ContextID, p16, sizeof(Prelin16Data));
-
-    if (Duped == NULL) return NULL;
-
-    Duped ->StageDEF         = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number)); 
-    Duped ->EvalCurveOut16   = _cmsDupMem(ContextID, p16 ->EvalCurveOut16, p16 ->nOutputs * sizeof(_cmsInterpFn16));
-    Duped ->ParamsCurveOut16 = _cmsDupMem(ContextID, p16 ->ParamsCurveOut16, p16 ->nOutputs * sizeof(cmsInterpParams* ));
-
-    return Duped;
-}
-
-
-static
-Prelin16Data* PrelinOpt16alloc(cmsContext ContextID, 
-                               const cmsInterpParams* ColorMap, 
-                               int nInputs, cmsToneCurve** In, 
-                               int nOutputs, cmsToneCurve** Out )
-{
-    int i;
-    Prelin16Data* p16 = (Prelin16Data*) _cmsMallocZero(ContextID, sizeof(Prelin16Data));
-    if (p16 == NULL) return NULL;
-
-    p16 ->nInputs = nInputs;
-    p16 -> nOutputs = nOutputs;
-
-    
-    for (i=0; i < nInputs; i++) {
-
-        if (In == NULL) {
-            p16 -> ParamsCurveIn16[i] = NULL;
-            p16 -> EvalCurveIn16[i] = Eval16nop1D;
-
-        }
-        else {
-            p16 -> ParamsCurveIn16[i] = In[i] ->InterpParams;
-            p16 -> EvalCurveIn16[i] = p16 ->ParamsCurveIn16[i]->Interpolation.Lerp16;
-        }
-    }
-
-    p16 ->CLUTparams = ColorMap;
-    p16 ->EvalCLUT   = ColorMap ->Interpolation.Lerp16;
-
-
-    p16 -> StageDEF = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number)); 
-    p16 -> EvalCurveOut16 = (_cmsInterpFn16*) _cmsCalloc(ContextID, nOutputs, sizeof(_cmsInterpFn16));
-    p16 -> ParamsCurveOut16 = (cmsInterpParams**) _cmsCalloc(ContextID, nOutputs, sizeof(cmsInterpParams* ));
-
-    for (i=0; i < nOutputs; i++) {
-
-        if (Out == NULL) {
-            p16 ->ParamsCurveOut16[i] = NULL;
-            p16 -> EvalCurveOut16[i] = Eval16nop1D;
-        }
-        else {
-
-            p16 ->ParamsCurveOut16[i] = Out[i] ->InterpParams;
-            p16 -> EvalCurveOut16[i] = p16 ->ParamsCurveOut16[i]->Interpolation.Lerp16;
-        }
-    }
-
-    return p16;
-}
-
-
-
-// Resampling ---------------------------------------------------------------------------------
-
-#define PRELINEARIZATION_POINTS 4096
-
-// Sampler implemented by another LUT. This is a clean way to precalculate the devicelink 3D CLUT for 
-// almost any transform. We use floating point precision and then convert from floating point to 16 bits.
-static
-int XFormSampler16(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    cmsPipeline* Lut = (cmsPipeline*) Cargo;
-    cmsFloat32Number InFloat[cmsMAXCHANNELS], OutFloat[cmsMAXCHANNELS];
-    cmsUInt32Number i;
-
-    _cmsAssert(Lut -> InputChannels < cmsMAXCHANNELS);
-    _cmsAssert(Lut -> OutputChannels < cmsMAXCHANNELS);
-
-    // From 16 bit to floating point
-    for (i=0; i < Lut ->InputChannels; i++) 
-        InFloat[i] = (cmsFloat32Number) (In[i] / 65535.0);
-
-    // Evaluate in floating point
-    cmsPipelineEvalFloat(InFloat, OutFloat, Lut);
-
-    // Back to 16 bits representation
-    for (i=0; i < Lut ->OutputChannels; i++) 
-        Out[i] = _cmsQuickSaturateWord(OutFloat[i] * 65535.0);
-
-    // Always succeed
-    return TRUE;
-}
-
-// Try to see if the curves of a given MPE are linear
-static
-cmsBool AllCurvesAreLinear(cmsStage* mpe)
-{
-    cmsToneCurve** Curves; 
-    cmsUInt32Number i, n;
-
-    Curves = _cmsStageGetPtrToCurveSet(mpe);
-    if (Curves == NULL) return FALSE;  
-
-    n = cmsStageOutputChannels(mpe);
-
-    for (i=0; i < n; i++) {
-        if (!cmsIsToneCurveLinear(Curves[i])) return FALSE;
-    }
-
-    return TRUE;
-}
-
-// This function replaces a specific node placed in "At" by the "Value" numbers. Its purpose
-// is to fix scum dot on broken profiles/transforms. Works on 1, 3 and 4 channels
-static
-cmsBool  PatchLUT(cmsStage* CLUT, cmsUInt16Number At[], cmsUInt16Number Value[],
-                  int nChannelsOut, int nChannelsIn)
-{
-    _cmsStageCLutData* Grid = (_cmsStageCLutData*) CLUT ->Data;
-    cmsInterpParams* p16  = Grid ->Params;
-    cmsFloat64Number px, py, pz, pw;
-    int        x0, y0, z0, w0;
-    int        i, index;
-
-    if (CLUT -> Type != cmsSigCLutElemType) {
-        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) Attempt to PatchLUT on non-lut MPE");
-        return FALSE;
-    }
-
-    px = ((cmsFloat64Number) At[0] * (p16->Domain[0])) / 65535.0;
-    py = ((cmsFloat64Number) At[1] * (p16->Domain[1])) / 65535.0;
-    pz = ((cmsFloat64Number) At[2] * (p16->Domain[2])) / 65535.0;
-    pw = ((cmsFloat64Number) At[3] * (p16->Domain[3])) / 65535.0;
-
-    x0 = (int) floor(px);
-    y0 = (int) floor(py);
-    z0 = (int) floor(pz);
-    w0 = (int) floor(pw);
-
-    if (nChannelsIn == 4) {
-
-        if (((px - x0) != 0) ||
-            ((py - y0) != 0) ||
-            ((pz - z0) != 0) ||
-            ((pw - w0) != 0)) return FALSE; // Not on exact node
-
-        index = p16 -> opta[3] * x0 +
-            p16 -> opta[2] * y0 +
-            p16 -> opta[1] * z0 +
-            p16 -> opta[0] * w0;
-    }
-    else 
-        if (nChannelsIn == 3) {
-
-            if (((px - x0) != 0) ||
-                ((py - y0) != 0) ||
-                ((pz - z0) != 0)) return FALSE;  // Not on exact node
-
-            index = p16 -> opta[2] * x0 +
-                p16 -> opta[1] * y0 +
-                p16 -> opta[0] * z0;
-        }
-        else 
-            if (nChannelsIn == 1) {
-
-                if (((px - x0) != 0)) return FALSE; // Not on exact node
-
-                index = p16 -> opta[0] * x0;    
-            }
-            else {
-                cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) %d Channels are not supported on PatchLUT", nChannelsIn);
-                return FALSE;
-            }
-
-            for (i=0; i < nChannelsOut; i++)
-                Grid -> Tab.T[index + i] = Value[i];
-
-            return TRUE;
-}
-
-// Auxiliar, to see if two values are equal.
-static
-cmsBool WhitesAreEqual(int n, cmsUInt16Number White1[], cmsUInt16Number White2[] ) 
-{
-    int i;
-
-    for (i=0; i < n; i++) {
-        if (White1[i] != White2[i]) return FALSE;
-    }
-    return TRUE;
-}
-
-
-// Locate the node for the white point and fix it to pure white in order to avoid scum dot.
-static
-cmsBool FixWhiteMisalignment(cmsPipeline* Lut, cmsColorSpaceSignature EntryColorSpace, cmsColorSpaceSignature ExitColorSpace)
-{
-    cmsUInt16Number *WhitePointIn, *WhitePointOut;
-    cmsUInt16Number  WhiteIn[cmsMAXCHANNELS], WhiteOut[cmsMAXCHANNELS], ObtainedOut[cmsMAXCHANNELS];
-    cmsUInt32Number i, nOuts, nIns;
-    cmsStage *PreLin = NULL, *CLUT = NULL, *PostLin = NULL;
-    
-    if (!_cmsEndPointsBySpace(EntryColorSpace,
-        &WhitePointIn, NULL, &nIns)) return FALSE;
-
-    if (!_cmsEndPointsBySpace(ExitColorSpace,
-        &WhitePointOut, NULL, &nOuts)) return FALSE;
-
-    // It needs to be fixed?
-
-    cmsPipelineEval16(WhitePointIn, ObtainedOut, Lut);
-
-    if (WhitesAreEqual(nOuts, WhitePointOut, ObtainedOut)) return TRUE; // whites already match 
-    
-    // Check if the LUT comes as Prelin, CLUT or Postlin. We allow all combinations
-    if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &PreLin, &CLUT, &PostLin))
-        if (!cmsPipelineCheckAndRetreiveStages(Lut, 2, cmsSigCurveSetElemType, cmsSigCLutElemType, &PreLin, &CLUT))
-            if (!cmsPipelineCheckAndRetreiveStages(Lut, 2, cmsSigCLutElemType, cmsSigCurveSetElemType, &CLUT, &PostLin))
-                if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCLutElemType, &CLUT))
-                    return FALSE;
-
-    // We need to interpolate white points of both, pre and post curves
-    if (PreLin) {
-
-        cmsToneCurve** Curves = _cmsStageGetPtrToCurveSet(PreLin);
-
-        for (i=0; i < nIns; i++) {    
-            WhiteIn[i] = cmsEvalToneCurve16(Curves[i], WhitePointIn[i]);
-        }
-    }
-    else {
-        for (i=0; i < nIns; i++) 
-            WhiteIn[i] = WhitePointIn[i]; 
-    }
-
-    // If any post-linearization, we need to find how is represented white before the curve, do
-    // a reverse interpolation in this case.
-    if (PostLin) {
-        
-        cmsToneCurve** Curves = _cmsStageGetPtrToCurveSet(PostLin);
-        
-        for (i=0; i < nOuts; i++) {
-        
-            cmsToneCurve* InversePostLin = cmsReverseToneCurve(Curves[i]);
-            WhiteOut[i] = cmsEvalToneCurve16(InversePostLin, WhitePointOut[i]);
-            cmsFreeToneCurve(InversePostLin);
-        }
-    }
-    else {
-        for (i=0; i < nOuts; i++) 
-            WhiteOut[i] = WhitePointOut[i]; 
-    }
-
-    // Ok, proceed with patching. May fail and we don't care if it fails
-    PatchLUT(CLUT, WhiteIn, WhiteOut, nOuts, nIns);
-
-    return TRUE;
-}
-
-// -----------------------------------------------------------------------------------------------------------------------------------------------
-// This function creates simple LUT from complex ones. The generated LUT has an optional set of 
-// prelinearization curves, a CLUT of nGridPoints and optional postlinearization tables. 
-// These curves have to exist in the original LUT in order to be used in the simplified output. 
-// Caller may also use the flags to allow this feature.
-// LUTS with all curves will be simplified to a single curve. Parametric curves are lost.
-// This function should be used on 16-bits LUTS only, as floating point losses precision when simplified
-// -----------------------------------------------------------------------------------------------------------------------------------------------
-
-static
-cmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)                          
-{
-    cmsPipeline* Src;
-    cmsPipeline* Dest;   
-    cmsStage* CLUT;      
-    cmsStage *KeepPreLin = NULL, *KeepPostLin = NULL;
-    int nGridPoints;    
-    cmsColorSpaceSignature ColorSpace, OutputColorSpace;
-    cmsStage *NewPreLin = NULL;
-    cmsStage *NewPostLin = NULL;
-    _cmsStageCLutData* DataCLUT;
-    cmsToneCurve** DataSetIn;
-    cmsToneCurve** DataSetOut;
-    Prelin16Data* p16;
-
-
-    // This is a loosy optimization! does not apply in floating-point cases
-    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;
-
-    ColorSpace       = _cmsICCcolorSpace(T_COLORSPACE(*InputFormat));
-    OutputColorSpace = _cmsICCcolorSpace(T_COLORSPACE(*OutputFormat));
-    nGridPoints      = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);
-
-    // For empty LUTs, 2 points are enough
-    if (cmsPipelineStageCount(*Lut) == 0)
-        nGridPoints = 2;
-
-    Src = *Lut;
-
-    // Allocate an empty LUT    
-    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);
-    if (!Dest) return FALSE;
-
-    // Prelinearization tables are kept unless indicated by flags
-    if (*dwFlags & cmsFLAGS_CLUT_PRE_LINEARIZATION) {
-
-        // Get a pointer to the prelinearization element
-        cmsStage* PreLin = cmsPipelineGetPtrToFirstStage(Src);
-
-        // Check if suitable
-        if (PreLin ->Type == cmsSigCurveSetElemType) {
-
-            // Maybe this is a linear tram, so we can avoid the whole stuff
-            if (!AllCurvesAreLinear(PreLin)) {
-
-                // All seems ok, proceed.    
-                NewPreLin = cmsStageDup(PreLin);
-                cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin);
-
-                // Remove prelinearization. Since we have duplicated the curve
-                // in destination LUT, the sampling shoud be applied after this stage.
-                cmsPipelineUnlinkStage(Src, cmsAT_BEGIN, &KeepPreLin);
-            }
-        }
-    }
-
-    // Allocate the CLUT
-    CLUT = cmsStageAllocCLut16bit(Src ->ContextID, nGridPoints, Src ->InputChannels, Src->OutputChannels, NULL);
-    if (CLUT == NULL) return FALSE;
-
-    // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(Dest, cmsAT_END, CLUT);
-
-    // Postlinearization tables are kept unless indicated by flags
-    if (*dwFlags & cmsFLAGS_CLUT_POST_LINEARIZATION) {
-
-        // Get a pointer to the postlinearization if present
-        cmsStage* PostLin = cmsPipelineGetPtrToLastStage(Src);
-
-        // Check if suitable
-        if (cmsStageType(PostLin) == cmsSigCurveSetElemType) {
-
-            // Maybe this is a linear tram, so we can avoid the whole stuff
-            if (!AllCurvesAreLinear(PostLin)) {
-
-                // All seems ok, proceed.       
-                NewPostLin = cmsStageDup(PostLin);
-                cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin);
-
-                // In destination LUT, the sampling shoud be applied after this stage.
-                cmsPipelineUnlinkStage(Src, cmsAT_END, &KeepPostLin);
-            }
-        }
-    }
-
-    // Now its time to do the sampling. We have to ignore pre/post linearization 
-    // The source LUT whithout pre/post curves is passed as parameter.
-    if (!cmsStageSampleCLut16bit(CLUT, XFormSampler16, (void*) Src, 0)) {
-
-        // Ops, something went wrong, Restore stages
-        if (KeepPreLin != NULL)  cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin);
-        if (KeepPostLin != NULL) cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin);
-        cmsPipelineFree(Dest);
-        return FALSE;
-    }      
-
-    // Done. 
-
-    if (KeepPreLin != NULL) cmsStageFree(KeepPreLin);
-    if (KeepPostLin != NULL) cmsStageFree(KeepPostLin);
-    cmsPipelineFree(Src);
-
-    DataCLUT = (_cmsStageCLutData*) CLUT ->Data;
-
-    if (NewPreLin == NULL) DataSetIn = NULL;
-    else DataSetIn = ((_cmsStageToneCurvesData*) NewPreLin ->Data) ->TheCurves;
-
-    if (NewPostLin == NULL) DataSetOut = NULL;
-    else  DataSetOut = ((_cmsStageToneCurvesData*) NewPostLin ->Data) ->TheCurves;
-
-
-    if (DataSetIn == NULL && DataSetOut == NULL) {
-
-        _cmsPipelineSetOptimizationParameters(Dest, (_cmsOPTeval16Fn) DataCLUT->Params->Interpolation.Lerp16, DataCLUT->Params, NULL, NULL);
-    }
-    else {
-
-        p16 = PrelinOpt16alloc(Dest ->ContextID, 
-                               DataCLUT ->Params, 
-                               Dest ->InputChannels,
-                               DataSetIn,
-                               Dest ->OutputChannels,
-                               DataSetOut);
-
-
-        _cmsPipelineSetOptimizationParameters(Dest, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);
-    }
-
-
-    // Don't fix white on absolute colorimetric
-    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)
-        *dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;
-
-    if (!(*dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP)) {
-
-        FixWhiteMisalignment(Dest, ColorSpace, OutputColorSpace);
-    }
-
-    *Lut = Dest;
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(Intent);    
-}
-
-
-// -----------------------------------------------------------------------------------------------------------------------------------------------
-// Fixes the gamma balancing of transform. This is described in my paper "Prelinearization Stages on 
-// Color-Management Application-Specific Integrated Circuits (ASICs)" presented at NIP24. It only works 
-// for RGB transforms. See the paper for more details
-// -----------------------------------------------------------------------------------------------------------------------------------------------
-
-
-// Normalize endpoints by slope limiting max and min. This assures endpoints as well.
-// Descending curves are handled as well.
-static
-void SlopeLimiting(cmsToneCurve* g)
-{
-    int BeginVal, EndVal;
-    int AtBegin = (int) floor((cmsFloat64Number) g ->nEntries * 0.02 + 0.5);   // Cutoff at 2%
-    int AtEnd   = g ->nEntries - AtBegin - 1;                                  // And 98%
-    cmsFloat64Number Val, Slope, beta;
-    int i;
-
-    if (cmsIsToneCurveDescending(g)) {
-        BeginVal = 0xffff; EndVal = 0;
-    }
-    else {
-        BeginVal = 0; EndVal = 0xffff;
-    }
-
-    // Compute slope and offset for begin of curve
-    Val   = g ->Table16[AtBegin];
-    Slope = (Val - BeginVal) / AtBegin;
-    beta  = Val - Slope * AtBegin;
-
-    for (i=0; i < AtBegin; i++)
-        g ->Table16[i] = _cmsQuickSaturateWord(i * Slope + beta);
-
-    // Compute slope and offset for the end
-    Val   = g ->Table16[AtEnd];
-    Slope = (EndVal - Val) / AtBegin;   // AtBegin holds the X interval, which is same in both cases
-    beta  = Val - Slope * AtEnd;
-
-    for (i = AtEnd; i < (int) g ->nEntries; i++) 
-        g ->Table16[i] = _cmsQuickSaturateWord(i * Slope + beta);
-}
-
-
-// Precomputes tables for 8-bit on input devicelink. 
-static
-Prelin8Data* PrelinOpt8alloc(cmsContext ContextID, const cmsInterpParams* p, cmsToneCurve* G[3])
-{
-    int i;
-    cmsUInt16Number Input[3];
-    cmsS15Fixed16Number v1, v2, v3;
-    Prelin8Data* p8;
-
-    p8 = _cmsMallocZero(ContextID, sizeof(Prelin8Data));
-    if (p8 == NULL) return NULL;
-    
-    // Since this only works for 8 bit input, values comes always as x * 257, 
-    // we can safely take msb byte (x << 8 + x)
-
-    for (i=0; i < 256; i++) {
-
-        if (G != NULL) {
-
-            // Get 16-bit representation
-            Input[0] = cmsEvalToneCurve16(G[0], FROM_8_TO_16(i));
-            Input[1] = cmsEvalToneCurve16(G[1], FROM_8_TO_16(i));
-            Input[2] = cmsEvalToneCurve16(G[2], FROM_8_TO_16(i));
-        }
-        else {
-            Input[0] = FROM_8_TO_16(i);
-            Input[1] = FROM_8_TO_16(i);
-            Input[2] = FROM_8_TO_16(i);
-        }
-
-
-        // Move to 0..1.0 in fixed domain
-        v1 = _cmsToFixedDomain(Input[0] * p -> Domain[0]);
-        v2 = _cmsToFixedDomain(Input[1] * p -> Domain[1]);
-        v3 = _cmsToFixedDomain(Input[2] * p -> Domain[2]);
-
-        // Store the precalculated table of nodes
-        p8 ->X0[i] = (p->opta[2] * FIXED_TO_INT(v1));
-        p8 ->Y0[i] = (p->opta[1] * FIXED_TO_INT(v2));
-        p8 ->Z0[i] = (p->opta[0] * FIXED_TO_INT(v3));
-
-        // Store the precalculated table of offsets
-        p8 ->rx[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v1);
-        p8 ->ry[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v2);
-        p8 ->rz[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v3);
-    }
-
-    p8 ->ContextID = ContextID;
-    p8 ->p = p;
-
-    return p8;
-}
-
-static
-void Prelin8free(cmsContext ContextID, void* ptr)
-{   
-    _cmsFree(ContextID, ptr);
-}
-
-static
-void* Prelin8dup(cmsContext ContextID, const void* ptr)
-{   
-    return _cmsDupMem(ContextID, ptr, sizeof(Prelin8Data));
-}
-
-
-
-// A optimized interpolation for 8-bit input.
-#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])
-static
-void PrelinEval8(register const cmsUInt16Number Input[],
-                  register cmsUInt16Number Output[],
-                  register const void* D)
-{
-    
-    cmsUInt8Number         r, g, b;
-    cmsS15Fixed16Number    rx, ry, rz;            
-    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;       
-    int        OutChan;
-    register   cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;
-    Prelin8Data* p8 = (Prelin8Data*) D;
-    register const cmsInterpParams* p = p8 ->p;
-    int                    TotalOut = p -> nOutputs;
-    const cmsUInt16Number* LutTable = p -> Table;
-    
-    r = Input[0] >> 8;
-    g = Input[1] >> 8;
-    b = Input[2] >> 8;
-
-    X0 = X1 = p8->X0[r];
-    Y0 = Y1 = p8->Y0[g];
-    Z0 = Z1 = p8->Z0[b];
-
-    rx = p8 ->rx[r];
-    ry = p8 ->ry[g];
-    rz = p8 ->rz[b];
-
-    X1 = X0 + ((rx == 0) ? 0 : p ->opta[2]);
-    Y1 = Y0 + ((ry == 0) ? 0 : p ->opta[1]);
-    Z1 = Z0 + ((rz == 0) ? 0 : p ->opta[0]);
-
-  
-    // These are the 6 Tetrahedral
-    for (OutChan=0; OutChan < TotalOut; OutChan++) {
-
-        c0 = DENS(X0, Y0, Z0);
-
-        if (rx >= ry && ry >= rz)
-        {
-            c1 = DENS(X1, Y0, Z0) - c0;
-            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);
-            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);                
-        }
-        else
-            if (rx >= rz && rz >= ry)
-            {            
-                c1 = DENS(X1, Y0, Z0) - c0;
-                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);
-            }
-            else
-                if (rz >= rx && rx >= ry)
-                {
-                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);
-                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);
-                    c3 = DENS(X0, Y0, Z1) - c0;                            
-                }
-                else
-                    if (ry >= rx && rx >= rz)
-                    {
-                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);
-                        c2 = DENS(X0, Y1, Z0) - c0;
-                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);          
-                    }
-                    else
-                        if (ry >= rz && rz >= rx)
-                        {
-                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                            c2 = DENS(X0, Y1, Z0) - c0;
-                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);                
-                        }
-                        else
-                            if (rz >= ry && ry >= rx)
-                            {             
-                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);
-                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);
-                                c3 = DENS(X0, Y0, Z1) - c0;              
-                            }
-                            else  {
-                                c1 = c2 = c3 = 0;              
-                            }
-
-
-                            Rest = c1 * rx + c2 * ry + c3 * rz;
-
-                            Output[OutChan] = (cmsUInt16Number)c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest));
-                            
-    }
-}
-
-#undef DENS
-
-// --------------------------------------------------------------------------------------------------------------
-// We need xput over here
-
-static
-cmsBool OptimizeByComputingLinearization(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)      
-{
-    cmsPipeline* OriginalLut;
-    int nGridPoints;
-    cmsToneCurve *Trans[cmsMAXCHANNELS], *TransReverse[cmsMAXCHANNELS];
-    cmsUInt32Number t, i;  
-    cmsFloat32Number v, In[cmsMAXCHANNELS], Out[cmsMAXCHANNELS];
-    cmsBool lIsSuitable, lIsLinear;
-    cmsPipeline* OptimizedLUT = NULL, *LutPlusCurves = NULL;    
-    cmsStage* OptimizedCLUTmpe;
-    cmsColorSpaceSignature ColorSpace, OutputColorSpace;
-    cmsStage* OptimizedPrelinMpe;
-    cmsToneCurve**   OptimizedPrelinCurves;
-    _cmsStageCLutData*     OptimizedPrelinCLUT;
-
-
-    // This is a loosy optimization! does not apply in floating-point cases
-    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;
-
-    // Only on RGB
-    if (T_COLORSPACE(*InputFormat)  != PT_RGB) return FALSE;
-    if (T_COLORSPACE(*OutputFormat) != PT_RGB) return FALSE;
-
-
-    // On 16 bits, user has to specify the feature
-    if (!_cmsFormatterIs8bit(*InputFormat)) {
-        if (!(*dwFlags & cmsFLAGS_CLUT_PRE_LINEARIZATION)) return FALSE;
-    }
-
-    OriginalLut = *Lut;
-    ColorSpace       = _cmsICCcolorSpace(T_COLORSPACE(*InputFormat));
-    OutputColorSpace = _cmsICCcolorSpace(T_COLORSPACE(*OutputFormat));
-    nGridPoints      = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);
-
-    // Empty gamma containers
-    memset(Trans, 0, sizeof(Trans));
-    memset(TransReverse, 0, sizeof(TransReverse));
-
-    for (t = 0; t < OriginalLut ->InputChannels; t++) {
-        Trans[t] = cmsBuildTabulatedToneCurve16(OriginalLut ->ContextID, PRELINEARIZATION_POINTS, NULL);
-        if (Trans[t] == NULL) goto Error;
-    }
-
-    // Populate the curves
-    for (i=0; i < PRELINEARIZATION_POINTS; i++) {
-
-        v = (cmsFloat32Number) ((cmsFloat64Number) i / (PRELINEARIZATION_POINTS - 1));
-
-        // Feed input with a gray ramp
-        for (t=0; t < OriginalLut ->InputChannels; t++)
-            In[t] = v;
-
-        // Evaluate the gray value
-        cmsPipelineEvalFloat(In, Out, OriginalLut);
-
-        // Store result in curve
-        for (t=0; t < OriginalLut ->InputChannels; t++)
-            Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);
-    }
-
-    // Slope-limit the obtained curves
-    for (t = 0; t < OriginalLut ->InputChannels; t++) 
-        SlopeLimiting(Trans[t]);
-
-    // Check for validity
-    lIsSuitable = TRUE;
-    lIsLinear   = TRUE;
-    for (t=0; (lIsSuitable && (t < OriginalLut ->InputChannels)); t++) {
-
-        // Exclude if already linear
-        if (!cmsIsToneCurveLinear(Trans[t]))
-            lIsLinear = FALSE;
-
-        // Exclude if non-monotonic
-        if (!cmsIsToneCurveMonotonic(Trans[t]))
-            lIsSuitable = FALSE;                             
-    }
-
-    // If it is not suitable, just quit
-    if (!lIsSuitable) goto Error;
-
-    // Invert curves if possible
-    for (t = 0; t < OriginalLut ->InputChannels; t++) {
-        TransReverse[t] = cmsReverseToneCurveEx(PRELINEARIZATION_POINTS, Trans[t]);
-        if (TransReverse[t] == NULL) goto Error;
-    }
-
-    // Now inset the reversed curves at the begin of transform
-    LutPlusCurves = cmsPipelineDup(OriginalLut);
-    if (LutPlusCurves == NULL) goto Error;
-
-    cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse));
-
-    // Create the result LUT
-    OptimizedLUT = cmsPipelineAlloc(OriginalLut ->ContextID, OriginalLut ->InputChannels, OriginalLut ->OutputChannels);
-    if (OptimizedLUT == NULL) goto Error;
-
-    OptimizedPrelinMpe = cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, Trans);
-
-    // Create and insert the curves at the beginning    
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe);
-
-    // Allocate the CLUT for result
-    OptimizedCLUTmpe = cmsStageAllocCLut16bit(OriginalLut ->ContextID, nGridPoints, OriginalLut ->InputChannels, OriginalLut ->OutputChannels, NULL);
-
-    // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe);
-
-    // Resample the LUT
-    if (!cmsStageSampleCLut16bit(OptimizedCLUTmpe, XFormSampler16, (void*) LutPlusCurves, 0)) goto Error;
-
-    // Free resources
-    for (t = 0; t < OriginalLut ->InputChannels; t++) {
-
-        if (Trans[t]) cmsFreeToneCurve(Trans[t]);
-        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);
-    }
-
-    cmsPipelineFree(LutPlusCurves);
-
-
-    OptimizedPrelinCurves = _cmsStageGetPtrToCurveSet(OptimizedPrelinMpe);
-    OptimizedPrelinCLUT   = (_cmsStageCLutData*) OptimizedCLUTmpe ->Data;
-
-    // Set the evaluator if 8-bit
-    if (_cmsFormatterIs8bit(*InputFormat)) {
-
-        Prelin8Data* p8 = PrelinOpt8alloc(OptimizedLUT ->ContextID, 
-                                                OptimizedPrelinCLUT ->Params, 
-                                                OptimizedPrelinCurves);
-        if (p8 == NULL) return FALSE;
-
-        _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval8, (void*) p8, Prelin8free, Prelin8dup);
-
-    } 
-    else
-    {
-        Prelin16Data* p16 = PrelinOpt16alloc(OptimizedLUT ->ContextID, 
-            OptimizedPrelinCLUT ->Params, 
-            3, OptimizedPrelinCurves, 3, NULL);
-        if (p16 == NULL) return FALSE;
-
-        _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);
-
-    }
-
-    // Don't fix white on absolute colorimetric
-    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)
-        *dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;
-
-    if (!(*dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP)) {
-
-        if (!FixWhiteMisalignment(OptimizedLUT, ColorSpace, OutputColorSpace)) {
-
-            return FALSE;
-        }
-    }
-
-    // And return the obtained LUT
-
-    cmsPipelineFree(OriginalLut);
-    *Lut = OptimizedLUT;
-    return TRUE;
-
-Error:
-
-    for (t = 0; t < OriginalLut ->InputChannels; t++) {
-
-        if (Trans[t]) cmsFreeToneCurve(Trans[t]);
-        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);
-    }
-
-    if (LutPlusCurves != NULL) cmsPipelineFree(LutPlusCurves);   
-    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);
-
-    return FALSE;    
-
-    cmsUNUSED_PARAMETER(Intent);
-}
-
-
-// Curves optimizer ------------------------------------------------------------------------------------------------------------------
-
-static
-void CurvesFree(cmsContext ContextID, void* ptr)
-{   
-     Curves16Data* Data = (Curves16Data*) ptr;
-     int i;
-
-     for (i=0; i < Data -> nCurves; i++) {
-     
-         _cmsFree(ContextID, Data ->Curves[i]);
-     }
-
-     _cmsFree(ContextID, Data ->Curves);
-     _cmsFree(ContextID, ptr);
-}
-
-static
-void* CurvesDup(cmsContext ContextID, const void* ptr)
-{   
-    Curves16Data* Data = _cmsDupMem(ContextID, ptr, sizeof(Curves16Data));
-    int i;
-
-    if (Data == NULL) return NULL;
-
-    Data ->Curves = _cmsDupMem(ContextID, Data ->Curves, Data ->nCurves * sizeof(cmsUInt16Number*));
-
-    for (i=0; i < Data -> nCurves; i++) {
-        Data ->Curves[i] = _cmsDupMem(ContextID, Data ->Curves[i], Data -> nElements * sizeof(cmsUInt16Number));
-    }
-
-    return (void*) Data;
-}
-
-// Precomputes tables for 8-bit on input devicelink. 
-static
-Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)
-{
-    int i, j;
-    Curves16Data* c16;
-
-    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));
-    if (c16 == NULL) return NULL;
-
-    c16 ->nCurves = nCurves;
-    c16 ->nElements = nElements;
-
-    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));
-    if (c16 ->Curves == NULL) return NULL;
-
-    for (i=0; i < nCurves; i++) {
-
-        c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));
-
-        if (nElements == 256) {
-
-            for (j=0; j < nElements; j++) {
-
-                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));             
-            }
-        }
-        else {
-
-            for (j=0; j < nElements; j++) {
-                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);             
-            }
-        }
-    }
-
-    return c16;
-}
-
-static
-void FastEvaluateCurves8(register const cmsUInt16Number In[], 
-                          register cmsUInt16Number Out[], 
-                          register const void* D)
-{   
-    Curves16Data* Data = (Curves16Data*) D;
-    cmsUInt8Number x;
-    int i;
-    
-    for (i=0; i < Data ->nCurves; i++) {
-
-         x = (In[i] >> 8);
-         Out[i] = Data -> Curves[i][x];
-    }
-}
-
-    
-static
-void FastEvaluateCurves16(register const cmsUInt16Number In[], 
-                          register cmsUInt16Number Out[], 
-                          register const void* D)
-{   
-    Curves16Data* Data = (Curves16Data*) D;
-    int i;
-    
-    for (i=0; i < Data ->nCurves; i++) {
-         Out[i] = Data -> Curves[i][In[i]];
-    }
-}
-
-
-static
-void FastIdentity16(register const cmsUInt16Number In[], 
-                    register cmsUInt16Number Out[], 
-                    register const void* D)
-{
-    cmsPipeline* Lut = (cmsPipeline*) D;
-    cmsUInt32Number i;
-
-    for (i=0; i < Lut ->InputChannels; i++) {
-         Out[i] = In[i];   
-    }
-}
-
-
-// If the target LUT holds only curves, the optimization procedure is to join all those
-// curves together. That only works on curves and does not work on matrices.
-static
-cmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)
-{
-    cmsToneCurve** GammaTables = NULL; 
-    cmsFloat32Number InFloat[cmsMAXCHANNELS], OutFloat[cmsMAXCHANNELS];
-    cmsUInt32Number i, j;
-    cmsPipeline* Src = *Lut;
-    cmsPipeline* Dest = NULL;
-    cmsStage* mpe;
-    cmsStage* ObtainedCurves = NULL;
-
-
-    // This is a loosy optimization! does not apply in floating-point cases
-    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;
-
-    //  Only curves in this LUT?
-    for (mpe = cmsPipelineGetPtrToFirstStage(Src);
-         mpe != NULL;
-         mpe = cmsStageNext(mpe)) {
-            if (cmsStageType(mpe) != cmsSigCurveSetElemType) return FALSE;
-    }
-
-    // Allocate an empty LUT 
-    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);
-    if (Dest == NULL) return FALSE;
-
-    // Create target curves
-    GammaTables = (cmsToneCurve**) _cmsCalloc(Src ->ContextID, Src ->InputChannels, sizeof(cmsToneCurve*));
-    if (GammaTables == NULL) goto Error;
-
-    for (i=0; i < Src ->InputChannels; i++) {
-        GammaTables[i] = cmsBuildTabulatedToneCurve16(Src ->ContextID, PRELINEARIZATION_POINTS, NULL);
-        if (GammaTables[i] == NULL) goto Error;
-    }
-
-    // Compute 16 bit result by using floating point
-    for (i=0; i < PRELINEARIZATION_POINTS; i++) {
-
-        for (j=0; j < Src ->InputChannels; j++) 
-            InFloat[j] = (cmsFloat32Number) ((cmsFloat64Number) i / (PRELINEARIZATION_POINTS - 1));
-
-        cmsPipelineEvalFloat(InFloat, OutFloat, Src);
-
-        for (j=0; j < Src ->InputChannels; j++)
-            GammaTables[j] -> Table16[i] = _cmsQuickSaturateWord(OutFloat[j] * 65535.0);
-    }
-
-    ObtainedCurves = cmsStageAllocToneCurves(Src ->ContextID, Src ->InputChannels, GammaTables);
-    if (ObtainedCurves == NULL) goto Error;
-
-    for (i=0; i < Src ->InputChannels; i++) {
-        cmsFreeToneCurve(GammaTables[i]);
-        GammaTables[i] = NULL;
-    }
-
-    if (GammaTables != NULL) _cmsFree(Src ->ContextID, GammaTables);
-
-    // Maybe the curves are linear at the end
-    if (!AllCurvesAreLinear(ObtainedCurves)) {
-
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves); 
-
-        // If the curves are to be applied in 8 bits, we can save memory
-        if (_cmsFormatterIs8bit(*InputFormat)) {
-
-            _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) ObtainedCurves ->Data;
-             Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 256, Data ->TheCurves);
-
-             *dwFlags |= cmsFLAGS_NOCACHE;
-            _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves8, c16, CurvesFree, CurvesDup);
-
-        }
-        else {
-
-            _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) cmsStageData(ObtainedCurves);
-             Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 65536, Data ->TheCurves);
-
-             *dwFlags |= cmsFLAGS_NOCACHE;
-            _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves16, c16, CurvesFree, CurvesDup);          
-        }
-    }
-    else {
-
-        // LUT optimizes to nothing. Set the identity LUT
-        cmsStageFree(ObtainedCurves);
-
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels));
-
-        *dwFlags |= cmsFLAGS_NOCACHE;
-        _cmsPipelineSetOptimizationParameters(Dest, FastIdentity16, (void*) Dest, NULL, NULL);
-    }
-
-    // We are done.
-    cmsPipelineFree(Src);
-    *Lut = Dest;
-    return TRUE;
-
-Error:
-
-    if (ObtainedCurves != NULL) cmsStageFree(ObtainedCurves);
-    if (GammaTables != NULL) {
-        for (i=0; i < Src ->InputChannels; i++) {
-            if (GammaTables[i] != NULL) cmsFreeToneCurve(GammaTables[i]);
-        }
-
-        _cmsFree(Src ->ContextID, GammaTables);
-    }
-
-    if (Dest != NULL) cmsPipelineFree(Dest);
-    return FALSE;
-
-    cmsUNUSED_PARAMETER(Intent);
-    cmsUNUSED_PARAMETER(InputFormat);
-    cmsUNUSED_PARAMETER(OutputFormat);
-    cmsUNUSED_PARAMETER(dwFlags);
-}
-
-// -------------------------------------------------------------------------------------------------------------------------------------
-// LUT is Shaper - Matrix - Matrix - Shaper, which is very frequent when combining two matrix-shaper profiles
-
-
-static
-void  FreeMatShaper(cmsContext ContextID, void* Data)
-{
-    if (Data != NULL) _cmsFree(ContextID, Data);
-}
-
-static
-void* DupMatShaper(cmsContext ContextID, const void* Data)
-{
-    return _cmsDupMem(ContextID, Data, sizeof(MatShaper8Data));
-}
-
-
-// A fast matrix-shaper evaluator for 8 bits. This is a bit ticky since I'm using 1.14 signed fixed point 
-// to accomplish some performance. Actually it takes 256x3 16 bits tables and 16385 x 3 tables of 8 bits, 
-// in total about 50K, and the performance boost is huge!
-static
-void MatShaperEval16(register const cmsUInt16Number In[], 
-                     register cmsUInt16Number Out[], 
-                     register const void* D)
-{    
-    MatShaper8Data* p = (MatShaper8Data*) D;
-    cmsS1Fixed14Number l1, l2, l3, r, g, b;
-    cmsUInt32Number ri, gi, bi;
-
-    // In this case (and only in this case!) we can use this simplification since 
-    // In[] is assured to come from a 8 bit number. (a << 8 | a)
-    ri = In[0] & 0xFF;
-    gi = In[1] & 0xFF;
-    bi = In[2] & 0xFF;
-    
-    // Across first shaper, which also converts to 1.14 fixed point
-    r = p->Shaper1R[ri];
-    g = p->Shaper1G[gi];
-    b = p->Shaper1B[bi];
-        
-    // Evaluate the matrix in 1.14 fixed point
-    l1 =  (p->Mat[0][0] * r + p->Mat[0][1] * g + p->Mat[0][2] * b + p->Off[0] + 0x2000) >> 14;
-    l2 =  (p->Mat[1][0] * r + p->Mat[1][1] * g + p->Mat[1][2] * b + p->Off[1] + 0x2000) >> 14;
-    l3 =  (p->Mat[2][0] * r + p->Mat[2][1] * g + p->Mat[2][2] * b + p->Off[2] + 0x2000) >> 14;
-    
-    // Now we have to clip to 0..1.0 range 
-    ri = (l1 < 0) ? 0 : ((l1 > 16384) ? 16384 : l1);               
-    gi = (l2 < 0) ? 0 : ((l2 > 16384) ? 16384 : l2);               
-    bi = (l3 < 0) ? 0 : ((l3 > 16384) ? 16384 : l3);               
-         
-    // And across second shaper, 
-    Out[0] = p->Shaper2R[ri];
-    Out[1] = p->Shaper2G[gi];
-    Out[2] = p->Shaper2B[bi];
-   
-}
-
-// This table converts from 8 bits to 1.14 after applying the curve
-static
-void FillFirstShaper(cmsS1Fixed14Number* Table, cmsToneCurve* Curve)
-{
-    int i;
-    cmsFloat32Number R, y;
-
-    for (i=0; i < 256; i++) {
-        
-        R   = (cmsFloat32Number) (i / 255.0);
-        y   = cmsEvalToneCurveFloat(Curve, R);        
-
-        Table[i] = DOUBLE_TO_1FIXED14(y);
-    }
-}
-
-// This table converts form 1.14 (being 0x4000 the last entry) to 8 bits after applying the curve
-static
-void FillSecondShaper(cmsUInt16Number* Table, cmsToneCurve* Curve, cmsBool Is8BitsOutput)
-{
-    int i;
-    cmsFloat32Number R, Val;
-
-    for (i=0; i < 16385; i++) {
-
-        R   = (cmsFloat32Number) (i / 16384.0);
-        Val = cmsEvalToneCurveFloat(Curve, R);    // Val comes 0..1.0
-        
-        if (Is8BitsOutput) {
-
-            // If 8 bits output, we can optimize further by computing the / 257 part.
-            // first we compute the resulting byte and then we store the byte times
-            // 257. This quantization allows to round very quick by doing a >> 8, but
-            // since the low byte is always equal to msb, we can do a & 0xff and this works!
-            cmsUInt16Number w = _cmsQuickSaturateWord(Val * 65535.0 + 0.5);        
-            cmsUInt8Number  b = FROM_16_TO_8(w);
-
-            Table[i] = FROM_8_TO_16(b);
-        }
-        else Table[i]  = _cmsQuickSaturateWord(Val * 65535.0 + 0.5);        
-    }
-}
-
-// Compute the matrix-shaper structure
-static
-cmsBool SetMatShaper(cmsPipeline* Dest, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3], cmsUInt32Number* OutputFormat)
-{
-    MatShaper8Data* p;
-    int i, j;
-    cmsBool Is8Bits = _cmsFormatterIs8bit(*OutputFormat);
-
-    // Allocate a big chuck of memory to store precomputed tables
-    p = (MatShaper8Data*) _cmsMalloc(Dest ->ContextID, sizeof(MatShaper8Data));
-    if (p == NULL) return FALSE;
-
-    p -> ContextID = Dest -> ContextID;
-
-    // Precompute tables
-    FillFirstShaper(p ->Shaper1R, Curve1[0]);
-    FillFirstShaper(p ->Shaper1G, Curve1[1]);
-    FillFirstShaper(p ->Shaper1B, Curve1[2]);
-
-    FillSecondShaper(p ->Shaper2R, Curve2[0], Is8Bits);
-    FillSecondShaper(p ->Shaper2G, Curve2[1], Is8Bits);
-    FillSecondShaper(p ->Shaper2B, Curve2[2], Is8Bits);
-
-    // Convert matrix to nFixed14. Note that those values may take more than 16 bits as
-    for (i=0; i < 3; i++) {
-        for (j=0; j < 3; j++) {         
-            p ->Mat[i][j] = DOUBLE_TO_1FIXED14(Mat->v[i].n[j]);
-        }
-    }
-    
-    for (i=0; i < 3; i++) {
-
-        if (Off == NULL) {          
-            p ->Off[i] = 0;
-        }
-        else {      
-            p ->Off[i] = DOUBLE_TO_1FIXED14(Off->n[i]);
-        }
-    }
-
-    // Mark as optimized for faster formatter
-    if (Is8Bits)
-        *OutputFormat |= OPTIMIZED_SH(1);
-
-    // Fill function pointers    
-    _cmsPipelineSetOptimizationParameters(Dest, MatShaperEval16, (void*) p, FreeMatShaper, DupMatShaper);
-    return TRUE;
-}
-
-//  8 bits on input allows matrix-shaper boot up to 25 Mpixels per second on RGB. That's fast!
-// TODO: Allow a third matrix for abs. colorimetric
-static
-cmsBool OptimizeMatrixShaper(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)
-{
-    cmsStage* Curve1, *Curve2;
-    cmsStage* Matrix1, *Matrix2;
-    _cmsStageMatrixData* Data1;
-    _cmsStageMatrixData* Data2;
-    cmsMAT3 res;
-    cmsBool IdentityMat;
-    cmsPipeline* Dest, *Src;
-   
-    // Only works on RGB to RGB
-    if (T_CHANNELS(*InputFormat) != 3 || T_CHANNELS(*OutputFormat) != 3) return FALSE;
-
-    // Only works on 8 bit input
-    if (!_cmsFormatterIs8bit(*InputFormat)) return FALSE;
-
-    // Seems suitable, proceed
-    Src = *Lut;
-
-    // Check for shaper-matrix-matrix-shaper structure, that is what this optimizer stands for
-    if (!cmsPipelineCheckAndRetreiveStages(Src, 4, 
-        cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, 
-        &Curve1, &Matrix1, &Matrix2, &Curve2)) return FALSE;
-
-    // Get both matrices
-    Data1 = (_cmsStageMatrixData*) cmsStageData(Matrix1);
-    Data2 = (_cmsStageMatrixData*) cmsStageData(Matrix2);
-
-    // Input offset should be zero
-    if (Data1 ->Offset != NULL) return FALSE;
-
-    // Multiply both matrices to get the result
-    _cmsMAT3per(&res, (cmsMAT3*) Data2 ->Double, (cmsMAT3*) Data1 ->Double);
-
-    // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?
-    IdentityMat = FALSE;
-    if (_cmsMAT3isIdentity(&res) && Data2 ->Offset == NULL) {
-
-        // We can get rid of full matrix
-        IdentityMat = TRUE;
-    }
-
-      // Allocate an empty LUT 
-    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);
-    if (!Dest) return FALSE;
-
-    // Assamble the new LUT
-    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));
-    if (!IdentityMat) 
-        cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest ->ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));
-    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));
-
-    // If identity on matrix, we can further optimize the curves, so call the join curves routine
-    if (IdentityMat) {
-
-        OptimizeByJoiningCurves(&Dest, Intent, InputFormat, OutputFormat, dwFlags);     
-    }
-    else {
-        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);
-        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);
-                
-        // In this particular optimization, cach does not help as it takes more time to deal with 
-        // the cach that with the pixel handling
-        *dwFlags |= cmsFLAGS_NOCACHE;
-
-        // Setup the optimizarion routines
-        SetMatShaper(Dest, mpeC1 ->TheCurves, &res, (cmsVEC3*) Data2 ->Offset, mpeC2->TheCurves, OutputFormat);
-    }
-
-    cmsPipelineFree(Src);
-    *Lut = Dest;
-    return TRUE;
-}
-
-
-// -------------------------------------------------------------------------------------------------------------------------------------
-// Optimization plug-ins
-
-// List of optimizations
-typedef struct _cmsOptimizationCollection_st {
-    
-    _cmsOPToptimizeFn  OptimizePtr;
-    
-    struct _cmsOptimizationCollection_st *Next;
-
-} _cmsOptimizationCollection;
-
-
-// The built-in list. We currently implement 4 types of optimizations. Joining of curves, matrix-shaper, linearization and resampling
-static _cmsOptimizationCollection DefaultOptimization[] = {
-
-    { OptimizeByJoiningCurves,            &DefaultOptimization[1] },
-    { OptimizeMatrixShaper,               &DefaultOptimization[2] },
-    { OptimizeByComputingLinearization,   &DefaultOptimization[3] },
-    { OptimizeByResampling,               NULL }
-};
-
-// The linked list head
-static _cmsOptimizationCollection* OptimizationCollection = DefaultOptimization;
-
-// Register new ways to optimize
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Data)
-{
-    cmsPluginOptimization* Plugin = (cmsPluginOptimization*) Data;
-    _cmsOptimizationCollection* fl;
-    
-    if (Data == NULL) {
-
-        OptimizationCollection = DefaultOptimization; 
-        return TRUE;
-    }
-    
-    // Optimizer callback is required
-    if (Plugin ->OptimizePtr == NULL) return FALSE;
-
-    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(sizeof(_cmsOptimizationCollection));
-    if (fl == NULL) return FALSE;
-
-    // Copy the parameters
-    fl ->OptimizePtr = Plugin ->OptimizePtr;
-        
-    // Keep linked list
-    fl ->Next = OptimizationCollection;
-    OptimizationCollection = fl;
-
-    // All is ok
-    return TRUE;
-}
-
-// The entry point for LUT optimization
-cmsBool _cmsOptimizePipeline(cmsPipeline**    PtrLut,                                               
-                             int              Intent,
-                             cmsUInt32Number* InputFormat, 
-                             cmsUInt32Number* OutputFormat,
-                             cmsUInt32Number* dwFlags)
-{    
-    _cmsOptimizationCollection* Opts;
-    cmsBool AnySuccess = FALSE;
-   
-    // A CLUT is being asked, so force this specific optimization
-    if (*dwFlags & cmsFLAGS_FORCE_CLUT) {
-    
-        PreOptimize(*PtrLut);
-        return OptimizeByResampling(PtrLut, Intent, InputFormat, OutputFormat, dwFlags);
-    }
-
-    // Anything to optimize?
-    if ((*PtrLut) ->Elements == NULL) {
-        _cmsPipelineSetOptimizationParameters(*PtrLut, FastIdentity16, (void*) *PtrLut, NULL, NULL);
-        return TRUE;        
-    }
-
-    // Try to get rid of identities and trivial conversions.
-    AnySuccess = PreOptimize(*PtrLut);
-
-    // After removal do we end with an identity?
-    if ((*PtrLut) ->Elements == NULL) {
-        _cmsPipelineSetOptimizationParameters(*PtrLut, FastIdentity16, (void*) *PtrLut, NULL, NULL);
-        return TRUE;
-    }
-
-    // Do not optimize, keep all precision
-    if (*dwFlags & cmsFLAGS_NOOPTIMIZE)
-        return FALSE;
-    
-    // Try built-in optimizations and plug-in
-    for (Opts = OptimizationCollection;
-         Opts != NULL;
-         Opts = Opts ->Next) {
-            
-            // If one schema succeeded, we are done
-            if (Opts ->OptimizePtr(PtrLut, Intent, InputFormat, OutputFormat, dwFlags)) {
-                
-                return TRUE;    // Optimized!
-            }
-    }
-    
-    // Only simple optimizations succeeded
-    return AnySuccess;
-}
-
-
-
diff --git a/thirdparty/liblcms2/src/cmspack.c b/thirdparty/liblcms2/src/cmspack.c
deleted file mode 100644
index 196afa9..0000000
--- a/thirdparty/liblcms2/src/cmspack.c
+++ /dev/null
@@ -1,2558 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// This module handles all formats supported by lcms. There are two flavors, 16 bits and 
-// floating point. Floating point is supported only in a subset, those formats holding
-// cmsFloat32Number (4 bytes per component) and double (marked as 0 bytes per component as special 
-// case)
-
-// ---------------------------------------------------------------------------
-
-
-// This macro return words stored as big endian
-#define CHANGE_ENDIAN(w)    (cmsUInt16Number) ((cmsUInt16Number) ((w)<<8)|((w)>>8))
-
-// These macros handles reversing (negative)
-#define REVERSE_FLAVOR_8(x)     ((cmsUInt8Number) (0xff-(x)))
-#define REVERSE_FLAVOR_16(x)    ((cmsUInt16Number)(0xffff-(x)))
-
-// * 0xffff / 0xff00 = (255 * 257) / (255 * 256) = 257 / 256
-cmsINLINE cmsUInt16Number FomLabV2ToLabV4(cmsUInt16Number x) 
-{
-    int a;
-
-    a = (x << 8 | x) >> 8;  // * 257 / 256
-    if ( a > 0xffff) return 0xffff;
-    return (cmsUInt16Number) a;
-}
-
-// * 0xf00 / 0xffff = * 256 / 257
-cmsINLINE cmsUInt16Number FomLabV4ToLabV2(cmsUInt16Number x) 
-{
-    return (cmsUInt16Number) (((x << 8) + 0x80) / 257);
-}
-
-
-typedef struct {
-    cmsUInt32Number Type;
-    cmsUInt32Number Mask;
-    cmsFormatter16 Frm;
-
-} cmsFormatters16;
-
-typedef struct {
-    cmsUInt32Number    Type;
-    cmsUInt32Number    Mask;
-    cmsFormatterFloat Frm;
-
-} cmsFormattersFloat;
-
-#define ANYSPACE        COLORSPACE_SH(31)
-#define ANYCHANNELS     CHANNELS_SH(15)
-#define ANYEXTRA        EXTRA_SH(7)
-#define ANYPLANAR       PLANAR_SH(1)
-#define ANYENDIAN       ENDIAN16_SH(1)
-#define ANYSWAP         DOSWAP_SH(1)
-#define ANYSWAPFIRST    SWAPFIRST_SH(1) 
-#define ANYFLAVOR       FLAVOR_SH(1)
-
-
-// Supress waning about info never being used
-
-#ifdef _MSC_VER
-#pragma warning(disable : 4100)
-#endif
-
-// Unpacking routines (16 bits) ---------------------------------------------------------------------------------------- 
-
-// Does almost everything but is slow
-static
-cmsUInt8Number* UnrollChunkyBytes(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wIn[], 
-                                  register cmsUInt8Number* accum,
-                                  register cmsUInt32Number Stride)
-{
-    int nChan      = T_CHANNELS(info -> InputFormat);
-    int DoSwap     = T_DOSWAP(info ->InputFormat);
-    int Reverse    = T_FLAVOR(info ->InputFormat);
-    int SwapFirst  = T_SWAPFIRST(info -> InputFormat);
-    int Extra      = T_EXTRA(info -> InputFormat);
-    int ExtraFirst = DoSwap && !SwapFirst;
-    cmsUInt16Number v;
-    int i;
-
-    if (ExtraFirst) {
-        accum += Extra;
-    }
-
-    for (i=0; i < nChan; i++) {
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = FROM_8_TO_16(*accum); 
-        v = Reverse ? REVERSE_FLAVOR_16(v) : v;
-        wIn[index] = v;
-        accum++;              
-    }
-
-    if (!ExtraFirst) {
-        accum += Extra;
-    }
-
-    if (Extra == 0 && SwapFirst) {
-        cmsUInt16Number tmp = wIn[0];
-
-        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));
-        wIn[nChan-1] = tmp;
-    }
-
-    return accum;
-}
-
-// Extra channels are just ignored because come in the next planes
-static
-cmsUInt8Number* UnrollPlanarBytes(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wIn[], 
-                                  register cmsUInt8Number* accum,
-                                  register cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> InputFormat);
-    int DoSwap= T_DOSWAP(info ->InputFormat);
-    int Reverse= T_FLAVOR(info ->InputFormat);
-    int i;
-    cmsUInt8Number* Init = accum;
-
-    if (DoSwap) {
-        accum += T_EXTRA(info -> InputFormat) * Stride;
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-        cmsUInt16Number v = FROM_8_TO_16(*accum); 
-
-        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;
-        accum += Stride;
-    }
-
-    return (Init + 1);
-}
-
-// Special cases, provided for performance
-static
-cmsUInt8Number* Unroll4Bytes(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = FROM_8_TO_16(*accum); accum++; // C
-    wIn[1] = FROM_8_TO_16(*accum); accum++; // M
-    wIn[2] = FROM_8_TO_16(*accum); accum++; // Y
-    wIn[3] = FROM_8_TO_16(*accum); accum++; // K
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4BytesReverse(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number Stride)
-{
-    wIn[0] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // C
-    wIn[1] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // M
-    wIn[2] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // Y
-    wIn[3] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // K
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4BytesSwapFirst(register _cmsTRANSFORM* info, 
-                                      register cmsUInt16Number wIn[], 
-                                      register cmsUInt8Number* accum,
-                                      register cmsUInt32Number Stride)
-{
-    wIn[3] = FROM_8_TO_16(*accum); accum++; // K
-    wIn[0] = FROM_8_TO_16(*accum); accum++; // C
-    wIn[1] = FROM_8_TO_16(*accum); accum++; // M
-    wIn[2] = FROM_8_TO_16(*accum); accum++; // Y
-
-    return accum;
-}
-
-// KYMC
-static
-cmsUInt8Number* Unroll4BytesSwap(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[3] = FROM_8_TO_16(*accum); accum++;  // K
-    wIn[2] = FROM_8_TO_16(*accum); accum++;  // Y
-    wIn[1] = FROM_8_TO_16(*accum); accum++;  // M
-    wIn[0] = FROM_8_TO_16(*accum); accum++;  // C
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4BytesSwapSwapFirst(register _cmsTRANSFORM* info, 
-                                          register cmsUInt16Number wIn[], 
-                                          register cmsUInt8Number* accum,
-                                          register cmsUInt32Number Stride)
-{
-    wIn[2] = FROM_8_TO_16(*accum); accum++;  // K
-    wIn[1] = FROM_8_TO_16(*accum); accum++;  // Y
-    wIn[0] = FROM_8_TO_16(*accum); accum++;  // M
-    wIn[3] = FROM_8_TO_16(*accum); accum++;  // C
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3Bytes(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = FROM_8_TO_16(*accum); accum++;     // R
-    wIn[1] = FROM_8_TO_16(*accum); accum++;     // G
-    wIn[2] = FROM_8_TO_16(*accum); accum++;     // B
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3BytesSkip1Swap(register _cmsTRANSFORM* info, 
-                                      register cmsUInt16Number wIn[], 
-                                      register cmsUInt8Number* accum,
-                                      register cmsUInt32Number Stride)
-{
-    accum++; // A
-    wIn[2] = FROM_8_TO_16(*accum); accum++; // B
-    wIn[1] = FROM_8_TO_16(*accum); accum++; // G
-    wIn[0] = FROM_8_TO_16(*accum); accum++; // R
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3BytesSkip1SwapFirst(register _cmsTRANSFORM* info, 
-                                           register cmsUInt16Number wIn[], 
-                                           register cmsUInt8Number* accum,
-                                           register cmsUInt32Number Stride)
-{
-    accum++; // A
-    wIn[0] = FROM_8_TO_16(*accum); accum++; // R
-    wIn[1] = FROM_8_TO_16(*accum); accum++; // G
-    wIn[2] = FROM_8_TO_16(*accum); accum++; // B
-
-    return accum;
-}
-
-
-// BRG
-static
-cmsUInt8Number* Unroll3BytesSwap(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[2] = FROM_8_TO_16(*accum); accum++;     // B
-    wIn[1] = FROM_8_TO_16(*accum); accum++;     // G
-    wIn[0] = FROM_8_TO_16(*accum); accum++;     // R
-
-    return accum;
-}
-
-static
-cmsUInt8Number* UnrollLabV2_8(register _cmsTRANSFORM* info, 
-                              register cmsUInt16Number wIn[], 
-                              register cmsUInt8Number* accum,
-                              register cmsUInt32Number Stride)
-{
-    wIn[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L
-    wIn[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a
-    wIn[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b
-
-    return accum;
-}
-
-static
-cmsUInt8Number* UnrollALabV2_8(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wIn[], 
-                               register cmsUInt8Number* accum,
-                               register cmsUInt32Number Stride)
-{
-    accum++;  // A
-    wIn[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L
-    wIn[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a
-    wIn[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b
-
-    return accum;
-}
-
-static
-cmsUInt8Number* UnrollLabV2_16(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wIn[], 
-                               register cmsUInt8Number* accum,
-                               register cmsUInt32Number Stride)
-{
-    wIn[0] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // L
-    wIn[1] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // a
-    wIn[2] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // b
-
-    return accum;
-}
-
-// for duplex
-static
-cmsUInt8Number* Unroll2Bytes(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = FROM_8_TO_16(*accum); accum++;     // ch1
-    wIn[1] = FROM_8_TO_16(*accum); accum++;     // ch2
-    return accum;
-}
-
-
-
-
-// Monochrome duplicates L into RGB for null-transforms
-static
-cmsUInt8Number* Unroll1Byte(register _cmsTRANSFORM* info, 
-                                     register cmsUInt16Number wIn[], 
-                                     register cmsUInt8Number* accum,
-                                     register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L       
-    return accum;
-}
-
-
-static
-cmsUInt8Number* Unroll1ByteSkip1(register _cmsTRANSFORM* info, 
-                            register cmsUInt16Number wIn[], 
-                            register cmsUInt8Number* accum,
-                            register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L
-    accum += 1;
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll1ByteSkip2(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L
-    accum += 2;
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll1ByteReversed(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = REVERSE_FLAVOR_16(FROM_8_TO_16(*accum)); accum++;     // L
-    return accum;
-}
-
-
-static
-cmsUInt8Number* UnrollAnyWords(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wIn[], 
-                               register cmsUInt8Number* accum,
-                               register cmsUInt32Number Stride)
-{
-    int nChan       = T_CHANNELS(info -> InputFormat);
-    int SwapEndian  = T_ENDIAN16(info -> InputFormat);
-    int DoSwap      = T_DOSWAP(info ->InputFormat);
-    int Reverse     = T_FLAVOR(info ->InputFormat);
-    int SwapFirst   = T_SWAPFIRST(info -> InputFormat);
-    int Extra       = T_EXTRA(info -> InputFormat);
-    int ExtraFirst  = DoSwap && !SwapFirst;
-    int i;
-
-    if (ExtraFirst) {
-        accum += Extra * sizeof(cmsUInt16Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-        cmsUInt16Number v = *(cmsUInt16Number*) accum; 
-
-        if (SwapEndian)
-            v = CHANGE_ENDIAN(v);
-
-        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;
-
-        accum += sizeof(cmsUInt16Number);              
-    }
-
-    if (!ExtraFirst) {
-        accum += Extra * sizeof(cmsUInt16Number);
-    }
-
-    if (Extra == 0 && SwapFirst) {
-
-        cmsUInt16Number tmp = wIn[0];
-
-        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));
-        wIn[nChan-1] = tmp;
-    }
-
-    return accum;
-}
-
-static
-cmsUInt8Number* UnrollPlanarWords(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wIn[], 
-                                  register cmsUInt8Number* accum,
-                                  register cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> InputFormat);
-    int DoSwap= T_DOSWAP(info ->InputFormat);
-    int Reverse= T_FLAVOR(info ->InputFormat);
-    int SwapEndian = T_ENDIAN16(info -> InputFormat);
-    int i;
-    cmsUInt8Number* Init = accum;
-
-    if (DoSwap) {
-        accum += T_EXTRA(info -> InputFormat) * Stride * sizeof(cmsUInt16Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-        cmsUInt16Number v = *(cmsUInt16Number*) accum; 
-
-        if (SwapEndian)
-            v = CHANGE_ENDIAN(v);
-
-        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;
-
-        accum +=  Stride * sizeof(cmsUInt16Number);           
-    }
-
-    return (Init + sizeof(cmsUInt16Number));
-}
-
-
-static
-cmsUInt8Number* Unroll4Words(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y
-    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4WordsReverse(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number Stride)
-{
-    wIn[0] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // C
-    wIn[1] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // M
-    wIn[2] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // Y
-    wIn[3] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // K
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4WordsSwapFirst(register _cmsTRANSFORM* info, 
-                                      register cmsUInt16Number wIn[], 
-                                      register cmsUInt8Number* accum,
-                                      register cmsUInt32Number Stride)
-{
-    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y
-
-    return accum;
-}
-
-// KYMC
-static
-cmsUInt8Number* Unroll4WordsSwap(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll4WordsSwapSwapFirst(register _cmsTRANSFORM* info, 
-                                          register cmsUInt16Number wIn[], 
-                                          register cmsUInt8Number* accum,
-                                          register cmsUInt32Number Stride)
-{
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // K
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // Y
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // M
-    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // C
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3Words(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2;  // C R
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2;  // M G
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;  // Y B
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3WordsSwap(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;  // C R
-    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2;  // M G
-    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2;  // Y B
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3WordsSkip1Swap(register _cmsTRANSFORM* info, 
-                                      register cmsUInt16Number wIn[], 
-                                      register cmsUInt8Number* accum,
-                                      register cmsUInt32Number Stride)
-{
-    accum += 2; // A
-    wIn[2] = *(cmsUInt16Number*) accum; accum += 2; // R
-    wIn[1] = *(cmsUInt16Number*) accum; accum += 2; // G
-    wIn[0] = *(cmsUInt16Number*) accum; accum += 2; // B
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll3WordsSkip1SwapFirst(register _cmsTRANSFORM* info, 
-                                           register cmsUInt16Number wIn[], 
-                                           register cmsUInt8Number* accum,
-                                           register cmsUInt32Number Stride)
-{
-    accum += 2; // A
-    wIn[0] = *(cmsUInt16Number*) accum; accum += 2; // R
-    wIn[1] = *(cmsUInt16Number*) accum; accum += 2; // G
-    wIn[2] = *(cmsUInt16Number*) accum; accum += 2; // B
-
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll1Word(register _cmsTRANSFORM* info, 
-                            register cmsUInt16Number wIn[], 
-                            register cmsUInt8Number* accum,
-                            register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;   // L
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll1WordReversed(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2;
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll1WordSkip3(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    wIn[0] = wIn[1] = wIn[2] = *(cmsUInt16Number*) accum; 
-
-    accum += 8;
-    return accum;
-}
-
-static
-cmsUInt8Number* Unroll2Words(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wIn[], 
-                             register cmsUInt8Number* accum,
-                             register cmsUInt32Number Stride)
-{
-    wIn[0] = *(cmsUInt16Number*) accum; accum += 2;    // ch1
-    wIn[1] = *(cmsUInt16Number*) accum; accum += 2;    // ch2
-
-    return accum;
-}
-
-
-// This is a conversion of Lab double to 16 bits
-static
-cmsUInt8Number* UnrollLabDoubleTo16(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number  Stride)
-{       
-    if (T_PLANAR(info -> InputFormat)) {
-
-        cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-        cmsCIELab Lab;
-
-        Lab.L = Pt[0];
-        Lab.a = Pt[Stride];
-        Lab.b = Pt[Stride*2];
-
-        cmsFloat2LabEncoded(wIn, &Lab);
-        return accum + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        cmsFloat2LabEncoded(wIn, (cmsCIELab*) accum);
-        accum += sizeof(cmsCIELab) + T_EXTRA(info ->InputFormat) * sizeof(cmsFloat64Number);
-        return accum;
-    }
-}
-
-// This is a conversion of XYZ double to 16 bits
-static
-cmsUInt8Number* UnrollXYZDoubleTo16(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wIn[], 
-                                    register cmsUInt8Number* accum,
-                                    register cmsUInt32Number Stride)
-{   
-    if (T_PLANAR(info -> InputFormat)) {
-
-        cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-        cmsCIEXYZ XYZ;
-
-        XYZ.X = Pt[0];
-        XYZ.Y = Pt[Stride];
-        XYZ.Z = Pt[Stride*2];
-        cmsFloat2XYZEncoded(wIn, &XYZ);
-
-        return accum + sizeof(cmsFloat64Number);
-
-    }
-
-    else {
-        cmsFloat2XYZEncoded(wIn, (cmsCIEXYZ*) accum);
-        accum += sizeof(cmsCIEXYZ) + T_EXTRA(info ->InputFormat) * sizeof(cmsFloat64Number);
-
-        return accum;
-    }
-}
-
-// Check if space is marked as ink
-cmsINLINE cmsBool IsInkSpace(cmsUInt32Number Type)
-{
-    switch (T_COLORSPACE(Type)) {
-
-     case PT_CMY:       
-     case PT_CMYK:      
-     case PT_MCH5:      
-     case PT_MCH6:
-     case PT_MCH7:     
-     case PT_MCH8:     
-     case PT_MCH9:     
-     case PT_MCH10:    
-     case PT_MCH11:    
-     case PT_MCH12:    
-     case PT_MCH13:    
-     case PT_MCH14:    
-     case PT_MCH15: return TRUE;
-
-     default: return FALSE;
-    }
-}
-
-// Inks does come in percentage, remaining cases are between 0..1.0, again to 16 bits
-static
-cmsUInt8Number* UnrollDoubleTo16(register _cmsTRANSFORM* info, 
-                                 register cmsUInt16Number wIn[], 
-                                 register cmsUInt8Number* accum,
-                                 register cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Inks = (cmsFloat64Number*) accum;
-    int nChan  = T_CHANNELS(info -> InputFormat);
-    int Planar = T_PLANAR(info -> InputFormat);
-    int i;
-    cmsFloat64Number v;
-    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 655.35 : 65535.0;
-
-    for (i=0; i < nChan; i++) {
-
-        if (Planar)
-
-            v = Inks[i * Stride];
-        else
-            v = Inks[i];
-
-        wIn[i] = _cmsQuickSaturateWord(v * maximum);
-    }
-
-    if (T_PLANAR(info -> InputFormat))
-        return accum + sizeof(cmsFloat64Number);
-    else
-        return accum + (nChan + T_EXTRA(info ->InputFormat)) * sizeof(cmsFloat64Number);
-}
-
-static
-cmsUInt8Number* UnrollFloatTo16(register _cmsTRANSFORM* info, 
-                                register cmsUInt16Number wIn[], 
-                                register cmsUInt8Number* accum,
-                                register cmsUInt32Number Stride)
-{
-    cmsFloat32Number* Inks = (cmsFloat32Number*) accum;
-    int nChan  = T_CHANNELS(info -> InputFormat);
-    int Planar = T_PLANAR(info -> InputFormat);
-    int i;
-    cmsFloat32Number v;
-    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 655.35 : 65535.0;
-
-    for (i=0; i < nChan; i++) {
-
-        if (Planar)
-
-            v = Inks[i * Stride];
-        else
-            v = Inks[i];
-
-        wIn[i] = _cmsQuickSaturateWord(v * maximum);
-    }
-
-    if (T_PLANAR(info -> InputFormat))
-        return accum + sizeof(cmsFloat32Number);
-    else
-        return accum + (nChan + T_EXTRA(info ->InputFormat)) * sizeof(cmsFloat32Number);
-}
-
-
-// For 1 channel, we need to duplicate data (it comes in 0..1.0 range)
-static
-cmsUInt8Number* UnrollDouble1Chan(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wIn[], 
-                                  register cmsUInt8Number* accum,
-                                  register cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Inks = (cmsFloat64Number*) accum;
-
-    wIn[0] = wIn[1] = wIn[2] = _cmsQuickSaturateWord(Inks[0] * 65535.0);
-
-    return accum + sizeof(cmsFloat64Number);    
-}
-
-//-------------------------------------------------------------------------------------------------------------------
-
-// True float transformation. 
-
-// For anything going from cmsFloat32Number 
-static
-cmsUInt8Number* UnrollFloatsToFloat(_cmsTRANSFORM* info, 
-                                    cmsFloat32Number wIn[], 
-                                    cmsUInt8Number* accum,
-                                    cmsUInt32Number Stride)
-{
-    cmsFloat32Number* Inks = (cmsFloat32Number*) accum;
-    int nChan  = T_CHANNELS(info -> InputFormat);
-    int Planar = T_PLANAR(info -> InputFormat);
-    int i;
-    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 100.0 : 1.0;
-
-
-    for (i=0; i <  nChan; i++) {
-
-        if (Planar)
-            wIn[i] = (cmsFloat32Number) (Inks[i * Stride] / maximum);
-        else
-            wIn[i] = (cmsFloat32Number) (Inks[i] / maximum);                            
-    }
-
-    if (T_PLANAR(info -> InputFormat))
-        return accum + sizeof(cmsFloat32Number);
-    else
-        return accum + (nChan + T_EXTRA(info ->InputFormat)) * sizeof(cmsFloat32Number);
-}
-
-// For anything going from double
-static
-cmsUInt8Number* UnrollDoublesToFloat(_cmsTRANSFORM* info, 
-                                     cmsFloat32Number wIn[], 
-                                     cmsUInt8Number* accum,
-                                     cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Inks = (cmsFloat64Number*) accum;
-    int nChan  = T_CHANNELS(info -> InputFormat);
-    int Planar = T_PLANAR(info -> InputFormat);
-    int i;
-    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 100.0 : 1.0;
-
-    for (i=0; i <  nChan; i++) {
-
-        if (Planar)
-            wIn[i] = (cmsFloat32Number) (Inks[i * Stride] / maximum);
-        else
-            wIn[i] = (cmsFloat32Number) (Inks[i] / maximum);                            
-    }
-
-    if (T_PLANAR(info -> InputFormat))
-        return accum + sizeof(cmsFloat64Number);
-    else
-        return accum + (nChan + T_EXTRA(info ->InputFormat)) * sizeof(cmsFloat64Number);
-}
-
-
-// From Lab double to cmsFloat32Number
-static
-cmsUInt8Number* UnrollLabDoubleToFloat(_cmsTRANSFORM* info,  
-                                       cmsFloat32Number wIn[], 
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{  
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);                            // from 0..100 to 0..1 
-        wIn[1] = (cmsFloat32Number) ((Pt[Stride] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[Stride*2] + 128) / 255.0);
-
-        return accum + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);             // from 0..100 to 0..1 
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
-
-        accum += sizeof(cmsFloat64Number)*(3 + T_EXTRA(info ->InputFormat));
-        return accum;
-    }
-}
-
-// From Lab double to cmsFloat32Number
-static
-cmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info, 
-                                      cmsFloat32Number wIn[], 
-                                      cmsUInt8Number* accum,
-                                      cmsUInt32Number Stride)
-{  
-    cmsFloat32Number* Pt = (cmsFloat32Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);                            // from 0..100 to 0..1 
-        wIn[1] = (cmsFloat32Number) ((Pt[Stride] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[Stride*2] + 128) / 255.0);
-
-        return accum + sizeof(cmsFloat32Number);
-    }
-    else {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);             // from 0..100 to 0..1 
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
-
-        accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
-        return accum;
-    }
-}
-
-
-// 1.15 fixed point, that means maximum value is MAX_ENCODEABLE_XYZ (0xFFFF)
-static
-cmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,  
-                                       cmsFloat32Number wIn[], 
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{  
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);                   
-        wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);    
-        wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
-
-        return accum + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);            
-        wIn[1] = (cmsFloat32Number) (Pt[1] / MAX_ENCODEABLE_XYZ);    
-        wIn[2] = (cmsFloat32Number) (Pt[2] / MAX_ENCODEABLE_XYZ);
-
-        accum += sizeof(cmsFloat64Number)*(3 + T_EXTRA(info ->InputFormat));
-        return accum;
-    }
-}
-
-static
-cmsUInt8Number* UnrollXYZFloatToFloat(_cmsTRANSFORM* info,  
-                                      cmsFloat32Number wIn[], 
-                                      cmsUInt8Number* accum,
-                                      cmsUInt32Number Stride)
-{  
-    cmsFloat32Number* Pt = (cmsFloat32Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);                   
-        wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);    
-        wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
-
-        return accum + sizeof(cmsFloat32Number);
-    }
-    else {
-
-        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);            
-        wIn[1] = (cmsFloat32Number) (Pt[1] / MAX_ENCODEABLE_XYZ);    
-        wIn[2] = (cmsFloat32Number) (Pt[2] / MAX_ENCODEABLE_XYZ);
-
-        accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
-        return accum;
-    }
-}
-
-// Packing routines -----------------------------------------------------------------------------------------------------------
-
-
-// Generic chunky for byte
-
-static
-cmsUInt8Number* PackAnyBytes(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wOut[], 
-                             register cmsUInt8Number* output,
-                             register cmsUInt32Number Stride)
-{
-    int nChan      = T_CHANNELS(info -> OutputFormat);
-    int DoSwap     = T_DOSWAP(info ->OutputFormat);
-    int Reverse    = T_FLAVOR(info ->OutputFormat);
-    int Extra      = T_EXTRA(info -> OutputFormat);
-    int SwapFirst  = T_SWAPFIRST(info -> OutputFormat);
-    int ExtraFirst = DoSwap && !SwapFirst;
-    cmsUInt8Number* swap1;
-    cmsUInt8Number v = 0;
-    int i;
-
-    swap1 = output;
-
-    if (ExtraFirst) {
-        output += Extra;
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = FROM_16_TO_8(wOut[index]);
-
-        if (Reverse)
-            v = REVERSE_FLAVOR_8(v);
-
-        *output++ = v;
-    }
-
-    if (!ExtraFirst) {
-        output += Extra;
-    }
-
-    if (Extra == 0 && SwapFirst) {
-
-        memmove(swap1 + 1, swap1, nChan-1);
-        *swap1 = v;
-    }
-
-
-    return output;
-}
-
-
-
-static
-cmsUInt8Number* PackAnyWords(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wOut[], 
-                             register cmsUInt8Number* output,
-                             register cmsUInt32Number Stride)
-{
-    int nChan      = T_CHANNELS(info -> OutputFormat);
-    int SwapEndian = T_ENDIAN16(info -> InputFormat);
-    int DoSwap     = T_DOSWAP(info ->OutputFormat);
-    int Reverse    = T_FLAVOR(info ->OutputFormat);
-    int Extra      = T_EXTRA(info -> OutputFormat);
-    int SwapFirst  = T_SWAPFIRST(info -> OutputFormat);
-    int ExtraFirst = DoSwap && !SwapFirst;
-    cmsUInt16Number* swap1;
-    cmsUInt16Number v = 0;
-    int i;
-
-    swap1 = (cmsUInt16Number*) output;
-
-    if (ExtraFirst) {
-        output += Extra * sizeof(cmsUInt16Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = wOut[index];
-
-        if (SwapEndian)
-            v = CHANGE_ENDIAN(v);
-
-        if (Reverse)
-            v = REVERSE_FLAVOR_16(v);
-
-        *(cmsUInt16Number*) output = v;
-
-        output += sizeof(cmsUInt16Number);
-    }
-
-    if (!ExtraFirst) {
-        output += Extra * sizeof(cmsUInt16Number);
-    }
-
-    if (Extra == 0 && SwapFirst) {
-
-        memmove(swap1 + 1, swap1, (nChan-1)* sizeof(cmsUInt16Number));
-        *swap1 = v;
-    }
-
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* PackPlanarBytes(register _cmsTRANSFORM* info, 
-                                register cmsUInt16Number wOut[], 
-                                register cmsUInt8Number* output,
-                                register cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> OutputFormat);
-    int DoSwap = T_DOSWAP(info ->OutputFormat);
-    int Reverse= T_FLAVOR(info ->OutputFormat);
-    int i;
-    cmsUInt8Number* Init = output;
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-        cmsUInt8Number v = FROM_16_TO_8(wOut[index]);
-
-        *(cmsUInt8Number*)  output = (cmsUInt8Number) (Reverse ? REVERSE_FLAVOR_8(v) : v);
-        output += Stride;
-    }
-
-    return (Init + 1);
-}
-
-
-static
-cmsUInt8Number* PackPlanarWords(register _cmsTRANSFORM* info, 
-                                register cmsUInt16Number wOut[], 
-                                register cmsUInt8Number* output,
-                                register cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> OutputFormat);
-    int DoSwap = T_DOSWAP(info ->OutputFormat);
-    int Reverse= T_FLAVOR(info ->OutputFormat);
-    int SwapEndian = T_ENDIAN16(info -> OutputFormat);
-    int i;
-    cmsUInt8Number* Init = output;
-    cmsUInt16Number v;
-
-    if (DoSwap) {
-        output += T_EXTRA(info -> OutputFormat) * Stride * sizeof(cmsUInt16Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = wOut[index];
-
-        if (SwapEndian)
-            v = CHANGE_ENDIAN(v);
-
-        if (Reverse) 
-            v =  REVERSE_FLAVOR_16(v);
-
-        *(cmsUInt16Number*) output = v;
-        output += (Stride * sizeof(cmsUInt16Number));
-    }
-
-    return (Init + sizeof(cmsUInt16Number));
-}
-
-// CMYKcm (unrolled for speed)
-
-static
-cmsUInt8Number* Pack6Bytes(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[3]);
-    *output++ = FROM_16_TO_8(wOut[4]);
-    *output++ = FROM_16_TO_8(wOut[5]);
-
-    return output;
-}
-
-// KCMYcm
-
-static
-cmsUInt8Number* Pack6BytesSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[5]);
-    *output++ = FROM_16_TO_8(wOut[4]);
-    *output++ = FROM_16_TO_8(wOut[3]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-
-    return output;
-}
-
-// CMYKcm
-static
-cmsUInt8Number* Pack6Words(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[3];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[4];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[5];
-    output+= 2;
-
-    return output;
-}
-
-// KCMYcm
-static
-cmsUInt8Number* Pack6WordsSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[5];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[4];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[3];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack4Bytes(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[3]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack4BytesReverse(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wOut[], 
-                                  register cmsUInt8Number* output,
-                                  register cmsUInt32Number Stride)
-{
-    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[0]));
-    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[1]));
-    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[2]));
-    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[3]));
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack4BytesSwapFirst(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output,
-                                    register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[3]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-
-    return output;
-}
-
-// ABGR
-static
-cmsUInt8Number* Pack4BytesSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[3]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack4BytesSwapSwapFirst(register _cmsTRANSFORM* info, 
-                                        register cmsUInt16Number wOut[], 
-                                        register cmsUInt8Number* output,
-                                        register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[3]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack4Words(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[3];
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack4WordsReverse(register _cmsTRANSFORM* info, 
-                                  register cmsUInt16Number wOut[], 
-                                  register cmsUInt8Number* output,
-                                  register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[0]);
-    output+= 2;
-    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[1]);
-    output+= 2;
-    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[2]);
-    output+= 2;
-    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[3]);
-    output+= 2;
-
-    return output;
-}
-
-// ABGR
-static
-cmsUInt8Number* Pack4WordsSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[3];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-// CMYK
-static
-cmsUInt8Number* Pack4WordsBigEndian(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output,
-                                    register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);
-    output+= 2;
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[1]);
-    output+= 2;
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[2]);
-    output+= 2;
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[3]);
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* PackLabV2_8(register _cmsTRANSFORM* info, 
-                            register cmsUInt16Number wOut[], 
-                            register cmsUInt8Number* output,
-                            register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[0]));
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[1]));
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[2]));
-
-    return output;
-}
-
-static
-cmsUInt8Number* PackALabV2_8(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wOut[], 
-                             register cmsUInt8Number* output,
-                             register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[0]));
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[1]));
-    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[2]));
-
-    return output;
-}
-
-static
-cmsUInt8Number* PackLabV2_16(register _cmsTRANSFORM* info, 
-                             register cmsUInt16Number wOut[], 
-                             register cmsUInt8Number* output,
-                             register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[0]);
-    output += 2;
-    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[1]);
-    output += 2;
-    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[2]);
-    output += 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3Bytes(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesOptimized(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output,
-                                    register cmsUInt32Number Stride)
-{
-    *output++ = (wOut[0] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[2] & 0xFF);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesSwapOptimized(register _cmsTRANSFORM* info, 
-                                        register cmsUInt16Number wOut[], 
-                                        register cmsUInt8Number* output,
-                                        register cmsUInt32Number Stride)
-{
-    *output++ = (wOut[2] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[0] & 0xFF);
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack3Words(register _cmsTRANSFORM* info, 
-                           register cmsUInt16Number wOut[], 
-                           register cmsUInt8Number* output,
-                           register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3WordsSwap(register _cmsTRANSFORM* info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3WordsBigEndian(register _cmsTRANSFORM* info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output,
-                                    register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);
-    output+= 2;
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[1]);
-    output+= 2;
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[2]);
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1(register _cmsTRANSFORM* Info, 
-                                   register cmsUInt16Number wOut[], 
-                                   register cmsUInt8Number* output,
-                                   register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-    output++;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1Optimized(register _cmsTRANSFORM* Info, 
-                                            register cmsUInt16Number wOut[], 
-                                            register cmsUInt8Number* output,
-                                            register cmsUInt32Number Stride)
-{
-    *output++ = (wOut[0] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[2] & 0xFF);
-    output++;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1SwapFirst(register _cmsTRANSFORM* Info, 
-                                            register cmsUInt16Number wOut[], 
-                                            register cmsUInt8Number* output,
-                                            register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = FROM_16_TO_8(wOut[0]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[2]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1SwapFirstOptimized(register _cmsTRANSFORM* Info, 
-                                                     register cmsUInt16Number wOut[], 
-                                                     register cmsUInt8Number* output,
-                                                     register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = (wOut[0] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[2] & 0xFF);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1Swap(register _cmsTRANSFORM* Info, 
-                                       register cmsUInt16Number wOut[], 
-                                       register cmsUInt8Number* output,
-                                       register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1SwapOptimized(register _cmsTRANSFORM* Info, 
-                                                register cmsUInt16Number wOut[], 
-                                                register cmsUInt8Number* output,
-                                                register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = (wOut[2] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[0] & 0xFF);
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1SwapSwapFirst(register _cmsTRANSFORM* Info, 
-                                                register cmsUInt16Number wOut[], 
-                                                register cmsUInt8Number* output,
-                                                register cmsUInt32Number Stride)
-{       
-    *output++ = FROM_16_TO_8(wOut[2]);
-    *output++ = FROM_16_TO_8(wOut[1]);
-    *output++ = FROM_16_TO_8(wOut[0]);
-    output++;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3BytesAndSkip1SwapSwapFirstOptimized(register _cmsTRANSFORM* Info, 
-                                                         register cmsUInt16Number wOut[], 
-                                                         register cmsUInt8Number* output,
-                                                         register cmsUInt32Number Stride)
-{       
-    *output++ = (wOut[2] & 0xFF);
-    *output++ = (wOut[1] & 0xFF);
-    *output++ = (wOut[0] & 0xFF);
-    output++;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3WordsAndSkip1(register _cmsTRANSFORM* Info, 
-                                   register cmsUInt16Number wOut[], 
-                                   register cmsUInt8Number* output,
-                                   register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack3WordsAndSkip1Swap(register _cmsTRANSFORM* Info, 
-                                       register cmsUInt16Number wOut[], 
-                                       register cmsUInt8Number* output,
-                                       register cmsUInt32Number Stride)
-{
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack3WordsAndSkip1SwapFirst(register _cmsTRANSFORM* Info, 
-                                            register cmsUInt16Number wOut[], 
-                                            register cmsUInt8Number* output,
-                                            register cmsUInt32Number Stride)
-{   
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack3WordsAndSkip1SwapSwapFirst(register _cmsTRANSFORM* Info, 
-                                                register cmsUInt16Number wOut[], 
-                                                register cmsUInt8Number* output,
-                                                register cmsUInt32Number Stride)
-{      
-    *(cmsUInt16Number*) output = wOut[2];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[1];
-    output+= 2;
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-    output+= 2;
-
-    return output;
-}
-
-
-
-static
-cmsUInt8Number* Pack1Byte(register _cmsTRANSFORM* Info, 
-                          register cmsUInt16Number wOut[], 
-                          register cmsUInt8Number* output,
-                          register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack1ByteReversed(register _cmsTRANSFORM* Info, 
-                                  register cmsUInt16Number wOut[], 
-                                  register cmsUInt8Number* output,
-                                  register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(REVERSE_FLAVOR_16(wOut[0]));
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack1ByteSkip1(register _cmsTRANSFORM* Info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *output++ = FROM_16_TO_8(wOut[0]);
-    output++;
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack1ByteSkip1SwapFirst(register _cmsTRANSFORM* Info, 
-                                        register cmsUInt16Number wOut[], 
-                                        register cmsUInt8Number* output,
-                                        register cmsUInt32Number Stride)
-{
-    output++;
-    *output++ = FROM_16_TO_8(wOut[0]);
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack1Word(register _cmsTRANSFORM* Info, 
-                          register cmsUInt16Number wOut[], 
-                          register cmsUInt8Number* output,
-                          register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack1WordReversed(register _cmsTRANSFORM* Info, 
-                                  register cmsUInt16Number wOut[], 
-                                  register cmsUInt8Number* output,
-                                  register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[0]);
-    output+= 2;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack1WordBigEndian(register _cmsTRANSFORM* Info, 
-                                   register cmsUInt16Number wOut[], 
-                                   register cmsUInt8Number* output,
-                                   register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);
-    output+= 2;
-
-    return output;
-}
-
-
-static
-cmsUInt8Number* Pack1WordSkip1(register _cmsTRANSFORM* Info, 
-                               register cmsUInt16Number wOut[], 
-                               register cmsUInt8Number* output,
-                               register cmsUInt32Number Stride)
-{
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 4;
-
-    return output;
-}
-
-static
-cmsUInt8Number* Pack1WordSkip1SwapFirst(register _cmsTRANSFORM* Info, 
-                                        register cmsUInt16Number wOut[], 
-                                        register cmsUInt8Number* output,
-                                        register cmsUInt32Number Stride)
-{
-    output += 2; 
-    *(cmsUInt16Number*) output = wOut[0];
-    output+= 2;
-
-    return output;
-}
-
-
-// Unencoded Float values -- don't try optimize speed
-static
-cmsUInt8Number* PackLabDoubleFrom16(register _cmsTRANSFORM* Info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output, 
-                                    register cmsUInt32Number Stride)
-{
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        cmsCIELab  Lab;
-        cmsFloat64Number* Out = (cmsFloat64Number*) output;
-        cmsLabEncoded2Float(&Lab, wOut);
-
-        Out[0]        = Lab.L;
-        Out[Stride]   = Lab.a;
-        Out[Stride*2] = Lab.b;
-
-        return output + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        cmsLabEncoded2Float((cmsCIELab*) output, wOut);
-        return output + (sizeof(cmsCIELab) + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));            
-    }
-
-}
-
-static
-cmsUInt8Number* PackXYZDoubleFrom16(register _cmsTRANSFORM* Info, 
-                                    register cmsUInt16Number wOut[], 
-                                    register cmsUInt8Number* output,
-                                    register cmsUInt32Number Stride)
-{
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        cmsCIEXYZ XYZ;
-        cmsFloat64Number* Out = (cmsFloat64Number*) output;
-        cmsXYZEncoded2Float(&XYZ, wOut);
-
-        Out[0]                  = XYZ.X;
-        Out[Stride]   = XYZ.Y;
-        Out[Stride*2] = XYZ.Z;
-
-        return output + sizeof(cmsFloat64Number);
-
-    }
-    else {
-
-        cmsXYZEncoded2Float((cmsCIEXYZ*) output, wOut);
-
-        return output + (sizeof(cmsCIEXYZ) + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));
-    }
-}
-
-static
-cmsUInt8Number* PackDoubleFrom16(register _cmsTRANSFORM* Info, 
-                                 register cmsUInt16Number wOut[], 
-                                 register cmsUInt8Number* output,
-                                 register cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Inks = (cmsFloat64Number*) output;
-    int nChan = T_CHANNELS(Info -> OutputFormat);
-    int i;
-    cmsFloat64Number maximum = IsInkSpace(Info ->InputFormat) ? 655.35 : 65535.0;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        for (i=0; i <  nChan; i++) {
-
-            Inks[i*Stride] = wOut[i] / maximum;
-        }
-
-        return output + sizeof(cmsFloat64Number);
-    } 
-    else {
-
-        for (i=0; i <  nChan; i++) {
-
-            Inks[i] = wOut[i] /  maximum;
-        }
-
-
-        return output + (nChan + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsFloat64Number);
-    }
-
-}
-
-static
-cmsUInt8Number* PackFloatFrom16(register _cmsTRANSFORM* Info, 
-                                register cmsUInt16Number wOut[], 
-                                register cmsUInt8Number* output,
-                                register cmsUInt32Number Stride)
-{
-    cmsFloat32Number* Inks = (cmsFloat32Number*) output;
-    int nChan = T_CHANNELS(Info -> OutputFormat);
-    int i;
-    cmsFloat64Number maximum = IsInkSpace(Info ->OutputFormat) ? 655.35 : 65535.0;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        for (i=0; i <  nChan; i++) {
-
-            Inks[i*Stride] = (cmsFloat32Number) (wOut[i] / maximum);
-        }
-
-        return output + sizeof(cmsFloat32Number);
-    } 
-    else {
-
-        for (i=0; i <  nChan; i++) {
-
-            Inks[i] = (cmsFloat32Number) (wOut[i] /  maximum);
-        }
-
-
-        return output + (nChan + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsFloat32Number);
-    }
-
-}
-
-
-// --------------------------------------------------------------------------------------------------------
-
-static
-cmsUInt8Number* PackChunkyFloatsFromFloat(_cmsTRANSFORM* info, 
-                                          cmsFloat32Number wOut[], 
-                                          cmsUInt8Number* output,
-                                          cmsUInt32Number Stride)
-{
-    int nChan      = T_CHANNELS(info -> OutputFormat);
-    int DoSwap     = T_DOSWAP(info ->OutputFormat);
-    int Reverse    = T_FLAVOR(info ->OutputFormat);
-    int Extra      = T_EXTRA(info -> OutputFormat);
-    int SwapFirst  = T_SWAPFIRST(info -> OutputFormat);
-    int ExtraFirst = DoSwap && !SwapFirst;
-    cmsFloat64Number maximum = IsInkSpace(info ->OutputFormat) ? 100.0 : 1.0;
-    cmsFloat32Number* swap1;
-    cmsFloat64Number v = 0;
-    int i;
-
-    swap1 = (cmsFloat32Number*) output;
-
-    if (ExtraFirst) {
-        output += Extra * sizeof(cmsFloat32Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = wOut[index] * maximum;
-
-        if (Reverse)
-            v = maximum - v;
-
-        *(cmsFloat32Number*) output = (cmsFloat32Number) v;
-
-        output += sizeof(cmsFloat32Number);
-    }
-
-    if (!ExtraFirst) {
-        output += Extra * sizeof(cmsFloat32Number);
-    }
-
-    if (Extra == 0 && SwapFirst) {
-
-        memmove(swap1 + 1, swap1, (nChan-1)* sizeof(cmsFloat32Number));
-        *swap1 = (cmsFloat32Number) v;
-    }
-
-
-    return output;
-}
-
-static
-cmsUInt8Number* PackPlanarFloatsFromFloat(_cmsTRANSFORM* info, 
-                                          cmsFloat32Number wOut[], 
-                                          cmsUInt8Number* output,
-                                          cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> OutputFormat);
-    int DoSwap = T_DOSWAP(info ->OutputFormat);
-    int Reverse= T_FLAVOR(info ->OutputFormat);
-    int i;
-    cmsUInt8Number* Init = output;
-    cmsFloat64Number maximum = IsInkSpace(info ->OutputFormat) ? 100.0 : 1.0;
-    cmsFloat64Number v;
-
-    if (DoSwap) {
-        output += T_EXTRA(info -> OutputFormat) * Stride * sizeof(cmsFloat32Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = wOut[index] * maximum;
-
-        if (Reverse) 
-            v =  maximum - v;
-
-        *(cmsFloat32Number*) output = (cmsFloat32Number) v;
-        output += (Stride * sizeof(cmsFloat32Number));
-    }
-
-    return (Init + sizeof(cmsFloat32Number));
-}
-
-
-static
-cmsUInt8Number* PackChunkyDoublesFromFloat(_cmsTRANSFORM* info, 
-                                           cmsFloat32Number wOut[], 
-                                           cmsUInt8Number* output,
-                                           cmsUInt32Number Stride)
-{
-    int nChan      = T_CHANNELS(info -> OutputFormat);
-    int DoSwap     = T_DOSWAP(info ->OutputFormat);
-    int Reverse    = T_FLAVOR(info ->OutputFormat);
-    int Extra      = T_EXTRA(info -> OutputFormat);
-    int SwapFirst  = T_SWAPFIRST(info -> OutputFormat);
-    int ExtraFirst = DoSwap && !SwapFirst;
-    cmsFloat64Number* swap1;
-    cmsFloat64Number maximum = IsInkSpace(info ->OutputFormat) ? 100.0 : 1.0;
-    cmsFloat64Number v = 0;
-    int i;
-
-    swap1 = (cmsFloat64Number*) output;
-
-    if (ExtraFirst) {
-        output += Extra * sizeof(cmsFloat64Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = (cmsFloat64Number) wOut[index] * maximum;
-
-        if (Reverse)
-            v = maximum - v;
-
-        *(cmsFloat64Number*) output = v;
-
-        output += sizeof(cmsFloat64Number);
-    }
-
-    if (!ExtraFirst) {
-        output += Extra * sizeof(cmsFloat64Number);
-    }
-
-    if (Extra == 0 && SwapFirst) {
-
-        memmove(swap1 + 1, swap1, (nChan-1)* sizeof(cmsFloat64Number));
-        *swap1 = v;
-    }
-
-
-    return output;
-}
-
-static
-cmsUInt8Number* PackPlanarDoublesFromFloat(_cmsTRANSFORM* info, 
-                                           cmsFloat32Number wOut[], 
-                                           cmsUInt8Number* output,
-                                           cmsUInt32Number Stride)
-{
-    int nChan = T_CHANNELS(info -> OutputFormat);
-    int DoSwap = T_DOSWAP(info ->OutputFormat);
-    int Reverse= T_FLAVOR(info ->OutputFormat);
-    int i;
-    cmsUInt8Number* Init = output;
-    cmsFloat64Number maximum = IsInkSpace(info ->OutputFormat) ? 100.0 : 1.0;
-    cmsFloat64Number v;
-
-    if (DoSwap) {
-        output += T_EXTRA(info -> OutputFormat) * Stride * sizeof(cmsFloat64Number);
-    }
-
-    for (i=0; i < nChan; i++) {
-
-        int index = DoSwap ? (nChan - i - 1) : i;
-
-        v = (cmsFloat64Number) wOut[index] * maximum;
-
-        if (Reverse) 
-            v =  maximum - v;
-
-        *(cmsFloat64Number*) output = v;
-        output += (Stride * sizeof(cmsFloat64Number));
-    }
-
-    return (Init + sizeof(cmsFloat64Number));
-}
-
-
-
-
-static
-cmsUInt8Number* PackLabFloatFromFloat(_cmsTRANSFORM* Info, 
-                                      cmsFloat32Number wOut[], 
-                                      cmsUInt8Number* output,
-                                      cmsUInt32Number Stride)
-{        
-    cmsFloat32Number* Out = (cmsFloat32Number*) output;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        Out[0]        = (cmsFloat32Number) (wOut[0] * 100.0);
-        Out[Stride]   = (cmsFloat32Number) (wOut[1] * 255.0 - 128.0);
-        Out[Stride*2] = (cmsFloat32Number) (wOut[2] * 255.0 - 128.0);
-
-        return output + sizeof(cmsFloat32Number);
-    }
-    else {
-
-        Out[0] = (cmsFloat32Number) (wOut[0] * 100.0);
-        Out[1] = (cmsFloat32Number) (wOut[1] * 255.0 - 128.0);
-        Out[2] = (cmsFloat32Number) (wOut[2] * 255.0 - 128.0);
-
-        return output + (sizeof(cmsFloat32Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat32Number));            
-    }
-
-}
-
-static
-cmsUInt8Number* PackLabDoubleFromFloat(_cmsTRANSFORM* Info, 
-                                       cmsFloat32Number wOut[], 
-                                       cmsUInt8Number* output,
-                                       cmsUInt32Number Stride)
-{        
-    cmsFloat64Number* Out = (cmsFloat64Number*) output;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        Out[0]        = (cmsFloat64Number) (wOut[0] * 100.0);
-        Out[Stride]   = (cmsFloat64Number) (wOut[1] * 255.0 - 128.0);
-        Out[Stride*2] = (cmsFloat64Number) (wOut[2] * 255.0 - 128.0);
-
-        return output + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        Out[0] = (cmsFloat64Number) (wOut[0] * 100.0);
-        Out[1] = (cmsFloat64Number) (wOut[1] * 255.0 - 128.0);
-        Out[2] = (cmsFloat64Number) (wOut[2] * 255.0 - 128.0);
-
-        return output + (sizeof(cmsFloat64Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));            
-    }
-
-}
-
-
-// From 0..1 range to 0..MAX_ENCODEABLE_XYZ
-static
-cmsUInt8Number* PackXYZFloatFromFloat(_cmsTRANSFORM* Info, 
-                                      cmsFloat32Number wOut[], 
-                                      cmsUInt8Number* output,
-                                      cmsUInt32Number Stride)
-{        
-    cmsFloat32Number* Out = (cmsFloat32Number*) output;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        Out[0]        = (cmsFloat32Number) (wOut[0] * MAX_ENCODEABLE_XYZ);
-        Out[Stride]   = (cmsFloat32Number) (wOut[1] * MAX_ENCODEABLE_XYZ);
-        Out[Stride*2] = (cmsFloat32Number) (wOut[2] * MAX_ENCODEABLE_XYZ);
-
-        return output + sizeof(cmsFloat32Number);
-    }
-    else {
-
-        Out[0] = (cmsFloat32Number) (wOut[0] * MAX_ENCODEABLE_XYZ);
-        Out[1] = (cmsFloat32Number) (wOut[1] * MAX_ENCODEABLE_XYZ);
-        Out[2] = (cmsFloat32Number) (wOut[2] * MAX_ENCODEABLE_XYZ);
-
-        return output + (sizeof(cmsFloat32Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat32Number));            
-    }
-
-}
-
-
-// Same, but convert to double
-static
-cmsUInt8Number* PackXYZDoubleFromFloat(_cmsTRANSFORM* Info, 
-                                       cmsFloat32Number wOut[], 
-                                       cmsUInt8Number* output,
-                                       cmsUInt32Number Stride)
-{        
-    cmsFloat64Number* Out = (cmsFloat64Number*) output;
-
-    if (T_PLANAR(Info -> OutputFormat)) {
-
-        Out[0]        = (cmsFloat64Number) (wOut[0] * MAX_ENCODEABLE_XYZ);
-        Out[Stride]   = (cmsFloat64Number) (wOut[1] * MAX_ENCODEABLE_XYZ);
-        Out[Stride*2] = (cmsFloat64Number) (wOut[2] * MAX_ENCODEABLE_XYZ);
-
-        return output + sizeof(cmsFloat64Number);
-    }
-    else {
-
-        Out[0] = (cmsFloat64Number) (wOut[0] * MAX_ENCODEABLE_XYZ);
-        Out[1] = (cmsFloat64Number) (wOut[1] * MAX_ENCODEABLE_XYZ);
-        Out[2] = (cmsFloat64Number) (wOut[2] * MAX_ENCODEABLE_XYZ);
-
-        return output + (sizeof(cmsFloat64Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));            
-    }
-
-}
-
-
-// ----------------------------------------------------------------------------------------------------------------
-
-
-static cmsFormatters16 InputFormatters16[] = {
-
-    //    Type                                          Mask                  Function
-    //  ----------------------------   ------------------------------------  ----------------------------
-    { TYPE_Lab_DBL,                                 ANYPLANAR|ANYEXTRA,   UnrollLabDoubleTo16},
-    { TYPE_XYZ_DBL,                                 ANYPLANAR|ANYEXTRA,   UnrollXYZDoubleTo16},
-    { TYPE_GRAY_DBL,                                                 0,   UnrollDouble1Chan},
-    { FLOAT_SH(1)|BYTES_SH(0), ANYCHANNELS|ANYPLANAR|ANYEXTRA|ANYSPACE,   UnrollDoubleTo16},
-    { FLOAT_SH(1)|BYTES_SH(4), ANYCHANNELS|ANYPLANAR|ANYEXTRA|ANYSPACE,   UnrollFloatTo16},
-
-
-    { CHANNELS_SH(1)|BYTES_SH(1),                              ANYSPACE,  Unroll1Byte}, 
-    { CHANNELS_SH(1)|BYTES_SH(1)|EXTRA_SH(1),                  ANYSPACE,  Unroll1ByteSkip1},
-    { CHANNELS_SH(1)|BYTES_SH(1)|EXTRA_SH(2),                  ANYSPACE,  Unroll1ByteSkip2},
-    { CHANNELS_SH(1)|BYTES_SH(1)|FLAVOR_SH(1),                 ANYSPACE,  Unroll1ByteReversed},
-    { COLORSPACE_SH(PT_MCH2)|CHANNELS_SH(2)|BYTES_SH(1),              0,  Unroll2Bytes},
-
-    { TYPE_LabV2_8,                                                   0,  UnrollLabV2_8 },
-    { TYPE_ALabV2_8,                                                  0,  UnrollALabV2_8 },
-    { TYPE_LabV2_16,                                                  0,  UnrollLabV2_16 },
-
-    { CHANNELS_SH(3)|BYTES_SH(1),                              ANYSPACE,  Unroll3Bytes},
-    { CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1),                 ANYSPACE,  Unroll3BytesSwap},
-    { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|DOSWAP_SH(1),     ANYSPACE,  Unroll3BytesSkip1Swap},
-    { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|SWAPFIRST_SH(1),  ANYSPACE,  Unroll3BytesSkip1SwapFirst},
-
-    { CHANNELS_SH(4)|BYTES_SH(1),                              ANYSPACE,  Unroll4Bytes},
-    { CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1),                 ANYSPACE,  Unroll4BytesReverse},
-    { CHANNELS_SH(4)|BYTES_SH(1)|SWAPFIRST_SH(1),              ANYSPACE,  Unroll4BytesSwapFirst}, 
-    { CHANNELS_SH(4)|BYTES_SH(1)|DOSWAP_SH(1),                 ANYSPACE,  Unroll4BytesSwap}, 
-    { CHANNELS_SH(4)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1), ANYSPACE,  Unroll4BytesSwapSwapFirst}, 
-
-    { BYTES_SH(1)|PLANAR_SH(1),    ANYFLAVOR|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, UnrollPlanarBytes},
-    { BYTES_SH(1),    ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, UnrollChunkyBytes},     
-
-
-    { CHANNELS_SH(1)|BYTES_SH(2),                              ANYSPACE,  Unroll1Word},
-    { CHANNELS_SH(1)|BYTES_SH(2)|FLAVOR_SH(1),                 ANYSPACE,  Unroll1WordReversed},
-    { CHANNELS_SH(1)|BYTES_SH(2)|EXTRA_SH(3),                  ANYSPACE,  Unroll1WordSkip3},
-
-    { CHANNELS_SH(2)|BYTES_SH(2),                              ANYSPACE,  Unroll2Words},
-    { CHANNELS_SH(3)|BYTES_SH(2),                              ANYSPACE,  Unroll3Words},
-    { CHANNELS_SH(4)|BYTES_SH(2),                              ANYSPACE,  Unroll4Words},
-
-    { CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1),                 ANYSPACE,  Unroll3WordsSwap},
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1)|SWAPFIRST_SH(1),  ANYSPACE,  Unroll3WordsSkip1SwapFirst},
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1)|DOSWAP_SH(1),     ANYSPACE,  Unroll3WordsSkip1Swap},
-    { CHANNELS_SH(4)|BYTES_SH(2)|FLAVOR_SH(1),                 ANYSPACE,  Unroll4WordsReverse},
-    { CHANNELS_SH(4)|BYTES_SH(2)|SWAPFIRST_SH(1),              ANYSPACE,  Unroll4WordsSwapFirst}, 
-    { CHANNELS_SH(4)|BYTES_SH(2)|DOSWAP_SH(1),                 ANYSPACE,  Unroll4WordsSwap}, 
-    { CHANNELS_SH(4)|BYTES_SH(2)|DOSWAP_SH(1)|SWAPFIRST_SH(1), ANYSPACE,  Unroll4WordsSwapSwapFirst}, 
-
-
-    { BYTES_SH(2)|PLANAR_SH(1),  ANYFLAVOR|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE,  UnrollPlanarWords },
-    { BYTES_SH(2),  ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE,  UnrollAnyWords}, 
-};
-
-
-
-static cmsFormattersFloat InputFormattersFloat[] = {
-
-    //    Type                                          Mask                  Function
-    //  ----------------------------   ------------------------------------  ----------------------------
-    {     TYPE_Lab_DBL,                                ANYPLANAR|ANYEXTRA,   UnrollLabDoubleToFloat},
-    {     TYPE_Lab_FLT,                                ANYPLANAR|ANYEXTRA,   UnrollLabFloatToFloat},
-    {     TYPE_XYZ_DBL,                                ANYPLANAR|ANYEXTRA,   UnrollXYZDoubleToFloat},
-    {     TYPE_XYZ_FLT,                                ANYPLANAR|ANYEXTRA,   UnrollXYZFloatToFloat},
-
-    {     FLOAT_SH(1)|BYTES_SH(4), ANYPLANAR|ANYEXTRA|ANYCHANNELS|ANYSPACE,  UnrollFloatsToFloat},
-    {     FLOAT_SH(1)|BYTES_SH(0), ANYPLANAR|ANYEXTRA|ANYCHANNELS|ANYSPACE,  UnrollDoublesToFloat},
-};
-
-
-// Bit fields set to one in the mask are not compared
-static
-cmsFormatter _cmsGetStockInputFormatter(cmsUInt32Number dwInput, cmsUInt32Number dwFlags)
-{
-    cmsUInt32Number i;
-    cmsFormatter fr;
-
-
-    if (!(dwFlags & CMS_PACK_FLAGS_FLOAT)) {
-
-        for (i=0; i < sizeof(InputFormatters16) / sizeof(cmsFormatters16); i++) {
-            cmsFormatters16* f = InputFormatters16 + i;
-
-            if ((dwInput & ~f ->Mask) == f ->Type) {
-                fr.Fmt16 = f ->Frm;
-                return fr;
-            }
-        }
-    }
-    else {
-        for (i=0; i < sizeof(InputFormattersFloat) / sizeof(cmsFormattersFloat); i++) {
-            cmsFormattersFloat* f = InputFormattersFloat + i;
-
-            if ((dwInput & ~f ->Mask) == f ->Type) {
-                fr.FmtFloat = f ->Frm;
-                return fr;
-            }
-        }
-    }
-
-    fr.Fmt16 = NULL;
-    return fr;
-}
-
-static cmsFormatters16 OutputFormatters16[] = {
-    //    Type                                          Mask                  Function
-    //  ----------------------------   ------------------------------------  ----------------------------
-
-    { TYPE_Lab_DBL,                                      ANYPLANAR|ANYEXTRA,  PackLabDoubleFrom16},
-    { TYPE_XYZ_DBL,                                      ANYPLANAR|ANYEXTRA,  PackXYZDoubleFrom16},
-    { FLOAT_SH(1)|BYTES_SH(0),      ANYCHANNELS|ANYPLANAR|ANYEXTRA|ANYSPACE,  PackDoubleFrom16},
-    { FLOAT_SH(1)|BYTES_SH(4),      ANYCHANNELS|ANYPLANAR|ANYEXTRA|ANYSPACE,  PackFloatFrom16},
-
-    { CHANNELS_SH(1)|BYTES_SH(1),                                  ANYSPACE,  Pack1Byte},   
-    { CHANNELS_SH(1)|BYTES_SH(1)|EXTRA_SH(1),                      ANYSPACE,  Pack1ByteSkip1},
-    { CHANNELS_SH(1)|BYTES_SH(1)|EXTRA_SH(1)|SWAPFIRST_SH(1),      ANYSPACE,  Pack1ByteSkip1SwapFirst},
-
-    { CHANNELS_SH(1)|BYTES_SH(1)|FLAVOR_SH(1),                     ANYSPACE,  Pack1ByteReversed},
-
-    { TYPE_LabV2_8,                                                       0,  PackLabV2_8 },
-    { TYPE_ALabV2_8,                                                      0,  PackALabV2_8 },
-    { TYPE_LabV2_16,                                                      0,  PackLabV2_16 },
-
-    { CHANNELS_SH(3)|BYTES_SH(1)|OPTIMIZED_SH(1),                  ANYSPACE,  Pack3BytesOptimized},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|OPTIMIZED_SH(1),      ANYSPACE,  Pack3BytesAndSkip1Optimized},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|SWAPFIRST_SH(1)|OPTIMIZED_SH(1),
-                                                                   ANYSPACE,  Pack3BytesAndSkip1SwapFirstOptimized},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1)|OPTIMIZED_SH(1),  
-                                                                   ANYSPACE,  Pack3BytesAndSkip1SwapSwapFirstOptimized},
-    { CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|EXTRA_SH(1)|OPTIMIZED_SH(1),         
-                                                                   ANYSPACE,  Pack3BytesAndSkip1SwapOptimized},
-    { CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|OPTIMIZED_SH(1),     ANYSPACE,  Pack3BytesSwapOptimized},
-
-
-
-    { CHANNELS_SH(3)|BYTES_SH(1),                                  ANYSPACE,  Pack3Bytes},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1),                      ANYSPACE,  Pack3BytesAndSkip1},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|SWAPFIRST_SH(1),      ANYSPACE,  Pack3BytesAndSkip1SwapFirst},
-    { CHANNELS_SH(3)|BYTES_SH(1)|EXTRA_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1),  
-                                                                   ANYSPACE,  Pack3BytesAndSkip1SwapSwapFirst},
-    { CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1)|EXTRA_SH(1),         ANYSPACE,  Pack3BytesAndSkip1Swap},
-    { CHANNELS_SH(3)|BYTES_SH(1)|DOSWAP_SH(1),                     ANYSPACE,  Pack3BytesSwap},
-    { CHANNELS_SH(6)|BYTES_SH(1),                                  ANYSPACE,  Pack6Bytes},
-    { CHANNELS_SH(6)|BYTES_SH(1)|DOSWAP_SH(1),                     ANYSPACE,  Pack6BytesSwap},
-    { CHANNELS_SH(4)|BYTES_SH(1),                                  ANYSPACE,  Pack4Bytes},
-    { CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1),                     ANYSPACE,  Pack4BytesReverse},
-    { CHANNELS_SH(4)|BYTES_SH(1)|SWAPFIRST_SH(1),                  ANYSPACE,  Pack4BytesSwapFirst}, 
-    { CHANNELS_SH(4)|BYTES_SH(1)|DOSWAP_SH(1),                     ANYSPACE,  Pack4BytesSwap}, 
-    { CHANNELS_SH(4)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1),     ANYSPACE,  Pack4BytesSwapSwapFirst}, 
-
-    { BYTES_SH(1),                 ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackAnyBytes},     
-    { BYTES_SH(1)|PLANAR_SH(1),    ANYFLAVOR|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackPlanarBytes},   
-
-    { CHANNELS_SH(1)|BYTES_SH(2),                                  ANYSPACE,  Pack1Word},
-    { CHANNELS_SH(1)|BYTES_SH(2)|EXTRA_SH(1),                      ANYSPACE,  Pack1WordSkip1},
-    { CHANNELS_SH(1)|BYTES_SH(2)|EXTRA_SH(1)|SWAPFIRST_SH(1),      ANYSPACE,  Pack1WordSkip1SwapFirst},
-    { CHANNELS_SH(1)|BYTES_SH(2)|FLAVOR_SH(1),                     ANYSPACE,  Pack1WordReversed},
-    { CHANNELS_SH(1)|BYTES_SH(2)|ENDIAN16_SH(1),                   ANYSPACE,  Pack1WordBigEndian},
-    { CHANNELS_SH(3)|BYTES_SH(2),                                  ANYSPACE,  Pack3Words},
-    { CHANNELS_SH(3)|BYTES_SH(2)|DOSWAP_SH(1),                     ANYSPACE,  Pack3WordsSwap},
-    { CHANNELS_SH(3)|BYTES_SH(2)|ENDIAN16_SH(1),                   ANYSPACE,  Pack3WordsBigEndian},
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1),                      ANYSPACE,  Pack3WordsAndSkip1},
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1)|DOSWAP_SH(1),         ANYSPACE,  Pack3WordsAndSkip1Swap},
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1)|SWAPFIRST_SH(1),      ANYSPACE,  Pack3WordsAndSkip1SwapFirst},
-
-    { CHANNELS_SH(3)|BYTES_SH(2)|EXTRA_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1),             
-                                                                   ANYSPACE,  Pack3WordsAndSkip1SwapSwapFirst},
-
-    { CHANNELS_SH(4)|BYTES_SH(2),                                  ANYSPACE,  Pack4Words},
-    { CHANNELS_SH(4)|BYTES_SH(2)|FLAVOR_SH(1),                     ANYSPACE,  Pack4WordsReverse},
-    { CHANNELS_SH(4)|BYTES_SH(2)|DOSWAP_SH(1),                     ANYSPACE,  Pack4WordsSwap}, 
-    { CHANNELS_SH(4)|BYTES_SH(2)|ENDIAN16_SH(1),                   ANYSPACE,  Pack4WordsBigEndian},
-
-    { CHANNELS_SH(6)|BYTES_SH(2),                                  ANYSPACE,  Pack6Words},
-    { CHANNELS_SH(6)|BYTES_SH(2)|DOSWAP_SH(1),                     ANYSPACE,  Pack6WordsSwap},
-
-    { BYTES_SH(2)|PLANAR_SH(1),     ANYFLAVOR|ANYENDIAN|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackPlanarWords}, 
-    { BYTES_SH(2),                  ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYENDIAN|ANYEXTRA|ANYCHANNELS|ANYSPACE, PackAnyWords}
-
-};
-
-
-static cmsFormattersFloat OutputFormattersFloat[] = {
-    //    Type                                          Mask                                 Function
-    //  ----------------------------   ---------------------------------------------------  ----------------------------
-    {     TYPE_Lab_FLT,                                                ANYPLANAR|ANYEXTRA,   PackLabFloatFromFloat},
-    {     TYPE_XYZ_FLT,                                                ANYPLANAR|ANYEXTRA,   PackXYZFloatFromFloat},
-    {     TYPE_Lab_DBL,                                                ANYPLANAR|ANYEXTRA,   PackLabDoubleFromFloat},
-    {     TYPE_XYZ_DBL,                                                ANYPLANAR|ANYEXTRA,   PackXYZDoubleFromFloat},
-    {     FLOAT_SH(1)|BYTES_SH(4), 
-                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackChunkyFloatsFromFloat }, 
-    {     FLOAT_SH(1)|BYTES_SH(4)|PLANAR_SH(1),             ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackPlanarFloatsFromFloat},
-    {     FLOAT_SH(1)|BYTES_SH(0),
-                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackChunkyDoublesFromFloat }, 
-    {     FLOAT_SH(1)|BYTES_SH(0)|PLANAR_SH(1),             ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackPlanarDoublesFromFloat},
-
-
-};
-
-
-// Bit fields set to one in the mask are not compared
-cmsFormatter _cmsGetStockOutputFormatter(cmsUInt32Number dwInput, cmsUInt32Number dwFlags)
-{
-    cmsUInt32Number i;
-    cmsFormatter fr;
-
-
-    if (dwFlags & CMS_PACK_FLAGS_FLOAT) {
-
-        for (i=0; i < sizeof(OutputFormattersFloat) / sizeof(cmsFormattersFloat); i++) {
-            cmsFormattersFloat* f = OutputFormattersFloat + i;
-
-            if ((dwInput & ~f ->Mask) == f ->Type) {
-                fr.FmtFloat = f ->Frm;
-                return fr;
-            }
-        }
-
-    }
-    else {
-
-        for (i=0; i < sizeof(OutputFormatters16) / sizeof(cmsFormatters16); i++) {
-            cmsFormatters16* f = OutputFormatters16 + i;
-
-            if ((dwInput & ~f ->Mask) == f ->Type) {
-                fr.Fmt16 = f ->Frm;
-                return fr;
-            }
-        }
-    }
-
-    fr.Fmt16 = NULL;
-    return fr;
-}
-
-
-typedef struct _cms_formatters_factory_list {
-
-    cmsFormatterFactory Factory;
-    struct _cms_formatters_factory_list *Next;
-
-} cmsFormattersFactoryList;
-
-static cmsFormattersFactoryList* FactoryList = NULL;
-
-
-// Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Data)
-{
-    cmsPluginFormatters* Plugin = (cmsPluginFormatters*) Data;
-    cmsFormattersFactoryList* fl ;
-
-    // Reset
-    if (Data == NULL) {
-
-          FactoryList = NULL;
-          return TRUE;
-    }
-    
-    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(sizeof(cmsFormattersFactoryList));
-    if (fl == NULL) return FALSE;
-
-    fl ->Factory    = Plugin ->FormattersFactory;
-
-    fl ->Next = FactoryList;
-    FactoryList = fl;
-
-    return TRUE;
-}
-
-cmsFormatter _cmsGetFormatter(cmsUInt32Number Type,         // Specific type, i.e. TYPE_RGB_8
-                             cmsFormatterDirection Dir, 
-                             cmsUInt32Number dwFlags)       // Float or 16 bits
-{
-    cmsFormattersFactoryList* f;
-
-    for (f = FactoryList; f != NULL; f = f ->Next) {
-
-        cmsFormatter fn = f ->Factory(Type, Dir, dwFlags);
-        if (fn.Fmt16 != NULL) return fn;
-    }
-
-    // Revert to default
-    if (Dir == cmsFormatterInput) 
-        return _cmsGetStockInputFormatter(Type, dwFlags);
-    else 
-        return _cmsGetStockOutputFormatter(Type, dwFlags);
-}
-
-
-// Return whatever given formatter refers to float values
-cmsBool  _cmsFormatterIsFloat(cmsUInt32Number Type)
-{
-    return T_FLOAT(Type) ? TRUE : FALSE;
-}
-
-// Return whatever given formatter refers to 8 bits
-cmsBool  _cmsFormatterIs8bit(cmsUInt32Number Type)
-{
-    int Bytes = T_BYTES(Type);
-
-    return (Bytes == 1);
-}
-
-// Build a suitable formatter for the colorspace of this profile
-cmsUInt32Number CMSEXPORT cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)
-{
- 
-    cmsColorSpaceSignature ColorSpace      = cmsGetColorSpace(hProfile);
-    cmsUInt32Number        ColorSpaceBits  = _cmsLCMScolorSpace(ColorSpace);
-    cmsUInt32Number        nOutputChans    = cmsChannelsOf(ColorSpace);
-    cmsUInt32Number        Float           = lIsFloat ? 1 : 0;
-
-    // Create a fake formatter for result
-    return FLOAT_SH(Float) | COLORSPACE_SH(ColorSpaceBits) | BYTES_SH(nBytes) | CHANNELS_SH(nOutputChans);
-}
-
-// Build a suitable formatter for the colorspace of this profile
-cmsUInt32Number CMSEXPORT cmsFormatterForPCSOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)
-{
- 
-    cmsColorSpaceSignature ColorSpace      = cmsGetPCS(hProfile);
-    int                    ColorSpaceBits  = _cmsLCMScolorSpace(ColorSpace);
-    cmsUInt32Number        nOutputChans    = cmsChannelsOf(ColorSpace);
-    cmsUInt32Number        Float           = lIsFloat ? 1 : 0;
-
-    // Create a fake formatter for result
-    return FLOAT_SH(Float) | COLORSPACE_SH(ColorSpaceBits) | BYTES_SH(nBytes) | CHANNELS_SH(nOutputChans);
-}
-
diff --git a/thirdparty/liblcms2/src/cmspcs.c b/thirdparty/liblcms2/src/cmspcs.c
deleted file mode 100644
index 8dd1c22..0000000
--- a/thirdparty/liblcms2/src/cmspcs.c
+++ /dev/null
@@ -1,926 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-//      inter PCS conversions XYZ <-> CIE L* a* b*
-/*
-
-
-       CIE 15:2004 CIELab is defined as:
-
-       L* = 116*f(Y/Yn) - 16                     0 <= L* <= 100
-       a* = 500*[f(X/Xn) - f(Y/Yn)]
-       b* = 200*[f(Y/Yn) - f(Z/Zn)]
-
-       and
-
-              f(t) = t^(1/3)                     1 >= t >  (24/116)^3
-                     (841/108)*t + (16/116)      0 <= t <= (24/116)^3
-
-
-       Reverse transform is:
-
-       X = Xn*[a* / 500 + (L* + 16) / 116] ^ 3   if (X/Xn) > (24/116)
-         = Xn*(a* / 500 + L* / 116) / 7.787      if (X/Xn) <= (24/116)
-
-
-
-       PCS in Lab2 is encoded as:
-
-              8 bit Lab PCS:
-
-                     L*      0..100 into a 0..ff byte.
-                     a*      t + 128 range is -128.0  +127.0
-                     b*
-
-             16 bit Lab PCS:
-
-                     L*     0..100  into a 0..ff00 word.
-                     a*     t + 128  range is  -128.0  +127.9961
-                     b*
-
-
-
-Interchange Space   Component     Actual Range        Encoded Range
-CIE XYZ             X             0 -> 1.99997        0x0000 -> 0xffff
-CIE XYZ             Y             0 -> 1.99997        0x0000 -> 0xffff
-CIE XYZ             Z             0 -> 1.99997        0x0000 -> 0xffff
-
-Version 2,3
------------
-
-CIELAB (16 bit)     L*            0 -> 100.0          0x0000 -> 0xff00
-CIELAB (16 bit)     a*            -128.0 -> +127.996  0x0000 -> 0x8000 -> 0xffff
-CIELAB (16 bit)     b*            -128.0 -> +127.996  0x0000 -> 0x8000 -> 0xffff
-
-
-Version 4
----------
-
-CIELAB (16 bit)     L*            0 -> 100.0          0x0000 -> 0xffff
-CIELAB (16 bit)     a*            -128.0 -> +127      0x0000 -> 0x8080 -> 0xffff
-CIELAB (16 bit)     b*            -128.0 -> +127      0x0000 -> 0x8080 -> 0xffff
-
-*/
-
-// Conversions
-void CMSEXPORT cmsXYZ2xyY(cmsCIExyY* Dest, const cmsCIEXYZ* Source)
-{
-    cmsFloat64Number ISum;
-
-    ISum = 1./(Source -> X + Source -> Y + Source -> Z);
-
-    Dest -> x = (Source -> X) * ISum;
-    Dest -> y = (Source -> Y) * ISum;
-    Dest -> Y = Source -> Y;
-}
-
-void CMSEXPORT cmsxyY2XYZ(cmsCIEXYZ* Dest, const cmsCIExyY* Source)
-{
-    Dest -> X = (Source -> x / Source -> y) * Source -> Y;
-    Dest -> Y = Source -> Y;
-    Dest -> Z = ((1 - Source -> x - Source -> y) / Source -> y) * Source -> Y;
-}
-
-static
-cmsFloat64Number f(cmsFloat64Number t)
-{
-    const cmsFloat64Number Limit = (24.0/116.0) * (24.0/116.0) * (24.0/116.0);
-
-    if (t <= Limit)
-        return (841.0/108.0) * t + (16.0/116.0);
-    else
-        return pow(t, 1.0/3.0); 
-}
-
-static
-cmsFloat64Number f_1(cmsFloat64Number t)
-{
-    const cmsFloat64Number Limit = (24.0/116.0);
-
-    if (t <= Limit) {
-        return (108.0/841.0) * (t - (16.0/116.0));
-    }
-
-    return t * t * t;
-}
-
-
-// Standard XYZ to Lab. it can handle negative XZY numbers in some cases
-void CMSEXPORT cmsXYZ2Lab(const cmsCIEXYZ* WhitePoint, cmsCIELab* Lab, const cmsCIEXYZ* xyz)
-{
-    cmsFloat64Number fx, fy, fz;
-
-    if (WhitePoint == NULL) 
-        WhitePoint = cmsD50_XYZ();
-
-    fx = f(xyz->X / WhitePoint->X);
-    fy = f(xyz->Y / WhitePoint->Y);
-    fz = f(xyz->Z / WhitePoint->Z);
-
-    Lab->L = 116.0*fy - 16.0;
-    Lab->a = 500.0*(fx - fy);
-    Lab->b = 200.0*(fy - fz);
-}
-
-
-// Standard XYZ to Lab. It can return negative XYZ in some cases
-void CMSEXPORT cmsLab2XYZ(const cmsCIEXYZ* WhitePoint, cmsCIEXYZ* xyz,  const cmsCIELab* Lab)
-{
-    cmsFloat64Number x, y, z;
-
-    if (WhitePoint == NULL) 
-        WhitePoint = cmsD50_XYZ();
-
-    y = (Lab-> L + 16.0) / 116.0;
-    x = y + 0.002 * Lab -> a;
-    z = y - 0.005 * Lab -> b;
-
-    xyz -> X = f_1(x) * WhitePoint -> X;
-    xyz -> Y = f_1(y) * WhitePoint -> Y;
-    xyz -> Z = f_1(z) * WhitePoint -> Z;
-
-}
-
-static
-cmsFloat64Number L2float2(cmsUInt16Number v)
-{
-	return (cmsFloat64Number) v / 652.800;
-}
-
-// the a/b part
-static
-cmsFloat64Number ab2float2(cmsUInt16Number v)
-{   
-	return ((cmsFloat64Number) v / 256.0) - 128.0;
-}
-
-static
-cmsUInt16Number L2Fix2(cmsFloat64Number L)
-{
-	return _cmsQuickSaturateWord(L *  652.8);
-}
-
-static
-cmsUInt16Number ab2Fix2(cmsFloat64Number ab)
-{
-	return _cmsQuickSaturateWord((ab + 128.0) * 256.0);
-}
-
-
-static
-cmsFloat64Number L2float4(cmsUInt16Number v)
-{
-    return (cmsFloat64Number) v / 655.35;
-}
-
-// the a/b part
-static
-cmsFloat64Number ab2float4(cmsUInt16Number v)
-{
-    return ((cmsFloat64Number) v / 257.0) - 128.0;
-}
-
-
-void CMSEXPORT cmsLabEncoded2FloatV2(cmsCIELab* Lab, const cmsUInt16Number wLab[3])
-{
-        Lab->L = L2float2(wLab[0]);
-        Lab->a = ab2float2(wLab[1]);
-        Lab->b = ab2float2(wLab[2]);
-}
-
-
-void CMSEXPORT cmsLabEncoded2Float(cmsCIELab* Lab, const cmsUInt16Number wLab[3])
-{
-        Lab->L = L2float4(wLab[0]);
-        Lab->a = ab2float4(wLab[1]);
-        Lab->b = ab2float4(wLab[2]);
-}
-
-static
-cmsFloat64Number Clamp_L_doubleV2(cmsFloat64Number L)
-{
-    const cmsFloat64Number L_max = (cmsFloat64Number) (0xFFFF * 100.0) / 0xFF00;
-
-    if (L < 0) L = 0;
-    if (L > L_max) L = L_max;
-
-    return L;
-}
-
-
-static
-cmsFloat64Number Clamp_ab_doubleV2(cmsFloat64Number ab)
-{
-    if (ab < MIN_ENCODEABLE_ab2) ab = MIN_ENCODEABLE_ab2;
-    if (ab > MAX_ENCODEABLE_ab2) ab = MAX_ENCODEABLE_ab2;
-
-    return ab;
-}
-
-void CMSEXPORT cmsFloat2LabEncodedV2(cmsUInt16Number wLab[3], const cmsCIELab* fLab)
-{
-    cmsCIELab Lab;
-
-    Lab.L = Clamp_L_doubleV2(fLab ->L);
-    Lab.a = Clamp_ab_doubleV2(fLab ->a);
-    Lab.b = Clamp_ab_doubleV2(fLab ->b);
-                                                
-    wLab[0] = L2Fix2(Lab.L);
-    wLab[1] = ab2Fix2(Lab.a);
-    wLab[2] = ab2Fix2(Lab.b);
-}
-
-
-static
-cmsFloat64Number Clamp_L_doubleV4(cmsFloat64Number L)
-{
-    if (L < 0) L = 0;
-    if (L > 100.0) L = 100.0;
-
-    return L;
-}
-
-static
-cmsFloat64Number Clamp_ab_doubleV4(cmsFloat64Number ab)
-{
-    if (ab < MIN_ENCODEABLE_ab4) ab = MIN_ENCODEABLE_ab4;
-    if (ab > MAX_ENCODEABLE_ab4) ab = MAX_ENCODEABLE_ab4;
-
-    return ab;
-}
-
-static 
-cmsUInt16Number L2Fix4(cmsFloat64Number L)
-{
-    return _cmsQuickSaturateWord(L *  655.35);
-}
-
-static
-cmsUInt16Number ab2Fix4(cmsFloat64Number ab)
-{
-    return _cmsQuickSaturateWord((ab + 128.0) * 257.0);
-}
-
-void CMSEXPORT cmsFloat2LabEncoded(cmsUInt16Number wLab[3], const cmsCIELab* fLab)
-{
-    cmsCIELab Lab;
-    
-    Lab.L = Clamp_L_doubleV4(fLab ->L);
-    Lab.a = Clamp_ab_doubleV4(fLab ->a);
-    Lab.b = Clamp_ab_doubleV4(fLab ->b);
-                                
-    wLab[0] = L2Fix4(Lab.L);
-    wLab[1] = ab2Fix4(Lab.a);
-    wLab[2] = ab2Fix4(Lab.b);
-}
-
-// Auxiliar: convert to Radians
-static
-cmsFloat64Number RADIANS(cmsFloat64Number deg)
-{
-    return (deg * M_PI) / 180.;
-}
-
-
-// Auxiliar: atan2 but operating in degrees and returning 0 if a==b==0
-static
-cmsFloat64Number atan2deg(cmsFloat64Number a, cmsFloat64Number b)
-{
-   cmsFloat64Number h;
-
-   if (a == 0 && b == 0)
-            h   = 0;
-    else
-            h = atan2(a, b);
-   
-    h *= (180. / M_PI);
-    
-    while (h > 360.)         
-        h -= 360.;
-    
-    while ( h < 0)
-        h += 360.;
-    
-    return h;
-}
-
-
-// Auxiliar: Square
-static
-cmsFloat64Number Sqr(cmsFloat64Number v)
-{
-    return v *  v; 
-}
-// From cylindrical coordinates. No check is performed, then negative values are allowed
-void CMSEXPORT cmsLab2LCh(cmsCIELCh* LCh, const cmsCIELab* Lab)
-{
-    LCh -> L = Lab -> L;
-    LCh -> C = pow(Sqr(Lab ->a) + Sqr(Lab ->b), 0.5);
-    LCh -> h = atan2deg(Lab ->b, Lab ->a);
-}
-
-
-// To cylindrical coordinates. No check is performed, then negative values are allowed
-void CMSEXPORT cmsLCh2Lab(cmsCIELab* Lab, const cmsCIELCh* LCh)
-{
-    cmsFloat64Number h = (LCh -> h * M_PI) / 180.0;
-
-    Lab -> L = LCh -> L;
-    Lab -> a = LCh -> C * cos(h);
-    Lab -> b = LCh -> C * sin(h);          
-}
-
-// In XYZ All 3 components are encoded using 1.15 fixed point
-static
-cmsUInt16Number XYZ2Fix(cmsFloat64Number d)
-{     
-    return _cmsQuickSaturateWord(d * 32768.0);
-}
-
-void CMSEXPORT cmsFloat2XYZEncoded(cmsUInt16Number XYZ[3], const cmsCIEXYZ* fXYZ)
-{
-    cmsCIEXYZ xyz;
-
-    xyz.X = fXYZ -> X;
-    xyz.Y = fXYZ -> Y;
-    xyz.Z = fXYZ -> Z;
-
-    // Clamp to encodeable values.     
-    if (xyz.Y <= 0) {
-
-        xyz.X = 0;
-        xyz.Y = 0;
-        xyz.Z = 0;
-    }
-
-    if (xyz.X > MAX_ENCODEABLE_XYZ)            
-        xyz.X = MAX_ENCODEABLE_XYZ;
-
-    if (xyz.X < 0)
-        xyz.X = 0;
-
-    if (xyz.Y > MAX_ENCODEABLE_XYZ)            
-        xyz.Y = MAX_ENCODEABLE_XYZ;
-
-    if (xyz.Y < 0)
-        xyz.Y = 0;
-
-    if (xyz.Z > MAX_ENCODEABLE_XYZ)            
-        xyz.Z = MAX_ENCODEABLE_XYZ;
-
-    if (xyz.Z < 0)
-        xyz.Z = 0;
-
-
-    XYZ[0] = XYZ2Fix(xyz.X);
-    XYZ[1] = XYZ2Fix(xyz.Y);
-    XYZ[2] = XYZ2Fix(xyz.Z);        
-}
-
-
-//  To convert from Fixed 1.15 point to cmsFloat64Number
-static
-cmsFloat64Number XYZ2float(cmsUInt16Number v)
-{
-    cmsS15Fixed16Number fix32;
-
-    // From 1.15 to 15.16
-    fix32 = v << 1;
-
-    // From fixed 15.16 to cmsFloat64Number
-    return _cms15Fixed16toDouble(fix32);
-}
-
-
-void CMSEXPORT cmsXYZEncoded2Float(cmsCIEXYZ* fXYZ, const cmsUInt16Number XYZ[3])
-{
-    fXYZ -> X = XYZ2float(XYZ[0]);
-    fXYZ -> Y = XYZ2float(XYZ[1]);
-    fXYZ -> Z = XYZ2float(XYZ[2]);
-}       
-
-
-// Returns dE on two Lab values
-cmsFloat64Number CMSEXPORT cmsDeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)
-{
-    cmsFloat64Number dL, da, db;
-
-    dL = fabs(Lab1 -> L - Lab2 -> L);
-    da = fabs(Lab1 -> a - Lab2 -> a);
-    db = fabs(Lab1 -> b - Lab2 -> b);
-
-    return pow(Sqr(dL) + Sqr(da) + Sqr(db), 0.5);
-}
-
-
-// Return the CIE94 Delta E 
-cmsFloat64Number CMSEXPORT cmsCIE94DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)
-{
-    cmsCIELCh LCh1, LCh2;
-    cmsFloat64Number dE, dL, dC, dh, dhsq;
-    cmsFloat64Number c12, sc, sh;
-
-    dL = fabs(Lab1 ->L - Lab2 ->L);
-
-    cmsLab2LCh(&LCh1, Lab1);
-    cmsLab2LCh(&LCh2, Lab2);
-
-    dC  = fabs(LCh1.C - LCh2.C);
-    dE  = cmsDeltaE(Lab1, Lab2);
-    
-    dhsq = Sqr(dE) - Sqr(dL) - Sqr(dC);
-    if (dhsq < 0)
-        dh = 0;
-    else
-        dh = pow(dhsq, 0.5);
-
-    c12 = sqrt(LCh1.C * LCh2.C);
-
-    sc = 1.0 + (0.048 * c12);
-    sh = 1.0 + (0.014 * c12);
-            
-    return sqrt(Sqr(dL)  + Sqr(dC) / Sqr(sc) + Sqr(dh) / Sqr(sh));
-}
-
-
-// Auxiliary
-static
-cmsFloat64Number ComputeLBFD(const cmsCIELab* Lab)
-{
-  cmsFloat64Number yt;
-
-  if (Lab->L > 7.996969)
-        yt = (Sqr((Lab->L+16)/116)*((Lab->L+16)/116))*100;
-  else
-        yt = 100 * (Lab->L / 903.3);
-
-  return (54.6 * (M_LOG10E * (log(yt + 1.5))) - 9.6);
-}
-
-
-
-// bfd - gets BFD(1:1) difference between Lab1, Lab2
-cmsFloat64Number CMSEXPORT cmsBFDdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)
-{
-    cmsFloat64Number lbfd1,lbfd2,AveC,Aveh,dE,deltaL,
-        deltaC,deltah,dc,t,g,dh,rh,rc,rt,bfd;
-    cmsCIELCh LCh1, LCh2;
-
-
-    lbfd1 = ComputeLBFD(Lab1);
-    lbfd2 = ComputeLBFD(Lab2);
-    deltaL = lbfd2 - lbfd1;
-
-    cmsLab2LCh(&LCh1, Lab1);
-    cmsLab2LCh(&LCh2, Lab2);
-
-    deltaC = LCh2.C - LCh1.C;
-    AveC = (LCh1.C+LCh2.C)/2;
-    Aveh = (LCh1.h+LCh2.h)/2;
-
-    dE = cmsDeltaE(Lab1, Lab2);
-
-    if (Sqr(dE)>(Sqr(Lab2->L-Lab1->L)+Sqr(deltaC)))
-        deltah = sqrt(Sqr(dE)-Sqr(Lab2->L-Lab1->L)-Sqr(deltaC));
-    else
-        deltah =0;
-
-
-    dc   = 0.035 * AveC / (1 + 0.00365 * AveC)+0.521;
-    g    = sqrt(Sqr(Sqr(AveC))/(Sqr(Sqr(AveC))+14000));
-    t    = 0.627+(0.055*cos((Aveh-254)/(180/M_PI))-       
-           0.040*cos((2*Aveh-136)/(180/M_PI))+
-           0.070*cos((3*Aveh-31)/(180/M_PI))+
-           0.049*cos((4*Aveh+114)/(180/M_PI))-
-           0.015*cos((5*Aveh-103)/(180/M_PI)));
-
-    dh    = dc*(g*t+1-g);
-    rh    = -0.260*cos((Aveh-308)/(180/M_PI))-
-           0.379*cos((2*Aveh-160)/(180/M_PI))-
-           0.636*cos((3*Aveh+254)/(180/M_PI))+
-           0.226*cos((4*Aveh+140)/(180/M_PI))-
-           0.194*cos((5*Aveh+280)/(180/M_PI));
-
-    rc = sqrt((AveC*AveC*AveC*AveC*AveC*AveC)/((AveC*AveC*AveC*AveC*AveC*AveC)+70000000));
-    rt = rh*rc;
-
-    bfd = sqrt(Sqr(deltaL)+Sqr(deltaC/dc)+Sqr(deltah/dh)+(rt*(deltaC/dc)*(deltah/dh)));
-
-    return bfd;
-}
-
-
-//  cmc - CMC(l:c) difference between Lab1, Lab2
-cmsFloat64Number CMSEXPORT cmsCMCdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number l, cmsFloat64Number c)
-{
-  cmsFloat64Number dE,dL,dC,dh,sl,sc,sh,t,f,cmc;
-  cmsCIELCh LCh1, LCh2;
-
-  if (Lab1 ->L == 0 && Lab2 ->L == 0) return 0;
-
-  cmsLab2LCh(&LCh1, Lab1);
-  cmsLab2LCh(&LCh2, Lab2);
-
-  
-  dL = Lab2->L-Lab1->L;
-  dC = LCh2.C-LCh1.C;
-
-  dE = cmsDeltaE(Lab1, Lab2);
-
-  if (Sqr(dE)>(Sqr(dL)+Sqr(dC))) 
-            dh = sqrt(Sqr(dE)-Sqr(dL)-Sqr(dC));
-  else
-            dh =0;
-
-  if ((LCh1.h > 164) && (LCh1.h < 345)) 
-      t = 0.56 + fabs(0.2 * cos(((LCh1.h + 168)/(180/M_PI))));
-  else 
-      t = 0.36 + fabs(0.4 * cos(((LCh1.h + 35 )/(180/M_PI))));
-
-   sc  = 0.0638   * LCh1.C / (1 + 0.0131  * LCh1.C) + 0.638;
-   sl  = 0.040975 * Lab1->L /(1 + 0.01765 * Lab1->L);
-   
-   if (Lab1->L<16)
-         sl = 0.511; 
-
-   f   = sqrt((LCh1.C * LCh1.C * LCh1.C * LCh1.C)/((LCh1.C * LCh1.C * LCh1.C * LCh1.C)+1900));
-   sh  = sc*(t*f+1-f);
-   cmc = sqrt(Sqr(dL/(l*sl))+Sqr(dC/(c*sc))+Sqr(dh/sh));
-
-   return cmc;
-}
-
-// dE2000 The weightings KL, KC and KH can be modified to reflect the relative 
-// importance of lightness, chroma and hue in different industrial applications
-cmsFloat64Number CMSEXPORT cmsCIE2000DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2,
-                                  cmsFloat64Number Kl, cmsFloat64Number Kc, cmsFloat64Number Kh)
-{
-    cmsFloat64Number L1  = Lab1->L;
-    cmsFloat64Number a1  = Lab1->a;
-    cmsFloat64Number b1  = Lab1->b;
-    cmsFloat64Number C   = sqrt( Sqr(a1) + Sqr(b1) );
-
-    cmsFloat64Number Ls = Lab2 ->L;
-    cmsFloat64Number as = Lab2 ->a;
-    cmsFloat64Number bs = Lab2 ->b;
-    cmsFloat64Number Cs = sqrt( Sqr(as) + Sqr(bs) );
-
-    cmsFloat64Number G = 0.5 * ( 1 - sqrt(pow((C + Cs) / 2 , 7.0) / (pow((C + Cs) / 2, 7.0) + pow(25.0, 7.0) ) ));
-
-    cmsFloat64Number a_p = (1 + G ) * a1;
-    cmsFloat64Number b_p = b1;
-    cmsFloat64Number C_p = sqrt( Sqr(a_p) + Sqr(b_p));
-    cmsFloat64Number h_p = atan2deg(b_p, a_p); 
-                
-
-    cmsFloat64Number a_ps = (1 + G) * as;
-    cmsFloat64Number b_ps = bs;
-    cmsFloat64Number C_ps = sqrt(Sqr(a_ps) + Sqr(b_ps));
-    cmsFloat64Number h_ps = atan2deg(b_ps, a_ps);
-              
-    cmsFloat64Number meanC_p =(C_p + C_ps) / 2;
-
-    cmsFloat64Number hps_plus_hp  = h_ps + h_p;
-    cmsFloat64Number hps_minus_hp = h_ps - h_p;
-
-    cmsFloat64Number meanh_p = fabs(hps_minus_hp) <= 180.000001 ? (hps_plus_hp)/2 : 
-                            (hps_plus_hp) < 360 ? (hps_plus_hp + 360)/2 : 
-                                                 (hps_plus_hp - 360)/2;
-
-    cmsFloat64Number delta_h = (hps_minus_hp) <= -180.000001 ?  (hps_minus_hp + 360) :
-                            (hps_minus_hp) > 180 ? (hps_minus_hp - 360) : 
-                                                    (hps_minus_hp);
-    cmsFloat64Number delta_L = (Ls - L1);
-    cmsFloat64Number delta_C = (C_ps - C_p );
-
-
-    cmsFloat64Number delta_H =2 * sqrt(C_ps*C_p) * sin(RADIANS(delta_h) / 2);
-
-    cmsFloat64Number T = 1 - 0.17 * cos(RADIANS(meanh_p-30)) 
-                 + 0.24 * cos(RADIANS(2*meanh_p))  
-                 + 0.32 * cos(RADIANS(3*meanh_p + 6)) 
-                 - 0.2  * cos(RADIANS(4*meanh_p - 63));
-
-    cmsFloat64Number Sl = 1 + (0.015 * Sqr((Ls + L1) /2- 50) )/ sqrt(20 + Sqr( (Ls+L1)/2 - 50) );
-
-    cmsFloat64Number Sc = 1 + 0.045 * (C_p + C_ps)/2;
-    cmsFloat64Number Sh = 1 + 0.015 * ((C_ps + C_p)/2) * T;
-
-    cmsFloat64Number delta_ro = 30 * exp( -Sqr(((meanh_p - 275 ) / 25)));
-
-    cmsFloat64Number Rc = 2 * sqrt(( pow(meanC_p, 7.0) )/( pow(meanC_p, 7.0) + pow(25.0, 7.0)));
-
-    cmsFloat64Number Rt = -sin(2 * RADIANS(delta_ro)) * Rc;
-
-    cmsFloat64Number deltaE00 = sqrt( Sqr(delta_L /(Sl * Kl)) + 
-                            Sqr(delta_C/(Sc * Kc))  + 
-                            Sqr(delta_H/(Sh * Kh))  + 
-                            Rt*(delta_C/(Sc * Kc)) * (delta_H / (Sh * Kh)));
-
-    return deltaE00;
-}
-
-// This function returns a number of gridpoints to be used as LUT table. It assumes same number
-// of gripdpoints in all dimensions. Flags may override the choice.
-int _cmsReasonableGridpointsByColorspace(cmsColorSpaceSignature Colorspace, cmsUInt32Number dwFlags)
-{
-    int nChannels;
-
-    // Already specified?
-    if (dwFlags & 0x00FF0000) {
-            // Yes, grab'em
-            return (dwFlags >> 16) & 0xFF;
-    }
-
-    nChannels = cmsChannelsOf(Colorspace);
-
-    // HighResPrecalc is maximum resolution
-    if (dwFlags & cmsFLAGS_HIGHRESPRECALC) {
-
-        if (nChannels > 4) 
-                return 7;       // 7 for Hifi
-
-        if (nChannels == 4)     // 23 for CMYK
-                return 23;
-    
-        return 49;      // 49 for RGB and others        
-    }
-
-
-    // LowResPrecal is lower resolution
-    if (dwFlags & cmsFLAGS_LOWRESPRECALC) {
-        
-        if (nChannels > 4) 
-                return 6;       // 6 for more than 4 channels
-
-        if (nChannels == 1) 
-                return 33;      // For monochrome
-
-        return 17;              // 17 for remaining
-    }
-
-    // Default values
-    if (nChannels > 4) 
-                return 7;       // 7 for Hifi
-
-    if (nChannels == 4)
-                return 17;      // 17 for CMYK
-
-    return 33;                  // 33 for RGB   
-}
-
-
-cmsBool  _cmsEndPointsBySpace(cmsColorSpaceSignature Space, 
-                             cmsUInt16Number **White, 
-                             cmsUInt16Number **Black,
-                             cmsUInt32Number *nOutputs)
-{
-       // Only most common spaces
-
-       static cmsUInt16Number RGBblack[4]  = { 0, 0, 0 };
-       static cmsUInt16Number RGBwhite[4]  = { 0xffff, 0xffff, 0xffff };
-       static cmsUInt16Number CMYKblack[4] = { 0xffff, 0xffff, 0xffff, 0xffff };   // 400% of ink
-       static cmsUInt16Number CMYKwhite[4] = { 0, 0, 0, 0 };
-       static cmsUInt16Number LABblack[4]  = { 0, 0x8080, 0x8080 };               // V4 Lab encoding
-       static cmsUInt16Number LABwhite[4]  = { 0xFFFF, 0x8080, 0x8080 };
-       static cmsUInt16Number CMYblack[4]  = { 0xffff, 0xffff, 0xffff };
-       static cmsUInt16Number CMYwhite[4]  = { 0, 0, 0 };
-       static cmsUInt16Number Grayblack[4] = { 0 };
-       static cmsUInt16Number GrayWhite[4] = { 0xffff };
-
-       switch (Space) {
-
-       case cmsSigGrayData: if (White)    *White = GrayWhite;
-                           if (Black)    *Black = Grayblack;
-                           if (nOutputs) *nOutputs = 1;
-                           return TRUE;
-                        
-       case cmsSigRgbData:  if (White)    *White = RGBwhite;
-                           if (Black)    *Black = RGBblack;
-                           if (nOutputs) *nOutputs = 3;
-                           return TRUE;
-
-       case cmsSigLabData:  if (White)    *White = LABwhite;
-                           if (Black)    *Black = LABblack;
-                           if (nOutputs) *nOutputs = 3;
-                           return TRUE;
-
-       case cmsSigCmykData: if (White)    *White = CMYKwhite;
-                           if (Black)    *Black = CMYKblack;
-                           if (nOutputs) *nOutputs = 4;
-                           return TRUE;
-
-       case cmsSigCmyData:  if (White)    *White = CMYwhite;
-                           if (Black)    *Black = CMYblack;
-                           if (nOutputs) *nOutputs = 3;
-                           return TRUE;
-
-       default:;
-       }
-
-  return FALSE;
-}
-
-   
-
-// Several utilities -------------------------------------------------------
-
-// Translate from our colorspace to ICC representation
-
-cmsColorSpaceSignature CMSEXPORT _cmsICCcolorSpace(int OurNotation)
-{
-       switch (OurNotation) {
-
-       case 1:
-       case PT_GRAY: return cmsSigGrayData;
-
-       case 2:
-       case PT_RGB:  return cmsSigRgbData;
-
-       case PT_CMY:  return cmsSigCmyData;
-       case PT_CMYK: return cmsSigCmykData;
-       case PT_YCbCr:return cmsSigYCbCrData;
-       case PT_YUV:  return cmsSigLuvData;
-       case PT_XYZ:  return cmsSigXYZData;
-
-       case PT_LabV2:
-       case PT_Lab:  return cmsSigLabData;
-
-       case PT_YUVK: return cmsSigLuvKData;
-       case PT_HSV:  return cmsSigHsvData;
-       case PT_HLS:  return cmsSigHlsData;
-       case PT_Yxy:  return cmsSigYxyData;
-
-       case PT_MCH1: return cmsSigMCH1Data;
-       case PT_MCH2: return cmsSigMCH2Data;
-       case PT_MCH3: return cmsSigMCH3Data;
-       case PT_MCH4: return cmsSigMCH4Data;
-       case PT_MCH5: return cmsSigMCH5Data;
-       case PT_MCH6: return cmsSigMCH6Data;
-       case PT_MCH7: return cmsSigMCH7Data;
-       case PT_MCH8: return cmsSigMCH8Data;
-
-       case PT_MCH9:  return cmsSigMCH9Data;
-       case PT_MCH10: return cmsSigMCHAData;
-       case PT_MCH11: return cmsSigMCHBData;
-       case PT_MCH12: return cmsSigMCHCData;
-       case PT_MCH13: return cmsSigMCHDData;
-       case PT_MCH14: return cmsSigMCHEData;
-       case PT_MCH15: return cmsSigMCHFData;
-
-       default:  return (cmsColorSpaceSignature) (-1);
-       }
-}
-
-
-int CMSEXPORT _cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace)
-{    
-    switch (ProfileSpace) {
-        
-    case cmsSigGrayData: return  PT_GRAY;
-    case cmsSigRgbData:  return  PT_RGB;
-    case cmsSigCmyData:  return  PT_CMY;
-    case cmsSigCmykData: return  PT_CMYK;
-    case cmsSigYCbCrData:return  PT_YCbCr;
-    case cmsSigLuvData:  return  PT_YUV;
-    case cmsSigXYZData:  return  PT_XYZ;
-    case cmsSigLabData:  return  PT_Lab;
-    case cmsSigLuvKData: return  PT_YUVK;
-    case cmsSigHsvData:  return  PT_HSV;
-    case cmsSigHlsData:  return  PT_HLS;
-    case cmsSigYxyData:  return  PT_Yxy;
-    
-    case cmsSig1colorData:
-    case cmsSigMCH1Data: return PT_MCH1;
-    
-    case cmsSig2colorData:
-    case cmsSigMCH2Data: return PT_MCH2;
-    
-    case cmsSig3colorData:
-    case cmsSigMCH3Data: return PT_MCH3;
-    
-    case cmsSig4colorData:
-    case cmsSigMCH4Data: return PT_MCH4;
-    
-    case cmsSig5colorData:
-    case cmsSigMCH5Data: return PT_MCH5;
-    
-    case cmsSig6colorData:
-    case cmsSigMCH6Data: return PT_MCH6;
-        
-    case cmsSigMCH7Data:
-    case cmsSig7colorData:return PT_MCH7;
-        
-    case cmsSigMCH8Data:
-    case cmsSig8colorData:return PT_MCH8;
-        
-    case cmsSigMCH9Data:
-    case cmsSig9colorData:return PT_MCH9;
-        
-    case cmsSigMCHAData:
-    case cmsSig10colorData:return PT_MCH10;
-        
-    case cmsSigMCHBData:
-    case cmsSig11colorData:return PT_MCH11;
-        
-    case cmsSigMCHCData:
-    case cmsSig12colorData:return PT_MCH12;
-        
-    case cmsSigMCHDData:
-    case cmsSig13colorData:return PT_MCH13;
-        
-    case cmsSigMCHEData:
-    case cmsSig14colorData:return PT_MCH14;
-        
-    case cmsSigMCHFData:
-    case cmsSig15colorData:return PT_MCH15;
-                
-    default:  return (cmsColorSpaceSignature) (-1);
-    }
-}
-
-
-cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)
-{
-    switch (ColorSpace) {
-
-    case cmsSigGrayData: return 1;
-
-    case cmsSig2colorData:  return 2;
-        
-    case cmsSigXYZData:
-    case cmsSigLabData:
-    case cmsSigLuvData:
-    case cmsSigYCbCrData:
-    case cmsSigYxyData:
-    case cmsSigRgbData:   
-    case cmsSigHsvData:
-    case cmsSigHlsData:
-    case cmsSigCmyData: 
-    case cmsSig3colorData:  return 3;
-                   
-    case cmsSigLuvKData:
-    case cmsSigCmykData:
-    case cmsSig4colorData:  return 4;
-
-    case cmsSigMCH5Data:
-    case cmsSig5colorData:  return 5;  
-
-    case cmsSigMCH6Data:   
-    case cmsSig6colorData:  return 6;
-        
-    case cmsSigMCH7Data:
-    case cmsSig7colorData:  return  7;
-
-    case cmsSigMCH8Data:
-    case cmsSig8colorData:  return  8;
-
-    case cmsSigMCH9Data:
-    case cmsSig9colorData:  return  9;
-
-    case cmsSigMCHAData:
-    case cmsSig10colorData: return 10;
-
-    case cmsSigMCHBData:
-    case cmsSig11colorData: return 11;
-    
-    case cmsSigMCHCData:
-    case cmsSig12colorData: return 12;
-
-    case cmsSigMCHDData:
-    case cmsSig13colorData: return 13;
-
-    case cmsSigMCHEData:
-    case cmsSig14colorData: return 14;
-
-    case cmsSigMCHFData:
-    case cmsSig15colorData: return 15;
-
-    default: return 3;
-    }
-}
diff --git a/thirdparty/liblcms2/src/cmsplugin.c b/thirdparty/liblcms2/src/cmsplugin.c
deleted file mode 100644
index 1fa5ff4..0000000
--- a/thirdparty/liblcms2/src/cmsplugin.c
+++ /dev/null
@@ -1,612 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// ----------------------------------------------------------------------------------
-// Encoding & Decoding support functions
-// ----------------------------------------------------------------------------------
-
-//      Little-Endian to Big-Endian
-
-// Adjust a word value after being readed/ before being written from/to an ICC profile
-cmsUInt16Number CMSEXPORT  _cmsAdjustEndianess16(cmsUInt16Number Word)
-{
-#ifndef CMS_USE_BIG_ENDIAN
-
-    cmsUInt8Number* pByte = (cmsUInt8Number*) &Word;
-    cmsUInt8Number tmp;
-
-    tmp = pByte[0];
-    pByte[0] = pByte[1];
-    pByte[1] = tmp;
-#endif      
-
-    return Word;
-}
-
-
-// Transports to properly encoded values - note that icc profiles does use big endian notation.
-
-// 1 2 3 4
-// 4 3 2 1
-
-cmsUInt32Number CMSEXPORT  _cmsAdjustEndianess32(cmsUInt32Number DWord)
-{
-#ifndef CMS_USE_BIG_ENDIAN
-
-    cmsUInt8Number* pByte = (cmsUInt8Number*) &DWord;
-    cmsUInt8Number temp1;
-    cmsUInt8Number temp2;
-
-    temp1 = *pByte++;
-    temp2 = *pByte++;
-    *(pByte-1) = *pByte;
-    *pByte++ = temp2;
-    *(pByte-3) = *pByte;
-    *pByte = temp1;
-#endif
-    return DWord;
-}
-
-// 1 2 3 4 5 6 7 8
-// 8 7 6 5 4 3 2 1
-
-void CMSEXPORT  _cmsAdjustEndianess64(cmsUInt64Number* Result, cmsUInt64Number QWord)
-{
-    
-#ifndef CMS_USE_BIG_ENDIAN
-    
-    cmsUInt8Number* pIn  = (cmsUInt8Number*) &QWord;
-    cmsUInt8Number* pOut = (cmsUInt8Number*) Result;
-
-    _cmsAssert(Result != NULL);
-
-    pOut[7] = pIn[0];
-    pOut[6] = pIn[1];
-    pOut[5] = pIn[2];
-    pOut[4] = pIn[3];
-    pOut[3] = pIn[4];
-    pOut[2] = pIn[5];   
-    pOut[1] = pIn[6];
-    pOut[0] = pIn[7];
-
-#else
-
-    _cmsAssert(Result != NULL);
-
-    *Result = QWord;
-#endif
-}
-
-// Auxiliar -- read 8, 16 and 32-bit numbers
-cmsBool CMSEXPORT  _cmsReadUInt8Number(cmsIOHANDLER* io, cmsUInt8Number* n)
-{
-    cmsUInt8Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsUInt8Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) *n = tmp;
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsReadUInt16Number(cmsIOHANDLER* io, cmsUInt16Number* n)
-{
-    cmsUInt16Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsUInt16Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) *n = _cmsAdjustEndianess16(tmp);
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsReadUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, cmsUInt16Number* Array)
-{
-    cmsUInt32Number i;
-
-    _cmsAssert(io != NULL);
-
-    for (i=0; i < n; i++) {
-
-        if (Array != NULL) {
-            if (!_cmsReadUInt16Number(io, Array + i)) return FALSE;
-        }
-        else {
-            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;
-        }
-
-    }
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsReadUInt32Number(cmsIOHANDLER* io, cmsUInt32Number* n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsUInt32Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) *n = _cmsAdjustEndianess32(tmp);
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsReadFloat32Number(cmsIOHANDLER* io, cmsFloat32Number* n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsFloat32Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) {
-
-        tmp = _cmsAdjustEndianess32(tmp);
-        *n = *(cmsFloat32Number*) &tmp;
-    }
-    return TRUE;
-}
-
-
-cmsBool CMSEXPORT   _cmsReadUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n)
-{
-    cmsUInt64Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsUInt64Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) _cmsAdjustEndianess64(n, tmp);
-    return TRUE;
-}
-
-
-cmsBool CMSEXPORT  _cmsRead15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number* n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &tmp, sizeof(cmsUInt32Number), 1) != 1) 
-            return FALSE;   
-
-    if (n != NULL) {
-        *n = _cms15Fixed16toDouble(_cmsAdjustEndianess32(tmp));
-    }
-
-    return TRUE;
-}
-
-
-// Jun-21-2000: Some profiles (those that comes with W2K) comes
-// with the media white (media black?) x 100. Add a sanity check
-
-static
-void NormalizeXYZ(cmsCIEXYZ* Dest)
-{
-    while (Dest -> X > 2. &&
-           Dest -> Y > 2. &&
-           Dest -> Z > 2.) {
-
-               Dest -> X /= 10.;
-               Dest -> Y /= 10.;
-               Dest -> Z /= 10.;
-       }
-}
-
-cmsBool CMSEXPORT  _cmsReadXYZNumber(cmsIOHANDLER* io, cmsCIEXYZ* XYZ)
-{
-    cmsEncodedXYZNumber xyz;
-
-    _cmsAssert(io != NULL);
-
-    if (io ->Read(io, &xyz, sizeof(cmsEncodedXYZNumber), 1) != 1) return FALSE;
-
-    if (XYZ != NULL) {
-
-        XYZ->X = _cms15Fixed16toDouble(_cmsAdjustEndianess32(xyz.X));
-        XYZ->Y = _cms15Fixed16toDouble(_cmsAdjustEndianess32(xyz.Y));
-        XYZ->Z = _cms15Fixed16toDouble(_cmsAdjustEndianess32(xyz.Z));
-
-        NormalizeXYZ(XYZ);
-    }
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteUInt8Number(cmsIOHANDLER* io, cmsUInt8Number n)
-{
-    _cmsAssert(io != NULL);
-
-    if (io -> Write(io, sizeof(cmsUInt8Number), &n) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteUInt16Number(cmsIOHANDLER* io, cmsUInt16Number n)
-{
-    cmsUInt16Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    tmp = _cmsAdjustEndianess16(n);
-    if (io -> Write(io, sizeof(cmsUInt16Number), &tmp) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, const cmsUInt16Number* Array)
-{
-    cmsUInt32Number i;
-
-    _cmsAssert(io != NULL);
-    _cmsAssert(Array != NULL);
-
-    for (i=0; i < n; i++) {
-        if (!_cmsWriteUInt16Number(io, Array[i])) return FALSE;
-    }
-
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteUInt32Number(cmsIOHANDLER* io, cmsUInt32Number n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    tmp = _cmsAdjustEndianess32(n);
-    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-
-cmsBool CMSEXPORT  _cmsWriteFloat32Number(cmsIOHANDLER* io, cmsFloat32Number n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    tmp = *(cmsUInt32Number*) &n;
-    tmp = _cmsAdjustEndianess32(tmp);
-    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteUInt64Number(cmsIOHANDLER* io, cmsUInt64Number n)
-{
-    cmsUInt64Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    _cmsAdjustEndianess64(&tmp, n);
-    if (io -> Write(io, sizeof(cmsUInt64Number), &tmp) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWrite15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number n)
-{
-    cmsUInt32Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    tmp = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(n));
-    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1) 
-            return FALSE;   
-    
-    return TRUE;
-}
-
-cmsBool CMSEXPORT  _cmsWriteXYZNumber(cmsIOHANDLER* io, const cmsCIEXYZ* XYZ)
-{
-    cmsEncodedXYZNumber xyz;
-  
-    _cmsAssert(io != NULL);
-    _cmsAssert(XYZ != NULL);
-
-    xyz.X = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(XYZ->X));
-    xyz.Y = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(XYZ->Y));
-    xyz.Z = _cmsAdjustEndianess32(_cmsDoubleTo15Fixed16(XYZ->Z));
-
-    return io -> Write(io,  sizeof(cmsEncodedXYZNumber), &xyz);
-}
-
-// from Fixed point 8.8 to double
-cmsFloat64Number CMSEXPORT _cms8Fixed8toDouble(cmsUInt16Number fixed8)
-{
-       cmsUInt8Number  msb, lsb;
-
-       lsb = (cmsUInt8Number) (fixed8 & 0xff);
-       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);
-
-       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb / 256.0));
-}
-
-cmsUInt16Number CMSEXPORT _cmsDoubleTo8Fixed8(cmsFloat64Number val)
-{
-    cmsS15Fixed16Number GammaFixed32 = _cmsDoubleTo15Fixed16(val);
-    return  (cmsUInt16Number) ((GammaFixed32 >> 8) & 0xFFFF);       
-}
-
-// from Fixed point 15.16 to double
-cmsFloat64Number CMSEXPORT _cms15Fixed16toDouble(cmsS15Fixed16Number fix32)
-{
-    cmsFloat64Number floater, sign, mid;
-    int Whole, FracPart;
-
-    sign  = (fix32 < 0 ? -1 : 1);
-    fix32 = abs(fix32);
-
-    Whole     = (cmsUInt16Number)(fix32 >> 16) & 0xffff;
-    FracPart  = (cmsUInt16Number)(fix32 & 0xffff);
-
-    mid     = (cmsFloat64Number) FracPart / 65536.0;
-    floater = (cmsFloat64Number) Whole + mid;
-
-    return sign * floater;
-}
-
-// from double to Fixed point 15.16 
-cmsS15Fixed16Number CMSEXPORT _cmsDoubleTo15Fixed16(cmsFloat64Number v)
-{
-    return ((cmsS15Fixed16Number) floor((v)*65536.0 + 0.5));
-}
-
-// Date/Time functions 
-
-void CMSEXPORT _cmsDecodeDateTimeNumber(const cmsDateTimeNumber *Source, struct tm *Dest)
-{
-
-    _cmsAssert(Dest != NULL);
-    _cmsAssert(Source != NULL);
-
-    Dest->tm_sec   = _cmsAdjustEndianess16(Source->seconds);
-    Dest->tm_min   = _cmsAdjustEndianess16(Source->minutes);
-    Dest->tm_hour  = _cmsAdjustEndianess16(Source->hours);
-    Dest->tm_mday  = _cmsAdjustEndianess16(Source->day);
-    Dest->tm_mon   = _cmsAdjustEndianess16(Source->month) - 1;
-    Dest->tm_year  = _cmsAdjustEndianess16(Source->year) - 1900;
-    Dest->tm_wday  = -1;
-    Dest->tm_yday  = -1;
-    Dest->tm_isdst = 0;
-}
-
-void CMSEXPORT _cmsEncodeDateTimeNumber(cmsDateTimeNumber *Dest, const struct tm *Source)
-{
-    _cmsAssert(Dest != NULL);
-    _cmsAssert(Source != NULL);
-
-    Dest->seconds = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_sec);
-    Dest->minutes = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_min);
-    Dest->hours   = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_hour);
-    Dest->day     = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_mday);
-    Dest->month   = _cmsAdjustEndianess16((cmsUInt16Number) (Source->tm_mon + 1));
-    Dest->year    = _cmsAdjustEndianess16((cmsUInt16Number) (Source->tm_year + 1900));
-}
-
-// Read base and return type base
-cmsTagTypeSignature CMSEXPORT _cmsReadTypeBase(cmsIOHANDLER* io)
-{
-    _cmsTagBase Base;
-
-    _cmsAssert(io != NULL);
-
-    if (io -> Read(io, &Base, sizeof(_cmsTagBase), 1) != 1) 
-        return (cmsTagTypeSignature) 0;
-
-    return (cmsTagTypeSignature) _cmsAdjustEndianess32(Base.sig);
-}
-
-// Setup base marker
-cmsBool  CMSEXPORT _cmsWriteTypeBase(cmsIOHANDLER* io, cmsTagTypeSignature sig)
-{
-    _cmsTagBase  Base;
-
-    _cmsAssert(io != NULL);
-
-    Base.sig = (cmsTagTypeSignature) _cmsAdjustEndianess32(sig);
-    memset(&Base.reserved, 0, sizeof(Base.reserved));
-    return io -> Write(io, sizeof(_cmsTagBase), &Base);
-}
-
-cmsBool CMSEXPORT _cmsReadAlignment(cmsIOHANDLER* io)
-{
-    cmsUInt8Number  Buffer[4];
-    cmsUInt32Number NextAligned, At;
-    cmsUInt32Number BytesToNextAlignedPos;
-    
-    _cmsAssert(io != NULL);
-
-    At = io -> Tell(io);
-    NextAligned = _cmsALIGNLONG(At);
-    BytesToNextAlignedPos = NextAligned - At;
-    if (BytesToNextAlignedPos == 0) return TRUE;
-    if (BytesToNextAlignedPos > 4)  return FALSE;
-
-    return (io ->Read(io, Buffer, BytesToNextAlignedPos, 1) == 1);
-}
-
-cmsBool CMSEXPORT _cmsWriteAlignment(cmsIOHANDLER* io)
-{
-    cmsUInt8Number  Buffer[4];
-    cmsUInt32Number NextAligned, At;
-    cmsUInt32Number BytesToNextAlignedPos;
-
-    _cmsAssert(io != NULL);
-
-    At = io -> Tell(io);
-    NextAligned = _cmsALIGNLONG(At);
-    BytesToNextAlignedPos = NextAligned - At;
-    if (BytesToNextAlignedPos == 0) return TRUE;
-    if (BytesToNextAlignedPos > 4)  return FALSE;
-
-    memset(Buffer, 0, BytesToNextAlignedPos);
-    return io -> Write(io, BytesToNextAlignedPos, Buffer);
-}
-
-
-// To deal with text streams. 2K at most
-cmsBool CMSEXPORT _cmsIOPrintf(cmsIOHANDLER* io, const char* frm, ...)
-{
-    va_list args;
-    int len;
-    cmsUInt8Number Buffer[2048];
-    cmsBool rc;
-
-    _cmsAssert(io != NULL);
-    _cmsAssert(frm != NULL);
-
-    va_start(args, frm);
-
-    len = vsnprintf((char*) Buffer, 2047, frm, args);
-    if (len < 0) return FALSE;   // Truncated, which is a fatal error for us
-
-    rc = io ->Write(io, len, Buffer);
-    
-    va_end(args);
-
-    return rc;
-}
-
-
-// Plugin memory management -------------------------------------------------------------------------------------------------
-
-static _cmsSubAllocator* PluginPool = NULL;
-
-// Specialized malloc for plug-ins, that is freed upon exit.
-void* _cmsPluginMalloc(cmsUInt32Number size)
-{
-    if (PluginPool == NULL)
-        PluginPool = _cmsCreateSubAlloc(0, 4*1024);
-
-    return _cmsSubAlloc(PluginPool, size);
-}
-
-
-// Main plug-in dispatcher
-cmsBool CMSEXPORT cmsPlugin(void* Plug_in)
-{
-    cmsPluginBase* Plugin;
-
-    for (Plugin = (cmsPluginBase*) Plug_in; 
-         Plugin != NULL; 
-         Plugin = Plugin -> Next) {
-
-            if (Plugin -> Magic != cmsPluginMagicNumber) {
-                cmsSignalError(0, cmsERROR_UNKNOWN_EXTENSION, "Unrecognized plugin");
-                return FALSE;
-            }
-
-			if (Plugin ->ExpectedVersion > LCMS_VERSION) {
-				cmsSignalError(0, cmsERROR_UNKNOWN_EXTENSION, "plugin needs Little CMS %d, current  version is %d", 
-					Plugin ->ExpectedVersion, LCMS_VERSION);
-				return FALSE;
-			}
-
-            switch (Plugin -> Type) {
-
-                case cmsPluginMemHandlerSig:
-                    if (!_cmsRegisterMemHandlerPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginInterpolationSig:
-                    if (!_cmsRegisterInterpPlugin(Plugin)) return FALSE;
-                    break;
-                
-                case cmsPluginTagTypeSig:
-                    if (!_cmsRegisterTagTypePlugin(Plugin)) return FALSE;
-                    break;
-            
-                case cmsPluginTagSig:
-                    if (!_cmsRegisterTagPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginFormattersSig:
-                    if (!_cmsRegisterFormattersPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginRenderingIntentSig:
-                    if (!_cmsRegisterRenderingIntentPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginParametricCurveSig:
-                    if (!_cmsRegisterParametricCurvesPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginMultiProcessElementSig:
-                    if (!_cmsRegisterMultiProcessElementPlugin(Plugin)) return FALSE;
-                    break;
-
-                case cmsPluginOptimizationSig:
-                    if (!_cmsRegisterOptimizationPlugin(Plugin)) return FALSE;
-                    break;
-
-                default:
-                    cmsSignalError(0, cmsERROR_UNKNOWN_EXTENSION, "Unrecognized plugin type '%X'", Plugin -> Type);
-                    return FALSE;
-            }            
-    }
-
-    // Keep a reference to the plug-in
-    return TRUE;
-}
-
-
-// Revert all plug-ins to default
-void CMSEXPORT cmsUnregisterPlugins(void)
-{
-    _cmsRegisterMemHandlerPlugin(NULL);
-    _cmsRegisterInterpPlugin(NULL);
-    _cmsRegisterTagTypePlugin(NULL);
-    _cmsRegisterTagPlugin(NULL);
-    _cmsRegisterFormattersPlugin(NULL);
-    _cmsRegisterRenderingIntentPlugin(NULL);
-    _cmsRegisterParametricCurvesPlugin(NULL);
-    _cmsRegisterMultiProcessElementPlugin(NULL);
-    _cmsRegisterOptimizationPlugin(NULL);
-
-    if (PluginPool != NULL)
-        _cmsSubAllocDestroy(PluginPool);
-
-    PluginPool = NULL;
-}
diff --git a/thirdparty/liblcms2/src/cmsps2.c b/thirdparty/liblcms2/src/cmsps2.c
deleted file mode 100644
index b41f58f..0000000
--- a/thirdparty/liblcms2/src/cmsps2.c
+++ /dev/null
@@ -1,1595 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2008 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// PostScript ColorRenderingDictionary and ColorSpaceArray															   
-
-
-#define MAXPSCOLS   60      // Columns on tables
-
-/*
-    Implementation
-    --------------
-
-  PostScript does use XYZ as its internal PCS. But since PostScript 
-  interpolation tables are limited to 8 bits, I use Lab as a way to 
-  improve the accuracy, favoring perceptual results. So, for the creation 
-  of each CRD, CSA the profiles are converted to Lab via a device 
-  link between  profile -> Lab or Lab -> profile. The PS code necessary to
-  convert Lab <-> XYZ is also included.
-
-
-
-  Color Space Arrays (CSA) 
-  ==================================================================================
-
-  In order to obtain precision, code chooses between three ways to implement
-  the device -> XYZ transform. These cases identifies monochrome profiles (often
-  implemented as a set of curves), matrix-shaper and Pipeline-based.
-
-  Monochrome 
-  -----------
-
-  This is implemented as /CIEBasedA CSA. The prelinearization curve is 
-  placed into /DecodeA section, and matrix equals to D50. Since here is
-  no interpolation tables, I do the conversion directly to XYZ
-
-  NOTE: CLUT-based monochrome profiles are NOT supported. So, cmsFLAGS_MATRIXINPUT
-  flag is forced on such profiles.
-
-    [ /CIEBasedA
-      <<            
-            /DecodeA { transfer function } bind
-            /MatrixA [D50]  
-            /RangeLMN [ 0.0 cmsD50X 0.0 cmsD50Y 0.0 cmsD50Z ]
-            /WhitePoint [D50]
-            /BlackPoint [BP]
-            /RenderingIntent (intent)
-      >>
-    ] 
-
-   On simpler profiles, the PCS is already XYZ, so no conversion is required.
-
- 
-   Matrix-shaper based
-   -------------------
-
-   This is implemented both with /CIEBasedABC or /CIEBasedDEF on dependig
-   of profile implementation. Since here there are no interpolation tables, I do 
-   the conversion directly to XYZ
-
-
-
-    [ /CIEBasedABC
-            <<
-                /DecodeABC [ {transfer1} {transfer2} {transfer3} ]
-                /MatrixABC [Matrix]
-                /RangeLMN [ 0.0 cmsD50X 0.0 cmsD50Y 0.0 cmsD50Z ]
-                /DecodeLMN [ { / 2} dup dup ]
-                /WhitePoint [D50]
-                /BlackPoint [BP]
-                /RenderingIntent (intent)
-            >>
-    ] 
-
-
-    CLUT based
-    ----------
-
-     Lab is used in such cases.
-
-    [ /CIEBasedDEF
-            <<
-            /DecodeDEF [ <prelinearization> ]
-            /Table [ p p p [<...>]]
-            /RangeABC [ 0 1 0 1 0 1]
-            /DecodeABC[ <postlinearization> ]
-            /RangeLMN [ -0.236 1.254 0 1 -0.635 1.640 ] 
-               % -128/500 1+127/500 0 1  -127/200 1+128/200 
-            /MatrixABC [ 1 1 1 1 0 0 0 0 -1]
-            /WhitePoint [D50]
-            /BlackPoint [BP]
-            /RenderingIntent (intent)
-    ] 
-
-
-  Color Rendering Dictionaries (CRD)
-  ==================================
-  These are always implemented as CLUT, and always are using Lab. Since CRD are expected to
-  be used as resources, the code adds the definition as well.
-
-  <<
-    /ColorRenderingType 1
-    /WhitePoint [ D50 ]
-    /BlackPoint [BP]
-    /MatrixPQR [ Bradford ]
-    /RangePQR [-0.125 1.375 -0.125 1.375 -0.125 1.375 ]
-    /TransformPQR [            
-    {4 index 3 get div 2 index 3 get mul exch pop exch pop exch pop exch pop } bind
-    {4 index 4 get div 2 index 4 get mul exch pop exch pop exch pop exch pop } bind
-    {4 index 5 get div 2 index 5 get mul exch pop exch pop exch pop exch pop } bind
-    ]
-    /MatrixABC <...>
-    /EncodeABC <...>
-    /RangeABC  <.. used for  XYZ -> Lab>
-    /EncodeLMN
-    /RenderTable [ p p p [<...>]]   
-    
-    /RenderingIntent (Perceptual)
-  >> 
-  /Current exch /ColorRendering defineresource pop
-
-
-  The following stages are used to convert from XYZ to Lab
-  --------------------------------------------------------  
-
-  Input is given at LMN stage on X, Y, Z
-
-  Encode LMN gives us f(X/Xn), f(Y/Yn), f(Z/Zn)
-
-  /EncodeLMN [
-
-    { 0.964200  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind
-    { 1.000000  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind
-    { 0.824900  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind
-
-    ]
-    
-      
-  MatrixABC is used to compute f(Y/Yn), f(X/Xn) - f(Y/Yn), f(Y/Yn) - f(Z/Zn)
-
-  | 0  1  0|
-  | 1 -1  0|
-  | 0  1 -1|
-
-  /MatrixABC [ 0 1 0 1 -1 1 0 0 -1 ]
-
- EncodeABC finally gives Lab values.
-
-  /EncodeABC [
-    { 116 mul  16 sub 100 div  } bind
-    { 500 mul 128 add 255 div  } bind
-    { 200 mul 128 add 255 div  } bind
-    ]   
-    
-  The following stages are used to convert Lab to XYZ
-  ----------------------------------------------------
-
-    /RangeABC [ 0 1 0 1 0 1]
-    /DecodeABC [ { 100 mul 16 add 116 div } bind
-                 { 255 mul 128 sub 500 div } bind
-                 { 255 mul 128 sub 200 div } bind 
-               ]
-    
-    /MatrixABC [ 1 1 1 1 0 0 0 0 -1]
-    /DecodeLMN [
-                {dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.964200 mul} bind
-                {dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse } bind
-                {dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.824900 mul} bind
-                ]
-
-
-*/
-
-/*
-
- PostScript algorithms discussion.
- =========================================================================================================
-
-  1D interpolation algorithm 
-
-
-  1D interpolation (float)
-  ------------------------
-    
-    val2 = Domain * Value;
-
-    cell0 = (int) floor(val2);
-    cell1 = (int) ceil(val2);
-
-    rest = val2 - cell0;
-
-    y0 = LutTable[cell0] ;
-    y1 = LutTable[cell1] ;
-
-    y = y0 + (y1 - y0) * rest;
-
-
-  
-  PostScript code                   Stack
-  ================================================
-
-  {                                 % v
-    <check 0..1.0>
-    [array]                         % v tab
-    dup                             % v tab tab
-    length 1 sub                    % v tab dom
-
-    3 -1 roll                       % tab dom v
-
-    mul                             % tab val2
-    dup                             % tab val2 val2
-    dup                             % tab val2 val2 val2
-    floor cvi                       % tab val2 val2 cell0
-    exch                            % tab val2 cell0 val2
-    ceiling cvi                     % tab val2 cell0 cell1
-
-    3 index                         % tab val2 cell0 cell1 tab  
-    exch                            % tab val2 cell0 tab cell1
-    get                             % tab val2 cell0 y1
-
-    4 -1 roll                       % val2 cell0 y1 tab
-    3 -1 roll                       % val2 y1 tab cell0 
-    get                             % val2 y1 y0 
-
-    dup                             % val2 y1 y0 y0
-    3 1 roll                        % val2 y0 y1 y0 
-
-    sub                             % val2 y0 (y1-y0)
-    3 -1 roll                       % y0 (y1-y0) val2
-    dup                             % y0 (y1-y0) val2 val2
-    floor cvi                       % y0 (y1-y0) val2 floor(val2) 
-    sub                             % y0 (y1-y0) rest
-    mul                             % y0 t1
-    add                             % y
-    65535 div                       % result
-
-  } bind
-
-
-*/
-
-
-// This struct holds the memory block currently being write
-typedef struct {
-	_cmsStageCLutData* Pipeline;
-	cmsIOHANDLER* m;
-
-	int FirstComponent;
-	int SecondComponent;
-	
-	const char* PreMaj;
-	const char* PostMaj;
-	const char* PreMin;
-	const char* PostMin;
-
-	int  FixWhite;    // Force mapping of pure white 
-
-	cmsColorSpaceSignature  ColorSpace;  // ColorSpace of profile
-
-
-} cmsPsSamplerCargo;
-
-static int _cmsPSActualColumn = 0;
-
-
-// Convert to byte
-static
-cmsUInt8Number Word2Byte(cmsUInt16Number w)
-{
-    return (cmsUInt8Number) floor((cmsFloat64Number) w / 257.0 + 0.5);
-}
-
-
-// Convert to byte (using ICC2 notation)
-/*
-static
-cmsUInt8Number L2Byte(cmsUInt16Number w)
-{    
-	int ww = w + 0x0080;
-
-	if (ww > 0xFFFF) return 0xFF;
-
-    return (cmsUInt8Number) ((cmsUInt16Number) (ww >> 8) & 0xFF);
-}
-*/
-
-// Write a cooked byte
-
-static
-void WriteByte(cmsIOHANDLER* m, cmsUInt8Number b)
-{
-	_cmsIOPrintf(m, "%02x", b);	
-	_cmsPSActualColumn += 2;
-
-	if (_cmsPSActualColumn > MAXPSCOLS) {
-
-		_cmsIOPrintf(m, "\n");
-		_cmsPSActualColumn = 0;
-	}	
-}
-
-// ----------------------------------------------------------------- PostScript generation
-
-
-// Removes offending Carriage returns
-static 
-char* RemoveCR(const char* txt)
-{
-    static char Buffer[2048];
-    char* pt;
-
-    strncpy(Buffer, txt, 2047);
-    Buffer[2047] = 0;
-    for (pt = Buffer; *pt; pt++)
-            if (*pt == '\n' || *pt == '\r') *pt = ' ';
-
-    return Buffer;
-
-}
-
-static
-void EmitHeader(cmsIOHANDLER* m, const char* Title, cmsHPROFILE hProfile)
-{
-    time_t timer;
-	cmsMLU *Description, *Copyright;
-	char DescASCII[256], CopyrightASCII[256];
-    
-    time(&timer);
-	
-	Description = (cmsMLU*) cmsReadTag(hProfile, cmsSigProfileDescriptionTag);
-	Copyright   = (cmsMLU*) cmsReadTag(hProfile, cmsSigCopyrightTag);
-
-	DescASCII[0] = DescASCII[255] = 0;
-    CopyrightASCII[0] = CopyrightASCII[255] = 0;
-
-	if (Description != NULL) cmsMLUgetASCII(Description,  cmsNoLanguage, cmsNoCountry, DescASCII,       255);
-	if (Copyright != NULL)   cmsMLUgetASCII(Copyright,    cmsNoLanguage, cmsNoCountry, CopyrightASCII,  255);
-
-    _cmsIOPrintf(m, "%%!PS-Adobe-3.0\n");
-    _cmsIOPrintf(m, "%%\n");
-    _cmsIOPrintf(m, "%% %s\n", Title);
-    _cmsIOPrintf(m, "%% Source: %s\n", RemoveCR(DescASCII));
-    _cmsIOPrintf(m, "%%         %s\n", RemoveCR(CopyrightASCII));
-    _cmsIOPrintf(m, "%% Created: %s", ctime(&timer)); // ctime appends a \n!!!
-    _cmsIOPrintf(m, "%%\n");
-    _cmsIOPrintf(m, "%%%%BeginResource\n");
-
-}
-
-
-// Emits White & Black point. White point is always D50, Black point is the device 
-// Black point adapted to D50. 
-
-static
-void EmitWhiteBlackD50(cmsIOHANDLER* m, cmsCIEXYZ* BlackPoint)
-{
-
-    _cmsIOPrintf(m, "/BlackPoint [%f %f %f]\n", BlackPoint -> X,
-                                          BlackPoint -> Y,
-                                          BlackPoint -> Z);
-
-    _cmsIOPrintf(m, "/WhitePoint [%f %f %f]\n", cmsD50_XYZ()->X, 
-                                          cmsD50_XYZ()->Y,
-                                          cmsD50_XYZ()->Z);
-}
-
-
-static
-void EmitRangeCheck(cmsIOHANDLER* m)
-{
-    _cmsIOPrintf(m, "dup 0.0 lt { pop 0.0 } if "
-                    "dup 1.0 gt { pop 1.0 } if ");
-
-}
-
-// Does write the intent
-
-static
-void EmitIntent(cmsIOHANDLER* m, int RenderingIntent)
-{
-    const char *intent;
-
-    switch (RenderingIntent) {
-
-        case INTENT_PERCEPTUAL:            intent = "Perceptual"; break;
-        case INTENT_RELATIVE_COLORIMETRIC: intent = "RelativeColorimetric"; break;
-        case INTENT_ABSOLUTE_COLORIMETRIC: intent = "AbsoluteColorimetric"; break;
-        case INTENT_SATURATION:            intent = "Saturation"; break;
-
-        default: intent = "Undefined"; break;
-    }
-
-    _cmsIOPrintf(m, "/RenderingIntent (%s)\n", intent );    
-}
-
-//
-//  Convert L* to Y
-//
-//      Y = Yn*[ (L* + 16) / 116] ^ 3   if (L*) >= 6 / 29
-//        = Yn*( L* / 116) / 7.787      if (L*) < 6 / 29
-//
-
-/*
-static
-void EmitL2Y(cmsIOHANDLER* m)
-{
-    _cmsIOPrintf(m, 
-            "{ " 
-                "100 mul 16 add 116 div "               // (L * 100 + 16) / 116
-                 "dup 6 29 div ge "                     // >= 6 / 29 ?          
-                 "{ dup dup mul mul } "                 // yes, ^3 and done
-                 "{ 4 29 div sub 108 841 div mul } "    // no, slope limiting
-            "ifelse } bind "); 
-}
-*/
-
-
-// Lab -> XYZ, see the discussion above
-
-static
-void EmitLab2XYZ(cmsIOHANDLER* m)
-{
-    _cmsIOPrintf(m, "/RangeABC [ 0 1 0 1 0 1]\n");
-    _cmsIOPrintf(m, "/DecodeABC [\n");
-    _cmsIOPrintf(m, "{100 mul  16 add 116 div } bind\n");
-    _cmsIOPrintf(m, "{255 mul 128 sub 500 div } bind\n");
-    _cmsIOPrintf(m, "{255 mul 128 sub 200 div } bind\n");
-    _cmsIOPrintf(m, "]\n");
-    _cmsIOPrintf(m, "/MatrixABC [ 1 1 1 1 0 0 0 0 -1]\n");
-	_cmsIOPrintf(m, "/RangeLMN [ -0.236 1.254 0 1 -0.635 1.640 ]\n"); 
-    _cmsIOPrintf(m, "/DecodeLMN [\n");
-    _cmsIOPrintf(m, "{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.964200 mul} bind\n");
-    _cmsIOPrintf(m, "{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse } bind\n");
-    _cmsIOPrintf(m, "{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.824900 mul} bind\n");
-    _cmsIOPrintf(m, "]\n");
-}
-
-
-
-// Outputs a table of words. It does use 16 bits
-
-static
-void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)
-{
-    cmsUInt32Number i;
-    cmsFloat64Number gamma;
-
-
-    if (Table ->nEntries <= 0) return;  // Empty table
-
-    // Suppress whole if identity
-    if (cmsIsToneCurveLinear(Table)) return;
-
-    // Check if is really an exponential. If so, emit "exp"
-	gamma = cmsEstimateGamma(Table, 0.001);
-     if (gamma > 0) {
-            _cmsIOPrintf(m, "{ %g exp } bind ", gamma);
-            return;
-     }
-
-    _cmsIOPrintf(m, "{ ");
-
-    // Bounds check
-    EmitRangeCheck(m);
-    
-    // Emit intepolation code
-
-    // PostScript code                      Stack
-    // ===============                      ========================
-                                            // v
-    _cmsIOPrintf(m, " [");
-
-    for (i=0; i < Table->nEntries; i++) {
-		_cmsIOPrintf(m, "%d ", Table->Table16[i]);
-    }
-
-    _cmsIOPrintf(m, "] ");                        // v tab
-
-    _cmsIOPrintf(m, "dup ");                      // v tab tab        
-    _cmsIOPrintf(m, "length 1 sub ");             // v tab dom
-    _cmsIOPrintf(m, "3 -1 roll ");                // tab dom v
-    _cmsIOPrintf(m, "mul ");                      // tab val2
-    _cmsIOPrintf(m, "dup ");                      // tab val2 val2
-    _cmsIOPrintf(m, "dup ");                      // tab val2 val2 val2
-    _cmsIOPrintf(m, "floor cvi ");                // tab val2 val2 cell0
-    _cmsIOPrintf(m, "exch ");                     // tab val2 cell0 val2
-    _cmsIOPrintf(m, "ceiling cvi ");              // tab val2 cell0 cell1
-    _cmsIOPrintf(m, "3 index ");                  // tab val2 cell0 cell1 tab 
-    _cmsIOPrintf(m, "exch ");                     // tab val2 cell0 tab cell1
-    _cmsIOPrintf(m, "get ");                      // tab val2 cell0 y1
-    _cmsIOPrintf(m, "4 -1 roll ");                // val2 cell0 y1 tab
-    _cmsIOPrintf(m, "3 -1 roll ");                // val2 y1 tab cell0 
-    _cmsIOPrintf(m, "get ");                      // val2 y1 y0 
-    _cmsIOPrintf(m, "dup ");                      // val2 y1 y0 y0
-    _cmsIOPrintf(m, "3 1 roll ");                 // val2 y0 y1 y0 
-    _cmsIOPrintf(m, "sub ");                      // val2 y0 (y1-y0)
-    _cmsIOPrintf(m, "3 -1 roll ");                // y0 (y1-y0) val2
-    _cmsIOPrintf(m, "dup ");                      // y0 (y1-y0) val2 val2
-    _cmsIOPrintf(m, "floor cvi ");                // y0 (y1-y0) val2 floor(val2) 
-    _cmsIOPrintf(m, "sub ");                      // y0 (y1-y0) rest
-    _cmsIOPrintf(m, "mul ");                      // y0 t1
-    _cmsIOPrintf(m, "add ");                      // y
-    _cmsIOPrintf(m, "65535 div ");                // result
-
-    _cmsIOPrintf(m, " } bind ");
-}
-
-
-// Compare gamma table
-
-static
-cmsBool GammaTableEquals(cmsUInt16Number* g1, cmsUInt16Number* g2, int nEntries)
-{    
-    return memcmp(g1, g2, nEntries* sizeof(cmsUInt16Number)) == 0;
-}
-
-
-// Does write a set of gamma curves
-
-static
-void EmitNGamma(cmsIOHANDLER* m, int n, cmsToneCurve* g[])                  
-{
-    int i;
-    
-    for( i=0; i < n; i++ )
-    {                
-		if (i > 0 && GammaTableEquals(g[i-1]->Table16, g[i]->Table16, g[i]->nEntries)) {
-
-            _cmsIOPrintf(m, "dup ");
-        }
-        else {    
-			Emit1Gamma(m, g[i]);
-        }
-    }
-    
-}
-
-
-
-
-
-// Following code dumps a LUT onto memory stream
-        
-
-// This is the sampler. Intended to work in SAMPLER_INSPECT mode,
-// that is, the callback will be called for each knot with
-//
-//          In[]  The grid location coordinates, normalized to 0..ffff
-//          Out[] The Pipeline values, normalized to 0..ffff
-//
-//  Returning a value other than 0 does terminate the sampling process
-//
-//  Each row contains Pipeline values for all but first component. So, I 
-//  detect row changing by keeping a copy of last value of first 
-//  component. -1 is used to mark begining of whole block.
-
-static
-int OutputValueSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;
-    cmsUInt32Number i;
-
-
-    if (sc -> FixWhite) {
-
-        if (In[0] == 0xFFFF) {  // Only in L* = 100, ab = [-8..8]
-
-            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&
-                (In[2] >= 0x7800 && In[2] <= 0x8800)) {
-
-                cmsUInt16Number* Black;
-                cmsUInt16Number* White;
-                cmsUInt32Number nOutputs;
-
-                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))
-                        return 0;
-
-                for (i=0; i < nOutputs; i++)
-                        Out[i] = White[i];
-            }
-
-             
-        }
-    }
-
-
-    // Hadle the parenthesis on rows
-
-    if (In[0] != sc ->FirstComponent) {
-            
-            if (sc ->FirstComponent != -1) {
-
-                    _cmsIOPrintf(sc ->m, sc ->PostMin);
-                    sc ->SecondComponent = -1;
-                    _cmsIOPrintf(sc ->m, sc ->PostMaj);           
-            }
-
-            // Begin block  
-            _cmsPSActualColumn = 0;
-                    
-            _cmsIOPrintf(sc ->m, sc ->PreMaj);            
-            sc ->FirstComponent = In[0]; 
-    }
-
-
-      if (In[1] != sc ->SecondComponent) {
-            
-            if (sc ->SecondComponent != -1) {
-
-                    _cmsIOPrintf(sc ->m, sc ->PostMin);           
-            }
-                    
-            _cmsIOPrintf(sc ->m, sc ->PreMin);            
-            sc ->SecondComponent = In[1]; 
-    }
-
-	  // Dump table. 
-
-	  for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {
-
-		  cmsUInt16Number wWordOut = Out[i];
-          cmsUInt8Number wByteOut;           // Value as byte
-		 
-
-		  // We always deal with Lab4
-		  
-		  wByteOut = Word2Byte(wWordOut);
-		  WriteByte(sc -> m, wByteOut);
-	  }
-
-	  return 1;
-}
-
-// Writes a Pipeline on memstream. Could be 8 or 16 bits based
-
-static
-void WriteCLUT(cmsIOHANDLER* m, cmsStage* mpe, const char* PreMaj, 
-                                             const char* PostMaj,
-                                             const char* PreMin,
-                                             const char* PostMin,                                             
-                                             int FixWhite,
-                                             cmsColorSpaceSignature ColorSpace)
-{
-    cmsUInt32Number i;
-    cmsPsSamplerCargo sc;
-
-    sc.FirstComponent = -1;
-    sc.SecondComponent = -1;
-	sc.Pipeline = (_cmsStageCLutData *) mpe ->Data;
-    sc.m   = m;    
-    sc.PreMaj = PreMaj;
-    sc.PostMaj= PostMaj;
-
-    sc.PreMin   = PreMin;
-    sc.PostMin  = PostMin;    
-    sc.FixWhite = FixWhite;
-    sc.ColorSpace = ColorSpace;
-
-    _cmsIOPrintf(m, "[");
-
-	for (i=0; i < sc.Pipeline->Params->nInputs; i++)
-		_cmsIOPrintf(m, " %d ", sc.Pipeline->Params->nSamples[i]);
-
-    _cmsIOPrintf(m, " [\n");
-
-    cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*) &sc, SAMPLER_INSPECT);
-    
-    _cmsIOPrintf(m, PostMin);
-    _cmsIOPrintf(m, PostMaj);
-    _cmsIOPrintf(m, "] ");
-
-}
-
-
-// Dumps CIEBasedA Color Space Array
-
-static
-int EmitCIEBasedA(cmsIOHANDLER* m, cmsToneCurve* Curve, cmsCIEXYZ* BlackPoint)
-{
-
-	_cmsIOPrintf(m, "[ /CIEBasedA\n");
-	_cmsIOPrintf(m, "  <<\n");
-
-	_cmsIOPrintf(m, "/DecodeA ");
-
-	Emit1Gamma(m, Curve);
-
-	_cmsIOPrintf(m, " \n");
-
-	_cmsIOPrintf(m, "/MatrixA [ 0.9642 1.0000 0.8249 ]\n");
-	_cmsIOPrintf(m, "/RangeLMN [ 0.0 0.9642 0.0 1.0000 0.0 0.8249 ]\n");
-
-	EmitWhiteBlackD50(m, BlackPoint);
-	EmitIntent(m, INTENT_PERCEPTUAL);
-
-	_cmsIOPrintf(m, ">>\n");        
-	_cmsIOPrintf(m, "]\n");
-
-	return 1;
-}
-
-
-// Dumps CIEBasedABC Color Space Array
-
-static
-int EmitCIEBasedABC(cmsIOHANDLER* m, cmsFloat64Number* Matrix, cmsToneCurve** CurveSet, cmsCIEXYZ* BlackPoint)
-{
-	int i;
-	
-	_cmsIOPrintf(m, "[ /CIEBasedABC\n");
-	_cmsIOPrintf(m, "<<\n");
-	_cmsIOPrintf(m, "/DecodeABC [ ");
-
-	EmitNGamma(m, 3, CurveSet);
-
-	_cmsIOPrintf(m, "]\n");
-
-	_cmsIOPrintf(m, "/MatrixABC [ " );
-
-	for( i=0; i < 3; i++ ) {
-
-        _cmsIOPrintf(m, "%.6f %.6f %.6f ", Matrix[i + 3*0],
-                                           Matrix[i + 3*1],
-                                           Matrix[i + 3*2]);      
-	}
-
-
-	_cmsIOPrintf(m, "]\n");
-
-	_cmsIOPrintf(m, "/RangeLMN [ 0.0 0.9642 0.0 1.0000 0.0 0.8249 ]\n");
-
-	EmitWhiteBlackD50(m, BlackPoint);
-	EmitIntent(m, INTENT_PERCEPTUAL);
-
-	_cmsIOPrintf(m, ">>\n");
-	_cmsIOPrintf(m, "]\n");
-
-
-	return 1;
-}
-
-
-static
-int EmitCIEBasedDEF(cmsIOHANDLER* m, cmsPipeline* Pipeline, int Intent, cmsCIEXYZ* BlackPoint)
-{
-    const char* PreMaj;
-    const char* PostMaj;
-    const char* PreMin, *PostMin;
-	cmsStage* mpe;
-
-	mpe = Pipeline ->Elements;
-
-
-	switch (cmsStageInputChannels(mpe)) {
-    case 3:
-
-            _cmsIOPrintf(m, "[ /CIEBasedDEF\n");
-            PreMaj ="<"; 
-            PostMaj= ">\n";
-            PreMin = PostMin = "";
-            break;
-    case 4:
-            _cmsIOPrintf(m, "[ /CIEBasedDEFG\n");
-            PreMaj = "[";
-            PostMaj = "]\n";
-            PreMin = "<";
-            PostMin = ">\n";
-            break;
-    default:
-            return 0;
-
-    }
-
-    _cmsIOPrintf(m, "<<\n");
-
-	if (cmsStageType(mpe) == cmsSigCurveSetElemType) {
-    		
-        _cmsIOPrintf(m, "/DecodeDEF [ ");
-		EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));
-        _cmsIOPrintf(m, "]\n");
-
-		mpe = mpe ->Next;
-    }
-
-
-
-	if (cmsStageType(mpe) == cmsSigCLutElemType) {
-
-            _cmsIOPrintf(m, "/Table ");    
-            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);
-            _cmsIOPrintf(m, "]\n");
-    }
-       
-    EmitLab2XYZ(m);
-    EmitWhiteBlackD50(m, BlackPoint);
-    EmitIntent(m, Intent);
-
-    _cmsIOPrintf(m, "   >>\n");       
-    _cmsIOPrintf(m, "]\n");
-    
-
-    return 1;
-}
-
-// Generates a curve from a gray profile
-
-static
-cmsToneCurve* ExtractGray2Y(cmsContext ContextID, cmsHPROFILE hProfile, int Intent)
-{
-    cmsToneCurve* Out = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);
-    cmsHPROFILE hXYZ  = cmsCreateXYZProfile();
-    cmsHTRANSFORM xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_GRAY_8, hXYZ, TYPE_XYZ_DBL, Intent, cmsFLAGS_NOOPTIMIZE);
-    int i;
-
-    for (i=0; i < 256; i++) {
-        
-      cmsUInt8Number Gray = (cmsUInt8Number) i;
-      cmsCIEXYZ XYZ;
-      
-        cmsDoTransform(xform, &Gray, &XYZ, 1);
-        
-		Out ->Table16[i] =_cmsQuickSaturateWord(XYZ.Y * 65535.0);
-    }
-
-    cmsDeleteTransform(xform);
-    cmsCloseProfile(hXYZ);
-    return Out;
-}
-
-
-
-// Because PostScript has only 8 bits in /Table, we should use
-// a more perceptually uniform space... I do choose Lab.
-
-static
-int WriteInputLUT(cmsIOHANDLER* m, cmsHPROFILE hProfile, int Intent, cmsUInt32Number dwFlags)
-{
-    cmsHPROFILE hLab;
-    cmsHTRANSFORM xform;
-    cmsUInt32Number nChannels;
-    cmsUInt32Number InputFormat;
-    int rc;
-    cmsHPROFILE Profiles[2];
-    cmsCIEXYZ BlackPointAdaptedToD50;
-
-    // Does create a device-link based transform. 
-    // The DeviceLink is next dumped as working CSA.
-    
-    InputFormat = cmsFormatterForColorspaceOfProfile(hProfile, 2, FALSE);
-    nChannels   = T_CHANNELS(InputFormat);
-
-	
-	cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, Intent, 0);
-
- 	// Adjust output to Lab4 
-    hLab = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);
-
-	Profiles[0] = hProfile;
-	Profiles[1] = hLab;
-
-	xform = cmsCreateMultiprofileTransform(Profiles, 2,  InputFormat, TYPE_Lab_DBL, Intent, 0);
-	cmsCloseProfile(hLab);
-	
-	if (xform == NULL) {
-
-		cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, "Cannot create transform Profile -> Lab");
-		return 0;
-	}
-    
-    // Only 1, 3 and 4 channels are allowed
-
-    switch (nChannels) {
-
-    case 1: {            
-		    cmsToneCurve* Gray2Y = ExtractGray2Y(m ->ContextID, hProfile, Intent);
-            EmitCIEBasedA(m, Gray2Y, &BlackPointAdaptedToD50);            
-            cmsFreeToneCurve(Gray2Y);            
-            }
-            break;
-
-    case 3: 
-    case 4: {
-		    cmsUInt32Number OutFrm = TYPE_Lab_16;
-            cmsPipeline* DeviceLink;
-            _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;
-
-			DeviceLink = cmsPipelineDup(v ->Lut);
-			if (DeviceLink == NULL) return 0;
-
-			dwFlags |= cmsFLAGS_FORCE_CLUT;
-			_cmsOptimizePipeline(&DeviceLink, Intent, &InputFormat, &OutFrm, &dwFlags);
-            
-            rc = EmitCIEBasedDEF(m, DeviceLink, Intent, &BlackPointAdaptedToD50);
-            cmsPipelineFree(DeviceLink);            
-            }
-            break;
-
-    default:
-
-		cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, "Only 3, 4 channels supported for CSA. This profile has %d channels.", nChannels);
-        return 0;
-    }
-    
-
-    cmsDeleteTransform(xform);
-    
-    return 1;
-}
-
-static
-cmsFloat64Number* GetPtrToMatrix(const cmsStage* mpe)
-{
-    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
-
-    return Data -> Double;
-}
-
-
-// Does create CSA based on matrix-shaper. Allowed types are gray and RGB based
-
-static
-int WriteInputMatrixShaper(cmsIOHANDLER* m, cmsHPROFILE hProfile, cmsStage* Matrix, cmsStage* Shaper)
-{
-    cmsColorSpaceSignature ColorSpace;    
-    int rc;
-    cmsCIEXYZ BlackPointAdaptedToD50;
-
-    ColorSpace = cmsGetColorSpace(hProfile);
-    
-    cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);
-
-    if (ColorSpace == cmsSigGrayData) {
-            
-		    cmsToneCurve** ShaperCurve = _cmsStageGetPtrToCurveSet(Shaper);
-            rc = EmitCIEBasedA(m, ShaperCurve[0], &BlackPointAdaptedToD50);
-        
-    }
-    else
-        if (ColorSpace == cmsSigRgbData) {
-        			
-            cmsMAT3 Mat;
-            int i, j;
-
-            memmove(&Mat, GetPtrToMatrix(Matrix), sizeof(Mat));
-
-            for (i=0; i < 3; i++)
-                for (j=0; j < 3; j++)
-                    Mat.v[i].n[j] *= MAX_ENCODEABLE_XYZ;
-
-            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat, 
-			                        _cmsStageGetPtrToCurveSet(Shaper), 
-									&BlackPointAdaptedToD50);      
-        }
-        else  {
-
-			cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, "Profile is not suitable for CSA. Unsupported colorspace.");
-            return 0;
-        }
-    
-    return rc;
-}
-
-
-
-// Creates a PostScript color list from a named profile data. 
-// This is a HP extension, and it works in Lab instead of XYZ
-
-static
-int WriteNamedColorCSA(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, int Intent)
-{
-    cmsHTRANSFORM xform;
-    cmsHPROFILE   hLab;
-    int i, nColors;
-    char ColorName[32];
-    cmsNAMEDCOLORLIST* NamedColorList;
-
-	hLab  = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);
-    xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, hLab, TYPE_Lab_DBL, Intent, 0);
-    if (xform == NULL) return 0;
-
-	NamedColorList = cmsGetNamedColorList(xform);
-    if (NamedColorList == NULL) return 0;
-
-    _cmsIOPrintf(m, "<<\n");
-    _cmsIOPrintf(m, "(colorlistcomment) (%s)\n", "Named color CSA");
-    _cmsIOPrintf(m, "(Prefix) [ (Pantone ) (PANTONE ) ]\n");
-    _cmsIOPrintf(m, "(Suffix) [ ( CV) ( CVC) ( C) ]\n");
-
-    nColors   = cmsNamedColorCount(NamedColorList);
-
-
-    for (i=0; i < nColors; i++) {
-        
-        cmsUInt16Number In[1];
-        cmsCIELab Lab;
-
-        In[0] = (cmsUInt16Number) i;
-
-        if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))
-                continue;
-
-        cmsDoTransform(xform, In, &Lab, 1);     
-        _cmsIOPrintf(m, "  (%s) [ %.3f %.3f %.3f ]\n", ColorName, Lab.L, Lab.a, Lab.b);
-    }
-
-
-        
-    _cmsIOPrintf(m, ">>\n");
-
-    cmsDeleteTransform(xform);
-    cmsCloseProfile(hLab);
-    return 1;
-}
-
-
-// Does create a Color Space Array on XYZ colorspace for PostScript usage
-static
-cmsUInt32Number GenerateCSA(cmsContext ContextID, 
-						    cmsHPROFILE hProfile, 
-						    cmsUInt32Number Intent, 
-						    cmsUInt32Number dwFlags, 
-						    cmsIOHANDLER* mem)
-{	
-	cmsUInt32Number dwBytesUsed;
-	cmsPipeline* lut = NULL;
-	cmsStage* Matrix, *Shaper;
-
-
-	// Is a named color profile?
-	if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {
-
-		if (!WriteNamedColorCSA(mem, hProfile, Intent)) goto Error;
-	}
-	else {
-
-
-		// Any profile class are allowed (including devicelink), but
-		// output (PCS) colorspace must be XYZ or Lab
-		cmsColorSpaceSignature ColorSpace = cmsGetPCS(hProfile);
-
-		if (ColorSpace != cmsSigXYZData &&
-			ColorSpace != cmsSigLabData) {
-
-				cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Invalid output color space");
-				goto Error;
-		}
-
-
-		// Read the lut with all necessary conversion stages
-		lut = _cmsReadInputLUT(hProfile, Intent);
-		if (lut == NULL) goto Error;
-
-
-		// Tone curves + matrix can be implemented without any LUT
-		if (cmsPipelineCheckAndRetreiveStages(lut, 2, cmsSigCurveSetElemType, cmsSigMatrixElemType, &Shaper, &Matrix)) {
-
-			if (!WriteInputMatrixShaper(mem, hProfile, Matrix, Shaper)) goto Error;
-
-		}
-		else {
-		   // We need a LUT for the rest
-		   if (!WriteInputLUT(mem, hProfile, Intent, dwFlags)) goto Error;
-		}
-	}
-
-
-	// Done, keep memory usage
-	dwBytesUsed = mem ->UsedSpace;
-
-	// Get rid of LUT
-	if (lut != NULL) cmsPipelineFree(lut);
-
-	// Finally, return used byte count
-	return dwBytesUsed;
-
-Error:
-	if (lut != NULL) cmsPipelineFree(lut);
-	return 0;	
-}
-
-// ------------------------------------------------------ Color Rendering Dictionary (CRD)
-
-
-
-/*
-
-  Black point compensation plus chromatic adaptation:
-
-  Step 1 - Chromatic adaptation
-  =============================
-
-          WPout
-    X = ------- PQR
-          Wpin
-
-  Step 2 - Black point compensation
-  =================================
-
-          (WPout - BPout)*X - WPout*(BPin - BPout)
-    out = --------------------------------------- 
-                        WPout - BPin
-
-
-  Algorithm discussion
-  ====================
-      
-  TransformPQR(WPin, BPin, WPout, BPout, PQR)
-
-  Wpin,etc= { Xws Yws Zws Pws Qws Rws }
-
-
-  Algorithm             Stack 0...n
-  ===========================================================
-                        PQR BPout WPout BPin WPin
-  4 index 3 get         WPin PQR BPout WPout BPin WPin  
-  div                   (PQR/WPin) BPout WPout BPin WPin   
-  2 index 3 get         WPout (PQR/WPin) BPout WPout BPin WPin   
-  mult                  WPout*(PQR/WPin) BPout WPout BPin WPin   
-  
-  2 index 3 get         WPout WPout*(PQR/WPin) BPout WPout BPin WPin   
-  2 index 3 get         BPout WPout WPout*(PQR/WPin) BPout WPout BPin WPin     
-  sub                   (WPout-BPout) WPout*(PQR/WPin) BPout WPout BPin WPin    
-  mult                  (WPout-BPout)* WPout*(PQR/WPin) BPout WPout BPin WPin   
-          
-  2 index 3 get         WPout (BPout-WPout)* WPout*(PQR/WPin) BPout WPout BPin WPin     
-  4 index 3 get         BPin WPout (BPout-WPout)* WPout*(PQR/WPin) BPout WPout BPin WPin     
-  3 index 3 get         BPout BPin WPout (BPout-WPout)* WPout*(PQR/WPin) BPout WPout BPin WPin
-  
-  sub                   (BPin-BPout) WPout (BPout-WPout)* WPout*(PQR/WPin) BPout WPout BPin WPin     
-  mult                  (BPin-BPout)*WPout (BPout-WPout)* WPout*(PQR/WPin) BPout WPout BPin WPin     
-  sub                   (BPout-WPout)* WPout*(PQR/WPin)-(BPin-BPout)*WPout BPout WPout BPin WPin     
-
-  3 index 3 get         BPin (BPout-WPout)* WPout*(PQR/WPin)-(BPin-BPout)*WPout BPout WPout BPin WPin     
-  3 index 3 get         WPout BPin (BPout-WPout)* WPout*(PQR/WPin)-(BPin-BPout)*WPout BPout WPout BPin WPin     
-  exch
-  sub                   (WPout-BPin) (BPout-WPout)* WPout*(PQR/WPin)-(BPin-BPout)*WPout BPout WPout BPin WPin       
-  div                
-  
-  exch pop 
-  exch pop
-  exch pop
-  exch pop
-
-*/
-
-
-static
-void EmitPQRStage(cmsIOHANDLER* m, cmsHPROFILE hProfile, int DoBPC, int lIsAbsolute)
-{
-
-   
-        if (lIsAbsolute) {
-
-            // For absolute colorimetric intent, encode back to relative 
-			// and generate a relative Pipeline
-
-			// Relative encoding is obtained across XYZpcs*(D50/WhitePoint)
-
-			cmsCIEXYZ White;
-
-			_cmsReadMediaWhitePoint(&White, hProfile);
-
-			_cmsIOPrintf(m,"/MatrixPQR [1 0 0 0 1 0 0 0 1 ]\n");
-            _cmsIOPrintf(m,"/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\n");
-
-            _cmsIOPrintf(m, "%% Absolute colorimetric -- encode to relative to maximize LUT usage\n"
-                      "/TransformPQR [\n"
-                      "{0.9642 mul %g div exch pop exch pop exch pop exch pop} bind\n"
-                      "{1.0000 mul %g div exch pop exch pop exch pop exch pop} bind\n"
-                      "{0.8249 mul %g div exch pop exch pop exch pop exch pop} bind\n]\n", 
-					  White.X, White.Y, White.Z);
-            return;
-        }
-
-
-        _cmsIOPrintf(m,"%% Bradford Cone Space\n"
-                 "/MatrixPQR [0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296 ] \n");
-
-        _cmsIOPrintf(m, "/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\n");
-
-
-        // No BPC
-
-        if (!DoBPC) {
-
-            _cmsIOPrintf(m, "%% VonKries-like transform in Bradford Cone Space\n"
-                      "/TransformPQR [\n"
-                      "{exch pop exch 3 get mul exch pop exch 3 get div} bind\n"
-                      "{exch pop exch 4 get mul exch pop exch 4 get div} bind\n"
-                      "{exch pop exch 5 get mul exch pop exch 5 get div} bind\n]\n"); 
-        } else {
-
-            // BPC
-
-            _cmsIOPrintf(m, "%% VonKries-like transform in Bradford Cone Space plus BPC\n"
-                      "/TransformPQR [\n");
-                  
-            _cmsIOPrintf(m, "{4 index 3 get div 2 index 3 get mul "
-                    "2 index 3 get 2 index 3 get sub mul "                          
-                    "2 index 3 get 4 index 3 get 3 index 3 get sub mul sub "
-                    "3 index 3 get 3 index 3 get exch sub div "
-                    "exch pop exch pop exch pop exch pop } bind\n");
-
-            _cmsIOPrintf(m, "{4 index 4 get div 2 index 4 get mul "
-                    "2 index 4 get 2 index 4 get sub mul "
-                    "2 index 4 get 4 index 4 get 3 index 4 get sub mul sub "
-                    "3 index 4 get 3 index 4 get exch sub div "
-                    "exch pop exch pop exch pop exch pop } bind\n");
-
-            _cmsIOPrintf(m, "{4 index 5 get div 2 index 5 get mul "
-                    "2 index 5 get 2 index 5 get sub mul "
-                    "2 index 5 get 4 index 5 get 3 index 5 get sub mul sub "
-                    "3 index 5 get 3 index 5 get exch sub div "
-                    "exch pop exch pop exch pop exch pop } bind\n]\n");
-
-        }
-          
-        
-}
-
-
-static
-void EmitXYZ2Lab(cmsIOHANDLER* m)
-{
-    _cmsIOPrintf(m, "/RangeLMN [ -0.635 2.0 0 2 -0.635 2.0 ]\n"); 
-    _cmsIOPrintf(m, "/EncodeLMN [\n");
-    _cmsIOPrintf(m, "{ 0.964200  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\n");
-    _cmsIOPrintf(m, "{ 1.000000  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\n");
-    _cmsIOPrintf(m, "{ 0.824900  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\n");
-    _cmsIOPrintf(m, "]\n");
-    _cmsIOPrintf(m, "/MatrixABC [ 0 1 0 1 -1 1 0 0 -1 ]\n");
-    _cmsIOPrintf(m, "/EncodeABC [\n");
-    
-        
-    _cmsIOPrintf(m, "{ 116 mul  16 sub 100 div  } bind\n");
-    _cmsIOPrintf(m, "{ 500 mul 128 add 256 div  } bind\n");
-    _cmsIOPrintf(m, "{ 200 mul 128 add 256 div  } bind\n");
-    
-    
-    _cmsIOPrintf(m, "]\n");
-    
-
-}
-
-// Due to impedance mismatch between XYZ and almost all RGB and CMYK spaces
-// I choose to dump LUTS in Lab instead of XYZ. There is still a lot of wasted
-// space on 3D CLUT, but since space seems not to be a problem here, 33 points
-// would give a reasonable accurancy. Note also that CRD tables must operate in 
-// 8 bits.
-
-static
-int WriteOutputLUT(cmsIOHANDLER* m, cmsHPROFILE hProfile, int Intent, cmsUInt32Number dwFlags)
-{
-    cmsHPROFILE hLab;
-    cmsHTRANSFORM xform;
-    int i, nChannels;
-    cmsUInt32Number OutputFormat;
-    _cmsTRANSFORM* v;
-    cmsPipeline* DeviceLink;
-    cmsHPROFILE Profiles[3];
-    cmsCIEXYZ BlackPointAdaptedToD50;
-    cmsBool lDoBPC = (dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION);
-    cmsBool lFixWhite = !(dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP);
-	cmsUInt32Number InFrm = TYPE_Lab_16;
-	int RelativeEncodingIntent;
-	cmsColorSpaceSignature ColorSpace;
-    
-    
-	hLab = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);
-	if (hLab == NULL) return 0;
-
-    OutputFormat = cmsFormatterForColorspaceOfProfile(hProfile, 2, FALSE);
-	nChannels    = T_CHANNELS(OutputFormat);
-
-	ColorSpace = cmsGetColorSpace(hProfile);
-
-	// For absolute colorimetric, the LUT is encoded as relative in order to preserve precision.
-
-    RelativeEncodingIntent = Intent;
-	if (RelativeEncodingIntent == INTENT_ABSOLUTE_COLORIMETRIC)
-		RelativeEncodingIntent = INTENT_RELATIVE_COLORIMETRIC;
-
-
-	// Use V4 Lab always
-	Profiles[0] = hLab;
-	Profiles[1] = hProfile;
-
-	xform = cmsCreateMultiprofileTransformTHR(m ->ContextID, 
-		                                      Profiles, 2, TYPE_Lab_DBL, 
-		                                      OutputFormat, RelativeEncodingIntent, 0);
-	cmsCloseProfile(hLab);
-
-    if (xform == NULL) {
-                        
-		cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, "Cannot create transform Lab -> Profile in CRD creation");
-        return 0;
-    }
-
-    // Get a copy of the internal devicelink
-    v = (_cmsTRANSFORM*) xform;
-    DeviceLink = cmsPipelineDup(v ->Lut);
-	if (DeviceLink == NULL) return 0;
-   
-  
-	// We need a CLUT
-	dwFlags |= cmsFLAGS_FORCE_CLUT;
-	_cmsOptimizePipeline(&DeviceLink, RelativeEncodingIntent, &InFrm, &OutputFormat, &dwFlags);
-  
-    _cmsIOPrintf(m, "<<\n");
-    _cmsIOPrintf(m, "/ColorRenderingType 1\n");
-
-
-    cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, Intent, 0);
-
-    // Emit headers, etc.
-    EmitWhiteBlackD50(m, &BlackPointAdaptedToD50);
-    EmitPQRStage(m, hProfile, lDoBPC, Intent == INTENT_ABSOLUTE_COLORIMETRIC);
-    EmitXYZ2Lab(m);
-        
-   
-    // FIXUP: map Lab (100, 0, 0) to perfect white, because the particular encoding for Lab 
-    // does map a=b=0 not falling into any specific node. Since range a,b goes -128..127, 
-    // zero is slightly moved towards right, so assure next node (in L=100 slice) is mapped to
-    // zero. This would sacrifice a bit of highlights, but failure to do so would cause
-    // scum dot. Ouch.
-    
-    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)
-            lFixWhite = FALSE;
-
-    _cmsIOPrintf(m, "/RenderTable ");
-    
-	
-    WriteCLUT(m, cmsPipelineGetPtrToFirstStage(DeviceLink), "<", ">\n", "", "", lFixWhite, ColorSpace);
-    
-    _cmsIOPrintf(m, " %d {} bind ", nChannels);
-
-    for (i=1; i < nChannels; i++)
-            _cmsIOPrintf(m, "dup ");
-
-    _cmsIOPrintf(m, "]\n");
-
-        
-    EmitIntent(m, Intent);
-
-    _cmsIOPrintf(m, ">>\n");
-
-    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
-
-        _cmsIOPrintf(m, "/Current exch /ColorRendering defineresource pop\n");
-    }
-
-    cmsPipelineFree(DeviceLink);
-    cmsDeleteTransform(xform);
- 
-    return 1;   
-}
-
-
-// Builds a ASCII string containing colorant list in 0..1.0 range
-static
-void BuildColorantList(char *Colorant, int nColorant, cmsUInt16Number Out[])
-{
-    char Buff[32];
-    int j;
-
-    Colorant[0] = 0;
-    if (nColorant > cmsMAXCHANNELS)
-        nColorant = cmsMAXCHANNELS;
-
-    for (j=0; j < nColorant; j++) {
-
-                sprintf(Buff, "%.3f", Out[j] / 65535.0);
-                strcat(Colorant, Buff);
-                if (j < nColorant -1) 
-                        strcat(Colorant, " ");
-
-        }       
-}
-
-
-// Creates a PostScript color list from a named profile data. 
-// This is a HP extension.
-
-static
-int WriteNamedColorCRD(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, int Intent, cmsUInt32Number dwFlags)
-{
-    cmsHTRANSFORM xform;    
-    int i, nColors, nColorant;
-    cmsUInt32Number OutputFormat;
-    char ColorName[32];
-    char Colorant[128];
-	cmsNAMEDCOLORLIST* NamedColorList;
-
-	
-    OutputFormat = cmsFormatterForColorspaceOfProfile(hNamedColor, 2, FALSE);
-	nColorant    = T_CHANNELS(OutputFormat);
-
-	
-    xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, NULL, OutputFormat, Intent, dwFlags);
-    if (xform == NULL) return 0;
-
-
-	NamedColorList = cmsGetNamedColorList(xform);
-	if (NamedColorList == NULL) return 0;
-
-    _cmsIOPrintf(m, "<<\n");
-    _cmsIOPrintf(m, "(colorlistcomment) (%s) \n", "Named profile");
-    _cmsIOPrintf(m, "(Prefix) [ (Pantone ) (PANTONE ) ]\n");
-    _cmsIOPrintf(m, "(Suffix) [ ( CV) ( CVC) ( C) ]\n");
-
-    nColors   = cmsNamedColorCount(NamedColorList);
-    
-    for (i=0; i < nColors; i++) {
-        
-        cmsUInt16Number In[1];
-        cmsUInt16Number Out[cmsMAXCHANNELS];
-
-        In[0] = (cmsUInt16Number) i;
-
-        if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))
-                continue;
-
-        cmsDoTransform(xform, In, Out, 1);      
-        BuildColorantList(Colorant, nColorant, Out);
-        _cmsIOPrintf(m, "  (%s) [ %s ]\n", ColorName, Colorant);
-    }
-
-    _cmsIOPrintf(m, "   >>");
-
-    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
-
-    _cmsIOPrintf(m, " /Current exch /HPSpotTable defineresource pop\n");
-    }
-
-    cmsDeleteTransform(xform);  
-    return 1;
-}
-
-
-
-// This one does create a Color Rendering Dictionary. 
-// CRD are always LUT-Based, no matter if profile is
-// implemented as matrix-shaper.
-
-static
-cmsUInt32Number  GenerateCRD(cmsContext ContextID,
-							 cmsHPROFILE hProfile, 
-							 cmsUInt32Number Intent, cmsUInt32Number dwFlags,
-							 cmsIOHANDLER* mem)
-{    
-	cmsUInt32Number dwBytesUsed;
-
-	if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
-
-		EmitHeader(mem, "Color Rendering Dictionary (CRD)", hProfile);
-	}
-
-
-	// Is a named color profile?
-	if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {
-
-		if (!WriteNamedColorCRD(mem, hProfile, Intent, dwFlags)) {
-			return 0;
-		}
-	}
-	else {
-
-		// CRD are always implemented as LUT 
-
-		if (!WriteOutputLUT(mem, hProfile, Intent, dwFlags)) {
-			return 0;
-		}
-	}
-
-	if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {
-
-		_cmsIOPrintf(mem, "%%%%EndResource\n");
-		_cmsIOPrintf(mem, "\n%% CRD End\n");
-	}
-
-	// Done, keep memory usage
-	dwBytesUsed = mem ->UsedSpace;
-
-	// Finally, return used byte count
-	return dwBytesUsed;
-
-	cmsUNUSED_PARAMETER(ContextID);
-}
-
-
-
-
-cmsUInt32Number CMSEXPORT cmsGetPostScriptColorResource(cmsContext ContextID, 															   
-															   cmsPSResourceType Type,
-															   cmsHPROFILE hProfile, 
-															   cmsUInt32Number Intent, 
-															   cmsUInt32Number dwFlags, 
-															   cmsIOHANDLER* io)
-{
-	cmsUInt32Number  rc; 
-
-
-	switch (Type) {
-
-		case cmsPS_RESOURCE_CSA:
-			rc = GenerateCSA(ContextID, hProfile, Intent, dwFlags, io);
-			break;
-			
-		default:
-		case cmsPS_RESOURCE_CRD:
-			rc = GenerateCRD(ContextID, hProfile, Intent, dwFlags, io);
-			break;
-	}
-
-	return rc;
-}
-
-
-
-cmsUInt32Number CMSEXPORT cmsGetPostScriptCRD(cmsContext ContextID,
-	                          cmsHPROFILE hProfile, 
-                              cmsUInt32Number Intent, cmsUInt32Number dwFlags,
-                              void* Buffer, cmsUInt32Number dwBufferLen)
-{
-	cmsIOHANDLER* mem;
-    cmsUInt32Number dwBytesUsed;
-
-    // Set up the serialization engine
-	if (Buffer == NULL)
-		mem = cmsOpenIOhandlerFromNULL(ContextID);
-	else
-        mem = cmsOpenIOhandlerFromMem(ContextID, Buffer, dwBufferLen, "w");
-
-    if (!mem) return 0;
-
-	dwBytesUsed =  cmsGetPostScriptColorResource(ContextID, cmsPS_RESOURCE_CRD, hProfile, Intent, dwFlags, mem);
-															   
-    // Get rid of memory stream
-	cmsCloseIOhandler(mem);
-
-	return dwBytesUsed;
-}
-
-
-
-// Does create a Color Space Array on XYZ colorspace for PostScript usage
-cmsUInt32Number CMSEXPORT cmsGetPostScriptCSA(cmsContext ContextID, 
-											  cmsHPROFILE hProfile, 
-											  cmsUInt32Number Intent, 
-											  cmsUInt32Number dwFlags, 
-											  void* Buffer, 
-											  cmsUInt32Number dwBufferLen)  
-{
-	cmsIOHANDLER* mem;
-    cmsUInt32Number dwBytesUsed;
-    
-	if (Buffer == NULL)
-		mem = cmsOpenIOhandlerFromNULL(ContextID);
-	else
-        mem = cmsOpenIOhandlerFromMem(ContextID, Buffer, dwBufferLen, "w");
-
-    if (!mem) return 0;
-
-	dwBytesUsed =  cmsGetPostScriptColorResource(ContextID, cmsPS_RESOURCE_CSA, hProfile, Intent, dwFlags, mem);
-															   
-    // Get rid of memory stream
-	cmsCloseIOhandler(mem);
-
-	return dwBytesUsed;
-
-}
diff --git a/thirdparty/liblcms2/src/cmssamp.c b/thirdparty/liblcms2/src/cmssamp.c
deleted file mode 100644
index 090d96d..0000000
--- a/thirdparty/liblcms2/src/cmssamp.c
+++ /dev/null
@@ -1,266 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-
-// This file contains routines for resampling and LUT optimization, black point detection
-// and black preservation. 
-
-// Black point detection -------------------------------------------------------------------------
-
-
-// PCS -> PCS round trip transform, always uses relative intent on the device -> pcs 
-static
-cmsHTRANSFORM CreateRoundtripXForm(cmsHPROFILE hProfile, cmsUInt32Number nIntent)
-{
-    cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);
-    cmsHTRANSFORM xform;
-    cmsBool BPC[4] = { FALSE, FALSE, FALSE, FALSE };
-    cmsFloat64Number States[4] = { 1.0, 1.0, 1.0, 1.0 };
-    cmsHPROFILE hProfiles[4];
-    cmsUInt32Number Intents[4];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-
-    hProfiles[0] = hLab; hProfiles[1] = hProfile; hProfiles[2] = hProfile; hProfiles[3] = hLab;
-    Intents[0]   = INTENT_RELATIVE_COLORIMETRIC; Intents[1] = nIntent; Intents[2] = INTENT_RELATIVE_COLORIMETRIC; Intents[3] = INTENT_RELATIVE_COLORIMETRIC;
-
-    xform =  cmsCreateExtendedTransform(ContextID, 4, hProfiles, BPC, Intents, 
-        States, NULL, 0, TYPE_Lab_DBL, TYPE_Lab_DBL, cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);
-
-    cmsCloseProfile(hLab);
-    return xform;
-}
-
-// Use darker colorants to obtain black point. This works in the relative colorimetric intent and
-// assumes more ink results in darker colors. No ink limit is assumed.
-static
-cmsBool  BlackPointAsDarkerColorant(cmsHPROFILE    hInput,                               
-                                    cmsUInt32Number Intent,
-                                    cmsCIEXYZ* BlackPoint,
-                                    cmsUInt32Number dwFlags)
-{
-    cmsUInt16Number *Black;
-    cmsHTRANSFORM xform;
-    cmsColorSpaceSignature Space;
-    cmsUInt32Number nChannels;
-    cmsUInt32Number dwFormat; 
-    cmsHPROFILE hLab;
-    cmsCIELab  Lab;
-    cmsCIEXYZ  BlackXYZ;        
-    cmsContext ContextID = cmsGetProfileContextID(hInput);
-    
-    // If the profile does not support input direction, assume Black point 0    
-    if (!cmsIsIntentSupported(hInput, Intent, LCMS_USED_AS_INPUT)) {
-
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
-    }
-    
-    // Create a formatter which has n channels and floating point
-    dwFormat = cmsFormatterForColorspaceOfProfile(hInput, 2, FALSE);
-
-   // Try to get black by using black colorant    
-    Space = cmsGetColorSpace(hInput);
-
-    // This function returns darker colorant in 16 bits for several spaces
-    if (!_cmsEndPointsBySpace(Space, NULL, &Black, &nChannels)) {
-        
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
-    }
-
-    if (nChannels != T_CHANNELS(dwFormat)) {
-       BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-       return FALSE;
-    }
-
-    // Lab will be used as the output space, but lab2 will avoid recursion
-    hLab = cmsCreateLab2ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) {
-       BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-       return FALSE;    
-    }
-
-    // Create the transform
-    xform = cmsCreateTransformTHR(ContextID, hInput, dwFormat,
-                                hLab, TYPE_Lab_DBL, Intent, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);
-    cmsCloseProfile(hLab);
-    
-    if (xform == NULL) {
-        // Something went wrong. Get rid of open resources and return zero as black
-        
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
-    }
-    
-    // Convert black to Lab
-    cmsDoTransform(xform, Black, &Lab, 1);
-
-    // Force it to be neutral, clip to max. L* of 50
-    Lab.a = Lab.b = 0;
-    if (Lab.L > 50) Lab.L = 50;
-
-    // Free the resources    
-    cmsDeleteTransform(xform);
-    
-    // Convert from Lab (which is now clipped) to XYZ.
-    cmsLab2XYZ(NULL, &BlackXYZ, &Lab);
-    
-    if (BlackPoint != NULL)
-        *BlackPoint = BlackXYZ;
-      
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(dwFlags);
-}
-
-// Get a black point of output CMYK profile, discounting any ink-limiting embedded 
-// in the profile. For doing that, we use perceptual intent in input direction:
-// Lab (0, 0, 0) -> [Perceptual] Profile -> CMYK -> [Rel. colorimetric] Profile -> Lab
-static
-cmsBool BlackPointUsingPerceptualBlack(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile)
-                                   
-{    
-    cmsHTRANSFORM hRoundTrip;    
-    cmsCIELab LabIn, LabOut;
-    cmsCIEXYZ  BlackXYZ;        
- 
-     // Is the intent supported by the profile?
-    if (!cmsIsIntentSupported(hProfile, INTENT_PERCEPTUAL, LCMS_USED_AS_INPUT)) {
-
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return TRUE;
-    }
-        
-    hRoundTrip = CreateRoundtripXForm(hProfile, INTENT_PERCEPTUAL);
-    if (hRoundTrip == NULL) {
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
-    }
-
-    LabIn.L = LabIn.a = LabIn.b = 0;
-    cmsDoTransform(hRoundTrip, &LabIn, &LabOut, 1);
-
-    // Clip Lab to reasonable limits
-    if (LabOut.L > 50) LabOut.L = 50;
-    LabOut.a = LabOut.b = 0;
-
-    cmsDeleteTransform(hRoundTrip);
-  
-    // Convert it to XYZ
-    cmsLab2XYZ(NULL, &BlackXYZ, &LabOut);   
-    
-    if (BlackPoint != NULL)
-        *BlackPoint = BlackXYZ;
-
-    return TRUE;
-}
-
-// This function shouldn't exist at all -- there is such quantity of broken
-// profiles on black point tag, that we must somehow fix chromaticity to 
-// avoid huge tint when doing Black point compensation. This function does
-// just that. There is a special flag for using black point tag, but turned 
-// off by default because it is bogus on most profiles. The detection algorithm 
-// involves to turn BP to neutral and to use only L component.  
-
-cmsBool CMSEXPORT cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)
-{    
-
-    // Zero for black point
-    if (cmsGetDeviceClass(hProfile) == cmsSigLinkClass) {
-
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;       
-    }
-
-    // v4 + perceptual & saturation intents does have its own black point, and it is 
-    // well specified enough to use it. Black point tag is deprecated in V4.
-
-    if ((cmsGetEncodedICCversion(hProfile) >= 0x4000000) &&     
-        (Intent == INTENT_PERCEPTUAL || Intent == INTENT_SATURATION)) {
-
-            // Matrix shaper share MRC & perceptual intents
-            if (cmsIsMatrixShaper(hProfile)) 
-                return BlackPointAsDarkerColorant(hProfile, INTENT_RELATIVE_COLORIMETRIC, BlackPoint, 0);
-
-            // Get Perceptual black out of v4 profiles. That is fixed for perceptual & saturation intents
-            BlackPoint -> X = cmsPERCEPTUAL_BLACK_X; 
-            BlackPoint -> Y = cmsPERCEPTUAL_BLACK_Y;
-            BlackPoint -> Z = cmsPERCEPTUAL_BLACK_Z;
-
-            return TRUE;
-    }
-
-
-#ifdef CMS_USE_PROFILE_BLACK_POINT_TAG
-
-    // v2, v4 rel/abs colorimetric
-    if (cmsIsTag(hProfile, cmsSigMediaBlackPointTag) && 
-        Intent == INTENT_RELATIVE_COLORIMETRIC) {
-
-            cmsCIEXYZ *BlackPtr, BlackXYZ, UntrustedBlackPoint, TrustedBlackPoint, MediaWhite;
-            cmsCIELab Lab;
-
-            // If black point is specified, then use it, 
-
-            BlackPtr = cmsReadTag(hProfile, cmsSigMediaBlackPointTag);
-            if (BlackPtr != NULL) {
-
-                BlackXYZ = *BlackPtr;
-                _cmsReadMediaWhitePoint(&MediaWhite, hProfile);
-
-                // Black point is absolute XYZ, so adapt to D50 to get PCS value
-                cmsAdaptToIlluminant(&UntrustedBlackPoint, &MediaWhite, cmsD50_XYZ(), &BlackXYZ);
-
-                // Force a=b=0 to get rid of any chroma
-                cmsXYZ2Lab(NULL, &Lab, &UntrustedBlackPoint);
-                Lab.a = Lab.b = 0;
-                if (Lab.L > 50) Lab.L = 50; // Clip to L* <= 50
-                cmsLab2XYZ(NULL, &TrustedBlackPoint, &Lab);
-
-                if (BlackPoint != NULL)
-                    *BlackPoint = TrustedBlackPoint;
-                
-                return TRUE;
-            }
-    }
-#endif
-
-    // That is about v2 profiles. 
-
-    // If output profile, discount ink-limiting and that's all
-    if (Intent == INTENT_RELATIVE_COLORIMETRIC && 
-        (cmsGetDeviceClass(hProfile) == cmsSigOutputClass) &&
-        (cmsGetColorSpace(hProfile)  == cmsSigCmykData))
-        return BlackPointUsingPerceptualBlack(BlackPoint, hProfile);
-
-    // Nope, compute BP using current intent.
-    return BlackPointAsDarkerColorant(hProfile, Intent, BlackPoint, dwFlags);
-}
-
-
diff --git a/thirdparty/liblcms2/src/cmssm.c b/thirdparty/liblcms2/src/cmssm.c
deleted file mode 100644
index e5a6b0d..0000000
--- a/thirdparty/liblcms2/src/cmssm.c
+++ /dev/null
@@ -1,734 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// ------------------------------------------------------------------------
-
-// Gamut boundary description by using Jan Morovic's Segment maxima method
-// Many thanks to Jan for allowing me to use his algorithm.
-
-// r = C*
-// alpha = Hab
-// theta = L*
-
-#define SECTORS 16      // number of divisions in alpha and theta 
-
-// Spherical coordinates
-typedef struct {
-
-    cmsFloat64Number r;
-    cmsFloat64Number alpha;
-    cmsFloat64Number theta;
-
-} cmsSpherical;
-
-typedef  enum {          
-        GP_EMPTY,
-        GP_SPECIFIED,
-        GP_MODELED
-
-    } GDBPointType;
-
-
-typedef struct {
-
-    GDBPointType Type;
-    cmsSpherical p;         // Keep also alpha & theta of maximum
-
-} cmsGDBPoint;
-
-
-typedef struct {
-
-    cmsContext ContextID;
-    cmsGDBPoint Gamut[SECTORS][SECTORS];
-
-} cmsGDB;
-
-
-// A line using the parametric form
-// P = a + t*u
-typedef struct {
-
-    cmsVEC3 a;
-    cmsVEC3 u;
-
-} cmsLine;
-
-
-// A plane using the parametric form
-// Q = b + r*v + s*w
-typedef struct {
-
-    cmsVEC3 b;
-    cmsVEC3 v;
-    cmsVEC3 w;
-
-} cmsPlane;
-
-
-
-// --------------------------------------------------------------------------------------------
-
-// ATAN2() which always returns degree positive numbers
-
-static
-cmsFloat64Number _cmsAtan2(cmsFloat64Number y, cmsFloat64Number x)
-{
-    cmsFloat64Number a;
-    
-    // Deal with undefined case
-    if (x == 0.0 && y == 0.0) return 0;
-
-    a = (atan2(y, x) * 180.0) / M_PI;
-
-    while (a < 0) {
-        a += 360;
-    }
-
-    return a;
-}
-
-// Convert to spherical coordinates
-static
-void ToSpherical(cmsSpherical* sp, const cmsVEC3* v)
-{
-
-    cmsFloat64Number L, a, b;
-    
-    L = v ->n[VX];
-    a = v ->n[VY];
-    b = v ->n[VZ];
-    
-    sp ->r = sqrt( L*L + a*a + b*b );
-
-   if (sp ->r == 0) {
-        sp ->alpha = sp ->theta = 0;
-        return;
-    }
-	    
-    sp ->alpha = _cmsAtan2(a, b);   
-    sp ->theta = _cmsAtan2(sqrt(a*a + b*b), L);  
-}
-
-
-// Convert to cartesian from spherical
-static
-void ToCartesian(cmsVEC3* v, const cmsSpherical* sp)
-{
-    cmsFloat64Number sin_alpha;
-    cmsFloat64Number cos_alpha;
-    cmsFloat64Number sin_theta;
-    cmsFloat64Number cos_theta;
-    cmsFloat64Number L, a, b;
-
-    sin_alpha = sin((M_PI * sp ->alpha) / 180.0);
-    cos_alpha = cos((M_PI * sp ->alpha) / 180.0);
-    sin_theta = sin((M_PI * sp ->theta) / 180.0);
-    cos_theta = cos((M_PI * sp ->theta) / 180.0);
-
-    a = sp ->r * sin_theta * sin_alpha;
-    b = sp ->r * sin_theta * cos_alpha; 
-    L = sp ->r * cos_theta;
-
-    v ->n[VX] = L;
-    v ->n[VY] = a;
-    v ->n[VZ] = b;
-}
-
-
-// Quantize sector of a spherical coordinate. Saturate 360, 180 to last sector
-// The limits are the centers of each sector, so
-static
-void QuantizeToSector(const cmsSpherical* sp, int* alpha, int* theta)
-{   
-    *alpha = (int) floor(((sp->alpha * (SECTORS)) / 360.0) );            
-    *theta = (int) floor(((sp->theta * (SECTORS)) / 180.0) );    
-
-	if (*alpha >= SECTORS)
-		*alpha = SECTORS-1;
-	if (*theta >= SECTORS)
-		*theta = SECTORS-1;
-}
-
-
-// Line determined by 2 points
-static
-void LineOf2Points(cmsLine* line, cmsVEC3* a, cmsVEC3* b)
-{
-
-    _cmsVEC3init(&line ->a, a ->n[VX], a ->n[VY], a ->n[VZ]);
-    _cmsVEC3init(&line ->u, b ->n[VX] - a ->n[VX], 
-                            b ->n[VY] - a ->n[VY], 
-                            b ->n[VZ] - a ->n[VZ]);     
-}
-
-
-// Evaluate parametric line 
-static
-void GetPointOfLine(cmsVEC3* p, const cmsLine* line, cmsFloat64Number t)
-{
-    p ->n[VX] = line ->a.n[VX] + t * line->u.n[VX];
-    p ->n[VY] = line ->a.n[VY] + t * line->u.n[VY];
-    p ->n[VZ] = line ->a.n[VZ] + t * line->u.n[VZ];     
-}
-
-
-
-/*
-    Closest point in sector line1 to sector line2 (both are defined as 0 <=t <= 1)
-    http://softsurfer.com/Archive/algorithm_0106/algorithm_0106.htm
-
-    Copyright 2001, softSurfer (www.softsurfer.com)
-    This code may be freely used and modified for any purpose
-    providing that this copyright notice is included with it.
-    SoftSurfer makes no warranty for this code, and cannot be held
-    liable for any real or imagined damage resulting from its use.
-    Users of this code must verify correctness for their application.
-
-*/
-
-static
-cmsBool ClosestLineToLine(cmsVEC3* r, const cmsLine* line1, const cmsLine* line2)
-{
-    cmsFloat64Number a, b, c, d, e, D;
-    cmsFloat64Number sc, sN, sD; 
-    cmsFloat64Number tc, tN, tD;
-    cmsVEC3 w0;
-
-    _cmsVEC3minus(&w0, &line1 ->a, &line2 ->a);
-
-    a  = _cmsVEC3dot(&line1 ->u, &line1 ->u);
-    b  = _cmsVEC3dot(&line1 ->u, &line2 ->u);
-    c  = _cmsVEC3dot(&line2 ->u, &line2 ->u);
-    d  = _cmsVEC3dot(&line1 ->u, &w0);
-    e  = _cmsVEC3dot(&line2 ->u, &w0);
-
-    D  = a*c - b * b;      // Denominator
-    sD = tD = D;           // default sD = D >= 0
-
-    if (D <  MATRIX_DET_TOLERANCE) {   // the lines are almost parallel
-
-        sN = 0.0;        // force using point P0 on segment S1
-        sD = 1.0;        // to prevent possible division by 0.0 later
-        tN = e;
-        tD = c;
-    }
-    else {                // get the closest points on the infinite lines
-
-        sN = (b*e - c*d);
-        tN = (a*e - b*d);
-
-        if (sN < 0.0) {       // sc < 0 => the s=0 edge is visible
-
-            sN = 0.0;
-            tN = e;
-            tD = c;
-        }
-        else if (sN > sD) {   // sc > 1 => the s=1 edge is visible
-            sN = sD;
-            tN = e + b;
-            tD = c;
-        }
-    }
-
-    if (tN < 0.0) {           // tc < 0 => the t=0 edge is visible
-
-        tN = 0.0;
-        // recompute sc for this edge
-        if (-d < 0.0)
-            sN = 0.0;
-        else if (-d > a)
-            sN = sD;
-        else {
-            sN = -d;
-            sD = a;
-        }
-    }
-    else if (tN > tD) {      // tc > 1 => the t=1 edge is visible
-        
-        tN = tD;
-        
-        // recompute sc for this edge
-        if ((-d + b) < 0.0)
-            sN = 0;
-        else if ((-d + b) > a)
-            sN = sD;
-        else {
-            sN = (-d + b);
-            sD = a;
-        }
-    }
-    // finally do the division to get sc and tc
-    sc = (fabs(sN) < MATRIX_DET_TOLERANCE ? 0.0 : sN / sD);
-    tc = (fabs(tN) < MATRIX_DET_TOLERANCE ? 0.0 : tN / tD);
-
-    GetPointOfLine(r, line1, sc);
-    return TRUE;
-}
-
-
-
-// ------------------------------------------------------------------ Wrapper
-
-
-// Allocate & free structure
-cmsHANDLE  CMSEXPORT cmsGBDAlloc(cmsContext ContextID)
-{
-    cmsGDB* gbd = (cmsGDB*) _cmsMallocZero(ContextID, sizeof(cmsGDB));
-    if (gbd == NULL) return NULL;
-    
-    gbd -> ContextID = ContextID;
-
-    return (cmsHANDLE) gbd;
-}
-
-
-void CMSEXPORT cmsGBDFree(cmsHANDLE hGBD)
-{   
-    cmsGDB* gbd = (cmsGDB*) hGBD;
-    if (hGBD != NULL) 
-        _cmsFree(gbd->ContextID, (void*) gbd);
-}
-
-
-// Auxiliar to retrieve a pointer to the segmentr containing the Lab value
-static
-cmsGDBPoint* GetPoint(cmsGDB* gbd, const cmsCIELab* Lab, cmsSpherical* sp)
-{
-    cmsVEC3 v;  
-    int alpha, theta;
-
-    // Housekeeping
-    _cmsAssert(gbd != NULL);
-	_cmsAssert(Lab != NULL);
-	_cmsAssert(sp != NULL);
-
-    // Center L* by substracting half of its domain, that's 50 
-    _cmsVEC3init(&v, Lab ->L - 50.0, Lab ->a, Lab ->b);
-	
-    // Convert to spherical coordinates
-    ToSpherical(sp, &v);
-    
-    if (sp ->r < 0 || sp ->alpha < 0 || sp->theta < 0) {
-         cmsSignalError(gbd ->ContextID, cmsERROR_RANGE, "spherical value out of range");
-         return NULL;
-    }
-
-    // On which sector it falls?
-    QuantizeToSector(sp, &alpha, &theta);
-  	
-    if (alpha < 0 || theta < 0 || alpha >= SECTORS || theta >= SECTORS) {
-         cmsSignalError(gbd ->ContextID, cmsERROR_RANGE, " quadrant out of range");
-         return NULL;
-    }
-
-    // Get pointer to the sector
-    return &gbd ->Gamut[theta][alpha];
-}
-
-// Add a point to gamut descriptor. Point to add is in Lab color space. 
-// GBD is centered on a=b=0 and L*=50
-cmsBool CMSEXPORT cmsGDBAddPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)
-{
-    cmsGDB* gbd = (cmsGDB*) hGBD;
-    cmsGDBPoint* ptr;
-    cmsSpherical sp;
-
-
-    // Get pointer to the sector
-    ptr = GetPoint(gbd, Lab, &sp);
-    if (ptr == NULL) return FALSE;
-
-    // If no samples at this sector, add it
-    if (ptr ->Type == GP_EMPTY) {
-
-        ptr -> Type = GP_SPECIFIED;
-        ptr -> p    = sp;
-    }
-    else {
-
-
-        // Substitute only if radius is greater
-        if (sp.r > ptr -> p.r) {
-
-                ptr -> Type = GP_SPECIFIED;
-                ptr -> p    = sp;
-        }
-    }
-
-    return TRUE;
-}
-
-// Check if a given point falls inside gamut
-cmsBool CMSEXPORT cmsGDBCheckPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)
-{
-    cmsGDB* gbd = (cmsGDB*) hGBD;   
-    cmsGDBPoint* ptr;
-    cmsSpherical sp;
-
-    // Get pointer to the sector
-    ptr = GetPoint(gbd, Lab, &sp);
-    if (ptr == NULL) return FALSE;
-
-    // If no samples at this sector, return no data
-    if (ptr ->Type == GP_EMPTY) return FALSE;
-
-    // In gamut only if radius is greater
-
-    return (sp.r <= ptr -> p.r);
-}
-
-// -----------------------------------------------------------------------------------------------------------------------
-
-// Find near sectors. The list of sectors found is returned on Close[]. 
-// The function returns the number of sectors as well.
-
-// 24   9  10  11  12
-// 23   8   1   2  13
-// 22   7   *   3  14
-// 21   6   5   4  15
-// 20  19  18  17  16
-//
-// Those are the relative movements
-// {-2,-2}, {-1, -2}, {0, -2}, {+1, -2}, {+2,  -2}, 
-// {-2,-1}, {-1, -1}, {0, -1}, {+1, -1}, {+2,  -1},
-// {-2, 0}, {-1,  0}, {0,  0}, {+1,  0}, {+2,   0},
-// {-2,+1}, {-1, +1}, {0, +1}, {+1,  +1}, {+2,  +1},
-// {-2,+2}, {-1, +2}, {0, +2}, {+1,  +2}, {+2,  +2}};
-
-
-static 
-const struct _spiral { 
-    
-    int AdvX, AdvY;
-    
-    } Spiral[] = { {0,  -1}, {+1, -1}, {+1,  0}, {+1, +1}, {0,  +1}, {-1, +1}, 
-                   {-1,  0}, {-1, -1}, {-1, -2}, {0,  -2}, {+1, -2}, {+2, -2}, 
-                   {+2, -1}, {+2,  0}, {+2, +1}, {+2, +2}, {+1, +2}, {0,  +2}, 
-                   {-1, +2}, {-2, +2}, {-2, +1}, {-2, 0},  {-2, -1}, {-2, -2} };
-
-#define NSTEPS (sizeof(Spiral) / sizeof(struct _spiral))
-
-static
-int FindNearSectors(cmsGDB* gbd, int alpha, int theta, cmsGDBPoint* Close[])
-{
-    int nSectors = 0;
-    int i, a, t;
-    cmsGDBPoint* pt;
-
-    for (i=0; i < NSTEPS; i++) {
-
-        a = alpha + Spiral[i].AdvX;
-        t = theta + Spiral[i].AdvY;
-
-        // Cycle at the end
-        a %= SECTORS;
-        t %= SECTORS;
-
-        // Cycle at the begin
-        if (a < 0) a = SECTORS + a;
-        if (t < 0) t = SECTORS + t;   
-
-        pt = &gbd ->Gamut[t][a];
-        
-        if (pt -> Type != GP_EMPTY) {
-
-            Close[nSectors++] = pt;
-        }                           
-    }
-
-    return nSectors;
-}
-
-
-// Interpolate a missing sector. Method identifies whatever this is top, bottom or mid
-static
-cmsBool InterpolateMissingSector(cmsGDB* gbd, int alpha, int theta)
-{   
-    cmsSpherical sp;
-    cmsVEC3 Lab;
-    cmsVEC3 Centre;
-    cmsLine ray;
-    int nCloseSectors;
-    cmsGDBPoint* Close[NSTEPS]; 
-    cmsSpherical closel, templ;
-    cmsLine edge;
-    int k, m;
-    
-    // Is that point already specified?
-    if (gbd ->Gamut[theta][alpha].Type != GP_EMPTY) return TRUE;
-
-    // Fill close points
-    nCloseSectors = FindNearSectors(gbd, alpha, theta, Close);
-
-
-    // Find a central point on the sector 
-    sp.alpha = (cmsFloat64Number) ((alpha + 0.5) * 360.0) / (SECTORS);
-    sp.theta = (cmsFloat64Number) ((theta + 0.5) * 180.0) / (SECTORS);
-    sp.r     = 50.0; 
-
-    // Convert to Cartesian
-    ToCartesian(&Lab, &sp);
-
-    // Create a ray line from centre to this point
-    _cmsVEC3init(&Centre, 50.0, 0, 0);
-    LineOf2Points(&ray, &Lab, &Centre);
-
-    // For all close sectors
-    closel.r = 0.0;
-    closel.alpha = 0;
-    closel.theta = 0;
-
-    for (k=0; k < nCloseSectors; k++) {
-
-        for(m = k+1; m < nCloseSectors; m++) {
-
-            cmsVEC3 temp, a1, a2;
-        
-            // A line from sector to sector
-            ToCartesian(&a1, &Close[k]->p);
-            ToCartesian(&a2, &Close[m]->p);
-
-            LineOf2Points(&edge, &a1, &a2);
-
-            // Find a line  
-            ClosestLineToLine(&temp, &ray, &edge);
-
-            // Convert to spherical
-            ToSpherical(&templ, &temp);
-            
-
-            if ( templ.r > closel.r && 
-                 templ.theta >= (theta*180.0/SECTORS) && 
-                 templ.theta <= ((theta+1)*180.0/SECTORS) &&
-                 templ.alpha >= (alpha*360.0/SECTORS) &&
-                 templ.alpha <= ((alpha+1)*360.0/SECTORS)) {
-
-                closel = templ;         
-            }       
-        }
-    }
-
-    gbd ->Gamut[theta][alpha].p = closel;
-    gbd ->Gamut[theta][alpha].Type = GP_MODELED;
-
-    return TRUE;
-
-}
-
-
-// Interpolate missing parts. The algorithm fist computes slices at
-// theta=0 and theta=Max.
-cmsBool CMSEXPORT cmsGDBCompute(cmsHANDLE hGBD, cmsUInt32Number dwFlags)
-{
-    int alpha, theta;
-    cmsGDB* gbd = (cmsGDB*) hGBD;
-
-    _cmsAssert(hGBD != NULL);
-
-    // Interpolate black
-    for (alpha = 0; alpha <= SECTORS; alpha++) {
-
-        if (!InterpolateMissingSector(gbd, alpha, 0)) return FALSE;
-    }
-
-    // Interpolate white
-    for (alpha = 0; alpha <= SECTORS; alpha++) {
-
-        if (!InterpolateMissingSector(gbd, alpha, SECTORS-1)) return FALSE;
-    }
-
-
-    // Interpolate Mid
-    for (theta = 1; theta < SECTORS; theta++) {
-        for (alpha = 0; alpha <= SECTORS; alpha++) {
-
-            if (!InterpolateMissingSector(gbd, alpha, theta)) return FALSE;
-        }
-    }
-
-    // Done
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(dwFlags);
-}
-
-
-
-
-// --------------------------------------------------------------------------------------------------------
-
-// Great for debug, but not suitable for real use
-
-#if 0
-cmsBool cmsGBDdumpVRML(cmsHANDLE hGBD, const char* fname)
-{
-    FILE* fp;
-    int   i, j;
-    cmsGDB* gbd = (cmsGDB*) hGBD;
-    cmsGDBPoint* pt;
-
-    fp = fopen (fname, "wt");
-    if (fp == NULL)
-        return FALSE;
-
-    fprintf (fp, "#VRML V2.0 utf8\n");
-
-    // set the viewing orientation and distance 
-    fprintf (fp, "DEF CamTest Group {\n");
-    fprintf (fp, "\tchildren [\n"); 
-    fprintf (fp, "\t\tDEF Cameras Group {\n"); 
-    fprintf (fp, "\t\t\tchildren [\n"); 
-    fprintf (fp, "\t\t\t\tDEF DefaultView Viewpoint {\n"); 
-    fprintf (fp, "\t\t\t\t\tposition 0 0 340\n"); 
-    fprintf (fp, "\t\t\t\t\torientation 0 0 1 0\n"); 
-    fprintf (fp, "\t\t\t\t\tdescription \"default view\"\n"); 
-    fprintf (fp, "\t\t\t\t}\n"); 
-    fprintf (fp, "\t\t\t]\n"); 
-    fprintf (fp, "\t\t},\n"); 
-    fprintf (fp, "\t]\n"); 
-    fprintf (fp, "}\n"); 
-
-    // Output the background stuff 
-    fprintf (fp, "Background {\n");
-    fprintf (fp, "\tskyColor [\n");
-    fprintf (fp, "\t\t.5 .5 .5\n");
-    fprintf (fp, "\t]\n");
-    fprintf (fp, "}\n");
-
-    // Output the shape stuff 
-    fprintf (fp, "Transform {\n");
-    fprintf (fp, "\tscale .3 .3 .3\n");
-    fprintf (fp, "\tchildren [\n");
-
-    // Draw the axes as a shape: 
-    fprintf (fp, "\t\tShape {\n");
-    fprintf (fp, "\t\t\tappearance Appearance {\n");
-    fprintf (fp, "\t\t\t\tmaterial Material {\n");
-    fprintf (fp, "\t\t\t\t\tdiffuseColor 0 0.8 0\n");
-    fprintf (fp, "\t\t\t\t\temissiveColor 1.0 1.0 1.0\n");
-    fprintf (fp, "\t\t\t\t\tshininess 0.8\n");
-    fprintf (fp, "\t\t\t\t}\n");
-    fprintf (fp, "\t\t\t}\n");
-    fprintf (fp, "\t\t\tgeometry IndexedLineSet {\n");
-    fprintf (fp, "\t\t\t\tcoord Coordinate {\n");
-    fprintf (fp, "\t\t\t\t\tpoint [\n");
-    fprintf (fp, "\t\t\t\t\t0.0 0.0 0.0,\n");
-    fprintf (fp, "\t\t\t\t\t%f 0.0 0.0,\n",  255.0);
-    fprintf (fp, "\t\t\t\t\t0.0 %f 0.0,\n",  255.0);
-    fprintf (fp, "\t\t\t\t\t0.0 0.0 %f]\n",  255.0);
-    fprintf (fp, "\t\t\t\t}\n");
-    fprintf (fp, "\t\t\t\tcoordIndex [\n");
-    fprintf (fp, "\t\t\t\t\t0, 1, -1\n");
-    fprintf (fp, "\t\t\t\t\t0, 2, -1\n");
-    fprintf (fp, "\t\t\t\t\t0, 3, -1]\n");
-    fprintf (fp, "\t\t\t}\n");
-    fprintf (fp, "\t\t}\n");
-
-    
-    fprintf (fp, "\t\tShape {\n");
-    fprintf (fp, "\t\t\tappearance Appearance {\n");
-    fprintf (fp, "\t\t\t\tmaterial Material {\n");
-    fprintf (fp, "\t\t\t\t\tdiffuseColor 0 0.8 0\n");
-    fprintf (fp, "\t\t\t\t\temissiveColor 1 1 1\n");
-    fprintf (fp, "\t\t\t\t\tshininess 0.8\n");
-    fprintf (fp, "\t\t\t\t}\n");
-    fprintf (fp, "\t\t\t}\n");
-    fprintf (fp, "\t\t\tgeometry PointSet {\n");
-    
-    // fill in the points here 
-    fprintf (fp, "\t\t\t\tcoord Coordinate {\n");
-    fprintf (fp, "\t\t\t\t\tpoint [\n");
-
-    // We need to transverse all gamut hull.
-    for (i=0; i < SECTORS; i++)
-        for (j=0; j < SECTORS; j++) {
-
-            cmsVEC3 v;
-
-            pt = &gbd ->Gamut[i][j];
-            ToCartesian(&v, &pt ->p);
-
-            fprintf (fp, "\t\t\t\t\t%g %g %g", v.n[0]+50, v.n[1], v.n[2]);
-
-            if ((j == SECTORS - 1) && (i == SECTORS - 1)) 
-                fprintf (fp, "]\n");
-            else
-                fprintf (fp, ",\n");
-
-        }
-
-        fprintf (fp, "\t\t\t\t}\n");
-
-
-
-    // fill in the face colors 
-    fprintf (fp, "\t\t\t\tcolor Color {\n");
-    fprintf (fp, "\t\t\t\t\tcolor [\n");
-
-    for (i=0; i < SECTORS; i++)
-        for (j=0; j < SECTORS; j++) {
-
-           cmsVEC3 v;
-   
-            pt = &gbd ->Gamut[i][j];
-
-		        
-            ToCartesian(&v, &pt ->p);
-
-
-        if (pt ->Type == GP_EMPTY) 
-            fprintf (fp, "\t\t\t\t\t%g %g %g", 0.0, 0.0, 0.0);
-        else
-            if (pt ->Type == GP_MODELED)
-                fprintf (fp, "\t\t\t\t\t%g %g %g", 1.0, .5, .5);
-			else {
-                fprintf (fp, "\t\t\t\t\t%g %g %g", 1.0, 1.0, 1.0);
-
-			}
-
-        if ((j == SECTORS - 1) && (i == SECTORS - 1)) 
-                fprintf (fp, "]\n");
-            else
-                fprintf (fp, ",\n");
-    }
-    fprintf (fp, "\t\t\t}\n");
-    
-
-    fprintf (fp, "\t\t\t}\n");
-    fprintf (fp, "\t\t}\n");
-    fprintf (fp, "\t]\n");
-    fprintf (fp, "}\n");
-
-    fclose (fp);
-
-    return TRUE;
-}
-#endif
-
diff --git a/thirdparty/liblcms2/src/cmstypes.c b/thirdparty/liblcms2/src/cmstypes.c
deleted file mode 100644
index 28f06d5..0000000
--- a/thirdparty/liblcms2/src/cmstypes.c
+++ /dev/null
@@ -1,4955 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Tag Serialization  ----------------------------------------------------------------------------- 
-// This file implements every single tag and tag type as described in the ICC spec. Some types
-// have been deprecated, like ncl and Data. There is no implementation for those types as there
-// are no profiles holding them. The programmer can also extend this list by defining his own types
-// by using the appropiate plug-in. There are three types of plug ins regarding that. First type
-// allows to define new tags using any existing type. Next plug-in type allows to define new types
-// and the third one is very specific: allows to extend the number of elements in the multiprofile
-// elements special type. 
-//--------------------------------------------------------------------------------------------------
-
-// Some broken types
-#define cmsCorbisBrokenXYZtype    ((cmsTagTypeSignature) 0x17A505B8)
-#define cmsMonacoBrokenCurveType  ((cmsTagTypeSignature) 0x9478ee00)
-
-// This is the linked list that keeps track of the defined types
-typedef struct _cmsTagTypeLinkedList_st {
-
-    cmsTagTypeHandler Handler;
-    struct _cmsTagTypeLinkedList_st* Next;
-
-} _cmsTagTypeLinkedList;
-
-// Some macros to define callbacks.
-#define READ_FN(x)  Type_##x##_Read
-#define WRITE_FN(x) Type_##x##_Write
-#define FREE_FN(x)  Type_##x##_Free
-#define DUP_FN(x)   Type_##x##_Dup
-
-// Helper macro to define a handler. Callbacks do have a fixed naming convention.
-#define TYPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), DUP_FN(x), FREE_FN(x) }
-
-// Helper macro to define a MPE handler. Callbacks do have a fixed naming convention
-#define TYPE_MPE_HANDLER(t, x)  { (t), READ_FN(x), WRITE_FN(x), GenericMPEdup, GenericMPEfree }
-
-// Register a new type handler. This routine is shared between normal types and MPE
-static
-cmsBool RegisterTypesPlugin(cmsPluginBase* Data, _cmsTagTypeLinkedList* LinkedList, cmsUInt32Number DefaultListCount)
-{
-    cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;
-    _cmsTagTypeLinkedList *pt, *Anterior = NULL;
-
-    // Calling the function with NULL as plug-in would unregister the plug in.
-    if (Data == NULL) {
-
-        LinkedList[DefaultListCount-1].Next = NULL;
-        return TRUE;
-    }
-
-    pt = Anterior = LinkedList; 
-    while (pt != NULL) {
-
-        if (Plugin->Handler.Signature == pt -> Handler.Signature) {
-            pt ->Handler = Plugin ->Handler;    // Replace old behaviour. 
-            // Note that since no memory is allocated, unregister does not
-            // reset this action. 
-            return TRUE;
-        }   
-
-        Anterior = pt;          
-        pt = pt ->Next;
-    }
-
-    // Registering happens in plug-in memory pool
-    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagTypeLinkedList));
-    if (pt == NULL) return FALSE;
-
-    pt ->Handler   = Plugin ->Handler;  
-    pt ->Next      = NULL;
-
-    if (Anterior) 
-        Anterior -> Next = pt;
-
-    return TRUE;
-}
-
-// Return handler for a given type or NULL if not found. Shared between normal types and MPE
-static
-cmsTagTypeHandler* GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* LinkedList)
-{
-    _cmsTagTypeLinkedList* pt;
-
-    for (pt = LinkedList; 
-         pt != NULL;
-         pt = pt ->Next) {
-
-            if (sig == pt -> Handler.Signature) return &pt ->Handler;
-    }
-
-    return NULL;
-}
-
-
-// Auxiliar to convert UTF-32 to UTF-16 in some cases
-static
-cmsBool _cmsWriteWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, const wchar_t* Array)
-{
-    cmsUInt32Number i;
-
-    _cmsAssert(io != NULL);
-    _cmsAssert(Array != NULL);
-
-    for (i=0; i < n; i++) {
-        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Array[i])) return FALSE;
-    }
-
-    return TRUE;
-}
-
-static
-cmsBool _cmsReadWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, wchar_t* Array)
-{
-    cmsUInt32Number i;
-    cmsUInt16Number tmp;
-
-    _cmsAssert(io != NULL);
-
-    for (i=0; i < n; i++) {
-
-        if (Array != NULL) {
-
-            if (!_cmsReadUInt16Number(io, &tmp)) return FALSE;
-            Array[i] = (wchar_t) tmp;
-        }
-        else {
-            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;
-        }
-
-    }
-    return TRUE;
-}
-
-// To deal with position tables
-typedef cmsBool (* PositionTableEntryFn)(struct _cms_typehandler_struct* self, 
-                                             cmsIOHANDLER* io,
-                                             void* Cargo,
-                                             cmsUInt32Number n, 
-                                             cmsUInt32Number SizeOfTag);
-
-// Helper function to deal with position tables as decribed in several addendums to ICC spec 4.2
-// A table of n elements is written, where first comes n records containing offsets and sizes and
-// then a block containing the data itself. This allows to reuse same data in more than one entry
-static
-cmsBool ReadPositionTable(struct _cms_typehandler_struct* self, 
-                              cmsIOHANDLER* io, 
-                              cmsUInt32Number Count, 
-                              cmsUInt32Number BaseOffset, 
-                              void *Cargo,
-                              PositionTableEntryFn ElementFn)
-{
-    cmsUInt32Number i;
-    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
-
-    // Let's take the offsets to each element
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
-    if (ElementOffsets == NULL) goto Error;
-
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
-    if (ElementSizes == NULL) goto Error;
-
-    for (i=0; i < Count; i++) {
-
-        if (!_cmsReadUInt32Number(io, &ElementOffsets[i])) goto Error;
-        if (!_cmsReadUInt32Number(io, &ElementSizes[i])) goto Error;
-
-        ElementOffsets[i] += BaseOffset;
-    }
-
-    // Seek to each element and read it
-    for (i=0; i < Count; i++) {
-
-        if (!io -> Seek(io, ElementOffsets[i])) goto Error;
-
-        // This is the reader callback
-        if (!ElementFn(self, io, Cargo, i, ElementSizes[i])) goto Error;
-    }
-
-    // Success
-    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);    
-    return TRUE;
-
-Error:    
-    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);
-    return FALSE;
-}
-
-// Same as anterior, but for write position tables
-static
-cmsBool WritePositionTable(struct _cms_typehandler_struct* self, 
-                               cmsIOHANDLER* io,
-                               cmsUInt32Number SizeOfTag,
-                               cmsUInt32Number Count, 
-                               cmsUInt32Number BaseOffset, 
-                               void *Cargo,
-                               PositionTableEntryFn ElementFn)
-{
-    cmsUInt32Number i;
-    cmsUInt32Number DirectoryPos, CurrentPos, Before;
-    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
-
-     // Create table
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
-    if (ElementOffsets == NULL) goto Error;
-
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
-    if (ElementSizes == NULL) goto Error;
-  
-    // Keep starting position of curve offsets
-    DirectoryPos = io ->Tell(io);
-
-    // Write a fake directory to be filled latter on
-    for (i=0; i < Count; i++) {
-
-        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset 
-        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size
-    }
-
-    // Write each element. Keep track of the size as well.
-    for (i=0; i < Count; i++) {
-
-        Before = io ->Tell(io);
-        ElementOffsets[i] = Before - BaseOffset;                
-
-        // Callback to write...
-        if (!ElementFn(self, io, Cargo, i, SizeOfTag)) goto Error;
-
-        // Now the size
-        ElementSizes[i] = io ->Tell(io) - Before;       
-    }
-
-    // Write the directory
-    CurrentPos = io ->Tell(io);
-    if (!io ->Seek(io, DirectoryPos)) goto Error;
-
-    for (i=0; i <  Count; i++) {
-        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;  
-        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;  
-    }
-
-    if (!io ->Seek(io, CurrentPos)) goto Error;
-
-    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);
-    return TRUE;
-
-Error:
-    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);
-    return FALSE;
-}
-
-
-// ********************************************************************************
-// Type XYZ. Only one value is allowed
-// ********************************************************************************
-
-//The XYZType contains an array of three encoded values for the XYZ tristimulus
-//values. Tristimulus values must be non-negative. The signed encoding allows for 
-//implementation optimizations by minimizing the number of fixed formats.
-
-
-static
-void *Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsCIEXYZ* xyz;
-
-    *nItems = 0;
-    xyz = (cmsCIEXYZ*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIEXYZ));
-    if (xyz == NULL) return NULL;
-
-    if (!_cmsReadXYZNumber(io, xyz)) {
-        _cmsFree(self ->ContextID, xyz);
-        return NULL;
-    }
-
-    *nItems = 1;
-    return (void*) xyz;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool  Type_XYZ_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    return _cmsWriteXYZNumber(io, (cmsCIEXYZ*) Ptr);
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_XYZ_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIEXYZ));
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_XYZ_Free(struct _cms_typehandler_struct* self, void *Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-
-static
-cmsTagTypeSignature DecideXYZtype(cmsFloat64Number ICCVersion, const void *Data)
-{
-    return cmsSigXYZType;
-
-    cmsUNUSED_PARAMETER(ICCVersion);
-    cmsUNUSED_PARAMETER(Data);
-}
-
-
-// ********************************************************************************
-// Type chromaticity. Only one value is allowed
-// ********************************************************************************
-// The chromaticity tag type provides basic chromaticity data and type of 
-// phosphors or colorants of a monitor to applications and utilities.
-
-static
-void *Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsCIExyYTRIPLE* chrm;
-    cmsUInt16Number nChans, Table;
-
-    *nItems = 0;
-    chrm =  (cmsCIExyYTRIPLE*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIExyYTRIPLE));
-    if (chrm == NULL) return NULL;
-
-    if (!_cmsReadUInt16Number(io, &nChans)) goto Error;
-
-    // Let's recover from a bug introduced in early versions of lcms1
-    if (nChans == 0 && SizeOfTag == 32) {
-
-        if (!_cmsReadUInt16Number(io, NULL)) goto Error;
-        if (!_cmsReadUInt16Number(io, &nChans)) goto Error;
-    }
-
-    if (nChans != 3) goto Error;
-
-    if (!_cmsReadUInt16Number(io, &Table)) goto Error;
-
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.x)) goto Error;
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.y)) goto Error;
-
-    chrm ->Red.Y = 1.0;
-
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.x)) goto Error;
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.y)) goto Error;
-
-    chrm ->Green.Y = 1.0;
-
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.x)) goto Error;
-    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.y)) goto Error;
-
-    chrm ->Blue.Y = 1.0;
-
-    *nItems = 1;
-    return (void*) chrm;
-
-Error:
-    _cmsFree(self ->ContextID, (void*) chrm);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool  SaveOneChromaticity(cmsFloat64Number x, cmsFloat64Number y, cmsIOHANDLER* io)
-{
-    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(x))) return FALSE;     
-    if (!_cmsWriteUInt32Number(io, _cmsDoubleTo15Fixed16(y))) return FALSE;     
-
-    return TRUE;
-}
-
-static
-cmsBool  Type_Chromaticity_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsCIExyYTRIPLE* chrm = (cmsCIExyYTRIPLE*) Ptr;
-
-    if (!_cmsWriteUInt16Number(io, 3)) return FALSE;        // nChannels
-    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Table
-
-    if (!SaveOneChromaticity(chrm -> Red.x,   chrm -> Red.y, io)) return FALSE;
-    if (!SaveOneChromaticity(chrm -> Green.x, chrm -> Green.y, io)) return FALSE;
-    if (!SaveOneChromaticity(chrm -> Blue.x,  chrm -> Blue.y, io)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);  
-}
-
-static
-void* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));
-    cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_Chromaticity_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-
-// ********************************************************************************
-// Type cmsSigColorantOrderType
-// ********************************************************************************
-
-// This is an optional tag which specifies the laydown order in which colorants will 
-// be printed on an n-colorant device. The laydown order may be the same as the 
-// channel generation order listed in the colorantTableTag or the channel order of a 
-// colour space such as CMYK, in which case this tag is not needed. When this is not 
-// the case (for example, ink-towers sometimes use the order KCMY), this tag may be 
-// used to specify the laydown order of the colorants. 
-
-
-static
-void *Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt8Number* ColorantOrder;
-    cmsUInt32Number Count;
-
-    *nItems = 0;
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;
-    if (Count > cmsMAXCHANNELS) return NULL;
-
-    ColorantOrder = (cmsUInt8Number*) _cmsCalloc(self ->ContextID, cmsMAXCHANNELS, sizeof(cmsUInt8Number));
-    if (ColorantOrder == NULL) return NULL;
-
-    // We use FF as end marker
-    memset(ColorantOrder, 0xFF, cmsMAXCHANNELS * sizeof(cmsUInt8Number));
-
-    if (io ->Read(io, ColorantOrder, sizeof(cmsUInt8Number), Count) != Count) {
-
-        _cmsFree(self ->ContextID, (void*) ColorantOrder);
-        return NULL;
-    }
-
-    *nItems = 1;
-    return (void*) ColorantOrder;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool Type_ColorantOrderType_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsUInt8Number*  ColorantOrder = (cmsUInt8Number*) Ptr; 
-    cmsUInt32Number i, sz, Count;
-
-    // Get the length
-    for (Count=i=0; i < cmsMAXCHANNELS; i++) {
-        if (ColorantOrder[i] != 0xFF) Count++;
-    }
-
-    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;    
-
-    sz = Count * sizeof(cmsUInt8Number);
-    if (!io -> Write(io, sz, ColorantOrder)) return FALSE;          
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_ColorantOrderType_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, cmsMAXCHANNELS * sizeof(cmsUInt8Number));
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-
-static
-void Type_ColorantOrderType_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigS15Fixed16ArrayType
-// ********************************************************************************
-// This type represents an array of generic 4-byte/32-bit fixed point quantity. 
-// The number of values is determined from the size of the tag.
-
-static
-void *Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsFloat64Number*  array_double;
-    cmsUInt32Number i, n;
-
-    *nItems = 0;
-    n = SizeOfTag / sizeof(cmsUInt32Number);
-    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));
-    if (array_double == NULL) return NULL;
-
-    for (i=0; i < n; i++) {
-
-        if (!_cmsRead15Fixed16Number(io, &array_double[i])) {
-
-            _cmsFree(self ->ContextID, array_double);
-            return NULL;
-        }       
-    }
-
-    *nItems = n;
-    return (void*) array_double;
-}
-
-static
-cmsBool Type_S15Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;
-    cmsUInt32Number i;
-
-    for (i=0; i < nItems; i++) {
-
-        if (!_cmsWrite15Fixed16Number(io, Value[i])) return FALSE;  
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_S15Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));
-}
-
-
-static
-void Type_S15Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigU16Fixed16ArrayType
-// ********************************************************************************
-// This type represents an array of generic 4-byte/32-bit quantity. 
-// The number of values is determined from the size of the tag.
-
-
-static
-void *Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsFloat64Number*  array_double;
-    cmsUInt32Number v;
-    cmsUInt32Number i, n;
-
-    *nItems = 0;
-    n = SizeOfTag / sizeof(cmsUInt32Number);
-    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));
-    if (array_double == NULL) return NULL;
-
-    for (i=0; i < n; i++) {
-
-        if (!_cmsReadUInt32Number(io, &v)) {
-            _cmsFree(self ->ContextID, (void*) array_double);
-            return NULL;
-        }
-
-        // Convert to cmsFloat64Number
-        array_double[i] =  (cmsFloat64Number) (v / 65536.0);
-    }
-
-    *nItems = n;
-    return (void*) array_double;
-}
-
-static
-cmsBool Type_U16Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;
-    cmsUInt32Number i;
-
-    for (i=0; i < nItems; i++) {
-
-        cmsUInt32Number v = (cmsUInt32Number) floor(Value[i]*65536.0 + 0.5);
-
-        if (!_cmsWriteUInt32Number(io, v)) return FALSE;    
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_U16Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));
-}
-
-static
-void Type_U16Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigSignatureType
-// ********************************************************************************
-//
-// The signatureType contains a four-byte sequence, Sequences of less than four 
-// characters are padded at the end with spaces, 20h. 
-// Typically this type is used for registered tags that can be displayed on many 
-// development systems as a sequence of four characters.
-
-static
-void *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));
-    if (SigPtr == NULL) return NULL;
-
-     if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;
-     *nItems = 1;
-
-     return SigPtr;
-
-     cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool  Type_Signature_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsSignature* SigPtr = (cmsSignature*) Ptr; 
-    
-    return _cmsWriteUInt32Number(io, *SigPtr);
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_Signature_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsSignature));
-}
-
-static
-void Type_Signature_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-
-// ********************************************************************************
-// Type cmsSigTextType
-// ********************************************************************************
-//
-// The textType is a simple text structure that contains a 7-bit ASCII text string. 
-// The length of the string is obtained by subtracting 8 from the element size portion 
-// of the tag itself. This string must be terminated with a 00h byte.
-
-static
-void *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    char* Text = NULL;
-    cmsMLU* mlu = NULL;
-
-    // Create a container
-    mlu = cmsMLUalloc(self ->ContextID, 1);
-    if (mlu == NULL) return NULL;
-
-    *nItems = 0;
-
-    // We need to store the "\0" at the end, so +1
-    if (SizeOfTag == UINT_MAX) goto Error;
-
-    Text = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);
-    if (Text == NULL) goto Error;
-
-    if (io -> Read(io, Text, sizeof(char), SizeOfTag) != SizeOfTag) goto Error;        
-
-    // Make sure text is properly ended
-    Text[SizeOfTag] = 0;
-    *nItems = 1;
-    
-    // Keep the result
-    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;
-
-    _cmsFree(self ->ContextID, Text);
-    return (void*) mlu;
-
-Error:
-    if (mlu != NULL) 
-        cmsMLUfree(mlu);
-    if (Text != NULL)
-        _cmsFree(self ->ContextID, Text);
-
-    return NULL;
-}
-
-// The conversion implies to choose a language. So, we choose the actual language.
-static
-cmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsMLU* mlu = (cmsMLU*) Ptr; 
-    cmsUInt32Number size;
-    cmsBool  rc;
-    char* Text;
-   
-    // Get the size of the string. Note there is an extra "\0" at the end
-    size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);
-    if (size == 0) return FALSE;       // Cannot be zero!
-
-    // Create memory
-    Text = (char*) _cmsMalloc(self ->ContextID, size);
-    cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);
-
-    // Write it, including separator
-    rc = io ->Write(io, size, Text);
-
-    _cmsFree(self ->ContextID, Text);
-    return rc;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsMLUdup((cmsMLU*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void Type_Text_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    cmsMLU* mlu = (cmsMLU*) Ptr;
-    cmsMLUfree(mlu);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-cmsTagTypeSignature DecideTextType(cmsFloat64Number ICCVersion, const void *Data)
-{
-    if (ICCVersion >= 4.0) 
-        return cmsSigMultiLocalizedUnicodeType;
-        
-    return cmsSigTextType;
-    
-    cmsUNUSED_PARAMETER(Data);
-}
-
-
-// ********************************************************************************
-// Type cmsSigDataType
-// ********************************************************************************
-
-// General purpose data type
-static
-void *Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsICCData* BinData;
-    cmsUInt32Number LenOfData;
-
-    *nItems = 0;
-    
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-
-    LenOfData = SizeOfTag - sizeof(cmsUInt32Number);
-    if (LenOfData > INT_MAX) return NULL;
-
-    BinData = (cmsICCData*) _cmsMalloc(self ->ContextID, sizeof(cmsICCData) + LenOfData - 1);
-    if (BinData == NULL) return NULL;
-
-    BinData ->len = LenOfData;
-    if (!_cmsReadUInt32Number(io, &BinData->flag)) {
-        _cmsFree(self ->ContextID, BinData);
-        return NULL;
-    }
-
-    if (io -> Read(io, BinData ->data, sizeof(cmsUInt8Number), LenOfData) != LenOfData) {
-       
-        _cmsFree(self ->ContextID, BinData);
-        return NULL;
-    }
-
-    *nItems = 1;
-  
-    return (void*) BinData;
-}
-
-
-static
-cmsBool Type_Data_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-   cmsICCData* BinData = (cmsICCData*) Ptr;
-    
-   if (!_cmsWriteUInt32Number(io, BinData ->flag)) return FALSE;
-
-   return io ->Write(io, BinData ->len, BinData ->data);
-
-   cmsUNUSED_PARAMETER(nItems);
-   cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_Data_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    cmsICCData* BinData = (cmsICCData*) Ptr;
-
-    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCData) + BinData ->len - 1);
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_Data_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigTextDescriptionType
-// ********************************************************************************
-
-static
-void *Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    char* Text = NULL;
-    cmsMLU* mlu = NULL;
-    cmsUInt32Number  AsciiCount;
-    cmsUInt32Number  i, UnicodeCode, UnicodeCount;
-    cmsUInt16Number  ScriptCodeCode, Dummy;
-    cmsUInt8Number   ScriptCodeCount;
-
-    *nItems = 0;
-
-    //  One dword should be there
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-
-    // Read len of ASCII
-    if (!_cmsReadUInt32Number(io, &AsciiCount)) return NULL;
-    SizeOfTag -= sizeof(cmsUInt32Number);
-
-    // Check for size
-    if (SizeOfTag < AsciiCount) return NULL; 
-
-    // All seems Ok, allocate the container
-    mlu = cmsMLUalloc(self ->ContextID, 1);
-    if (mlu == NULL) return NULL;
-
-    // As many memory as size of tag
-    Text = (char*) _cmsMalloc(self ->ContextID, AsciiCount + 1);
-    if (Text == NULL) goto Error;
-
-    // Read it
-    if (io ->Read(io, Text, sizeof(char), AsciiCount) != AsciiCount) goto Error;
-    SizeOfTag -= AsciiCount;
-
-    // Make sure there is a terminator
-    Text[AsciiCount] = 0;
-
-    // Set the MLU entry. From here we can be tolerant to wrong types
-    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;
-    _cmsFree(self ->ContextID, (void*) Text);
-    Text = NULL;
-    
-    // Skip Unicode code
-    if (SizeOfTag < 2* sizeof(cmsUInt32Number)) goto Done;
-    if (!_cmsReadUInt32Number(io, &UnicodeCode)) goto Done;                      
-    if (!_cmsReadUInt32Number(io, &UnicodeCount)) goto Done;    
-    SizeOfTag -= 2* sizeof(cmsUInt32Number);
-
-    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;
-
-    for (i=0; i < UnicodeCount; i++) {
-        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;
-    }
-    SizeOfTag -= UnicodeCount*sizeof(cmsUInt16Number);
-
-    // Skip ScriptCode code if present. Some buggy profiles does have less
-    // data that stricttly required. We need to skip it as this type may come 
-    // embedded in other types.
-    
-    if (SizeOfTag >= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number) + 67) {
-
-        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;
-        if (!_cmsReadUInt8Number(io,  &ScriptCodeCount)) goto Done;                      
-
-        // Skip rest of tag
-        for (i=0; i < 67; i++) {
-            if (!io ->Read(io, &Dummy, sizeof(cmsUInt8Number), 1)) goto Error;
-        }
-    }
-
-Done:
-
-    *nItems = 1;
-    return mlu;
-
-Error:
-    if (Text) _cmsFree(self ->ContextID, (void*) Text);
-    if (mlu) cmsMLUfree(mlu);
-    return NULL;
-}
-
-
-// This tag can come IN UNALIGNED SIZE. In order to prevent issues, we force zeros on description to align it
-static
-cmsBool  Type_Text_Description_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsMLU* mlu = (cmsMLU*) Ptr;
-    char *Text = NULL;
-    wchar_t *Wide = NULL;
-    cmsUInt32Number len, len_aligned, len_filler_alignment;
-    cmsBool  rc = FALSE;
-    char Filler[68];
-
-    // Used below for writting zeroes
-    memset(Filler, 0, sizeof(Filler));
-    
-    // Get the len of string
-    len = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);
-    
-    // From ICC3.4: It has been found that textDescriptionType can contain misaligned data
-    //(see clause 4.1 for the definition of aligned). Because the Unicode language
-    // code and Unicode count immediately follow the ASCII description, their
-    // alignment is not correct if the ASCII count is not a multiple of four. The
-    // ScriptCode code is misaligned when the ASCII count is odd. Profile reading and
-    // writing software must be written carefully in order to handle these alignment
-    // problems. 
-
-    // Compute an aligned size
-    len_aligned = _cmsALIGNLONG(len);
-    len_filler_alignment = len_aligned - len;
-
-    // Null strings
-    if (len <= 0) {
-
-        Text = (char*)    _cmsDupMem(self ->ContextID, "", sizeof(char));
-        Wide = (wchar_t*) _cmsDupMem(self ->ContextID, L"", sizeof(wchar_t));
-    }
-    else {
-        // Create independent buffers
-        Text = (char*) _cmsCalloc(self ->ContextID, len, sizeof(char));
-        if (Text == NULL) goto Error;
-
-        Wide = (wchar_t*) _cmsCalloc(self ->ContextID, len, sizeof(wchar_t));
-        if (Wide == NULL) goto Error;
-
-        // Get both representations. 
-        cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry,  Text, len * sizeof(char));
-        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));
-    }
-          
-  // * cmsUInt32Number       count;          * Description length
-  // * cmsInt8Number         desc[count]     * NULL terminated ascii string
-  // * cmsUInt32Number       ucLangCode;     * UniCode language code
-  // * cmsUInt32Number       ucCount;        * UniCode description length
-  // * cmsInt16Number        ucDesc[ucCount];* The UniCode description
-  // * cmsUInt16Number       scCode;         * ScriptCode code
-  // * cmsUInt8Number        scCount;        * ScriptCode count
-  // * cmsInt8Number         scDesc[67];     * ScriptCode Description
-    
-    if (!_cmsWriteUInt32Number(io, len_aligned)) goto Error;        
-    if (!io ->Write(io, len, Text)) goto Error;    
-    if (!io ->Write(io, len_filler_alignment, Filler)) goto Error;    
-
-    if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // ucLanguageCode
-    
-    // This part is tricky: we need an aligned tag size, and the ScriptCode part
-    // takes 70 bytes, so we need 2 extra bytes to do the alignment
-
-    if (!_cmsWriteUInt32Number(io, len_aligned+1)) goto Error;  
-
-    // Note that in some compilers sizeof(cmsUInt16Number) != sizeof(wchar_t)
-    if (!_cmsWriteWCharArray(io, len, Wide)) goto Error;            
-    if (!_cmsWriteUInt16Array(io, len_filler_alignment+1, (cmsUInt16Number*) Filler)) goto Error;   
-
-    // ScriptCode Code & count (unused)
-    if (!_cmsWriteUInt16Number(io, 0)) goto Error;  
-    if (!_cmsWriteUInt8Number(io, 0)) goto Error;   
-        
-    if (!io ->Write(io, 67, Filler)) goto Error;
-
-    rc = TRUE;
-
-Error:
-    if (Text) _cmsFree(self ->ContextID, Text);
-    if (Wide) _cmsFree(self ->ContextID, Wide);
-
-    return rc;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsMLUdup((cmsMLU*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_Text_Description_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    cmsMLU* mlu = (cmsMLU*) Ptr;
-
-    cmsMLUfree(mlu);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-cmsTagTypeSignature DecideTextDescType(cmsFloat64Number ICCVersion, const void *Data)
-{
-    if (ICCVersion >= 4.0) 
-        return cmsSigMultiLocalizedUnicodeType;
-        
-    return cmsSigTextDescriptionType;
-    
-    cmsUNUSED_PARAMETER(Data);
-}
-
-
-// ********************************************************************************
-// Type cmsSigCurveType
-// ********************************************************************************
-
-static
-void *Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt32Number Count;
-    cmsToneCurve* NewGamma;
-    cmsUInt16Number Linear[2] = { 0, 0xffff };
-
-
-    *nItems = 0;
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;
-
-    switch (Count) {
-
-           case 0:   // Linear.
-
-               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, 2, Linear);               
-               if (!NewGamma) return NULL;
-               *nItems = 1;
-               return NewGamma;
-
-           case 1:  // Specified as the exponent of gamma function
-               {
-                   cmsUInt16Number SingleGammaFixed;
-                   cmsFloat64Number SingleGamma;
-
-                   if (!_cmsReadUInt16Number(io, &SingleGammaFixed)) return NULL;
-                   SingleGamma = _cms8Fixed8toDouble(SingleGammaFixed);
-
-                   *nItems = 1;
-                   return cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);
-               }
-
-           default:  // Curve
-
-               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, Count, NULL);
-               if (!NewGamma) return NULL;
-
-               if (!_cmsReadUInt16Array(io, Count, NewGamma -> Table16)) return NULL;         
-
-               *nItems = 1;
-               return NewGamma;
-    }
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-static
-cmsBool  Type_Curve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;
-
-    if (Curve ->nSegments == 1 && Curve ->Segments[0].Type == 1) {
-
-            // Single gamma, preserve number
-            cmsUInt16Number SingleGammaFixed = _cmsDoubleTo8Fixed8(Curve ->Segments[0].Params[0]);
-
-            if (!_cmsWriteUInt32Number(io, 1)) return FALSE;    
-            if (!_cmsWriteUInt16Number(io, SingleGammaFixed)) return FALSE;
-            return TRUE;
-        
-    }
-
-    if (!_cmsWriteUInt32Number(io, Curve ->nEntries)) return FALSE; 
-    return _cmsWriteUInt16Array(io, Curve ->nEntries, Curve ->Table16);
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_Curve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_Curve_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;
-
-    cmsFreeToneCurve(gamma);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigParametricCurveType
-// ********************************************************************************
-
-
-// Decide which curve type to use on writting
-static
-cmsTagTypeSignature DecideCurveType(cmsFloat64Number ICCVersion, const void *Data)
-{
-    cmsToneCurve* Curve = (cmsToneCurve*) Data;
-
-    if (ICCVersion < 4.0) return cmsSigCurveType;
-    if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric
-    if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves
-
-    return cmsSigParametricCurveType;
-}
-
-static
-void *Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    static const int ParamsByType[] = { 1, 3, 4, 5, 7 };
-    cmsFloat64Number Params[10];
-    cmsUInt16Number Type;
-    int i, n;
-    cmsToneCurve* NewGamma;
-
-    if (!_cmsReadUInt16Number(io, &Type)) return NULL;
-    if (!_cmsReadUInt16Number(io, NULL)) return NULL;   // Reserved
-
-    if (Type > 4) {
-
-        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown parametric curve type '%d'", Type);
-        return NULL;
-    }
-
-    memset(Params, 0, sizeof(Params));
-    n = ParamsByType[Type];
-
-    for (i=0; i < n; i++) {
-
-        if (!_cmsRead15Fixed16Number(io, &Params[i])) return NULL;      
-    }
-
-    NewGamma = cmsBuildParametricToneCurve(self ->ContextID, Type+1, Params);
-
-    *nItems = 1;
-    return NewGamma;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-    
-
-static
-cmsBool  Type_ParametricCurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;
-    int i, nParams;
-    static const int ParamsByType[] = { 0, 1, 3, 4, 5, 7 };
-      
-
-    if (Curve ->nSegments > 1 || Curve -> Segments[0].Type < 1) {
-
-        cmsSignalError(self->ContextID, 0, "Multisegment or Inverted parametric curves cannot be written");          
-        return FALSE;
-    }
-
-    nParams = ParamsByType[Curve ->Segments[0].Type];
-    
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) (Curve ->Segments[0].Type - 1))) return FALSE;
-    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Reserved
-
-    for (i=0; i < nParams; i++) {
-
-        if (!_cmsWrite15Fixed16Number(io, Curve -> Segments[0].Params[i])) return FALSE;        
-    }
-    
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_ParametricCurve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_ParametricCurve_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;
-
-    cmsFreeToneCurve(gamma);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigDateTimeType
-// ********************************************************************************
-
-// A 12-byte value representation of the time and date, where the byte usage is assigned 
-// as specified in table 1. The actual values are encoded as 16-bit unsigned integers 
-// (uInt16Number - see 5.1.6).
-//
-// All the dateTimeNumber values in a profile shall be in Coordinated Universal Time 
-// (UTC, also known as GMT or ZULU Time). Profile writers are required to convert local
-// time to UTC when setting these values. Programmes that display these values may show 
-// the dateTimeNumber as UTC, show the equivalent local time (at current locale), or 
-// display both UTC and local versions of the dateTimeNumber.
-
-static
-void *Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsDateTimeNumber timestamp;
-    struct tm * NewDateTime;
-
-    *nItems = 0;
-    NewDateTime = (struct tm*) _cmsMalloc(self ->ContextID, sizeof(struct tm));
-    if (NewDateTime == NULL) return NULL;
-
-    if (io->Read(io, &timestamp, sizeof(cmsDateTimeNumber), 1) != 1) return NULL;
-            
-     _cmsDecodeDateTimeNumber(&timestamp, NewDateTime);
-
-     *nItems = 1;
-     return NewDateTime;
-
-     cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-static
-cmsBool  Type_DateTime_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    struct tm * DateTime = (struct tm*) Ptr;
-    cmsDateTimeNumber timestamp;
-
-    _cmsEncodeDateTimeNumber(&timestamp, DateTime);
-    if (!io ->Write(io, sizeof(cmsDateTimeNumber), &timestamp)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_DateTime_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return _cmsDupMem(self ->ContextID, Ptr, sizeof(struct tm));
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_DateTime_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-
-
-// ********************************************************************************
-// Type icMeasurementType
-// ********************************************************************************
-
-/*
-The measurementType information refers only to the internal profile data and is
-meant to provide profile makers an alternative to the default measurement 
-specifications.
-*/
-
-static
-void *Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsICCMeasurementConditions mc;
-
-    if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;
-    if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;
-    if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &mc.Flare)) return NULL;
-    if (!_cmsReadUInt32Number(io, &mc.IlluminantType)) return NULL;
-
-    *nItems = 1;
-    return _cmsDupMem(self ->ContextID, &mc, sizeof(cmsICCMeasurementConditions));
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-static
-cmsBool  Type_Measurement_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsICCMeasurementConditions* mc =(cmsICCMeasurementConditions*) Ptr;
-    
-    if (!_cmsWriteUInt32Number(io, mc->Observer)) return FALSE;
-    if (!_cmsWriteXYZNumber(io,    &mc->Backing)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, mc->Geometry)) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, mc->Flare)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, mc->IlluminantType)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCMeasurementConditions));
-
-     cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_Measurement_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-   _cmsFree(self ->ContextID, Ptr);
-}
-
-
-// ********************************************************************************
-// Type cmsSigMultiLocalizedUnicodeType
-// ********************************************************************************
-//
-//   Do NOT trust SizeOfTag as there is an issue on the definition of profileSequenceDescTag. See the TechNote from 
-//   Max Derhak and Rohit Patil about this: basically the size of the string table should be guessed and cannot be
-//   taken from the size of tag if this tag is embedded as part of bigger structures (profileSequenceDescTag, for instance)
-//
-
-static
-void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsMLU* mlu;
-    cmsUInt32Number Count, RecLen, NumOfWchar;       
-    cmsUInt32Number SizeOfHeader;
-    cmsUInt32Number  Len, Offset;
-    cmsUInt32Number  i;
-    wchar_t*         Block;
-    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;
-
-    *nItems = 0;
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;           
-    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;           
-
-    if (RecLen != 12) {
-
-        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "multiLocalizedUnicodeType of len != 12 is not supported.");
-        return NULL;
-    }
-
-    mlu = cmsMLUalloc(self ->ContextID, Count);
-    if (mlu == NULL) return NULL;
-
-    mlu ->UsedEntries = Count;
-
-    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);
-    LargestPosition = 0;
-
-    for (i=0; i < Count; i++) {
-
-        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;           
-        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;           
-
-        // Now deal with Len and offset.
-        if (!_cmsReadUInt32Number(io, &Len)) goto Error;      
-        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;
-
-        // Check for overflow
-        if (Offset < (SizeOfHeader + 8)) goto Error;
-
-        // True begin of the string
-        BeginOfThisString = Offset - SizeOfHeader - 8;
-        
-        // Ajust to wchar_t elements
-        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);        
-        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
-
-        // To guess maximum size, add offset + len
-        EndOfThisString = BeginOfThisString + Len;
-        if (EndOfThisString > LargestPosition)
-            LargestPosition = EndOfThisString;
-    }
-
-    // Now read the remaining of tag and fill all strings. Substract the directory
-    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
-
-    Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);
-    if (Block == NULL) goto Error;
-
-    NumOfWchar = SizeOfTag / sizeof(wchar_t);
-
-    if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;
-
-    mlu ->MemPool  = Block;
-    mlu ->PoolSize = SizeOfTag;
-    mlu ->PoolUsed = SizeOfTag;
-
-    *nItems = 1;
-    return (void*) mlu;
-
-Error:          
-    if (mlu) cmsMLUfree(mlu);
-    return NULL;                                                
-}
-
-static
-cmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsMLU* mlu =(cmsMLU*) Ptr;
-    cmsUInt32Number HeaderSize;
-    cmsUInt32Number  Len, Offset;
-    int i;
-
-    if (Ptr == NULL) {
-
-          // Empty placeholder
-          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;           
-          if (!_cmsWriteUInt32Number(io, 12)) return FALSE;           
-          return TRUE;
-    }
-    
-    if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;           
-    if (!_cmsWriteUInt32Number(io, 12)) return FALSE;           
-          
-    HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);
-
-    for (i=0; i < mlu ->UsedEntries; i++) {
-
-        Len    =  mlu ->Entries[i].Len;
-        Offset =  mlu ->Entries[i].StrW;
-        
-        Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);
-        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;
-
-        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;           
-        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;  
-        if (!_cmsWriteUInt32Number(io, Len)) return FALSE;
-        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;               
-    }
-
-    if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_MLU_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsMLUdup((cmsMLU*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_MLU_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsMLUfree((cmsMLU*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigLut8Type
-// ********************************************************************************
-
-// Decide which LUT type to use on writting
-static
-cmsTagTypeSignature DecideLUTtypeA2B(cmsFloat64Number ICCVersion, const void *Data)
-{
-    cmsPipeline* Lut = (cmsPipeline*) Data;
-
-    if (ICCVersion < 4.0) {
-        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;
-        return cmsSigLut16Type;
-    }
-    else {
-         return cmsSigLutAtoBType;
-    }
-}
-
-static
-cmsTagTypeSignature DecideLUTtypeB2A(cmsFloat64Number ICCVersion, const void *Data)
-{
-    cmsPipeline* Lut = (cmsPipeline*) Data;
-
-    if (ICCVersion < 4.0) {
-        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;
-        return cmsSigLut16Type;
-    }
-    else {
-         return cmsSigLutBtoAType;
-    }
-}
-
-/*
-This structure represents a colour transform using tables of 8-bit precision. 
-This type contains four processing elements: a 3 by 3 matrix (which shall be 
-the identity matrix unless the input colour space is XYZ), a set of one dimensional 
-input tables, a multidimensional lookup table, and a set of one dimensional output 
-tables. Data is processed using these elements via the following sequence:
-(matrix) -> (1d input tables)  -> (multidimensional lookup table - CLUT) -> (1d output tables)
-
-Byte Position   Field Length (bytes)  Content Encoded as...
-8                  1          Number of Input Channels (i)    uInt8Number
-9                  1          Number of Output Channels (o)   uInt8Number
-10                 1          Number of CLUT grid points (identical for each side) (g) uInt8Number
-11                 1          Reserved for padding (fill with 00h)
-
-12..15             4          Encoded e00 parameter   s15Fixed16Number
-*/
-
-
-// Read 8 bit tables as gamma functions
-static 
-cmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)
-{
-    cmsStage* mpe;
-    cmsUInt8Number* Temp = NULL;
-    int i, j;
-    cmsToneCurve* Tables[cmsMAXCHANNELS];
-
-    if (nChannels > cmsMAXCHANNELS) return FALSE;
-        
-    memset(Tables, 0, sizeof(Tables));
-
-    Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);
-    if (Temp == NULL) return FALSE;
-
-    for (i=0; i < nChannels; i++) {
-        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);
-        if (Tables[i] == NULL) goto Error;
-    }
-
-    for (i=0; i < nChannels; i++) {
-
-        if (io ->Read(io, Temp, 256, 1) != 1) goto Error;
-
-        for (j=0; j < 256; j++)
-            Tables[i]->Table16[j] = (cmsUInt16Number) FROM_8_TO_16(Temp[j]);
-    }
-
-    _cmsFree(ContextID, Temp);
-
-
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
-
-    for (i=0; i < nChannels; i++) 
-        cmsFreeToneCurve(Tables[i]);
-
-    return TRUE;
-
-Error:
-    for (i=0; i < nChannels; i++) {
-        if (Tables[i]) cmsFreeToneCurve(Tables[i]);
-    }
-
-    if (Temp) _cmsFree(ContextID, Temp);
-    return FALSE;       
-}
-
-
-static
-cmsBool Write8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsUInt32Number n, _cmsStageToneCurvesData* Tables)
-{
-    int j;
-    cmsUInt32Number i;
-    cmsUInt8Number val;
-
-    for (i=0; i < n; i++) {
-
-        if (Tables) {
-
-            if (Tables ->TheCurves[i]->nEntries != 256) {
-                cmsSignalError(ContextID, cmsERROR_RANGE, "LUT8 needs 256 entries on prelinearization");
-                return FALSE;
-            }
-
-        }
-
-        for (j=0; j < 256; j++) {
-
-            if (Tables != NULL)
-                val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);
-            else
-                val = (cmsUInt8Number) j;
-
-            if (!_cmsWriteUInt8Number(io, val)) return FALSE;
-        }
-    }
-    return TRUE;
-}
-
-
-// Check overflow
-static
-unsigned int uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b) 
-{
-    cmsUInt32Number rv = 1, rc;
-
-    if (a == 0) return 0;
-    if (n == 0) return 0;
-
-    for (; b > 0; b--) {
-
-        rv *= a;
-
-        // Check for overflow
-        if (rv > UINT_MAX / a) return 0;
-
-    }
-    
-    rc = rv * n;
-
-    if (rv != rc / n) return 0;
-    return rc;
-}
-
-
-// That will create a MPE LUT with Matrix, pre tables, CLUT and post tables. 
-// 8 bit lut may be scaled easely to v4 PCS, but we need also to properly adjust
-// PCS on BToAxx tags and AtoB if abstract. We need to fix input direction.
-
-static
-void *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
-    cmsUInt8Number* Temp = NULL;
-    cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat, *mpeclut;
-    cmsUInt32Number nTabSize, i;    
-    cmsFloat64Number Matrix[3*3];
-
-    *nItems = 0;
- 
-    if (!_cmsReadUInt8Number(io, &InputChannels)) goto Error;
-    if (!_cmsReadUInt8Number(io, &OutputChannels)) goto Error;
-    if (!_cmsReadUInt8Number(io, &CLUTpoints)) goto Error;
-
-    // Padding
-    if (!_cmsReadUInt8Number(io, NULL)) goto Error;
-
-    // Do some checking
-   
-    if (InputChannels > cmsMAXCHANNELS)  goto Error;
-    if (OutputChannels > cmsMAXCHANNELS) goto Error;
-
-   // Allocates an empty Pipeline
-    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);
-    if (NewLUT == NULL) goto Error;
-
-    // Read the Matrix
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;
-
-  
-    // Only operates if not identity...
-    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
-
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, mpemat);
-    }
-    
-    // Get input tables
-    if (!Read8bitTables(self ->ContextID, io,  NewLUT, InputChannels)) goto Error;
-    
-    // Get 3D CLUT. Check the overflow....
-    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize > 0) {
-
-        cmsUInt16Number *PtrW, *T;
-        cmsUInt32Number Tsize;
-
-        Tsize = (cmsUInt32Number) nTabSize * sizeof(cmsUInt16Number);
-
-        PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
-        if (T  == NULL) goto Error;
-
-        Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);             
-        if (Temp == NULL) goto Error;
-
-        if (io ->Read(io, Temp, nTabSize, 1) != 1) goto Error;
-
-        for (i = 0; i < nTabSize; i++) {
-
-            *PtrW++ = FROM_8_TO_16(Temp[i]);
-        }
-        _cmsFree(self ->ContextID, Temp);
-        Temp = NULL;
-
-        
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
-        _cmsFree(self ->ContextID, T);
-    }
-
-
-    // Get output tables
-    if (!Read8bitTables(self ->ContextID, io,  NewLUT, OutputChannels)) goto Error;
-    
-    *nItems = 1;
-    return NewLUT;
-
-Error:
-    if (NewLUT != NULL) cmsPipelineFree(NewLUT);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-// We only allow a specific MPE structure: Matrix plus prelin, plus clut, plus post-lin.
-static
-cmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsUInt32Number j, nTabSize;
-    cmsUInt8Number  val;
-    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;
-    cmsStage* mpe;
-    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;
-    _cmsStageMatrixData* MatMPE = NULL;
-    _cmsStageCLutData* clut = NULL;
-    int clutPoints;
-
-    // Disassemble the LUT into components.
-    mpe = NewLUT -> Elements;
-    if (mpe ->Type == cmsSigMatrixElemType) {
-
-        MatMPE = (_cmsStageMatrixData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-
-    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {
-        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-
-    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {
-        clut  = (_cmsStageCLutData*) mpe -> Data;
-        mpe = mpe ->Next;
-    }
-
-    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {
-        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-
-    // That should be all
-    if (mpe != NULL) {
-        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, "LUT is not suitable to be saved as LUT8");
-        return FALSE;
-    }
-
-
-    if (clut == NULL)
-        clutPoints = 0;
-    else
-        clutPoints    = clut->Params->nSamples[0];
-
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->InputChannels)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) NewLUT ->OutputChannels)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding
-
-
-    if (MatMPE != NULL) {
-
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;
-
-    }
-    else {
-
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-    }
-
-    // The prelinearization table
-    if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;
-
-    nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);
-    if (nTabSize > 0) {
-
-    // The 3D CLUT.
-    if (clut != NULL) {
-
-        for (j=0; j < nTabSize; j++) {
-
-            val = (cmsUInt8Number) FROM_16_TO_8(clut ->Tab.T[j]);
-            if (!_cmsWriteUInt8Number(io, val)) return FALSE;
-        }
-    }
-    }
-
-    // The postlinearization table
-    if (!Write8bitTables(self ->ContextID, io, NewLUT ->OutputChannels, PostMPE)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_LUT8_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_LUT8_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsPipelineFree((cmsPipeline*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-// ********************************************************************************
-// Type cmsSigLut16Type
-// ********************************************************************************
-
-// Read 16 bit tables as gamma functions
-static 
-cmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)
-{
-    cmsStage* mpe;
-    int i;
-    cmsToneCurve* Tables[cmsMAXCHANNELS];
-
-    // Maybe an empty table? (this is a lcms extension)
-    if (nEntries <= 0) return TRUE;
-
-    // Check for malicious profiles
-    if (nChannels > cmsMAXCHANNELS) return FALSE;
-    
-    // Init table to zero
-    memset(Tables, 0, sizeof(Tables));
-
-    for (i=0; i < nChannels; i++) {
-
-        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, nEntries, NULL);
-        if (Tables[i] == NULL) goto Error;
-
-        if (!_cmsReadUInt16Array(io, nEntries, Tables[i]->Table16)) goto Error;
-    }
-
-
-    // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
-
-    for (i=0; i < nChannels; i++) 
-        cmsFreeToneCurve(Tables[i]);
-
-    return TRUE;
-
-Error:
-    for (i=0; i < nChannels; i++) {
-        if (Tables[i]) cmsFreeToneCurve(Tables[i]);
-    }
-
-    return FALSE;       
-}
-
-static
-cmsBool Write16bitTables(cmsContext ContextID, cmsIOHANDLER* io, _cmsStageToneCurvesData* Tables)
-{
-    int j;
-    cmsUInt32Number i;
-    cmsUInt16Number val;
-    int nEntries = 256;
-
-    nEntries = Tables->TheCurves[0]->nEntries;
-    
-    for (i=0; i < Tables ->nCurves; i++) {
-
-        for (j=0; j < nEntries; j++) {
-
-            if (Tables != NULL)
-                val = Tables->TheCurves[i]->Table16[j];
-            else
-                val = _cmsQuantizeVal(j, nEntries);
-
-            if (!_cmsWriteUInt16Number(io, val)) return FALSE;
-        }
-    }
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(ContextID);
-}
-
-static
-void *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
-    cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat,  *mpeclut;
-    cmsUInt32Number nTabSize;
-    cmsFloat64Number Matrix[3*3];
-    cmsUInt16Number InputEntries, OutputEntries;
-    
-    *nItems = 0;
-
-    if (!_cmsReadUInt8Number(io, &InputChannels)) return NULL;
-    if (!_cmsReadUInt8Number(io, &OutputChannels)) return NULL;
-    if (!_cmsReadUInt8Number(io, &CLUTpoints)) return NULL;   // 255 maximum
-    
-    // Padding
-    if (!_cmsReadUInt8Number(io, NULL)) return NULL;
-
-    // Do some checking
-    if (InputChannels > cmsMAXCHANNELS)  goto Error;
-    if (OutputChannels > cmsMAXCHANNELS) goto Error;
-
-    // Allocates an empty LUT
-    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);
-    if (NewLUT == NULL) goto Error;
-
-    // Read the Matrix
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;
-    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;
-
-
-    // Only operates on 3 channels
-
-    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
-
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpemat);
-    }
-
-    if (!_cmsReadUInt16Number(io, &InputEntries)) return NULL;
-    if (!_cmsReadUInt16Number(io, &OutputEntries)) return NULL; 
-
-    
-    // Get input tables
-    if (!Read16bitTables(self ->ContextID, io,  NewLUT, InputChannels, InputEntries)) goto Error;
-
-    // Get 3D CLUT
-    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize > 0) {
-
-        cmsUInt16Number *T;
-
-        T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
-        if (T  == NULL) goto Error;
-
-        if (!_cmsReadUInt16Array(io, nTabSize, T)) {
-            _cmsFree(self ->ContextID, T);
-            goto Error;      
-        }
-        
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) {
-             _cmsFree(self ->ContextID, T);
-            goto Error;
-        }
-
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
-        _cmsFree(self ->ContextID, T);
-    }
-
-
-    // Get output tables
-    if (!Read16bitTables(self ->ContextID, io,  NewLUT, OutputChannels, OutputEntries)) goto Error;
-
-    *nItems = 1;
-    return NewLUT;
-
-Error:
-    if (NewLUT != NULL) cmsPipelineFree(NewLUT);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-// We only allow some specific MPE structures: Matrix plus prelin, plus clut, plus post-lin. 
-// Some empty defaults are created for missing parts
-
-static
-cmsBool  Type_LUT16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsUInt32Number nTabSize;
-    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;
-    cmsStage* mpe;
-    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;
-    _cmsStageMatrixData* MatMPE = NULL;
-    _cmsStageCLutData* clut = NULL;
-    int InputChannels, OutputChannels, clutPoints;
-
-    // Disassemble the LUT into components.
-    mpe = NewLUT -> Elements;
-    if (mpe != NULL && mpe ->Type == cmsSigMatrixElemType) {
-
-        MatMPE = (_cmsStageMatrixData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-    
-
-    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {
-        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-    
-    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {
-        clut  = (_cmsStageCLutData*) mpe -> Data;
-        mpe = mpe ->Next;
-    }
-    
-    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {
-        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;
-        mpe = mpe -> Next;
-    }
-
-    // That should be all
-    if (mpe != NULL) {
-        cmsSignalError(mpe->ContextID, cmsERROR_UNKNOWN_EXTENSION, "LUT is not suitable to be saved as LUT16");
-        return FALSE;
-    }
-
-    InputChannels  = cmsPipelineInputChannels(NewLUT);
-    OutputChannels = cmsPipelineOutputChannels(NewLUT);
-    
-    if (clut == NULL)
-        clutPoints = 0;
-    else
-        clutPoints    = clut->Params->nSamples[0];
-
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) InputChannels)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) OutputChannels)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding
-
-
-    if (MatMPE != NULL) {
-    
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[0])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[1])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[2])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[3])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[4])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[5])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[6])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[7])) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, MatMPE -> Double[8])) return FALSE;
-    }
-    else {
-
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;
-    }
-
-
-    if (PreMPE != NULL) {
-        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;
-    } else {
-            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
-    }
-
-    if (PostMPE != NULL) {
-        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;
-    } else {
-        if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
-    
-    }
-
-    // The prelinearization table
-
-    if (PreMPE != NULL) {
-        if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;
-    }
-
-    nTabSize = uipow(OutputChannels, clutPoints, InputChannels);
-
-    if (nTabSize > 0) {
-    // The 3D CLUT.
-    if (clut != NULL) {
-        if (!_cmsWriteUInt16Array(io, nTabSize, clut->Tab.T)) return FALSE;
-    }
-    }
-
-    // The postlinearization table
-    if (PostMPE != NULL) {
-        if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;
-    }
-
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_LUT16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_LUT16_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsPipelineFree((cmsPipeline*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigLutAToBType
-// ********************************************************************************
-
-
-// V4 stuff. Read matrix for LutAtoB and LutBtoA
-
-static
-cmsStage* ReadMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset)
-{
-    cmsFloat64Number dMat[3*3];
-    cmsFloat64Number dOff[3];
-    cmsStage* Mat;
-
-    // Go to address 
-    if (!io -> Seek(io, Offset)) return NULL;
-
-    // Read the Matrix
-    if (!_cmsRead15Fixed16Number(io, &dMat[0])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[1])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[2])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[3])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[4])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[5])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[6])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[7])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dMat[8])) return NULL;
-
-    if (!_cmsRead15Fixed16Number(io, &dOff[0])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dOff[1])) return NULL;
-    if (!_cmsRead15Fixed16Number(io, &dOff[2])) return NULL;
-    
-    Mat = cmsStageAllocMatrix(self ->ContextID, 3, 3, dMat, dOff);
-
-     return Mat;
-}
-
-
-
-
-//  V4 stuff. Read CLUT part for LutAtoB and LutBtoA
-
-static
-cmsStage* ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, int InputChannels, int OutputChannels)
-{
-    cmsUInt8Number  gridPoints8[cmsMAXCHANNELS]; // Number of grid points in each dimension.  
-    cmsUInt32Number GridPoints[cmsMAXCHANNELS], i;
-    cmsUInt8Number  Precision;
-    cmsStage* CLUT;
-    _cmsStageCLutData* Data;
-
-    if (!io -> Seek(io, Offset)) return NULL;
-    if (io -> Read(io, gridPoints8, cmsMAXCHANNELS, 1) != 1) return NULL;
-
-    for (i=0; i < cmsMAXCHANNELS; i++)
-        GridPoints[i] = gridPoints8[i];
-
-    if (!_cmsReadUInt8Number(io, &Precision)) return NULL;
-
-    if (!_cmsReadUInt8Number(io, NULL)) return NULL;
-    if (!_cmsReadUInt8Number(io, NULL)) return NULL;
-    if (!_cmsReadUInt8Number(io, NULL)) return NULL;
-
-    CLUT = cmsStageAllocCLut16bitGranular(self ->ContextID, GridPoints, InputChannels, OutputChannels, NULL);
-    if (CLUT == NULL) return NULL;
-
-    Data = (_cmsStageCLutData*) CLUT ->Data;
-
-    // Precision can be 1 or 2 bytes
-    if (Precision == 1) {
-
-       cmsUInt8Number  v;
-  
-        for (i=0; i < Data ->nEntries; i++) {
-
-                if (io ->Read(io, &v, sizeof(cmsUInt8Number), 1) != 1) return NULL;
-                Data ->Tab.T[i] = FROM_8_TO_16(v);
-        }
-                
-    }
-    else  
-        if (Precision == 2) {
-        
-            if (!_cmsReadUInt16Array(io, Data->nEntries, Data ->Tab.T)) return NULL;
-    }
-    else {
-        cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown precision of '%d'", Precision); 
-        return NULL;
-    }
-
-    
-    return CLUT;
-}
-
-static
-cmsToneCurve* ReadEmbeddedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)
-{
-    cmsTagTypeSignature  BaseType;
-    cmsUInt32Number nItems;
-
-    BaseType = _cmsReadTypeBase(io);       
-    switch (BaseType) {
-
-            case cmsSigCurveType:
-                return (cmsToneCurve*) Type_Curve_Read(self, io, &nItems, 0);
-
-            case cmsSigParametricCurveType:
-                return (cmsToneCurve*) Type_ParametricCurve_Read(self, io, &nItems, 0);
-
-            default: 
-                {
-                    char String[5];
-
-                    _cmsTagSignature2String(String, (cmsTagSignature) BaseType);
-                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown curve type '%s'", String);
-                }
-                return NULL;
-    }
-}
-
-
-// Read a set of curves from specific offset
-static
-cmsStage* ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, cmsUInt32Number nCurves)
-{     
-    cmsToneCurve* Curves[cmsMAXCHANNELS];
-    cmsUInt32Number i;
-    cmsStage* Lin = NULL;
-
-    if (nCurves > cmsMAXCHANNELS) return FALSE;
-
-    if (!io -> Seek(io, Offset)) return FALSE;
-    
-    for (i=0; i < nCurves; i++) 
-        Curves[i] = NULL;
-
-    for (i=0; i < nCurves; i++) {
-
-        Curves[i] = ReadEmbeddedCurve(self, io);                     
-        if (Curves[i] == NULL) goto Error;
-        if (!_cmsReadAlignment(io)) goto Error;   
-    }
-    
-    Lin = cmsStageAllocToneCurves(self ->ContextID, nCurves, Curves);
-    
-Error:
-    for (i=0; i < nCurves; i++) 
-        cmsFreeToneCurve(Curves[i]);
-
-    return Lin;
-}
-
-
-// LutAtoB type 
-
-// This structure represents a colour transform. The type contains up to five processing 
-// elements which are stored in the AtoBTag tag in the following order: a set of one 
-// dimensional curves, a 3 by 3 matrix with offset terms, a set of one dimensional curves, 
-// a multidimensional lookup table, and a set of one dimensional output curves.
-// Data are processed using these elements via the following sequence:
-//
-//("A" curves) -> (multidimensional lookup table - CLUT) -> ("M" curves) -> (matrix) -> ("B" curves).
-//
-/*
-It is possible to use any or all of these processing elements. At least one processing element 
-must be included.Only the following combinations are allowed:
-
-B
-M - Matrix - B
-A - CLUT - B
-A - CLUT - M - Matrix - B
-
-*/
-
-static
-void* Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt32Number      BaseOffset;
-    cmsUInt8Number       inputChan;      // Number of input channels     
-    cmsUInt8Number       outputChan;     // Number of output channels     
-    cmsUInt32Number      offsetB;        // Offset to first "B" curve    
-    cmsUInt32Number      offsetMat;      // Offset to matrix             
-    cmsUInt32Number      offsetM;        // Offset to first "M" curve    
-    cmsUInt32Number      offsetC;        // Offset to CLUT               
-    cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
-    cmsPipeline* NewLUT = NULL;
-
-
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;
-    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;
-    
-    if (!_cmsReadUInt16Number(io, NULL)) return NULL;
-    
-    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;
-
-   // Allocates an empty LUT
-    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);
-    if (NewLUT == NULL) return NULL;
-
-    if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan);
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetMat != 0) {           
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetB != 0) {                                        
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-      
-    *nItems = 1;
-    return NewLUT;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-// Write a set of curves
-static
-cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)
-{   
-    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;
-
-    // Write the Matrix
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;
-
-    if (m ->Offset != NULL) {
-
-    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;
-    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;
-    }
-    else {
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
-
-    }
-
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// Write a set of curves
-static
-cmsBool WriteSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsTagTypeSignature Type, cmsStage* mpe)
-{   
-    cmsUInt32Number i, n;
-    cmsTagTypeSignature CurrentType;
-    cmsToneCurve** Curves;
-
-
-    n      = cmsStageOutputChannels(mpe);
-    Curves = _cmsStageGetPtrToCurveSet(mpe);
-
-    for (i=0; i < n; i++) {
-
-        // If this is a table-based curve, use curve type even on V4
-        CurrentType = Type;
-
-        if (Curves[i] ->nSegments == 0)
-            CurrentType = cmsSigCurveType;
-        else
-        if (Curves[i] ->Segments[0].Type < 0)
-            CurrentType = cmsSigCurveType;
-
-        if (!_cmsWriteTypeBase(io, CurrentType)) return FALSE;
-
-        switch (CurrentType) {
-
-            case cmsSigCurveType:
-                if (!Type_Curve_Write(self, io, Curves[i], 1)) return FALSE;
-                break;
-
-            case cmsSigParametricCurveType:
-                if (!Type_ParametricCurve_Write(self, io, Curves[i], 1)) return FALSE;
-                break;
-
-            default: 
-                {
-                    char String[5];
-
-                    _cmsTagSignature2String(String, (cmsTagSignature) Type);
-                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown curve type '%s'", String);
-                }               
-                return FALSE;
-        }
-
-        if (!_cmsWriteAlignment(io)) return FALSE;
-    }
-
-
-    return TRUE;
-}
-
-
-static
-cmsBool WriteCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt8Number  Precision, cmsStage* mpe)
-{
-    cmsUInt8Number  gridPoints[cmsMAXCHANNELS]; // Number of grid points in each dimension.  
-    cmsUInt32Number i;    
-    _cmsStageCLutData* CLUT = ( _cmsStageCLutData*) mpe -> Data;
-
-    if (CLUT ->HasFloatValues) {
-         cmsSignalError(self ->ContextID, cmsERROR_NOT_SUITABLE, "Cannot save floating point data, CLUT are 8 or 16 bit only"); 
-         return FALSE;
-    }
-
-    memset(gridPoints, 0, sizeof(gridPoints));
-    for (i=0; i < (cmsUInt32Number) CLUT ->Params ->nInputs; i++) 
-        gridPoints[i] = (cmsUInt8Number) CLUT ->Params ->nSamples[i];
-
-    if (!io -> Write(io, cmsMAXCHANNELS*sizeof(cmsUInt8Number), gridPoints)) return FALSE;
-
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) Precision)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;
-
-    // Precision can be 1 or 2 bytes
-    if (Precision == 1) {
-
-        for (i=0; i < CLUT->nEntries; i++) {
-
-            if (!_cmsWriteUInt8Number(io, FROM_16_TO_8(CLUT->Tab.T[i]))) return FALSE;                
-        }
-    }
-    else  
-        if (Precision == 2) {
-
-            if (!_cmsWriteUInt16Array(io, CLUT->nEntries, CLUT ->Tab.T)) return FALSE;
-        }
-        else {
-             cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown precision of '%d'", Precision); 
-            return FALSE;
-        }
-
-        if (!_cmsWriteAlignment(io)) return FALSE;
-
-        return TRUE;
-}
-
-
-
-
-static
-cmsBool Type_LUTA2B_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsPipeline* Lut = (cmsPipeline*) Ptr;
-    int inputChan, outputChan;
-    cmsStage *A = NULL, *B = NULL, *M = NULL;
-    cmsStage * Matrix = NULL;
-    cmsStage * CLUT = NULL;
-    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;
-    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;
-
-    // Get the base for all offsets
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    if (Lut ->Elements != NULL)
-        if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))
-            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &M, &Matrix, &B))          
-                if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &A, &CLUT, &B))              
-                    if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, 
-                        cmsSigMatrixElemType, cmsSigCurveSetElemType, &A, &CLUT, &M, &Matrix, &B)) {    
-
-                            cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, "LUT is not suitable to be saved as LutAToB");
-                            return FALSE;
-                    }
-
-    // Get input, output channels
-    inputChan  = cmsPipelineInputChannels(Lut);
-    outputChan = cmsPipelineOutputChannels(Lut);
-
-    // Write channel count
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;
-    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
-
-    // Keep directory to be filled latter
-    DirectoryPos = io ->Tell(io);
-
-    // Write the directory
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-
-    if (A != NULL) {
-
-        offsetA = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;
-    }
-    
-    if (CLUT != NULL) {
-        offsetC = io ->Tell(io) - BaseOffset;
-        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;
-
-    }
-    if (M != NULL) {
-
-        offsetM = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;
-    }
-    
-    if (Matrix != NULL) {
-        offsetMat = io ->Tell(io) - BaseOffset;
-        if (!WriteMatrix(self, io, Matrix)) return FALSE;
-    }
-
-    if (B != NULL) {
-
-        offsetB = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;
-    }
-    
-    CurrentPos = io ->Tell(io);
-
-    if (!io ->Seek(io, DirectoryPos)) return FALSE;
-
-    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;
-
-    if (!io ->Seek(io, CurrentPos)) return FALSE;
-    
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_LUTA2B_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_LUTA2B_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsPipelineFree((cmsPipeline*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// LutBToA type 
-
-static
-void* Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt8Number       inputChan;      // Number of input channels     
-    cmsUInt8Number       outputChan;     // Number of output channels     
-    cmsUInt32Number      BaseOffset;     // Actual position in file
-    cmsUInt32Number      offsetB;        // Offset to first "B" curve    
-    cmsUInt32Number      offsetMat;      // Offset to matrix             
-    cmsUInt32Number      offsetM;        // Offset to first "M" curve    
-    cmsUInt32Number      offsetC;        // Offset to CLUT               
-    cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
-    cmsPipeline* NewLUT = NULL;
-
-
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;
-    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;
-
-    // Padding
-    if (!_cmsReadUInt16Number(io, NULL)) return NULL;
-    
-    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;
-    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;
-
-    // Allocates an empty LUT
-    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);
-    if (NewLUT == NULL) return NULL;
-    
-    if (offsetB != 0) {                                        
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetMat != 0) {           
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan);
-        if (mpe != NULL) cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    *nItems = 1;
-    return NewLUT;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-/*
-B
-B - Matrix - M
-B - CLUT - A
-B - Matrix - M - CLUT - A
-*/
-
-static
-cmsBool  Type_LUTB2A_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsPipeline* Lut = (cmsPipeline*) Ptr;
-    int inputChan, outputChan;
-    cmsStage *A = NULL, *B = NULL, *M = NULL;
-    cmsStage *Matrix = NULL;
-    cmsStage *CLUT = NULL;
-    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;
-    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;
-
-
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))
-        if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &B, &Matrix, &M))          
-            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &CLUT, &A))              
-                if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, 
-                    cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &Matrix, &M, &CLUT, &A)) {                 
-                        cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, "LUT is not suitable to be saved as LutBToA");
-                        return FALSE;
-                }
-
-    inputChan  = cmsPipelineInputChannels(Lut);
-    outputChan = cmsPipelineOutputChannels(Lut);
-    
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;
-    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;
-    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
-
-    DirectoryPos = io ->Tell(io);
-
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;  
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;  
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-
-    if (A != NULL) {
-
-        offsetA = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;
-    }
-    
-    if (CLUT != NULL) {
-        offsetC = io ->Tell(io) - BaseOffset;
-        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;
-
-    }
-    if (M != NULL) {
-
-        offsetM = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;
-    }
-    
-    if (Matrix != NULL) {
-        offsetMat = io ->Tell(io) - BaseOffset;
-        if (!WriteMatrix(self, io, Matrix)) return FALSE;    
-    }
-
-    if (B != NULL) {
-
-        offsetB = io ->Tell(io) - BaseOffset;
-        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;
-    }
-    
-    CurrentPos = io ->Tell(io);
-
-    if (!io ->Seek(io, DirectoryPos)) return FALSE;
-
-    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;
-
-    if (!io ->Seek(io, CurrentPos)) return FALSE;
-    
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-
-static
-void* Type_LUTB2A_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_LUTB2A_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsPipelineFree((cmsPipeline*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-
-// ********************************************************************************
-// Type cmsSigColorantTableType
-// ********************************************************************************
-/*
-The purpose of this tag is to identify the colorants used in the profile by a 
-unique name and set of XYZ or L*a*b* values to give the colorant an unambiguous 
-value. The first colorant listed is the colorant of the first device channel of
-a lut tag. The second colorant listed is the colorant of the second device channel
-of a lut tag, and so on.
-*/
-
-static
-void *Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUInt32Number i, Count;
-    cmsNAMEDCOLORLIST* List;
-    char Name[34];
-    cmsUInt16Number PCS[3]; 
-
-
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;
-
-    if (Count > cmsMAXCHANNELS) {
-        cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many colorants '%d'", Count);
-        return NULL;
-    }
-
-    List = cmsAllocNamedColorList(self ->ContextID, Count, 0, "", "");
-    for (i=0; i < Count; i++) {
-
-        if (io ->Read(io, Name, 32, 1) != 1) goto Error;
-        Name[33] = 0;
-
-        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;
-
-        if (!cmsAppendNamedColor(List, Name, PCS, NULL)) goto Error; 
-                                                            
-    }
-
-    *nItems = 1;
-    return List;
-
-Error:
-    *nItems = 0;
-    cmsFreeNamedColorList(List);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-
-// Saves a colorant table. It is using the named color structure for simplicity sake
-static
-cmsBool  Type_ColorantTable_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr; 
-    int i, nColors;
-
-    nColors = cmsNamedColorCount(NamedColorList);
-
-    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;
-
-    for (i=0; i < nColors; i++) {
-
-        char root[33];
-        cmsUInt16Number PCS[3]; 
-
-        if (!cmsNamedColorInfo(NamedColorList, i, root, NULL, NULL, PCS, NULL)) return 0;
-        root[32] = 0;
-
-        if (!io ->Write(io, 32, root)) return FALSE;
-        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_ColorantTable_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)
-{
-    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;
-    return (void*) cmsDupNamedColorList(nc); 
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void Type_ColorantTable_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigNamedColor2Type
-// ********************************************************************************
-//
-//The namedColor2Type is a count value and array of structures that provide color 
-//coordinates for 7-bit ASCII color names. For each named color, a PCS and optional 
-//device representation of the color are given. Both representations are 16-bit values. 
-//The device representation corresponds to the headers color space of data field. 
-//This representation should be consistent with the number of device components
-//field in the namedColor2Type. If this field is 0, device coordinates are not provided.
-//The PCS representation corresponds to the headers PCS field. The PCS representation 
-//is always provided. Color names are fixed-length, 32-byte fields including null 
-//termination. In order to maintain maximum portability, it is strongly recommended 
-//that special characters of the 7-bit ASCII set not be used.
-
-static
-void *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-
-    cmsUInt32Number      vendorFlag;     // Bottom 16 bits for ICC use 
-    cmsUInt32Number      count;          // Count of named colors 
-    cmsUInt32Number      nDeviceCoords;  // Num of device coordinates 
-    char                 prefix[32];     // Prefix for each color name 
-    char                 suffix[32];     // Suffix for each color name 
-    cmsNAMEDCOLORLIST*  v;
-    cmsUInt32Number i;
-
-
-    *nItems = 0;
-    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;
-    if (!_cmsReadUInt32Number(io, &count)) return NULL;
-    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;
-
-    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;
-    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;
-
-    prefix[31] = suffix[31] = 0;
-
-    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);
-    if (v == NULL) {
-        cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many named colors '%d'", count);
-        return NULL;
-    }
-
-    if (nDeviceCoords > cmsMAXCHANNELS) {
-        cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many device coordinates '%d'", nDeviceCoords);
-        return 0;
-    }
-    for (i=0; i < count; i++) {
-
-        cmsUInt16Number PCS[3];
-        cmsUInt16Number Colorant[cmsMAXCHANNELS];
-        char Root[33];
-
-        memset(Colorant, 0, sizeof(Colorant));
-        if (io -> Read(io, Root, 32, 1) != 1) return NULL;
-        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;
-        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;
-
-        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;
-    }
-
-    *nItems = 1;
-    return (void*) v ;
-
-Error:
-    cmsFreeNamedColorList(v);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-// Saves a named color list into a named color profile
-static
-cmsBool Type_NamedColor_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;
-    char                prefix[32];     // Prefix for each color name 
-    char                suffix[32];     // Suffix for each color name 
-    int i, nColors;
-
-    nColors = cmsNamedColorCount(NamedColorList);
-
-    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, NamedColorList ->ColorantCount)) return FALSE;
-
-    strncpy(prefix, (const char*) NamedColorList->Prefix, 32);
-    strncpy(suffix, (const char*) NamedColorList->Suffix, 32);
-
-    suffix[31] = prefix[31] = 0;
-
-    if (!io ->Write(io, 32, prefix)) return FALSE;
-    if (!io ->Write(io, 32, suffix)) return FALSE;
-
-    for (i=0; i < nColors; i++) {
-
-       cmsUInt16Number PCS[3];
-       cmsUInt16Number Colorant[cmsMAXCHANNELS];
-       char Root[33];
-
-        if (!cmsNamedColorInfo(NamedColorList, i, Root, NULL, NULL, PCS, Colorant)) return 0;
-        if (!io ->Write(io, 32 , Root)) return FALSE;
-        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;   
-        if (!_cmsWriteUInt16Array(io, NamedColorList ->ColorantCount, Colorant)) return FALSE;
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void* Type_NamedColor_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)
-{
-    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;
-
-    return (void*) cmsDupNamedColorList(nc);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigProfileSequenceDescType
-// ********************************************************************************
-
-// This type is an array of structures, each of which contains information from the 
-// header fields and tags from the original profiles which were combined to create 
-// the final profile. The order of the structures is the order in which the profiles 
-// were combined and includes a structure for the final profile. This provides a 
-// description of the profile sequence from source to destination, 
-// typically used with the DeviceLink profile.
-
-static
-cmsBool ReadEmbeddedText(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU** mlu, cmsUInt32Number SizeOfTag)
-{
-    cmsTagTypeSignature  BaseType;
-    cmsUInt32Number nItems;
-
-    BaseType = _cmsReadTypeBase(io); 
-
-    switch (BaseType) {
-
-       case cmsSigTextType:
-           if (*mlu) cmsMLUfree(*mlu);
-           *mlu = (cmsMLU*)Type_Text_Read(self, io, &nItems, SizeOfTag);
-           return (*mlu != NULL); 
-
-       case cmsSigTextDescriptionType:
-           if (*mlu) cmsMLUfree(*mlu);
-           *mlu =  (cmsMLU*) Type_Text_Description_Read(self, io, &nItems, SizeOfTag);
-           return (*mlu != NULL); 
-
-           /*
-           TBD: Size is needed for MLU, and we have no idea on which is the available size
-           */
-
-       case cmsSigMultiLocalizedUnicodeType:
-           if (*mlu) cmsMLUfree(*mlu);
-           *mlu =  (cmsMLU*) Type_MLU_Read(self, io, &nItems, SizeOfTag);
-           return (*mlu != NULL);
-
-       default: return FALSE;
-    }
-}
-
-
-static
-void *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsSEQ* OutSeq;
-    cmsUInt32Number i, Count;
-    
-    *nItems = 0;
-    
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;  
-
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-    SizeOfTag -= sizeof(cmsUInt32Number);
-
-   
-    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);
-    if (OutSeq == NULL) return NULL;
-
-    OutSeq ->n = Count;
-    
-    // Get structures as well
-
-    for (i=0; i < Count; i++) {
-        
-        cmsPSEQDESC* sec = &OutSeq -> seq[i];
-
-        if (!_cmsReadUInt32Number(io, &sec ->deviceMfg)) return NULL;
-        if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-        SizeOfTag -= sizeof(cmsUInt32Number);
-
-        if (!_cmsReadUInt32Number(io, &sec ->deviceModel)) return NULL;
-        if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-        SizeOfTag -= sizeof(cmsUInt32Number);
-
-        if (!_cmsReadUInt64Number(io, &sec ->attributes)) return NULL;        
-        if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-        SizeOfTag -= sizeof(cmsUInt64Number);
-
-        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) return NULL;
-        if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-        SizeOfTag -= sizeof(cmsUInt32Number);
-
-        if (!ReadEmbeddedText(self, io, &sec ->Manufacturer, SizeOfTag)) return NULL;
-        if (!ReadEmbeddedText(self, io, &sec ->Model, SizeOfTag)) return NULL;
-    }
-
-    *nItems = 1;
-    return OutSeq;
-}
-
-
-// Aux--Embed a text description type. It can be of type text description or multilocalized unicode
-// and it depends of the version number passed on cmsTagDescriptor structure instead of stack
-static
-cmsBool  SaveDescription(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* Text)
-{
-    if (self ->ICCVersion < 0x4000000) { 
-        
-        if (!_cmsWriteTypeBase(io, cmsSigTextDescriptionType)) return FALSE;
-        return Type_Text_Description_Write(self, io, Text, 1);
-    }
-    else {
-        if (!_cmsWriteTypeBase(io, cmsSigMultiLocalizedUnicodeType)) return FALSE;
-        return Type_MLU_Write(self, io, Text, 1);
-    }
-}
-
-
-static
-cmsBool  Type_ProfileSequenceDesc_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsSEQ* Seq = (cmsSEQ*) Ptr;
-    cmsUInt32Number i;
-
-    if (!_cmsWriteUInt32Number(io, Seq->n)) return FALSE;
-    
-    for (i=0; i < Seq ->n; i++) {
-
-        cmsPSEQDESC* sec = &Seq -> seq[i];
-
-        if (!_cmsWriteUInt32Number(io, sec ->deviceMfg)) return FALSE;
-        if (!_cmsWriteUInt32Number(io, sec ->deviceModel)) return FALSE;
-        if (!_cmsWriteUInt64Number(io, sec ->attributes)) return FALSE;        
-        if (!_cmsWriteUInt32Number(io, sec ->technology)) return FALSE;
-        
-        if (!SaveDescription(self, io, sec ->Manufacturer)) return FALSE;       
-        if (!SaveDescription(self, io, sec ->Model)) return FALSE;          
-    }
-    
-     return TRUE;  
-
-     cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)
-{   
-    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_ProfileSequenceDesc_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigProfileSequenceIdType
-// ********************************************************************************
-/*
-In certain workflows using ICC Device Link Profiles, it is necessary to identify the 
-original profiles that were combined to create the Device Link Profile.
-This type is an array of structures, each of which contains information for 
-identification of a profile used in a sequence
-*/
-
-
-static
-cmsBool ReadSeqID(struct _cms_typehandler_struct* self, 
-                                             cmsIOHANDLER* io,
-                                             void* Cargo,
-                                             cmsUInt32Number n, 
-                                             cmsUInt32Number SizeOfTag)
-{
-    cmsSEQ* OutSeq = (cmsSEQ*) Cargo;
-    cmsPSEQDESC* seq = &OutSeq ->seq[n];
-    
-    if (io -> Read(io, seq ->ProfileID.ID8, 16, 1) != 1) return FALSE;
-    if (!ReadEmbeddedText(self, io, &seq ->Description, SizeOfTag)) return FALSE;
-
-    return TRUE;
-}
-
-
-
-static
-void *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsSEQ* OutSeq;
-    cmsUInt32Number Count;
-    cmsUInt32Number BaseOffset;
-
-    *nItems = 0;
-
-    // Get actual position as a basis for element offsets
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    // Get table count
-    if (!_cmsReadUInt32Number(io, &Count)) return NULL;  
-    SizeOfTag -= sizeof(cmsUInt32Number);
-
-    // Allocate an empty structure
-    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);
-    if (OutSeq == NULL) return NULL;
-
-
-    // Read the position table
-    if (!ReadPositionTable(self, io, Count, BaseOffset, OutSeq, ReadSeqID)) {
-
-        cmsFreeProfileSequenceDescription(OutSeq);
-        return NULL;
-    }
-
-    // Success
-    *nItems = 1;
-    return OutSeq;
-
-}
-
-
-static
-cmsBool WriteSeqID(struct _cms_typehandler_struct* self, 
-                                             cmsIOHANDLER* io,
-                                             void* Cargo,
-                                             cmsUInt32Number n, 
-                                             cmsUInt32Number SizeOfTag)
-{
-    cmsSEQ* Seq = (cmsSEQ*) Cargo;
-    
-    if (!io ->Write(io, 16, Seq ->seq[n].ProfileID.ID8)) return FALSE;
-
-    // Store here the MLU
-    if (!SaveDescription(self, io, Seq ->seq[n].Description)) return FALSE;  
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool  Type_ProfileSequenceId_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsSEQ* Seq = (cmsSEQ*) Ptr;
-    cmsUInt32Number BaseOffset;
-
-    // Keep the base offset
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-    
-    // This is the table count
-    if (!_cmsWriteUInt32Number(io, Seq ->n)) return FALSE;
-
-    // This is the position table and content
-    if (!WritePositionTable(self, io, 0, Seq ->n, BaseOffset, Seq, WriteSeqID)) return FALSE;
-          
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)
-{   
-    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_ProfileSequenceId_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{    
-    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigUcrBgType
-// ********************************************************************************
-/*
-This type contains curves representing the under color removal and black
-generation and a text string which is a general description of the method used
-for the ucr/bg.
-*/
-
-static
-void *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsUcrBg* n = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));
-    cmsUInt32Number CountUcr, CountBg;
-    char* ASCIIString;
-
-    *nItems = 0;
-    if (n == NULL) return NULL;
-
-    // First curve is Under color removal
-    if (!_cmsReadUInt32Number(io, &CountUcr)) return NULL;
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-    SizeOfTag -= sizeof(cmsUInt32Number);
-
-    n ->Ucr = cmsBuildTabulatedToneCurve16(self ->ContextID, CountUcr, NULL);
-    if (n ->Ucr == NULL) return NULL;
-
-    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) return NULL;
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-    SizeOfTag -= CountUcr * sizeof(cmsUInt16Number);
-
-    // Second curve is Black generation
-    if (!_cmsReadUInt32Number(io, &CountBg)) return NULL;
-    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
-    SizeOfTag -= sizeof(cmsUInt32Number);
-
-    n ->Bg = cmsBuildTabulatedToneCurve16(self ->ContextID, CountBg, NULL);
-    if (n ->Bg == NULL) return NULL;
-    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) return NULL;
-    if (SizeOfTag < CountBg * sizeof(cmsUInt16Number)) return NULL;
-    SizeOfTag -= CountBg * sizeof(cmsUInt16Number);
-    if (SizeOfTag == UINT_MAX) return NULL;
-
-    // Now comes the text. The length is specified by the tag size
-    n ->Desc = cmsMLUalloc(self ->ContextID, 1);
-    if (n ->Desc == NULL) return NULL;
-
-    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);
-    if (io ->Read(io, ASCIIString, sizeof(char), SizeOfTag) != SizeOfTag) return NULL;
-    ASCIIString[SizeOfTag] = 0;
-    cmsMLUsetASCII(n ->Desc, cmsNoLanguage, cmsNoCountry, ASCIIString);
-    _cmsFree(self ->ContextID, ASCIIString);
-
-    *nItems = 1;
-    return (void*) n;
-}
-
-static
-cmsBool  Type_UcrBg_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsUcrBg* Value = (cmsUcrBg*) Ptr;
-    cmsUInt32Number TextSize;
-    char* Text;
-
-    // First curve is Under color removal
-    if (!_cmsWriteUInt32Number(io, Value ->Ucr ->nEntries)) return FALSE;
-    if (!_cmsWriteUInt16Array(io, Value ->Ucr ->nEntries, Value ->Ucr ->Table16)) return FALSE;
-
-    // Then black generation    
-    if (!_cmsWriteUInt32Number(io, Value ->Bg ->nEntries)) return FALSE;
-    if (!_cmsWriteUInt16Array(io, Value ->Bg ->nEntries, Value ->Bg ->Table16)) return FALSE;
-
-    // Now comes the text. The length is specified by the tag size
-    TextSize = cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, NULL, 0);
-    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);
-    if (cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, Text, TextSize) != TextSize) return FALSE;
-
-    if (!io ->Write(io, TextSize, Text)) return FALSE;      
-    _cmsFree(self ->ContextID, Text);
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    cmsUcrBg* Src = (cmsUcrBg*) Ptr;
-    cmsUcrBg* NewUcrBg = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));
-
-    if (NewUcrBg == NULL) return NULL;
-
-    NewUcrBg ->Bg   = cmsDupToneCurve(Src ->Bg);
-    NewUcrBg ->Ucr  = cmsDupToneCurve(Src ->Ucr);
-    NewUcrBg ->Desc = cmsMLUdup(Src ->Desc);
-
-    return (void*) NewUcrBg;
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-static
-void Type_UcrBg_Free(struct _cms_typehandler_struct* self, void *Ptr)
-{
-   cmsUcrBg* Src = (cmsUcrBg*) Ptr;
-   
-   if (Src ->Ucr) cmsFreeToneCurve(Src ->Ucr);
-   if (Src ->Bg)  cmsFreeToneCurve(Src ->Bg);
-   if (Src ->Desc) cmsMLUfree(Src ->Desc);
-   
-   _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigCrdInfoType
-// ********************************************************************************
-
-/*
-This type contains the PostScript product name to which this profile corresponds
-and the names of the companion CRDs. Recall that a single profile can generate
-multiple CRDs. It is implemented as a MLU being the language code "PS" and then
-country varies for each element:
-
-                nm: PostScript product name
-                #0: Rendering intent 0 CRD name
-                #1: Rendering intent 1 CRD name
-                #2: Rendering intent 2 CRD name
-                #3: Rendering intent 3 CRD name
-*/
-
-
-
-// Auxiliar, read an string specified as count + string
-static
-cmsBool  ReadCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)
-{
-    cmsUInt32Number Count;
-    char* Text;
-
-    if (*SizeOfTag < sizeof(cmsUInt32Number)) return FALSE; 
-    
-    if (!_cmsReadUInt32Number(io, &Count)) return FALSE;
-
-    if (Count > UINT_MAX - sizeof(cmsUInt32Number)) return FALSE;
-    if (*SizeOfTag < Count + sizeof(cmsUInt32Number)) return FALSE; 
-
-    Text     = (char*) _cmsMalloc(self ->ContextID, Count+1);
-    if (Text == NULL) return FALSE;
-
-    if (io ->Read(io, Text, sizeof(cmsUInt8Number), Count) != Count) {
-        _cmsFree(self ->ContextID, Text);
-        return FALSE;
-    }
-
-    Text[Count] = 0;
-   
-    cmsMLUsetASCII(mlu, "PS", Section, Text);
-    _cmsFree(self ->ContextID, Text);
-
-    *SizeOfTag -= (Count + sizeof(cmsUInt32Number));
-    return TRUE;    
-}
-
-static
-cmsBool  WriteCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)
-{
- cmsUInt32Number TextSize;
- char* Text;    
-    
-    TextSize = cmsMLUgetASCII(mlu, "PS", Section, NULL, 0);
-    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);
-
-    if (!_cmsWriteUInt32Number(io, TextSize)) return FALSE; 
-
-    if (cmsMLUgetASCII(mlu, "PS", Section, Text, TextSize) == 0) return FALSE;
-
-    if (!io ->Write(io, TextSize, Text)) return FALSE;      
-    _cmsFree(self ->ContextID, Text);
-
-    return TRUE;
-}
-
-static
-void *Type_CrdInfo_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsMLU* mlu = cmsMLUalloc(self ->ContextID, 5);
-
-    *nItems = 0;
-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, "nm")) goto Error;
-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, "#0")) goto Error;
-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, "#1")) goto Error;
-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, "#2")) goto Error;
-    if (!ReadCountAndSting(self, io, mlu, &SizeOfTag, "#3")) goto Error;
-  
-    *nItems = 1;
-    return (void*) mlu;
-
-Error:
-    cmsMLUfree(mlu);
-    return NULL;
-
-}
-
-static
-cmsBool  Type_CrdInfo_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-
-    cmsMLU* mlu = (cmsMLU*) Ptr;
-
-    if (!WriteCountAndSting(self, io, mlu, "nm")) goto Error;
-    if (!WriteCountAndSting(self, io, mlu, "#0")) goto Error;
-    if (!WriteCountAndSting(self, io, mlu, "#1")) goto Error;
-    if (!WriteCountAndSting(self, io, mlu, "#2")) goto Error;
-    if (!WriteCountAndSting(self, io, mlu, "#3")) goto Error;
-
-    return TRUE;
-
-Error:
-    return FALSE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_CrdInfo_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsMLUdup((cmsMLU*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_CrdInfo_Free(struct _cms_typehandler_struct* self, void *Ptr)
-{    
-    cmsMLUfree((cmsMLU*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-// ********************************************************************************
-// Type cmsSigScreeningType
-// ********************************************************************************
-//
-//The screeningType describes various screening parameters including screen
-//frequency, screening angle, and spot shape.
-
-static
-void *Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsScreening* sc = NULL;
-    cmsUInt32Number i;
-    
-    sc = (cmsScreening*) _cmsMallocZero(self ->ContextID, sizeof(cmsScreening));
-    if (sc == NULL) return NULL;
-
-    *nItems = 0;
-    
-    if (!_cmsReadUInt32Number(io, &sc ->Flag)) goto Error;
-    if (!_cmsReadUInt32Number(io, &sc ->nChannels)) goto Error;
-
-    if (sc ->nChannels > cmsMAXCHANNELS - 1)
-        sc ->nChannels = cmsMAXCHANNELS - 1;
-
-    for (i=0; i < sc ->nChannels; i++) {
-
-        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].Frequency)) goto Error;      
-        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].ScreenAngle)) goto Error;        
-        if (!_cmsReadUInt32Number(io, &sc ->Channels[i].SpotShape)) goto Error;
-    }
-
-
-    *nItems = 1;
-
-    return (void*) sc;
-
-Error:
-    if (sc != NULL) 
-        _cmsFree(self ->ContextID, sc);
-
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-static
-cmsBool Type_Screening_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsScreening* sc = (cmsScreening* ) Ptr; 
-    cmsUInt32Number i;
-        
-    if (!_cmsWriteUInt32Number(io, sc ->Flag)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, sc ->nChannels)) return FALSE;
-
-    for (i=0; i < sc ->nChannels; i++) {
-
-        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].Frequency)) return FALSE;
-        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].ScreenAngle)) return FALSE;
-        if (!_cmsWriteUInt32Number(io, sc ->Channels[i].SpotShape)) return FALSE;
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_Screening_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-   return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsScreening));
-
-   cmsUNUSED_PARAMETER(n);
-}
-
-
-static
-void Type_Screening_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-   _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type cmsSigViewingConditionsType
-// ********************************************************************************
-//
-//This type represents a set of viewing condition parameters including: 
-//CIE absolute illuminant white point tristimulus values and CIE absolute 
-//surround tristimulus values.
-
-static
-void *Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsICCViewingConditions* vc = NULL;
-    
-    vc = (cmsICCViewingConditions*) _cmsMallocZero(self ->ContextID, sizeof(cmsICCViewingConditions));
-    if (vc == NULL) return NULL;
-
-    *nItems = 0;
-        
-    if (!_cmsReadXYZNumber(io, &vc ->IlluminantXYZ)) goto Error;
-    if (!_cmsReadXYZNumber(io, &vc ->SurroundXYZ)) goto Error;
-    if (!_cmsReadUInt32Number(io, &vc ->IlluminantType)) goto Error;
-
-    *nItems = 1;
-
-    return (void*) vc;
-
-Error:
-    if (vc != NULL) 
-        _cmsFree(self ->ContextID, vc);
-
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-static
-cmsBool Type_ViewingConditions_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsICCViewingConditions* sc = (cmsICCViewingConditions* ) Ptr; 
-            
-    if (!_cmsWriteXYZNumber(io, &sc ->IlluminantXYZ)) return FALSE;
-    if (!_cmsWriteXYZNumber(io, &sc ->SurroundXYZ)) return FALSE;
-    if (!_cmsWriteUInt32Number(io, sc ->IlluminantType)) return FALSE;
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-static
-void* Type_ViewingConditions_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-   return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsScreening));
-
-   cmsUNUSED_PARAMETER(n);
-}
-
-
-static
-void Type_ViewingConditions_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-   _cmsFree(self ->ContextID, Ptr);
-}
-
-
-// ********************************************************************************
-// Type cmsSigMultiProcessElementType
-// ********************************************************************************
-
-
-static
-void* GenericMPEdup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsStageDup((cmsStage*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void GenericMPEfree(struct _cms_typehandler_struct* self, void *Ptr)
-{    
-    cmsStageFree((cmsStage*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-// Each curve is stored in one or more curve segments, with break-points specified between curve segments.
-// The first curve segment always starts at Infinity, and the last curve segment always ends at +Infinity. The
-// first and last curve segments shall be specified in terms of a formula, whereas the other segments shall be
-// specified either in terms of a formula, or by a sampled curve.
-
-
-// Read an embedded segmented curve
-static
-cmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)
-{   
-    cmsCurveSegSignature ElementSig;
-    cmsUInt32Number i, j;
-    cmsUInt16Number nSegments;
-    cmsCurveSegment*  Segments;
-    cmsToneCurve* Curve;
-    cmsFloat32Number PrevBreak = -1E22F;    // - infinite
- 
-    // Take signature and channels for each element.
-     if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return NULL;    
-
-     // That should be a segmented curve
-     if (ElementSig != cmsSigSegmentedCurve) return NULL;
-
-     if (!_cmsReadUInt32Number(io, NULL)) return NULL;
-     if (!_cmsReadUInt16Number(io, &nSegments)) return NULL;
-     if (!_cmsReadUInt16Number(io, NULL)) return NULL;
-
-     if (nSegments < 1) return NULL;
-     Segments = (cmsCurveSegment*) _cmsCalloc(self ->ContextID, nSegments, sizeof(cmsCurveSegment));
-     if (Segments == NULL) return NULL;
-
-     // Read breakpoints
-     for (i=0; i < (cmsUInt32Number) nSegments - 1; i++) {
-
-         Segments[i].x0 = PrevBreak;
-         if (!_cmsReadFloat32Number(io, &Segments[i].x1)) goto Error;
-         PrevBreak = Segments[i].x1;
-     }
-
-     Segments[nSegments-1].x0 = PrevBreak;
-     Segments[nSegments-1].x1 = 1E22F;     // A big cmsFloat32Number number
-
-     // Read segments
-     for (i=0; i < nSegments; i++) {
-
-          if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) goto Error;
-          if (!_cmsReadUInt32Number(io, NULL)) goto Error;
-         
-           switch (ElementSig) {
-
-            case cmsSigFormulaCurveSeg: {
-                                       
-                cmsUInt16Number Type;
-                cmsUInt32Number ParamsByType[] = {4, 5, 5 };
-
-                if (!_cmsReadUInt16Number(io, &Type)) goto Error;
-                if (!_cmsReadUInt16Number(io, NULL)) goto Error;
-
-                Segments[i].Type = Type + 6;
-                if (Type > 2) goto Error;
-
-                for (j=0; j < ParamsByType[Type]; j++) {
-
-                    cmsFloat32Number f;
-                    if (!_cmsReadFloat32Number(io, &f)) goto Error;
-                    Segments[i].Params[j] = f;
-                }
-                }
-                break;
-
-
-            case cmsSigSampledCurveSeg: {
-                cmsUInt32Number Count;
-
-                if (!_cmsReadUInt32Number(io, &Count)) return NULL;
-
-                Segments[i].nGridPoints = Count;
-                Segments[i].SampledPoints = (cmsFloat32Number*) _cmsCalloc(self ->ContextID, Count, sizeof(cmsFloat32Number));
-                if (Segments[i].SampledPoints == NULL) goto Error;
-
-                for (j=0; j < Count; j++) {
-                    if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;
-                }
-                }
-                break;
-
-            default:
-                {
-                char String[5];
-
-                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);
-                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown curve element type '%s' found.", String);
-                }
-                return NULL;                
-
-         }
-     }
-
-     Curve = cmsBuildSegmentedToneCurve(self ->ContextID, nSegments, Segments);
-
-     for (i=0; i < nSegments; i++) {
-         if (Segments[i].SampledPoints) _cmsFree(self ->ContextID, Segments[i].SampledPoints);
-     }
-     _cmsFree(self ->ContextID, Segments);
-     return Curve;
-
-Error:
-     if (Segments) _cmsFree(self ->ContextID, Segments);
-     return NULL;
-}
-
-
-static
-cmsBool ReadMPECurve(struct _cms_typehandler_struct* self, 
-                     cmsIOHANDLER* io,
-                     void* Cargo,
-                     cmsUInt32Number n, 
-                     cmsUInt32Number SizeOfTag)
-{
-      cmsToneCurve** GammaTables = ( cmsToneCurve**) Cargo;
-
-      GammaTables[n] = ReadSegmentedCurve(self, io);
-      return (GammaTables[n] != NULL);
-
-      cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-void *Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsStage* mpe = NULL;
-    cmsUInt16Number InputChans, OutputChans;
-    cmsUInt32Number i, BaseOffset;
-    cmsToneCurve** GammaTables;
-
-    *nItems = 0;
-
-    // Get actual position as a basis for element offsets
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
-    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
-
-    if (InputChans != OutputChans) return NULL;
-
-    GammaTables = (cmsToneCurve**) _cmsCalloc(self ->ContextID, InputChans, sizeof(cmsToneCurve*));
-    if (GammaTables == NULL) return NULL;
-
-    if (ReadPositionTable(self, io, InputChans, BaseOffset, GammaTables, ReadMPECurve)) {
-
-        mpe = cmsStageAllocToneCurves(self ->ContextID, InputChans, GammaTables);
-    }
-    else {
-        mpe = NULL;
-    }
-
-    for (i=0; i < InputChans; i++) {
-        if (GammaTables[i]) cmsFreeToneCurve(GammaTables[i]);
-    }
-
-    _cmsFree(self ->ContextID, GammaTables);
-    *nItems = (mpe != NULL) ? 1 : 0;
-    return mpe;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-// Write a single segmented curve. NO CHECK IS PERFORMED ON VALIDITY
-static
-cmsBool WriteSegmentedCurve(cmsIOHANDLER* io, cmsToneCurve* g)
-{
-    cmsUInt32Number i, j;
-    cmsCurveSegment* Segments = g ->Segments;
-    cmsUInt32Number nSegments = g ->nSegments;
-
-    if (!_cmsWriteUInt32Number(io, cmsSigSegmentedCurve)) goto Error;    
-    if (!_cmsWriteUInt32Number(io, 0)) goto Error;  
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) nSegments)) goto Error;    
-    if (!_cmsWriteUInt16Number(io, 0)) goto Error;  
-
-    // Write the break-points
-    for (i=0; i < nSegments - 1; i++) {
-        if (!_cmsWriteFloat32Number(io, Segments[i].x1)) goto Error;
-    }
-
-    // Write the segments
-    for (i=0; i < g ->nSegments; i++) {
-
-        cmsCurveSegment* ActualSeg = Segments + i;
-
-        if (ActualSeg -> Type == 0) {
-
-            // This is a sampled curve
-            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigSampledCurveSeg)) goto Error;
-            if (!_cmsWriteUInt32Number(io, 0)) goto Error;
-            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints)) goto Error;
-
-            for (j=0; j < g ->Segments[i].nGridPoints; j++) {
-                if (!_cmsWriteFloat32Number(io, ActualSeg -> SampledPoints[j])) goto Error;
-            }
-
-        }
-        else {
-            int Type;
-            cmsUInt32Number ParamsByType[] = { 4, 5, 5 };
-
-            // This is a formula-based
-            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigFormulaCurveSeg)) goto Error;
-            if (!_cmsWriteUInt32Number(io, 0)) goto Error;
-
-            // We only allow 1, 2 and 3 as types
-            Type = ActualSeg ->Type - 6;
-            if (Type > 2 || Type < 0) goto Error;
-
-            if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Type)) goto Error;
-            if (!_cmsWriteUInt16Number(io, 0)) goto Error;
-
-            for (j=0; j < ParamsByType[Type]; j++) {
-                if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) ActualSeg ->Params[j])) goto Error;
-            }
-        }         
-
-        // It seems there is no need to align. Code is here, and for safety commented out
-        // if (!_cmsWriteAlignment(io)) goto Error;
-    }
-
-    return TRUE;
-
-Error:
-    return FALSE;
-}
-
-
-static
-cmsBool WriteMPECurve(struct _cms_typehandler_struct* self, 
-                      cmsIOHANDLER* io,
-                      void* Cargo,
-                      cmsUInt32Number n, 
-                      cmsUInt32Number SizeOfTag)
-{
-    _cmsStageToneCurvesData* Curves  = (_cmsStageToneCurvesData*) Cargo;
-
-    return WriteSegmentedCurve(io, Curves ->TheCurves[n]);
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-    cmsUNUSED_PARAMETER(self);
-}
-
-// Write a curve, checking first for validity
-static
-cmsBool  Type_MPEcurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{   
-    cmsUInt32Number BaseOffset;
-    cmsStage* mpe = (cmsStage*) Ptr;
-    _cmsStageToneCurvesData* Curves = (_cmsStageToneCurvesData*) mpe ->Data;
-
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    // Write the header. Since those are curves, input and output channels are same
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;
-    
-    if (!WritePositionTable(self, io, 0, 
-                                mpe ->InputChannels, BaseOffset, Curves, WriteMPECurve)) return FALSE;
-
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-
-// The matrix is organized as an array of PxQ+Q elements, where P is the number of input channels to the
-// matrix, and Q is the number of output channels. The matrix elements are each float32Numbers. The array
-// is organized as follows:
-// array = [e11, e12, , e1P, e21, e22, , e2P, , eQ1, eQ2, , eQP, e1, e2, , eQ]
-
-static
-void *Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsStage* mpe;
-    cmsUInt16Number   InputChans, OutputChans;
-    cmsUInt32Number   nElems, i;  
-    cmsFloat64Number* Matrix;
-    cmsFloat64Number* Offsets;
-
-    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
-    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
-
-    
-    nElems = InputChans * OutputChans;
-
-    // Input and output chans may be ANY (up to 0xffff)
-    Matrix = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, nElems, sizeof(cmsFloat64Number));
-    if (Matrix == NULL) return NULL;
-
-    Offsets = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, OutputChans, sizeof(cmsFloat64Number));
-    if (Offsets == NULL) {
-    
-        _cmsFree(self ->ContextID, Matrix);
-        return NULL;
-    }
-
-    for (i=0; i < nElems; i++) {
-
-        cmsFloat32Number v;
-
-        if (!_cmsReadFloat32Number(io, &v)) return NULL;        
-        Matrix[i] = v;
-    }
-
-
-    for (i=0; i < OutputChans; i++) {
-
-        cmsFloat32Number v;
-
-        if (!_cmsReadFloat32Number(io, &v)) return NULL;        
-        Offsets[i] = v;
-    }
-
-
-    mpe = cmsStageAllocMatrix(self ->ContextID, OutputChans, InputChans, Matrix, Offsets);
-    _cmsFree(self ->ContextID, Matrix);
-    _cmsFree(self ->ContextID, Offsets);
-
-    *nItems = 1;
-
-    return mpe;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-static
-cmsBool  Type_MPEmatrix_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsUInt32Number i, nElems;
-    cmsStage* mpe = (cmsStage*) Ptr;
-    _cmsStageMatrixData* Matrix = (_cmsStageMatrixData*) mpe ->Data;
-
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;    
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;
-
-    nElems = mpe ->InputChannels * mpe ->OutputChannels;
-
-    for (i=0; i < nElems; i++) {
-        if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Double[i])) return FALSE;        
-    }
-
-
-    for (i=0; i < mpe ->OutputChannels; i++) {
-
-        if (Matrix ->Offset == NULL) {
-
-               if (!_cmsWriteFloat32Number(io, 0)) return FALSE;        
-        }
-        else {
-               if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Offset[i])) return FALSE;        
-        }
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-
-static
-void *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{
-    cmsStage* mpe = NULL;
-    cmsUInt16Number InputChans, OutputChans;
-    cmsUInt8Number Dimensions8[16];
-    cmsUInt32Number i, nMaxGrids, GridPoints[MAX_INPUT_DIMENSIONS];
-    _cmsStageCLutData* clut;
-    
-    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
-    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
-    
-    if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)
-        goto Error;
-    
-    // Copy MAX_INPUT_DIMENSIONS at most. Expand to cmsUInt32Number
-    nMaxGrids = InputChans > MAX_INPUT_DIMENSIONS ? MAX_INPUT_DIMENSIONS : InputChans;
-    for (i=0; i < nMaxGrids; i++) GridPoints[i] = (cmsUInt32Number) Dimensions8[i];
-
-    // Allocate the true CLUT
-    mpe = cmsStageAllocCLutFloatGranular(self ->ContextID, GridPoints, InputChans, OutputChans, NULL);
-    if (mpe == NULL) goto Error;
-
-    // Read the data
-    clut = (_cmsStageCLutData*) mpe ->Data;
-    for (i=0; i < clut ->nEntries; i++) {
-        
-        if (!_cmsReadFloat32Number(io, &clut ->Tab.TFloat[i])) goto Error;
-    }
-
-    *nItems = 1;    
-    return mpe;
-
-Error:
-    *nItems = 0;
-    if (mpe != NULL) cmsStageFree(mpe);
-    return NULL;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-// Write a CLUT in floating point
-static
-cmsBool  Type_MPEclut_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{   
-    cmsUInt8Number Dimensions8[16];
-    cmsUInt32Number i;
-    cmsStage* mpe = (cmsStage*) Ptr;
-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe ->Data;
-
-    // Check for maximum number of channels
-    if (mpe -> InputChannels > 15) return FALSE;
-    
-    // Only floats are supported in MPE
-    if (clut ->HasFloatValues == FALSE) return FALSE;
-
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;
-
-    memset(Dimensions8, 0, sizeof(Dimensions8));
-
-    for (i=0; i < mpe ->InputChannels; i++) 
-        Dimensions8[i] = (cmsUInt8Number) clut ->Params ->nSamples[i];
-
-    if (!io ->Write(io, 16, Dimensions8)) return FALSE;
-
-    for (i=0; i < clut ->nEntries; i++) {
-        
-        if (!_cmsWriteFloat32Number(io, clut ->Tab.TFloat[i])) return FALSE;
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(nItems);
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-
-// This is the list of built-in MPE types
-static _cmsTagTypeLinkedList SupportedMPEtypes[] = {
-
-{{ (cmsTagTypeSignature) cmsSigBAcsElemType, NULL, NULL, NULL, NULL }, &SupportedMPEtypes[1] },   // Ignore those elements for now
-{{ (cmsTagTypeSignature) cmsSigEAcsElemType, NULL, NULL, NULL, NULL }, &SupportedMPEtypes[2] },   // (That's what the spec says)
-
-{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCurveSetElemType,     MPEcurve),      &SupportedMPEtypes[3] },
-{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigMatrixElemType,       MPEmatrix),     &SupportedMPEtypes[4] },
-{TYPE_MPE_HANDLER((cmsTagTypeSignature) cmsSigCLutElemType,         MPEclut),        NULL },
-};
-
-#define DEFAULT_MPE_TYPE_COUNT  (sizeof(SupportedMPEtypes) / sizeof(_cmsTagTypeLinkedList))
-
-static
-cmsBool ReadMPEElem(struct _cms_typehandler_struct* self, 
-                    cmsIOHANDLER* io,
-                    void* Cargo,
-                    cmsUInt32Number n, 
-                    cmsUInt32Number SizeOfTag)
-{
-    cmsStageSignature ElementSig;
-    cmsTagTypeHandler* TypeHandler;
-    cmsStage *mpe = NULL;
-    cmsUInt32Number nItems;
-    cmsPipeline *NewLUT = (cmsPipeline *) Cargo;
-
-    // Take signature and channels for each element.
-    if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return FALSE;
-
-    // The reserved placeholder
-    if (!_cmsReadUInt32Number(io, NULL)) return FALSE;
-
-    // Read diverse MPE types
-    TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, SupportedMPEtypes);
-    if (TypeHandler == NULL)  {
-
-        char String[5];
-
-        _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);
-
-        // An unknown element was found. 
-        cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown MPE type '%s' found.", String);
-        return FALSE;
-    }
-
-    // If no read method, just ignore the element (valid for cmsSigBAcsElemType and cmsSigEAcsElemType)
-    // Read the MPE. No size is given
-    if (TypeHandler ->ReadPtr != NULL) {
-
-        // This is a real element which should be read and processed
-        mpe = (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag);
-        if (mpe == NULL) return FALSE;
-
-        // All seems ok, insert element
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-    cmsUNUSED_PARAMETER(n);
-}
-
-
-// This is the main dispatcher for MPE
-static
-void *Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
-{   
-    cmsUInt16Number InputChans, OutputChans;
-    cmsUInt32Number ElementCount;
-    cmsPipeline *NewLUT = NULL;
-    cmsUInt32Number BaseOffset;
-
-    // Get actual position as a basis for element offsets
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    // Read channels and element count
-    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
-    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL; 
-    
-    // Allocates an empty LUT
-    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChans, OutputChans);
-    if (NewLUT == NULL) return NULL;
-
-    if (!_cmsReadUInt32Number(io, &ElementCount)) return NULL;
-
-    if (!ReadPositionTable(self, io, ElementCount, BaseOffset, NewLUT, ReadMPEElem)) {
-        if (NewLUT != NULL) cmsPipelineFree(NewLUT);
-        *nItems = 0;
-        return NULL;
-    }
-
-    // Success
-    *nItems = 1;
-    return NewLUT;
-
-    cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-
-// This one is a liitle bit more complex, so we don't use position tables this time.
-static
-cmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{   
-    cmsUInt32Number i, BaseOffset, DirectoryPos, CurrentPos;
-    int inputChan, outputChan;
-    cmsUInt32Number ElemCount;
-    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL, Before;
-    cmsStageSignature ElementSig;
-    cmsPipeline* Lut = (cmsPipeline*) Ptr;
-    cmsStage* Elem = Lut ->Elements;
-    cmsTagTypeHandler* TypeHandler;
-
-    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
-
-    inputChan  = cmsPipelineInputChannels(Lut);
-    outputChan = cmsPipelineOutputChannels(Lut);
-    ElemCount  = cmsPipelineStageCount(Lut);
-
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
-    if (ElementOffsets == NULL) goto Error;
-
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
-    if (ElementSizes == NULL) goto Error;
-
-    // Write the head
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;
-    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) outputChan)) goto Error;
-    if (!_cmsWriteUInt32Number(io, (cmsUInt16Number) ElemCount)) goto Error;
-
-    DirectoryPos = io ->Tell(io);
-
-    // Write a fake directory to be filled latter on
-    for (i=0; i < ElemCount; i++) {
-        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset 
-        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size
-    }
-
-    // Write each single tag. Keep track of the size as well.
-    for (i=0; i < ElemCount; i++) {
-
-        ElementOffsets[i] = io ->Tell(io) - BaseOffset;
-
-        ElementSig = Elem ->Type;
-
-        TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, SupportedMPEtypes);
-        if (TypeHandler == NULL)  {
-
-                char String[5];
-
-                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);
-
-                 // An unknow element was found. 
-                 cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Found unknown MPE type '%s'", String);
-                 goto Error;
-        }
-
-        if (!_cmsWriteUInt32Number(io, ElementSig)) goto Error;  
-        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  
-        Before = io ->Tell(io);
-        if (!TypeHandler ->WritePtr(self, io, Elem, 1)) goto Error;
-        if (!_cmsWriteAlignment(io)) goto Error;
-
-        ElementSizes[i] = io ->Tell(io) - Before;
-
-        Elem = Elem ->Next;
-    }
-
-    // Write the directory
-    CurrentPos = io ->Tell(io);
-
-    if (!io ->Seek(io, DirectoryPos)) goto Error;
-
-    for (i=0; i < ElemCount; i++) {
-        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;  
-        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;  
-    }
-
-    if (!io ->Seek(io, CurrentPos)) goto Error;
-
-    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);
-    return TRUE;
-
-Error:
-    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);
-    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);
-    return FALSE;
-
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-
-static
-void* Type_MPE_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);
-
-    cmsUNUSED_PARAMETER(n);
-    cmsUNUSED_PARAMETER(self);
-}
-
-static
-void Type_MPE_Free(struct _cms_typehandler_struct* self, void *Ptr)
-{    
-    cmsPipelineFree((cmsPipeline*) Ptr);
-    return;
-
-    cmsUNUSED_PARAMETER(self);
-}
-
-
-// ********************************************************************************
-// Type cmsSigVcgtType
-// ********************************************************************************
-
-
-#define cmsVideoCardGammaTableType    0
-#define cmsVideoCardGammaFormulaType  1
-
-// Used internally
-typedef struct {
-    double Gamma;
-    double Min;
-    double Max;
-} _cmsVCGTGAMMA;
-
-
-static
-void *Type_vcgt_Read(struct _cms_typehandler_struct* self, 
-                     cmsIOHANDLER* io, 
-                     cmsUInt32Number* nItems, 
-                     cmsUInt32Number SizeOfTag)
-{
-    cmsUInt32Number TagType, n, i;
-    cmsToneCurve** Curves;
-
-    *nItems = 0;
-
-    // Read tag type
-    if (!_cmsReadUInt32Number(io, &TagType)) return NULL;
- 
-    // Allocate space for the array
-    Curves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));
-    if (Curves == NULL) return NULL;
-
-    // There are two possible flavors
-    switch (TagType) {
-
-    // Gamma is stored as a table
-    case cmsVideoCardGammaTableType: 
-    {
-       cmsUInt16Number nChannels, nElems, nBytes;
-
-       // Check channel count, which should be 3 (we don't support monochrome this time)
-       if (!_cmsReadUInt16Number(io, &nChannels)) goto Error;
-
-       if (nChannels != 3) {
-           cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported number of channels for VCGT '%d'", nChannels);
-           goto Error;                               
-       }
-
-       // Get Table element count and bytes per element
-       if (!_cmsReadUInt16Number(io, &nElems)) goto Error;
-       if (!_cmsReadUInt16Number(io, &nBytes)) goto Error;
-       
-	   // Adobe's quirk fixup. Fixing broken profiles...
-	   if (nElems == 256 && nBytes == 1 && SizeOfTag == 1576)
-		   nBytes = 2;
-
-
-       // Populate tone curves
-       for (n=0; n < 3; n++) {
-
-           Curves[n] = cmsBuildTabulatedToneCurve16(self ->ContextID, nElems, NULL);
-           if (Curves[n] == NULL) goto Error;
-
-           // On depending on byte depth
-           switch (nBytes) {
-
-           // One byte, 0..255
-           case 1:
-               for (i=0; i < nElems; i++) {
-
-                   cmsUInt8Number v;
-
-                      if (!_cmsReadUInt8Number(io, &v)) goto Error;
-                      Curves[n] ->Table16[i] = FROM_8_TO_16(v);
-               }
-               break;
-
-           // One word 0..65535
-           case 2:
-              if (!_cmsReadUInt16Array(io, nElems, Curves[n]->Table16)) goto Error;
-              break;
-
-          // Unsupported
-           default:
-              cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported bit depth for VCGT '%d'", nBytes * 8);
-              goto Error;       
-           }
-       } // For all 3 channels
-    }
-    break;
-
-   // In this case, gamma is stored as a formula
-   case cmsVideoCardGammaFormulaType: 
-   {
-       _cmsVCGTGAMMA Colorant[3];
-       
-        // Populate tone curves
-       for (n=0; n < 3; n++) {
-
-           double Params[10];
-
-           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Gamma)) goto Error;
-           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Min)) goto Error;
-           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Max)) goto Error;
-           
-            // Parametric curve type 5 is:
-            // Y = (aX + b)^Gamma + e | X >= d
-            // Y = cX + f             | X < d
-
-            // vcgt formula is:
-            // Y = (Max  Min) * (X ^ Gamma) + Min
-            
-            // So, the translation is
-            // a = (Max  Min) ^ ( 1 / Gamma) 
-            // e = Min
-            // b=c=d=f=0
-
-           Params[0] = Colorant[n].Gamma;
-           Params[1] = pow((Colorant[n].Max - Colorant[n].Min), (1.0 / Colorant[n].Gamma));
-           Params[2] = 0;
-           Params[3] = 0;
-           Params[4] = 0;
-           Params[5] = Colorant[n].Min;
-           Params[6] = 0;
-    
-           Curves[n] = cmsBuildParametricToneCurve(self ->ContextID, 5, Params);
-           if (Curves[n] == NULL) goto Error;
-       }
-   }
-   break;
-
-   // Unsupported
-   default: 
-      cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported tag type for VCGT '%d'", TagType);
-      goto Error;
-   }
-
-   *nItems = 1;
-   return (void*) Curves;
-
-// Regret,  free all resources
-Error:
-
-    cmsFreeToneCurveTriple(Curves);
-    _cmsFree(self ->ContextID, Curves);
-    return NULL;
-
-     cmsUNUSED_PARAMETER(SizeOfTag);
-}
-
-
-// We don't support all flavors, only 16bits tables and formula
-static
-cmsBool Type_vcgt_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)
-{
-    cmsToneCurve** Curves =  (cmsToneCurve**) Ptr;
-    cmsUInt32Number i, j;
-
-    if (cmsGetToneCurveParametricType(Curves[0]) == 5 &&
-        cmsGetToneCurveParametricType(Curves[1]) == 5 &&
-        cmsGetToneCurveParametricType(Curves[2]) == 5) {
-
-            if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaFormulaType)) return FALSE;  
-
-            // Save parameters
-            for (i=0; i < 3; i++) {
-
-                _cmsVCGTGAMMA v;
-
-                v.Gamma = Curves[i] ->Segments[0].Params[0];
-                v.Min   = Curves[i] ->Segments[0].Params[5];
-                v.Max   = pow(Curves[i] ->Segments[0].Params[1], v.Gamma) + v.Min;
-
-                if (!_cmsWrite15Fixed16Number(io, v.Gamma)) return FALSE;
-                if (!_cmsWrite15Fixed16Number(io, v.Min)) return FALSE;
-                if (!_cmsWrite15Fixed16Number(io, v.Max)) return FALSE;
-            }
-    }
-
-    else {
-
-        // Always store as a table of 256 words
-        if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaTableType)) return FALSE;    
-        if (!_cmsWriteUInt16Number(io, 3)) return FALSE;    
-        if (!_cmsWriteUInt16Number(io, 256)) return FALSE;    
-        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;    
-
-        for (i=0; i < 3; i++) {
-            for (j=0; j < 256; j++) {
-
-                cmsFloat32Number v = cmsEvalToneCurveFloat(Curves[i], (cmsFloat32Number) (j / 255.0));
-                cmsUInt16Number  n = _cmsQuickSaturateWord(v * 65535.0);
-
-                if (!_cmsWriteUInt16Number(io, n)) return FALSE;    
-            }
-        }
-    }
-
-    return TRUE;
-
-    cmsUNUSED_PARAMETER(self);
-    cmsUNUSED_PARAMETER(nItems);
-}
-
-static
-void* Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
-{
-    cmsToneCurve** OldCurves =  (cmsToneCurve**) Ptr;
-    cmsToneCurve** NewCurves;
-
-    NewCurves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));
-    if (NewCurves == NULL) return NULL;
-
-    NewCurves[0] = cmsDupToneCurve(OldCurves[0]);
-    NewCurves[1] = cmsDupToneCurve(OldCurves[1]);
-    NewCurves[2] = cmsDupToneCurve(OldCurves[2]);
-
-    return (void*) NewCurves;
-
-    cmsUNUSED_PARAMETER(n);
-}
-
-
-static
-void Type_vcgt_Free(struct _cms_typehandler_struct* self, void* Ptr)
-{
-    cmsFreeToneCurveTriple((cmsToneCurve**) Ptr);
-    _cmsFree(self ->ContextID, Ptr);
-}
-
-// ********************************************************************************
-// Type support main routines
-// ********************************************************************************
-
-
-// This is the list of built-in types
-static _cmsTagTypeLinkedList SupportedTagTypes[] = {
-
-{TYPE_HANDLER(cmsSigChromaticityType,          Chromaticity),        &SupportedTagTypes[1] },
-{TYPE_HANDLER(cmsSigColorantOrderType,         ColorantOrderType),   &SupportedTagTypes[2] },
-{TYPE_HANDLER(cmsSigS15Fixed16ArrayType,       S15Fixed16),          &SupportedTagTypes[3] },
-{TYPE_HANDLER(cmsSigU16Fixed16ArrayType,       U16Fixed16),          &SupportedTagTypes[4] },
-{TYPE_HANDLER(cmsSigTextType,                  Text),                &SupportedTagTypes[5] },
-{TYPE_HANDLER(cmsSigTextDescriptionType,       Text_Description),    &SupportedTagTypes[6] },
-{TYPE_HANDLER(cmsSigCurveType,                 Curve),               &SupportedTagTypes[7] },
-{TYPE_HANDLER(cmsSigParametricCurveType,       ParametricCurve),     &SupportedTagTypes[8] },
-{TYPE_HANDLER(cmsSigDateTimeType,              DateTime),            &SupportedTagTypes[9] },
-{TYPE_HANDLER(cmsSigLut8Type,                  LUT8),                &SupportedTagTypes[10] },
-{TYPE_HANDLER(cmsSigLut16Type,                 LUT16),               &SupportedTagTypes[11] },
-{TYPE_HANDLER(cmsSigColorantTableType,         ColorantTable),       &SupportedTagTypes[12] },
-{TYPE_HANDLER(cmsSigNamedColor2Type,           NamedColor),          &SupportedTagTypes[13] },
-{TYPE_HANDLER(cmsSigMultiLocalizedUnicodeType, MLU),                 &SupportedTagTypes[14] },
-{TYPE_HANDLER(cmsSigProfileSequenceDescType,   ProfileSequenceDesc), &SupportedTagTypes[15] },
-{TYPE_HANDLER(cmsSigSignatureType,             Signature),           &SupportedTagTypes[16] },
-{TYPE_HANDLER(cmsSigMeasurementType,           Measurement),         &SupportedTagTypes[17] },
-{TYPE_HANDLER(cmsSigDataType,                  Data),                &SupportedTagTypes[18] },
-{TYPE_HANDLER(cmsSigLutAtoBType,               LUTA2B),              &SupportedTagTypes[19] },
-{TYPE_HANDLER(cmsSigLutBtoAType,               LUTB2A),              &SupportedTagTypes[20] },
-{TYPE_HANDLER(cmsSigUcrBgType,                 UcrBg),               &SupportedTagTypes[21] },
-{TYPE_HANDLER(cmsSigCrdInfoType,               CrdInfo),             &SupportedTagTypes[22] },
-{TYPE_HANDLER(cmsSigMultiProcessElementType,   MPE),                 &SupportedTagTypes[23] },
-{TYPE_HANDLER(cmsSigScreeningType,             Screening),           &SupportedTagTypes[24] },
-{TYPE_HANDLER(cmsSigViewingConditionsType,     ViewingConditions),   &SupportedTagTypes[25] },
-{TYPE_HANDLER(cmsSigXYZType,                   XYZ),                 &SupportedTagTypes[26] },
-{TYPE_HANDLER(cmsCorbisBrokenXYZtype,          XYZ),                 &SupportedTagTypes[27] },
-{TYPE_HANDLER(cmsMonacoBrokenCurveType,        Curve),               &SupportedTagTypes[28] },
-{TYPE_HANDLER(cmsSigProfileSequenceIdType,     ProfileSequenceId),   &SupportedTagTypes[29] },
-{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }
-};
-
-#define DEFAULT_TAG_TYPE_COUNT  (sizeof(SupportedTagTypes) / sizeof(_cmsTagTypeLinkedList))
-                                
-// Both kind of plug-ins share same structure
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Data)
-{
-    return RegisterTypesPlugin(Data, SupportedTagTypes, DEFAULT_TAG_TYPE_COUNT);
-}
-
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Data)
-{
-    return RegisterTypesPlugin(Data, SupportedMPEtypes, DEFAULT_MPE_TYPE_COUNT);
-}
-
-
-// Wrapper for tag types
-cmsTagTypeHandler* _cmsGetTagTypeHandler(cmsTagTypeSignature sig)
-{
-    return GetHandler(sig, SupportedTagTypes);
-}
-    
-// ********************************************************************************
-// Tag support main routines
-// ********************************************************************************
-
-typedef struct _cmsTagLinkedList_st {
-
-            cmsTagSignature Signature;
-            cmsTagDescriptor Descriptor;
-            struct _cmsTagLinkedList_st* Next;
-
-} _cmsTagLinkedList;
-
-// This is the list of built-in tags
-static _cmsTagLinkedList SupportedTags[] = {
-
-    { cmsSigAToB0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[1]},   
-    { cmsSigAToB1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[2]},
-    { cmsSigAToB2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutAtoBType, cmsSigLut8Type}, DecideLUTtypeA2B}, &SupportedTags[3]},
-    { cmsSigBToA0Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[4]},
-    { cmsSigBToA1Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[5]},
-    { cmsSigBToA2Tag,               { 1, 3,  { cmsSigLut16Type,  cmsSigLutBtoAType, cmsSigLut8Type}, DecideLUTtypeB2A}, &SupportedTags[6]},
-     
-    // Allow corbis  and its broken XYZ type
-    { cmsSigRedColorantTag,         { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[7]},
-    { cmsSigGreenColorantTag,       { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[8]},
-    { cmsSigBlueColorantTag,        { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, DecideXYZtype}, &SupportedTags[9]},
-                                   
-    { cmsSigRedTRCTag,              { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[10]},
-    { cmsSigGreenTRCTag,            { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[11]},
-    { cmsSigBlueTRCTag,             { 1, 3, { cmsSigCurveType, cmsSigParametricCurveType, cmsMonacoBrokenCurveType }, DecideCurveType}, &SupportedTags[12]}, 
-
-    { cmsSigCalibrationDateTimeTag, { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[13]},
-    { cmsSigCharTargetTag,          { 1, 1, { cmsSigTextType },     NULL}, &SupportedTags[14]},
-
-    { cmsSigChromaticAdaptationTag, { 9, 1, { cmsSigS15Fixed16ArrayType }, NULL}, &SupportedTags[15]},
-    { cmsSigChromaticityTag,        { 1, 1, { cmsSigChromaticityType    }, NULL}, &SupportedTags[16]},
-    { cmsSigColorantOrderTag,       { 1, 1, { cmsSigColorantOrderType   }, NULL}, &SupportedTags[17]},
-    { cmsSigColorantTableTag,       { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[18]},
-    { cmsSigColorantTableOutTag,    { 1, 1, { cmsSigColorantTableType   }, NULL}, &SupportedTags[19]},
-
-    { cmsSigCopyrightTag,           { 1, 3, { cmsSigTextType,  cmsSigMultiLocalizedUnicodeType, cmsSigTextDescriptionType}, DecideTextType}, &SupportedTags[20]},
-    { cmsSigDateTimeTag,            { 1, 1, { cmsSigDateTimeType }, NULL}, &SupportedTags[21]},
-
-    { cmsSigDeviceMfgDescTag,       { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[22]},
-    { cmsSigDeviceModelDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[23]},
-
-    { cmsSigGamutTag,               { 1, 3, { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[24]},
-
-    { cmsSigGrayTRCTag,             { 1, 2, { cmsSigCurveType, cmsSigParametricCurveType }, DecideCurveType}, &SupportedTags[25]},
-    { cmsSigLuminanceTag,           { 1, 1, { cmsSigXYZType }, NULL}, &SupportedTags[26]},
-
-    { cmsSigMediaBlackPointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[27]},
-    { cmsSigMediaWhitePointTag,     { 1, 2, { cmsSigXYZType, cmsCorbisBrokenXYZtype }, NULL}, &SupportedTags[28]},
-
-    { cmsSigNamedColor2Tag,         { 1, 1, { cmsSigNamedColor2Type }, NULL}, &SupportedTags[29]},
-
-    { cmsSigPreview0Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[30]},
-    { cmsSigPreview1Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[31]},
-    { cmsSigPreview2Tag,            { 1, 3,  { cmsSigLut16Type, cmsSigLutBtoAType, cmsSigLut8Type }, DecideLUTtypeB2A}, &SupportedTags[32]},
-
-    { cmsSigProfileDescriptionTag,  { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[33]},
-    { cmsSigProfileSequenceDescTag, { 1, 1, { cmsSigProfileSequenceDescType }, NULL}, &SupportedTags[34]},
-    { cmsSigTechnologyTag,          { 1, 1, { cmsSigSignatureType }, NULL},  &SupportedTags[35]},
-
-    { cmsSigColorimetricIntentImageStateTag,   { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[36]},
-    { cmsSigPerceptualRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[37]},
-    { cmsSigSaturationRenderingIntentGamutTag, { 1, 1, { cmsSigSignatureType }, NULL}, &SupportedTags[38]},
-
-    { cmsSigMeasurementTag,         { 1, 1, { cmsSigMeasurementType }, NULL}, &SupportedTags[39]},
-
-    { cmsSigPs2CRD0Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[40]},          
-    { cmsSigPs2CRD1Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[41]},                     
-    { cmsSigPs2CRD2Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[42]},                    
-    { cmsSigPs2CRD3Tag,             { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[43]},                    
-    { cmsSigPs2CSATag,              { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[44]},                    
-    { cmsSigPs2RenderingIntentTag,  { 1, 1, { cmsSigDataType }, NULL}, &SupportedTags[45]},     
-
-    { cmsSigViewingCondDescTag,     { 1, 3, { cmsSigTextDescriptionType, cmsSigMultiLocalizedUnicodeType, cmsSigTextType}, DecideTextDescType}, &SupportedTags[46]},
-
-    { cmsSigUcrBgTag,               { 1, 1, { cmsSigUcrBgType}, NULL},    &SupportedTags[47]}, 
-    { cmsSigCrdInfoTag,             { 1, 1, { cmsSigCrdInfoType}, NULL},  &SupportedTags[48]}, 
-
-    { cmsSigDToB0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[49]}, 
-    { cmsSigDToB1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[50]}, 
-    { cmsSigDToB2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[51]}, 
-    { cmsSigDToB3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[52]}, 
-    { cmsSigBToD0Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[53]}, 
-    { cmsSigBToD1Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[54]}, 
-    { cmsSigBToD2Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[55]}, 
-    { cmsSigBToD3Tag,               { 1, 1, { cmsSigMultiProcessElementType}, NULL}, &SupportedTags[56]}, 
-        
-    { cmsSigScreeningDescTag,       { 1, 1, { cmsSigTextDescriptionType },    NULL}, &SupportedTags[57]}, 
-    { cmsSigViewingConditionsTag,   { 1, 1, { cmsSigViewingConditionsType },  NULL}, &SupportedTags[58]}, 
-
-    { cmsSigScreeningTag,           { 1, 1, { cmsSigScreeningType},          NULL }, &SupportedTags[59]},  
-    { cmsSigVcgtTag,                { 1, 1, { cmsSigVcgtType},               NULL }, &SupportedTags[60]}, 
-    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL},  NULL}  
-
-};
-
-/*
-    Not supported                 Why
-    =======================       =========================================                
-    cmsSigOutputResponseTag   ==> WARNING, POSSIBLE PATENT ON THIS SUBJECT!                
-    cmsSigNamedColorTag       ==> Deprecated                                 
-    cmsSigDataTag             ==> Ancient, unused             
-    cmsSigDeviceSettingsTag   ==> Deprecated, useless     
-*/               
-
-#define DEFAULT_TAG_COUNT  (sizeof(SupportedTags) / sizeof(_cmsTagLinkedList))
-
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Data)
-{
-    cmsPluginTag* Plugin = (cmsPluginTag*) Data;
-    _cmsTagLinkedList *pt, *Anterior;
-
-
-    if (Data == NULL) {
-    
-        SupportedTags[DEFAULT_TAG_COUNT-1].Next = NULL;
-        return TRUE;
-    }
-
-    pt = Anterior = SupportedTags; 
-    while (pt != NULL) {
-
-        if (Plugin->Signature == pt -> Signature) {
-            pt ->Descriptor = Plugin ->Descriptor;  // Replace old behaviour
-            return TRUE;
-        }   
-
-        Anterior = pt;          
-        pt = pt ->Next;
-    }
-
-    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagLinkedList));
-    if (pt == NULL) return FALSE;
-
-    pt ->Signature  = Plugin ->Signature;
-    pt ->Descriptor = Plugin ->Descriptor;  
-    pt ->Next       = NULL;
-
-    if (Anterior != NULL) Anterior -> Next = pt;
-
-    return TRUE;
-}
-
-// Return a descriptor for a given tag or NULL
-cmsTagDescriptor* _cmsGetTagDescriptor(cmsTagSignature sig)
-{
-    _cmsTagLinkedList* pt;
-
-    for (pt = SupportedTags; 
-            pt != NULL;
-            pt = pt ->Next) {
-
-                if (sig == pt -> Signature) return &pt ->Descriptor;
-    }
-
-    return NULL;
-}
-
diff --git a/thirdparty/liblcms2/src/cmsvirt.c b/thirdparty/liblcms2/src/cmsvirt.c
deleted file mode 100644
index 807bd22..0000000
--- a/thirdparty/liblcms2/src/cmsvirt.c
+++ /dev/null
@@ -1,1148 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Virtual (built-in) profiles
-// -----------------------------------------------------------------------------------
-
-static
-cmsBool SetTextTags(cmsHPROFILE hProfile, const wchar_t* Description)
-{
-    cmsMLU *DescriptionMLU, *CopyrightMLU;
-    cmsBool  rc = FALSE;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    
-    DescriptionMLU  = cmsMLUalloc(ContextID, 1);
-    CopyrightMLU    = cmsMLUalloc(ContextID, 1);
-
-    if (DescriptionMLU == NULL || CopyrightMLU == NULL) goto Error;
-
-    if (!cmsMLUsetWide(DescriptionMLU,  "en", "US", Description)) goto Error;
-    if (!cmsMLUsetWide(CopyrightMLU,    "en", "US", L"No copyright, use freely")) goto Error;
-
-    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag,  DescriptionMLU)) goto Error;
-    if (!cmsWriteTag(hProfile, cmsSigCopyrightTag,           CopyrightMLU)) goto Error;     
-        
-    rc = TRUE;
-
-Error:
-
-    if (DescriptionMLU)
-        cmsMLUfree(DescriptionMLU);
-    if (CopyrightMLU)
-        cmsMLUfree(CopyrightMLU);
-    return rc;
-}
-    
-
-static
-cmsBool  SetSeqDescTag(cmsHPROFILE hProfile, const char* Model)
-{
-    cmsBool  rc = FALSE;
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
-    cmsSEQ* Seq = cmsAllocProfileSequenceDescription(ContextID, 1);
-
-    if (Seq == NULL) return FALSE;
-
-    Seq->seq[0].deviceMfg = (cmsSignature) 0;
-    Seq->seq[0].deviceModel = (cmsSignature) 0;
-
-#ifdef CMS_DONT_USE_INT64
-    Seq->seq[0].attributes[0] = 0;  
-    Seq->seq[0].attributes[1] = 0;  
-#else
-    Seq->seq[0].attributes = 0; 
-#endif
-
-    Seq->seq[0].technology = (cmsTechnologySignature) 0;
-
-    cmsMLUsetASCII( Seq->seq[0].Manufacturer, cmsNoLanguage, cmsNoCountry, "Little CMS");
-    cmsMLUsetASCII( Seq->seq[0].Model,        cmsNoLanguage, cmsNoCountry, Model);
-
-    if (!_cmsWriteProfileSequence(hProfile, Seq)) goto Error;
-    
-    rc = TRUE;
-
-Error:
-    if (Seq) 
-        cmsFreeProfileSequenceDescription(Seq);
-
-    return rc;
-}
-
-
-
-// This function creates a profile based on White point, primaries and
-// transfer functions.
-cmsHPROFILE CMSEXPORT cmsCreateRGBProfileTHR(cmsContext ContextID,
-                                          const cmsCIExyY* WhitePoint,
-                                          const cmsCIExyYTRIPLE* Primaries,
-                                          cmsToneCurve* const TransferFunction[3])
-{
-    cmsHPROFILE hICC;   
-    cmsMAT3 MColorants;
-    cmsCIEXYZTRIPLE Colorants;
-    cmsCIExyY MaxWhite;
-    cmsMAT3 CHAD;
-    cmsCIEXYZ WhitePointXYZ;
-
-    hICC = cmsCreateProfilePlaceholder(ContextID);
-    if (!hICC)                          // can't allocate
-        return NULL;
-
-    cmsSetProfileVersion(hICC, 4.2);
-
-    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);
-    cmsSetColorSpace(hICC,       cmsSigRgbData);
-    cmsSetPCS(hICC,              cmsSigXYZData);
-
-    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL); 
-
-
-    // Implement profile using following tags:
-    //
-    //  1 cmsSigProfileDescriptionTag
-    //  2 cmsSigMediaWhitePointTag
-    //  3 cmsSigRedColorantTag
-    //  4 cmsSigGreenColorantTag
-    //  5 cmsSigBlueColorantTag
-    //  6 cmsSigRedTRCTag
-    //  7 cmsSigGreenTRCTag
-    //  8 cmsSigBlueTRCTag
-    //  9 Chromatic adaptation Tag
-    // This conforms a standard RGB DisplayProfile as says ICC, and then I add (As per addendum II)
-    // 10 cmsSigChromaticityTag
-
-    
-    if (!SetTextTags(hICC, L"RGB built-in")) goto Error;
-
-    if (WhitePoint) {
-
-        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;
-
-        cmsxyY2XYZ(&WhitePointXYZ, WhitePoint);
-        _cmsAdaptationMatrix(&CHAD, NULL, &WhitePointXYZ, cmsD50_XYZ());     
-
-        // This is a V4 tag, but many CMM does read and understand it no matter which version       
-        if (!cmsWriteTag(hICC, cmsSigChromaticAdaptationTag, (void*) &CHAD)) goto Error;
-    }
-
-    if (WhitePoint && Primaries) {
-
-        MaxWhite.x =  WhitePoint -> x;
-        MaxWhite.y =  WhitePoint -> y;
-        MaxWhite.Y =  1.0;
-
-        if (!_cmsBuildRGB2XYZtransferMatrix(&MColorants, &MaxWhite, Primaries)) goto Error;         
-        
-        Colorants.Red.X   = MColorants.v[0].n[0];
-        Colorants.Red.Y   = MColorants.v[1].n[0];
-        Colorants.Red.Z   = MColorants.v[2].n[0];
-
-        Colorants.Green.X = MColorants.v[0].n[1];
-        Colorants.Green.Y = MColorants.v[1].n[1];
-        Colorants.Green.Z = MColorants.v[2].n[1];
-
-        Colorants.Blue.X  = MColorants.v[0].n[2];
-        Colorants.Blue.Y  = MColorants.v[1].n[2];
-        Colorants.Blue.Z  = MColorants.v[2].n[2];
-
-        if (!cmsWriteTag(hICC, cmsSigRedColorantTag,   (void*) &Colorants.Red)) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigBlueColorantTag,  (void*) &Colorants.Blue)) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigGreenColorantTag, (void*) &Colorants.Green)) goto Error;
-    }
-
-
-    if (TransferFunction) {
-    
-        if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigBlueTRCTag,  (void*) TransferFunction[2])) goto Error;
-    }
-
-    if (Primaries) {
-        if (!cmsWriteTag(hICC, cmsSigChromaticityTag, (void*) Primaries)) goto Error;
-    }
-
-
-    return hICC;
-
-Error:
-    if (hICC)
-        cmsCloseProfile(hICC);
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreateRGBProfile(const cmsCIExyY* WhitePoint,
-                                          const cmsCIExyYTRIPLE* Primaries,
-                                          cmsToneCurve* const TransferFunction[3])
-{
-    return cmsCreateRGBProfileTHR(NULL, WhitePoint, Primaries, TransferFunction);
-}
-
-
-
-// This function creates a profile based on White point and transfer function.
-cmsHPROFILE CMSEXPORT cmsCreateGrayProfileTHR(cmsContext ContextID,
-                                           const cmsCIExyY* WhitePoint,
-                                           const cmsToneCurve* TransferFunction)
-{
-    cmsHPROFILE hICC;
-    cmsCIEXYZ tmp;              
-
-    hICC = cmsCreateProfilePlaceholder(ContextID);
-    if (!hICC)                          // can't allocate
-        return NULL;
-
-    cmsSetProfileVersion(hICC, 4.2);
-
-    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);
-    cmsSetColorSpace(hICC,       cmsSigGrayData);
-    cmsSetPCS(hICC,              cmsSigXYZData);
-    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL); 
-
-
-    // Implement profile using following tags:
-    //
-    //  1 cmsSigProfileDescriptionTag
-    //  2 cmsSigMediaWhitePointTag
-    //  3 cmsSigGrayTRCTag
-
-    // This conforms a standard Gray DisplayProfile 
-
-    // Fill-in the tags
-
-    if (!SetTextTags(hICC, L"gray built-in")) goto Error;
-
-
-    if (WhitePoint) {
-
-        cmsxyY2XYZ(&tmp, WhitePoint);
-        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) &tmp)) goto Error;
-    }
-
-    if (TransferFunction) {
-
-        if (!cmsWriteTag(hICC, cmsSigGrayTRCTag, (void*) TransferFunction)) goto Error;
-    }
-
-    return hICC;
-
-Error:
-    if (hICC)
-        cmsCloseProfile(hICC);
-    return NULL;
-}
-
-
-
-cmsHPROFILE CMSEXPORT cmsCreateGrayProfile(const cmsCIExyY* WhitePoint,
-                                                    const cmsToneCurve* TransferFunction)
-{
-    return cmsCreateGrayProfileTHR(NULL, WhitePoint, TransferFunction);
-}
-
-// This is a devicelink operating in the target colorspace with as many transfer functions as components
-
-cmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,
-                                                          cmsColorSpaceSignature ColorSpace,
-                                                          cmsToneCurve* const TransferFunctions[])
-{
-    cmsHPROFILE hICC;
-    cmsPipeline* Pipeline;
-    cmsStage* Lin;
-    int nChannels;
-
-    hICC = cmsCreateProfilePlaceholder(ContextID);
-    if (!hICC)                          
-        return NULL;
-
-    cmsSetProfileVersion(hICC, 4.2);
-
-    cmsSetDeviceClass(hICC,      cmsSigLinkClass);
-    cmsSetColorSpace(hICC,       ColorSpace);
-    cmsSetPCS(hICC,              ColorSpace);
-
-    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL); 
-
-    // Set up channels
-    nChannels = cmsChannelsOf(ColorSpace);
-
-    // Creates a Pipeline with prelinearization step only
-    Pipeline = cmsPipelineAlloc(ContextID, nChannels, nChannels);
-    if (Pipeline == NULL) goto Error;
-
-
-    // Copy tables to Pipeline
-    Lin = cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions);
-    if (Lin == NULL) goto Error;
-
-    cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Lin);
-
-    // Create tags       
-    if (!SetTextTags(hICC, L"Linearization built-in")) goto Error;    
-    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline)) goto Error;       
-    if (!SetSeqDescTag(hICC, "Linearization built-in")) goto Error;
-
-    // Pipeline is already on virtual profile
-    cmsPipelineFree(Pipeline);
-
-    // Ok, done
-    return hICC;
-
-Error:
-    if (hICC)
-        cmsCloseProfile(hICC);
-
-
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLink(cmsColorSpaceSignature ColorSpace,
-                                                                 cmsToneCurve* const TransferFunctions[])
-{
-    return cmsCreateLinearizationDeviceLinkTHR(NULL, ColorSpace, TransferFunctions);
-}
-
-// Ink-limiting algorithm
-//
-//  Sum = C + M + Y + K 
-//  If Sum > InkLimit 
-//        Ratio= 1 - (Sum - InkLimit) / (C + M + Y)
-//        if Ratio <0 
-//              Ratio=0
-//        endif     
-//     Else 
-//         Ratio=1
-//     endif
-//
-//     C = Ratio * C
-//     M = Ratio * M
-//     Y = Ratio * Y
-//     K: Does not change
-
-static
-int InkLimitingSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    cmsFloat64Number InkLimit = *(cmsFloat64Number *) Cargo;
-    cmsFloat64Number SumCMY, SumCMYK, Ratio;
-
-    InkLimit = (InkLimit * 655.35);
-
-    SumCMY   = In[0]  + In[1] + In[2];
-    SumCMYK  = SumCMY + In[3];      
-
-    if (SumCMYK > InkLimit) {
-
-        Ratio = 1 - ((SumCMYK - InkLimit) / SumCMY);
-        if (Ratio < 0)
-            Ratio = 0;
-    }
-    else Ratio = 1;
-
-    Out[0] = _cmsQuickSaturateWord(In[0] * Ratio);     // C
-    Out[1] = _cmsQuickSaturateWord(In[1] * Ratio);     // M
-    Out[2] = _cmsQuickSaturateWord(In[2] * Ratio);     // Y
-
-    Out[3] = In[3];                                 // K (untouched)
-
-    return TRUE;
-}
-
-// This is a devicelink operating in CMYK for ink-limiting
-
-cmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID, 
-                                                     cmsColorSpaceSignature ColorSpace,
-                                                     cmsFloat64Number Limit)
-{
-    cmsHPROFILE hICC;
-    cmsPipeline* LUT;
-    cmsStage* CLUT;
-    int nChannels;
-    
-    if (ColorSpace != cmsSigCmykData) {
-        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "InkLimiting: Only CMYK currently supported");
-        return NULL;
-    }
-
-    if (Limit < 0.0 || Limit > 400) {
-
-        cmsSignalError(ContextID, cmsERROR_RANGE, "InkLimiting: Limit should be between 0..400");        
-        if (Limit < 0) Limit = 0;
-        if (Limit > 400) Limit = 400;
-
-    }
-
-    hICC = cmsCreateProfilePlaceholder(ContextID);
-    if (!hICC)                          // can't allocate
-        return NULL;
-
-    cmsSetProfileVersion(hICC, 4.2);
-
-    cmsSetDeviceClass(hICC,      cmsSigLinkClass);
-    cmsSetColorSpace(hICC,       ColorSpace);
-    cmsSetPCS(hICC,              ColorSpace);
-
-    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL); 
-
-
-    // Creates a Pipeline with 3D grid only
-    LUT = cmsPipelineAlloc(ContextID, 4, 4);
-    if (LUT == NULL) goto Error;
-    
-
-    nChannels = cmsChannelsOf(ColorSpace);
-    
-    CLUT = cmsStageAllocCLut16bit(ContextID, 17, nChannels, nChannels, NULL);
-    if (CLUT == NULL) goto Error;
-
-    if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;
-
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels));  
-    cmsPipelineInsertStage(LUT, cmsAT_END, CLUT);
-    cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels));
-
-    // Create tags
-    if (!SetTextTags(hICC, L"ink-limiting built-in")) goto Error;
-
-    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) LUT))  goto Error;
-    if (!SetSeqDescTag(hICC, "ink-limiting built-in")) goto Error;
-     
-    // cmsPipeline is already on virtual profile
-    cmsPipelineFree(LUT);
-
-    // Ok, done
-    return hICC;
-
-Error:
-    if (LUT != NULL)
-        cmsPipelineFree(LUT);
-
-    if (hICC != NULL)
-        cmsCloseProfile(hICC);
-
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLink(cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit)
-{
-    return cmsCreateInkLimitingDeviceLinkTHR(NULL, ColorSpace, Limit);
-}
-
-
-// Creates a fake Lab identity.
-cmsHPROFILE CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)
-{
-    cmsHPROFILE hProfile;        
-    cmsPipeline* LUT = NULL;
-    
-    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);
-    if (hProfile == NULL) return NULL;
-
-    cmsSetProfileVersion(hProfile, 2.1);
-
-    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);
-    cmsSetColorSpace(hProfile,  cmsSigLabData);
-    cmsSetPCS(hProfile,         cmsSigLabData);
-
-    if (!SetTextTags(hProfile, L"Lab identity built-in")) return NULL;
-
-    // An identity LUT is all we need
-    LUT = cmsPipelineAlloc(ContextID, 3, 3);
-    if (LUT == NULL) goto Error;
-
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3));
-
-    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
-    cmsPipelineFree(LUT);
-
-    return hProfile;
-
-Error:
-
-    if (LUT != NULL)
-        cmsPipelineFree(LUT);
-
-    if (hProfile != NULL)
-        cmsCloseProfile(hProfile);
-
-    return NULL;
-}
-
-
-cmsHPROFILE CMSEXPORT cmsCreateLab2Profile(const cmsCIExyY* WhitePoint)
-{
-    return cmsCreateLab2ProfileTHR(NULL, WhitePoint);
-}
-
-
-// Creates a fake Lab V4 identity.
-cmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)
-{
-    cmsHPROFILE hProfile;        
-    cmsPipeline* LUT = NULL;
-    
-    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);
-    if (hProfile == NULL) return NULL;
-
-    cmsSetProfileVersion(hProfile, 4.2);
-
-    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);
-    cmsSetColorSpace(hProfile,  cmsSigLabData);
-    cmsSetPCS(hProfile,         cmsSigLabData);
-
-    if (!SetTextTags(hProfile, L"Lab identity built-in")) goto Error;
-
-    // An empty LUTs is all we need
-    LUT = cmsPipelineAlloc(ContextID, 3, 3);
-    if (LUT == NULL) goto Error;
-
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
-
-    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
-    cmsPipelineFree(LUT);
-
-    return hProfile;
-
-Error:
-
-    if (LUT != NULL)
-        cmsPipelineFree(LUT);
-
-    if (hProfile != NULL)
-        cmsCloseProfile(hProfile);
-
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreateLab4Profile(const cmsCIExyY* WhitePoint)
-{
-    return cmsCreateLab4ProfileTHR(NULL, WhitePoint);
-}
-
-
-// Creates a fake XYZ identity
-cmsHPROFILE CMSEXPORT cmsCreateXYZProfileTHR(cmsContext ContextID)
-{
-    cmsHPROFILE hProfile;        
-    cmsPipeline* LUT = NULL;
-    
-    hProfile = cmsCreateRGBProfileTHR(ContextID, cmsD50_xyY(), NULL, NULL);
-    if (hProfile == NULL) return NULL;
-
-    cmsSetProfileVersion(hProfile, 4.2);
-
-    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);
-    cmsSetColorSpace(hProfile,  cmsSigXYZData);
-    cmsSetPCS(hProfile,         cmsSigXYZData);
-
-    if (!SetTextTags(hProfile, L"XYZ identity built-in")) goto Error;
-
-    // An identity LUT is all we need
-    LUT = cmsPipelineAlloc(ContextID, 3, 3);
-    if (LUT == NULL) goto Error;
-
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
-
-    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
-    cmsPipelineFree(LUT);
-
-    return hProfile;
-
-Error:
-
-    if (LUT != NULL)
-        cmsPipelineFree(LUT);
-
-    if (hProfile != NULL)
-        cmsCloseProfile(hProfile);
-
-    return NULL;
-}
-
-
-cmsHPROFILE CMSEXPORT cmsCreateXYZProfile(void)
-{
-    return cmsCreateXYZProfileTHR(NULL);
-}
-
-
-//sRGB Curves are defined by:
-//
-//If  RsRGB,GsRGB, BsRGB < 0.04045
-//
-//    R =  RsRGB / 12.92
-//    G =  GsRGB / 12.92
-//    B =  BsRGB / 12.92
-//
-//
-//else if  RsRGB,GsRGB, BsRGB >= 0.04045
-//
-//    R = ((RsRGB + 0.055) / 1.055)^2.4
-//    G = ((GsRGB + 0.055) / 1.055)^2.4
-//    B = ((BsRGB + 0.055) / 1.055)^2.4
-
-static
-cmsToneCurve* Build_sRGBGamma(cmsContext ContextID)
-{
-    cmsFloat64Number Parameters[5];
-
-    Parameters[0] = 2.4;
-    Parameters[1] = 1. / 1.055;
-    Parameters[2] = 0.055 / 1.055;
-    Parameters[3] = 1. / 12.92;
-    Parameters[4] = 0.04045;    
-
-    return cmsBuildParametricToneCurve(ContextID, 4, Parameters);
-}
-
-// Create the ICC virtual profile for sRGB space 
-cmsHPROFILE CMSEXPORT cmsCreate_sRGBProfileTHR(cmsContext ContextID)
-{
-       cmsCIExyY       D65;
-       cmsCIExyYTRIPLE Rec709Primaries = {
-                                   {0.6400, 0.3300, 1.0},
-                                   {0.3000, 0.6000, 1.0},
-                                   {0.1500, 0.0600, 1.0}
-                                   };
-       cmsToneCurve* Gamma22[3];
-       cmsHPROFILE  hsRGB;
- 
-       cmsWhitePointFromTemp(&D65, 6504);
-       Gamma22[0] = Gamma22[1] = Gamma22[2] = Build_sRGBGamma(ContextID);
-       if (Gamma22[0] == NULL) return NULL;
-           
-       hsRGB = cmsCreateRGBProfileTHR(ContextID, &D65, &Rec709Primaries, Gamma22);
-       cmsFreeToneCurve(Gamma22[0]);
-       if (hsRGB == NULL) return NULL;
-
-       if (!SetTextTags(hsRGB, L"sRGB built-in")) {
-           cmsCloseProfile(hsRGB);
-           return NULL;
-       }
-
-       return hsRGB;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreate_sRGBProfile(void)
-{
-    return cmsCreate_sRGBProfileTHR(NULL);
-}
-
-
-
-typedef struct {
-                cmsFloat64Number Brightness;
-                cmsFloat64Number Contrast;
-                cmsFloat64Number Hue;
-                cmsFloat64Number Saturation;
-                cmsCIEXYZ WPsrc, WPdest;
-
-} BCHSWADJUSTS, *LPBCHSWADJUSTS;
-
-
-static
-int bchswSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)
-{
-    cmsCIELab LabIn, LabOut;
-    cmsCIELCh LChIn, LChOut;
-    cmsCIEXYZ XYZ;
-    LPBCHSWADJUSTS bchsw = (LPBCHSWADJUSTS) Cargo;
-    
-
-    cmsLabEncoded2Float(&LabIn, In);
-    
-
-    cmsLab2LCh(&LChIn, &LabIn);
-
-    // Do some adjusts on LCh
-    
-    LChOut.L = LChIn.L * bchsw ->Contrast + bchsw ->Brightness;
-    LChOut.C = LChIn.C + bchsw -> Saturation;
-    LChOut.h = LChIn.h + bchsw -> Hue;
-    
-        
-    cmsLCh2Lab(&LabOut, &LChOut);
-
-    // Move white point in Lab
-
-    cmsLab2XYZ(&bchsw ->WPsrc,  &XYZ, &LabOut);
-    cmsXYZ2Lab(&bchsw ->WPdest, &LabOut, &XYZ);
-    
-    // Back to encoded
-
-    cmsFloat2LabEncoded(Out, &LabOut);
-    
-    return TRUE;
-}
-
-
-// Creates an abstract profile operating in Lab space for Brightness,
-// contrast, Saturation and white point displacement
-
-cmsHPROFILE CMSEXPORT cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,
-                                                     int nLUTPoints,
-                                                     cmsFloat64Number Bright, 
-                                                     cmsFloat64Number Contrast,
-                                                     cmsFloat64Number Hue,
-                                                     cmsFloat64Number Saturation,
-                                                     int TempSrc, 
-                                                     int TempDest)
-{
-     cmsHPROFILE hICC;
-     cmsPipeline* Pipeline;
-     BCHSWADJUSTS bchsw;
-     cmsCIExyY WhitePnt;
-     cmsStage* CLUT;
-     cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-     int i;
-
-
-     bchsw.Brightness = Bright;
-     bchsw.Contrast   = Contrast;
-     bchsw.Hue        = Hue;
-     bchsw.Saturation = Saturation;
-     
-     cmsWhitePointFromTemp(&WhitePnt, TempSrc );         
-     cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);
-
-     cmsWhitePointFromTemp(&WhitePnt, TempDest);
-     cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);
-    
-      hICC = cmsCreateProfilePlaceholder(ContextID);
-       if (!hICC)                          // can't allocate
-            return NULL;
-              
-
-       cmsSetDeviceClass(hICC,      cmsSigAbstractClass);
-       cmsSetColorSpace(hICC,       cmsSigLabData);
-       cmsSetPCS(hICC,              cmsSigLabData);
-
-       cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL); 
-
-      
-       // Creates a Pipeline with 3D grid only
-       Pipeline = cmsPipelineAlloc(ContextID, 3, 3);
-       if (Pipeline == NULL) {
-           cmsCloseProfile(hICC);
-           return NULL;
-           }
-
-       for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;
-       CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);
-       if (CLUT == NULL) return NULL;
-    
-       
-       if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {
-
-                // Shouldn't reach here
-                cmsPipelineFree(Pipeline);
-                cmsCloseProfile(hICC);
-                return NULL;
-       }    
-
-       cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT);
-
-       // Create tags
-        
-       if (!SetTextTags(hICC, L"BCHS built-in")) return NULL;    
-       
-       cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());
-
-       cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);
-       
-       // Pipeline is already on virtual profile
-       cmsPipelineFree(Pipeline);
-
-       // Ok, done
-       return hICC;
-}
-
-
-CMSAPI cmsHPROFILE   CMSEXPORT cmsCreateBCHSWabstractProfile(int nLUTPoints,
-                                                             cmsFloat64Number Bright, 
-                                                             cmsFloat64Number Contrast,
-                                                             cmsFloat64Number Hue,
-                                                             cmsFloat64Number Saturation,
-                                                             int TempSrc, 
-                                                             int TempDest)
-{
-    return cmsCreateBCHSWabstractProfileTHR(NULL, nLUTPoints, Bright, Contrast, Hue, Saturation, TempSrc, TempDest);
-}
-
-
-// Creates a fake NULL profile. This profile return 1 channel as always 0. 
-// Is useful only for gamut checking tricks
-cmsHPROFILE CMSEXPORT cmsCreateNULLProfileTHR(cmsContext ContextID)
-{
-    cmsHPROFILE hProfile;        
-    cmsPipeline* LUT = NULL;
-    cmsStage* PostLin;
-    cmsToneCurve* EmptyTab;
-    cmsUInt16Number Zero[2] = { 0, 0 };
-
-    hProfile = cmsCreateProfilePlaceholder(ContextID);
-    if (!hProfile)                          // can't allocate
-        return NULL;
-
-    cmsSetProfileVersion(hProfile, 4.2);
-
-    if (!SetTextTags(hProfile, L"NULL profile built-in")) goto Error;    
-
-    
-
-    cmsSetDeviceClass(hProfile, cmsSigOutputClass);
-    cmsSetColorSpace(hProfile,  cmsSigGrayData);
-    cmsSetPCS(hProfile,         cmsSigLabData);
-
-    // An empty LUTs is all we need
-    LUT = cmsPipelineAlloc(ContextID, 1, 1);
-    if (LUT == NULL) goto Error;
-
-    EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);       
-    PostLin = cmsStageAllocToneCurves(ContextID, 1, &EmptyTab);
-    cmsFreeToneCurve(EmptyTab);
-
-    cmsPipelineInsertStage(LUT, cmsAT_END, PostLin);
-
-    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;
-    if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;
-
-    cmsPipelineFree(LUT);       
-    return hProfile;
-
-Error:
-
-    if (LUT != NULL)
-        cmsPipelineFree(LUT);
-
-    if (hProfile != NULL)
-        cmsCloseProfile(hProfile);
-
-    return NULL;
-}
-
-cmsHPROFILE CMSEXPORT cmsCreateNULLProfile(void)
-{
-    return cmsCreateNULLProfileTHR(NULL);
-}
-
-
-static
-int IsPCS(cmsColorSpaceSignature ColorSpace)
-{
-    return (ColorSpace == cmsSigXYZData ||
-            ColorSpace == cmsSigLabData);
-}
-
-
-static
-void FixColorSpaces(cmsHPROFILE hProfile, 
-                              cmsColorSpaceSignature ColorSpace, 
-                              cmsColorSpaceSignature PCS,
-                              cmsUInt32Number dwFlags)
-{
-    if (dwFlags & cmsFLAGS_GUESSDEVICECLASS) {
-
-            if (IsPCS(ColorSpace) && IsPCS(PCS)) { 
-
-                    cmsSetDeviceClass(hProfile,      cmsSigAbstractClass);
-                    cmsSetColorSpace(hProfile,       ColorSpace);
-                    cmsSetPCS(hProfile,              PCS);
-                    return;
-            }
-
-            if (IsPCS(ColorSpace) && !IsPCS(PCS)) {
-
-                    cmsSetDeviceClass(hProfile, cmsSigOutputClass);
-                    cmsSetPCS(hProfile,         ColorSpace);
-                    cmsSetColorSpace(hProfile,  PCS);        
-                    return;
-            }
-
-            if (IsPCS(PCS) && !IsPCS(ColorSpace)) {
-
-                   cmsSetDeviceClass(hProfile,  cmsSigInputClass);
-                   cmsSetColorSpace(hProfile,   ColorSpace);
-                   cmsSetPCS(hProfile,          PCS);
-                   return;
-            }
-    }
-
-    cmsSetDeviceClass(hProfile,      cmsSigLinkClass);
-    cmsSetColorSpace(hProfile,       ColorSpace);
-    cmsSetPCS(hProfile,              PCS);
-}
-
-
-
-// This function creates a named color profile dumping all the contents of transform to a single profile
-// In this way, LittleCMS may be used to "group" several named color databases into a single profile.
-// It has, however, several minor limitations. PCS is always Lab, which is not very critic since this
-// is the normal PCS for named color profiles.
-static
-cmsHPROFILE CreateNamedColorDevicelink(cmsHTRANSFORM xform)
-{
-    _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;
-    cmsHPROFILE hICC = NULL;  
-    int i, nColors;
-    cmsNAMEDCOLORLIST *nc2 = NULL, *Original = NULL;
-
-    // Create an empty placeholder
-    hICC = cmsCreateProfilePlaceholder(v->ContextID);
-    if (hICC == NULL) return NULL;
-
-    // Critical information
-    cmsSetDeviceClass(hICC, cmsSigNamedColorClass);
-    cmsSetColorSpace(hICC, v ->ExitColorSpace);
-    cmsSetPCS(hICC, cmsSigLabData);
-
-    // Tag profile with information
-    if (!SetTextTags(hICC, L"Named color devicelink")) goto Error;    
-
-    Original = cmsGetNamedColorList(xform);
-    if (Original == NULL) goto Error;
-
-    nColors = cmsNamedColorCount(Original);
-    nc2     = cmsDupNamedColorList(Original);
-    if (nc2 == NULL) goto Error;
-
-    // Colorant count now depends on the output space 
-    nc2 ->ColorantCount = cmsPipelineOutputChannels(v ->Lut);
-
-    // Apply the transfor to colorants.
-    for (i=0; i < nColors; i++) {
-        cmsDoTransform(xform, &i, nc2 ->List[i].DeviceColorant, 1);
-    }
-
-    if (!cmsWriteTag(hICC, cmsSigNamedColor2Tag, (void*) nc2)) goto Error;
-    cmsFreeNamedColorList(nc2);
-
-    return hICC;
-
-Error:
-    if (hICC != NULL) cmsCloseProfile(hICC);
-    return NULL;
-}
-
-
-// This structure holds information about which MPU can be stored on a profile based on the version
-
-typedef struct {
-    cmsBool              IsV4;             // Is a V4 tag?
-    cmsTagSignature      RequiredTag;      // Set to 0 for both types
-    cmsTagTypeSignature  LutType;          // The LUT type
-    int                  nTypes;           // Number of types (up to 5)
-    cmsStageSignature    MpeTypes[5];      // 5 is the maximum number
-
-} cmsAllowedLUT;
-
-static const cmsAllowedLUT AllowedLUTTypes[] = {
-
-    { FALSE, 0,              cmsSigLut16Type,    4,  { cmsSigMatrixElemType,  cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
-    { FALSE, 0,              cmsSigLut16Type,    3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
-    { TRUE , 0,              cmsSigLutAtoBType,  1,  { cmsSigCurveSetElemType }},
-    { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType } },
-    { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType   } },
-    { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  5,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType }},
-    { TRUE , cmsSigBToA0Tag, cmsSigLutBtoAType,  1,  { cmsSigCurveSetElemType }},
-    { TRUE , cmsSigBToA0Tag, cmsSigLutBtoAType,  3,  { cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType }},
-    { TRUE , cmsSigBToA0Tag, cmsSigLutBtoAType,  3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType }},
-    { TRUE , cmsSigBToA0Tag, cmsSigLutBtoAType,  5,  { cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType }}
-};
-
-#define SIZE_OF_ALLOWED_LUT (sizeof(AllowedLUTTypes)/sizeof(cmsAllowedLUT))
-
-// Check a single entry
-static
-cmsBool CheckOne(const cmsAllowedLUT* Tab, const cmsPipeline* Lut)
-{
-    cmsStage* mpe;
-    int n;
-
-    for (n=0, mpe = Lut ->Elements; mpe != NULL; mpe = mpe ->Next, n++) {
-
-        if (n > Tab ->nTypes) return FALSE;
-        if (cmsStageType(mpe) != Tab ->MpeTypes[n]) return FALSE;             
-    }
-
-    return (n == Tab ->nTypes);
-}
-
-
-static 
-const cmsAllowedLUT* FindCombination(const cmsPipeline* Lut, cmsBool IsV4, cmsTagSignature DestinationTag)
-{
-    int n;
-
-    for (n=0; n < SIZE_OF_ALLOWED_LUT; n++) {
-
-        const cmsAllowedLUT* Tab = AllowedLUTTypes + n;
-
-        if (IsV4 ^ Tab -> IsV4) continue;
-        if ((Tab ->RequiredTag != 0) && (Tab ->RequiredTag != DestinationTag)) continue;
-
-        if (CheckOne(Tab, Lut)) return Tab;
-    }
-
-    return NULL;
-}
-    
-
-// Does convert a transform into a device link profile
-cmsHPROFILE CMSEXPORT cmsTransform2DeviceLink(cmsHTRANSFORM hTransform, cmsFloat64Number Version, cmsUInt32Number dwFlags)
-{
-    cmsHPROFILE hProfile = NULL;
-    cmsUInt32Number FrmIn, FrmOut, ChansIn, ChansOut;
-    cmsUInt32Number ColorSpaceBitsIn, ColorSpaceBitsOut;
-    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;
-    cmsPipeline* LUT = NULL;
-    cmsStage* mpe;
-    cmsContext ContextID = cmsGetTransformContextID(hTransform);
-    const cmsAllowedLUT* AllowedLUT;
-    cmsTagSignature DestinationTag;
-
-    _cmsAssert(hTransform != NULL);
-    
-    // Get the first mpe to check for named color
-    mpe = cmsPipelineGetPtrToFirstStage(xform ->Lut);
-    
-    // Check if is a named color transform
-    if (mpe != NULL) {
-
-        if (cmsStageType(mpe) == cmsSigNamedColorElemType) {
-            return CreateNamedColorDevicelink(hTransform);
-        }
-    }
-
-    // First thing to do is to get a copy of the transformation
-    LUT = cmsPipelineDup(xform ->Lut);
-    if (LUT == NULL) return NULL;
-
-    // Time to fix the Lab2/Lab4 issue.
-    if ((xform ->EntryColorSpace == cmsSigLabData) && (Version < 4.0)) {
-
-        cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID));        
-    }
-
-    // On the output side too
-    if ((xform ->ExitColorSpace) == cmsSigLabData && (Version < 4.0)) {
-
-        cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID));        
-    }
-    
-
-    hProfile = cmsCreateProfilePlaceholder(ContextID);
-    if (!hProfile) goto Error;                    // can't allocate        
-    
-    cmsSetProfileVersion(hProfile, Version);
-
-    FixColorSpaces(hProfile, xform -> EntryColorSpace, xform -> ExitColorSpace, dwFlags);   
-
-    // Optimize the LUT and precalculate a devicelink
-
-    ChansIn  = cmsChannelsOf(xform -> EntryColorSpace);
-    ChansOut = cmsChannelsOf(xform -> ExitColorSpace);
-
-    ColorSpaceBitsIn  = _cmsLCMScolorSpace(xform -> EntryColorSpace);
-    ColorSpaceBitsOut = _cmsLCMScolorSpace(xform -> ExitColorSpace);
-
-    FrmIn  = COLORSPACE_SH(ColorSpaceBitsIn) | CHANNELS_SH(ChansIn)|BYTES_SH(2);
-    FrmOut = COLORSPACE_SH(ColorSpaceBitsOut) | CHANNELS_SH(ChansOut)|BYTES_SH(2);
-
-
-     if (cmsGetDeviceClass(hProfile) == cmsSigOutputClass)
-         DestinationTag = cmsSigBToA0Tag;
-     else
-         DestinationTag = cmsSigAToB0Tag;
-
-    // Check if the profile/version can store the result
-    if (dwFlags & cmsFLAGS_FORCE_CLUT)
-        AllowedLUT = NULL;
-    else
-    AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
-
-    if (AllowedLUT == NULL) {
-
-        // Try to optimize
-        _cmsOptimizePipeline(&LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);
-        AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
-
-    }
-
-    // If no way, then force CLUT that for sure can be written
-    if (AllowedLUT == NULL) {
-
-        dwFlags |= cmsFLAGS_FORCE_CLUT;
-        _cmsOptimizePipeline(&LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);
-
-        // Put identity curves if needed
-        if (cmsPipelineStageCount(LUT) == 1) {
-
-            cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn));    
-            cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut));   
-        }
-
-        AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
-    }
-
-    // Somethings is wrong...
-    if (AllowedLUT == NULL) {
-        goto Error;
-    }
-
-
-    if (dwFlags & cmsFLAGS_8BITS_DEVICELINK) 
-                     cmsPipelineSetSaveAs8bitsFlag(LUT, TRUE);
-        
-    // Tag profile with information
-    if (!SetTextTags(hProfile, L"devicelink")) goto Error;    
-                
-    // Store result            
-    if (!cmsWriteTag(hProfile, DestinationTag, LUT)) goto Error;
-    
-    
-    if (xform -> InputColorant != NULL) {
-           if (!cmsWriteTag(hProfile, cmsSigColorantTableTag, xform->InputColorant)) goto Error;
-    }
-
-    if (xform -> OutputColorant != NULL) {
-           if (!cmsWriteTag(hProfile, cmsSigColorantTableOutTag, xform->OutputColorant)) goto Error;
-    }
-    
-    if (xform ->Sequence != NULL) {
-        if (!_cmsWriteProfileSequence(hProfile, xform ->Sequence)) goto Error;
-    }
-
-    cmsPipelineFree(LUT);       
-    return hProfile;
-
-Error:
-    if (LUT != NULL) cmsPipelineFree(LUT);       
-    cmsCloseProfile(hProfile);
-    return NULL;
-}
diff --git a/thirdparty/liblcms2/src/cmswtpnt.c b/thirdparty/liblcms2/src/cmswtpnt.c
deleted file mode 100644
index 6319984..0000000
--- a/thirdparty/liblcms2/src/cmswtpnt.c
+++ /dev/null
@@ -1,351 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-
-// D50 - Widely used
-const cmsCIEXYZ* CMSEXPORT cmsD50_XYZ(void)
-{
-    static cmsCIEXYZ D50XYZ = {cmsD50X, cmsD50Y, cmsD50Z};
-
-    return &D50XYZ;
-}
-
-const cmsCIExyY* CMSEXPORT cmsD50_xyY(void)
-{
-    static cmsCIExyY D50xyY;
-
-    cmsXYZ2xyY(&D50xyY, cmsD50_XYZ());
-
-    return &D50xyY;
-}
-
-// Obtains WhitePoint from Temperature
-cmsBool  CMSEXPORT cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number TempK)
-{
-       cmsFloat64Number x, y;
-       cmsFloat64Number T, T2, T3;
-       // cmsFloat64Number M1, M2;
-
-	   _cmsAssert(WhitePoint != NULL);
-
-       T = TempK;
-       T2 = T*T;            // Square
-       T3 = T2*T;           // Cube
-
-       // For correlated color temperature (T) between 4000K and 7000K:
-
-       if (T >= 4000. && T <= 7000.)
-       {
-              x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;
-       }
-       else
-              // or for correlated color temperature (T) between 7000K and 25000K:
-
-       if (T > 7000.0 && T <= 25000.0)
-       {
-              x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;
-       }
-       else {
-              cmsSignalError(0, cmsERROR_RANGE, "cmsWhitePointFromTemp: invalid temp");
-              return FALSE;
-              }
-
-       // Obtain y(x)
-
-       y = -3.000*(x*x) + 2.870*x - 0.275;
-
-       // wave factors (not used, but here for futures extensions)
-
-       // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);
-       // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);
-
-       WhitePoint -> x = x;
-       WhitePoint -> y = y;
-       WhitePoint -> Y = 1.0;
-
-       return TRUE;
-}
-
-
-
-typedef struct {
-
-    cmsFloat64Number mirek;  // temp (in microreciprocal kelvin) 
-    cmsFloat64Number ut;     // u coord of intersection w/ blackbody locus  
-    cmsFloat64Number vt;     // v coord of intersection w/ blackbody locus 
-    cmsFloat64Number tt;     // slope of ISOTEMPERATURE. line 
-
-    } ISOTEMPERATURE;
-
-static ISOTEMPERATURE isotempdata[] = {
-//  {Mirek, Ut,       Vt,      Tt      } 
-    {0,     0.18006,  0.26352,  -0.24341},
-    {10,    0.18066,  0.26589,  -0.25479},
-    {20,    0.18133,  0.26846,  -0.26876},
-    {30,    0.18208,  0.27119,  -0.28539},
-    {40,    0.18293,  0.27407,  -0.30470},
-    {50,    0.18388,  0.27709,  -0.32675},
-    {60,    0.18494,  0.28021,  -0.35156},
-    {70,    0.18611,  0.28342,  -0.37915},
-    {80,    0.18740,  0.28668,  -0.40955},
-    {90,    0.18880,  0.28997,  -0.44278},
-    {100,   0.19032,  0.29326,  -0.47888},
-    {125,   0.19462,  0.30141,  -0.58204},
-    {150,   0.19962,  0.30921,  -0.70471},
-    {175,   0.20525,  0.31647,  -0.84901},
-    {200,   0.21142,  0.32312,  -1.0182 },
-    {225,   0.21807,  0.32909,  -1.2168 },
-    {250,   0.22511,  0.33439,  -1.4512 },
-    {275,   0.23247,  0.33904,  -1.7298 },
-    {300,   0.24010,  0.34308,  -2.0637 },
-    {325,   0.24702,  0.34655,  -2.4681 },
-    {350,   0.25591,  0.34951,  -2.9641 },
-    {375,   0.26400,  0.35200,  -3.5814 },
-    {400,   0.27218,  0.35407,  -4.3633 },
-    {425,   0.28039,  0.35577,  -5.3762 },
-    {450,   0.28863,  0.35714,  -6.7262 },
-    {475,   0.29685,  0.35823,  -8.5955 },
-    {500,   0.30505,  0.35907,  -11.324 },
-    {525,   0.31320,  0.35968,  -15.628 },
-    {550,   0.32129,  0.36011,  -23.325 },
-    {575,   0.32931,  0.36038,  -40.770 },
-    {600,   0.33724,  0.36051,  -116.45  }
-};
-
-#define NISO sizeof(isotempdata)/sizeof(ISOTEMPERATURE)
-
-
-// Robertson's method
-cmsBool  CMSEXPORT cmsTempFromWhitePoint(cmsFloat64Number* TempK, const cmsCIExyY* WhitePoint)
-{
-	int j;
-	cmsFloat64Number us,vs;
-	cmsFloat64Number uj,vj,tj,di,dj,mi,mj;
-	cmsFloat64Number xs, ys;
-
-	_cmsAssert(WhitePoint != NULL);
-    _cmsAssert(TempK != NULL);
-
-	di = mi = 0;
-	xs = WhitePoint -> x;
-	ys = WhitePoint -> y;
-
-	// convert (x,y) to CIE 1960 (u,WhitePoint) 
-
-	us = (2*xs) / (-xs + 6*ys + 1.5);
-	vs = (3*ys) / (-xs + 6*ys + 1.5);
-
-
-	for (j=0; j < NISO; j++) {
-
-		uj = isotempdata[j].ut;
-		vj = isotempdata[j].vt;
-		tj = isotempdata[j].tt;
-		mj = isotempdata[j].mirek;
-
-		dj = ((vs - vj) - tj * (us - uj)) / sqrt(1.0 + tj * tj);
-
-		if ((j != 0) && (di/dj < 0.0)) {
-
-			// Found a match
-			*TempK = 1000000.0 / (mi + (di / (di - dj)) * (mj - mi));
-			return TRUE;
-		}
-
-		di = dj;
-		mi = mj;
-	}
-
-	// Not found
-	return FALSE;
-}
-
-
-// Compute chromatic adaptation matrix using Chad as cone matrix 
-
-static
-cmsBool ComputeChromaticAdaptation(cmsMAT3* Conversion,
-                                const cmsCIEXYZ* SourceWhitePoint,
-                                const cmsCIEXYZ* DestWhitePoint,
-                                const cmsMAT3* Chad)
-
-{
-      
-    cmsMAT3 Chad_Inv;
-    cmsVEC3 ConeSourceXYZ, ConeSourceRGB;
-    cmsVEC3 ConeDestXYZ, ConeDestRGB;
-    cmsMAT3 Cone, Tmp;
-
-
-    Tmp = *Chad;
-    if (!_cmsMAT3inverse(&Tmp, &Chad_Inv)) return FALSE;
-
-    _cmsVEC3init(&ConeSourceXYZ, SourceWhitePoint -> X,
-                             SourceWhitePoint -> Y,
-                             SourceWhitePoint -> Z);
-
-    _cmsVEC3init(&ConeDestXYZ,   DestWhitePoint -> X,
-                             DestWhitePoint -> Y,
-                             DestWhitePoint -> Z);
-
-    _cmsMAT3eval(&ConeSourceRGB, Chad, &ConeSourceXYZ);
-    _cmsMAT3eval(&ConeDestRGB,   Chad, &ConeDestXYZ);
-
-    // Build matrix
-    _cmsVEC3init(&Cone.v[0], ConeDestRGB.n[0]/ConeSourceRGB.n[0],    0.0,  0.0);
-    _cmsVEC3init(&Cone.v[1], 0.0,   ConeDestRGB.n[1]/ConeSourceRGB.n[1],   0.0);
-    _cmsVEC3init(&Cone.v[2], 0.0,   0.0,   ConeDestRGB.n[2]/ConeSourceRGB.n[2]);
-
-
-    // Normalize
-    _cmsMAT3per(&Tmp, &Cone, Chad);
-    _cmsMAT3per(Conversion, &Chad_Inv, &Tmp);
-
-	return TRUE;
-}
-
-// Returns the final chrmatic adaptation from illuminant FromIll to Illuminant ToIll
-// The cone matrix can be specified in ConeMatrix. If NULL, Bradford is assumed
-cmsBool  _cmsAdaptationMatrix(cmsMAT3* r, const cmsMAT3* ConeMatrix, const cmsCIEXYZ* FromIll, const cmsCIEXYZ* ToIll)
-{
-	cmsMAT3 LamRigg   = {{ // Bradford matrix
-		{{  0.8951,  0.2664, -0.1614 }},
-		{{ -0.7502,  1.7135,  0.0367 }},
-		{{  0.0389, -0.0685,  1.0296 }}
-	}};
-
-	if (ConeMatrix == NULL)
-		ConeMatrix = &LamRigg;
-
-	return ComputeChromaticAdaptation(r, FromIll, ToIll, ConeMatrix);	
-}
-
-// Same as anterior, but assuming D50 destination. White point is given in xyY
-static
-cmsBool _cmsAdaptMatrixToD50(cmsMAT3* r, const cmsCIExyY* SourceWhitePt)
-{
-	cmsCIEXYZ Dn;      
-	cmsMAT3 Bradford;
-	cmsMAT3 Tmp;
-
-	cmsxyY2XYZ(&Dn, SourceWhitePt);
-
-	if (!_cmsAdaptationMatrix(&Bradford, NULL, &Dn, cmsD50_XYZ())) return FALSE;
-
-	Tmp = *r;
-	_cmsMAT3per(r, &Bradford, &Tmp);
-
-	return TRUE;
-}
-
-// Build a White point, primary chromas transfer matrix from RGB to CIE XYZ
-// This is just an approximation, I am not handling all the non-linear
-// aspects of the RGB to XYZ process, and assumming that the gamma correction
-// has transitive property in the tranformation chain.
-//
-// the alghoritm:
-//
-//            - First I build the absolute conversion matrix using
-//              primaries in XYZ. This matrix is next inverted
-//            - Then I eval the source white point across this matrix
-//              obtaining the coeficients of the transformation
-//            - Then, I apply these coeficients to the original matrix
-//
-cmsBool _cmsBuildRGB2XYZtransferMatrix(cmsMAT3* r, const cmsCIExyY* WhitePt, const cmsCIExyYTRIPLE* Primrs)
-{
-	cmsVEC3 WhitePoint, Coef;
-	cmsMAT3 Result, Primaries;
-	cmsFloat64Number xn, yn;
-	cmsFloat64Number xr, yr;
-	cmsFloat64Number xg, yg;
-	cmsFloat64Number xb, yb;
-
-	xn = WhitePt -> x;
-	yn = WhitePt -> y;
-	xr = Primrs -> Red.x;
-	yr = Primrs -> Red.y;
-	xg = Primrs -> Green.x;
-	yg = Primrs -> Green.y;
-	xb = Primrs -> Blue.x;
-	yb = Primrs -> Blue.y;
-
-	// Build Primaries matrix
-	_cmsVEC3init(&Primaries.v[0], xr,        xg,         xb);
-	_cmsVEC3init(&Primaries.v[1], yr,        yg,         yb);
-	_cmsVEC3init(&Primaries.v[2], (1-xr-yr), (1-xg-yg),  (1-xb-yb));
-
-
-	// Result = Primaries ^ (-1) inverse matrix
-	if (!_cmsMAT3inverse(&Primaries, &Result))
-		return FALSE;
-
-
-	_cmsVEC3init(&WhitePoint, xn/yn, 1.0, (1.0-xn-yn)/yn);
-
-	// Across inverse primaries ...
-	_cmsMAT3eval(&Coef, &Result, &WhitePoint);
-
-	// Give us the Coefs, then I build transformation matrix
-	_cmsVEC3init(&r -> v[0], Coef.n[VX]*xr,          Coef.n[VY]*xg,          Coef.n[VZ]*xb);
-	_cmsVEC3init(&r -> v[1], Coef.n[VX]*yr,          Coef.n[VY]*yg,          Coef.n[VZ]*yb);
-	_cmsVEC3init(&r -> v[2], Coef.n[VX]*(1.0-xr-yr), Coef.n[VY]*(1.0-xg-yg), Coef.n[VZ]*(1.0-xb-yb));
-
-
-	return _cmsAdaptMatrixToD50(r, WhitePt);
-	
-}
-
-
-// Adapts a color to a given illuminant. Original color is expected to have
-// a SourceWhitePt white point. 
-cmsBool CMSEXPORT cmsAdaptToIlluminant(cmsCIEXYZ* Result, 
-							 const cmsCIEXYZ* SourceWhitePt, 
-							 const cmsCIEXYZ* Illuminant, 
-							 const cmsCIEXYZ* Value)
-{
-	cmsMAT3 Bradford;
-	cmsVEC3 In, Out;
-
-	_cmsAssert(Result != NULL);
-	_cmsAssert(SourceWhitePt != NULL);
-	_cmsAssert(Illuminant != NULL);
-	_cmsAssert(Value != NULL);
-
-	if (!_cmsAdaptationMatrix(&Bradford, NULL, SourceWhitePt, Illuminant)) return FALSE;
-
-	_cmsVEC3init(&In, Value -> X, Value -> Y, Value -> Z);
-	_cmsMAT3eval(&Out, &Bradford, &In);
-
-	Result -> X = Out.n[0];
-	Result -> Y = Out.n[1];
-	Result -> Z = Out.n[2];
-
-	return TRUE;
-}
-
-
diff --git a/thirdparty/liblcms2/src/cmsxform.c b/thirdparty/liblcms2/src/cmsxform.c
deleted file mode 100644
index 7f5cc94..0000000
--- a/thirdparty/liblcms2/src/cmsxform.c
+++ /dev/null
@@ -1,809 +0,0 @@
-//---------------------------------------------------------------------------------
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#include "lcms2_internal.h"
-
-// Transformations stuff
-// -----------------------------------------------------------------------
-
-// Alarm codes for 16-bit transformations, because the fixed range of containers there are
-// no values left to mark out of gamut. volatile is C99 per 6.2.5
-static volatile cmsUInt16Number Alarm[cmsMAXCHANNELS];
-static volatile cmsFloat64Number GlobalAdaptationState = 0;
-
-// The adaptation state may be defaulted by this function. If you don't like it, use the extended transform routine
-cmsFloat64Number CMSEXPORT cmsSetAdaptationState(cmsFloat64Number d)
-{
-    cmsFloat64Number OldVal = GlobalAdaptationState;
-
-    if (d >= 0) 
-        GlobalAdaptationState = d;
-
-    return OldVal;  
-}
-
-// Alarm codes are always global
-void CMSEXPORT cmsSetAlarmCodes(cmsUInt16Number NewAlarm[cmsMAXCHANNELS])
-{
-    int i;
-
-    _cmsAssert(NewAlarm != NULL);
-
-    for (i=0; i < cmsMAXCHANNELS; i++) 
-        Alarm[i] = NewAlarm[i];
-}
-
-// You can get the codes cas well
-void CMSEXPORT cmsGetAlarmCodes(cmsUInt16Number OldAlarm[cmsMAXCHANNELS])
-{
-    int i;
-
-    _cmsAssert(OldAlarm != NULL);
-
-    for (i=0; i < cmsMAXCHANNELS; i++) 
-        OldAlarm[i] = Alarm[i];
-}
-
-// Get rid of transform resources
-void CMSEXPORT cmsDeleteTransform(cmsHTRANSFORM hTransform)
-{
-    _cmsTRANSFORM* p = (_cmsTRANSFORM*) hTransform;
-
-    _cmsAssert(p != NULL);
-
-    if (p -> GamutCheck)
-        cmsPipelineFree(p -> GamutCheck);
-
-    if (p -> Lut)
-        cmsPipelineFree(p -> Lut);
-
-    if (p ->InputColorant)
-        cmsFreeNamedColorList(p ->InputColorant);
-
-    if (p -> OutputColorant)
-        cmsFreeNamedColorList(p ->OutputColorant);
-
-    if (p ->Sequence)
-        cmsFreeProfileSequenceDescription(p ->Sequence);
-
-    LCMS_FREE_LOCK(&p->rwlock);
-    _cmsFree(p ->ContextID, (void *) p);
-}
-
-// Apply transform 
-void CMSEXPORT cmsDoTransform(cmsHTRANSFORM  Transform,
-                              const void* InputBuffer,
-                              void* OutputBuffer, 
-                              cmsUInt32Number Size)
-
-{
-    _cmsTRANSFORM* p = (_cmsTRANSFORM*) Transform;
-
-    p -> xform(p, InputBuffer, OutputBuffer, Size);
-}
-
-
-// Transform routines ----------------------------------------------------------------------------------------------------------
-
-// Float xform converts floats. Since there are no performance issues, one routine does all job, including gamut check.
-// Note that because extended range, we can use a -1.0 value for out of gamut in this case.
-static
-void FloatXFORM(_cmsTRANSFORM* p,
-                const void* in,
-                void* out, cmsUInt32Number Size)
-{
-    cmsUInt8Number* accum;
-    cmsUInt8Number* output;
-    cmsFloat32Number fIn[cmsMAXCHANNELS], fOut[cmsMAXCHANNELS];
-    cmsFloat32Number OutOfGamut;
-    cmsUInt32Number i, j;
-
-    accum  = (cmsUInt8Number*)  in;
-    output = (cmsUInt8Number*)  out;
-
-    for (i=0; i < Size; i++) {
-
-        accum = p -> FromInputFloat(p, fIn, accum, Size);         
-
-        // Any gamut chack to do?
-        if (p ->GamutCheck != NULL) {
-
-            // Evaluate gamut marker.
-            cmsPipelineEvalFloat( fIn, &OutOfGamut, p ->GamutCheck);
-
-            // Is current color out of gamut?
-            if (OutOfGamut > 0.0) {
-
-                // Certainly, out of gamut
-                for (j=0; j < cmsMAXCHANNELS; j++)
-                    fOut[j] = -1.0;
-
-            }
-            else {
-                // No, proceed normally
-                cmsPipelineEvalFloat(fIn, fOut, p -> Lut); 
-            }
-        }
-        else {
-
-            // No gamut check at all
-            cmsPipelineEvalFloat(fIn, fOut, p -> Lut);     
-        }
-
-        // Back to asked representation
-        output = p -> ToOutputFloat(p, fOut, output, Size);
-    }
-}
-
-// 16 bit precision -----------------------------------------------------------------------------------------------------------
-
-// Null transformation, only applies formatters. No cach
-static
-void NullXFORM(_cmsTRANSFORM* p,
-               const void* in,
-               void* out, cmsUInt32Number Size)
-{
-    cmsUInt8Number* accum;
-    cmsUInt8Number* output;
-    cmsUInt16Number wIn[cmsMAXCHANNELS];
-    cmsUInt32Number i, n;
-
-    accum  = (cmsUInt8Number*)  in;
-    output = (cmsUInt8Number*)  out;
-    n = Size;                    // Buffer len
-
-    for (i=0; i < n; i++) {
-
-        accum  = p -> FromInput(p, wIn, accum, Size);
-        output = p -> ToOutput(p, wIn, output, Size);
-    }
-}
-
-
-// No gamut check, no cache, 16 bits
-static
-void PrecalculatedXFORM(_cmsTRANSFORM* p,
-                        const void* in,
-                        void* out, cmsUInt32Number Size)
-{
-    register cmsUInt8Number* accum;
-    register cmsUInt8Number* output;
-    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];
-    cmsUInt32Number i, n;
-
-    accum  = (cmsUInt8Number*)  in;
-    output = (cmsUInt8Number*)  out;
-    n = Size;                    
-
-    for (i=0; i < n; i++) {
-
-        accum = p -> FromInput(p, wIn, accum, Size);         
-        p ->Lut ->Eval16Fn(wIn, wOut, p -> Lut->Data);     
-        output = p -> ToOutput(p, wOut, output, Size);
-    }
-}
-
-
-// Auxiliar: Handle precalculated gamut check
-static
-void TransformOnePixelWithGamutCheck(_cmsTRANSFORM* p, 
-                                     const cmsUInt16Number wIn[], 
-                                     cmsUInt16Number wOut[])
-{
-    cmsUInt16Number wOutOfGamut;
-
-    p ->GamutCheck ->Eval16Fn(wIn, &wOutOfGamut, p ->GamutCheck ->Data);   
-    if (wOutOfGamut >= 1) {
-
-        cmsUInt16Number i;
-
-        for (i=0; i < p ->Lut->OutputChannels; i++)
-            wOut[i] = Alarm[i];                      
-    }
-    else
-        p ->Lut ->Eval16Fn(wIn, wOut, p -> Lut->Data);   
-}
-
-// Gamut check, No cach, 16 bits.
-static
-void PrecalculatedXFORMGamutCheck(_cmsTRANSFORM* p,
-                                  const void* in,
-                                  void* out, cmsUInt32Number Size)
-{
-    cmsUInt8Number* accum;
-    cmsUInt8Number* output;
-    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];
-    cmsUInt32Number i, n;
-
-    accum  = (cmsUInt8Number*)  in;
-    output = (cmsUInt8Number*)  out;
-    n = Size;                    // Buffer len
-
-    for (i=0; i < n; i++) {
-
-        accum = p -> FromInput(p, wIn, accum, Size);
-        TransformOnePixelWithGamutCheck(p, wIn, wOut);
-        output = p -> ToOutput(p, wOut, output, Size);
-    }
-}
-
-
-// No gamut check, Cach, 16 bits, 
-static
-void CachedXFORM(_cmsTRANSFORM* p,
-                 const void* in,
-                 void* out, cmsUInt32Number Size)
-{
-    cmsUInt8Number* accum;
-    cmsUInt8Number* output;
-    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];
-    cmsUInt32Number i, n;
-    cmsUInt16Number CacheIn[cmsMAXCHANNELS], CacheOut[cmsMAXCHANNELS];
-
-    accum  = (cmsUInt8Number*)  in;
-    output = (cmsUInt8Number*)  out;
-    n = Size;                    // Buffer len
-
-    // Empty buffers for quick memcmp
-    memset(wIn,  0, sizeof(wIn));
-    memset(wOut, 0, sizeof(wOut));
-
-
-    LCMS_READ_LOCK(&p ->rwlock);
-    memmove(CacheIn,  p ->CacheIn, sizeof(CacheIn));
-    memmove(CacheOut, p ->CacheOut, sizeof(CacheOut));
-    LCMS_UNLOCK(&p ->rwlock);
-
-    for (i=0; i < n; i++) {
-
-        accum = p -> FromInput(p, wIn, accum, Size);
-
-        if (memcmp(wIn, CacheIn, sizeof(CacheIn)) == 0) {
-
-            memmove(wOut, CacheOut, sizeof(CacheOut));
-        }
-        else {   
-
-            p ->Lut ->Eval16Fn(wIn, wOut, p -> Lut->Data);  
-
-            memmove(CacheIn,  wIn,  sizeof(CacheIn));
-            memmove(CacheOut, wOut, sizeof(CacheOut));
-        }
-
-        output = p -> ToOutput(p, wOut, output, Size);            
-    }
-
-
-    LCMS_WRITE_LOCK(&p ->rwlock);
-    memmove(p->CacheIn,  CacheIn, sizeof(CacheIn));
-    memmove(p->CacheOut, CacheOut, sizeof(CacheOut));
-    LCMS_UNLOCK(&p ->rwlock);
-}
-
-
-// All those nice features together
-static
-void CachedXFORMGamutCheck(_cmsTRANSFORM* p,
-                           const void* in,
-                           void* out, cmsUInt32Number Size)
-{
-       cmsUInt8Number* accum;
-       cmsUInt8Number* output;
-       cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];
-       cmsUInt32Number i, n;
-       cmsUInt16Number CacheIn[cmsMAXCHANNELS], CacheOut[cmsMAXCHANNELS];
-
-       accum  = (cmsUInt8Number*)  in;
-       output = (cmsUInt8Number*)  out;
-       n = Size;                    // Buffer len
-
-       // Empty buffers for quick memcmp
-       memset(wIn,  0, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-       memset(wOut, 0, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-
-       LCMS_READ_LOCK(&p ->rwlock);
-           memmove(CacheIn,  p ->CacheIn, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-           memmove(CacheOut, p ->CacheOut, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-       LCMS_UNLOCK(&p ->rwlock);
-
-
-       for (i=0; i < n; i++) {
-
-            accum = p -> FromInput(p, wIn, accum, Size);
-     
-            if (memcmp(wIn, CacheIn, sizeof(cmsUInt16Number) * cmsMAXCHANNELS) == 0) {
-                    memmove(wOut, CacheOut, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-            }
-            else {            
-                    TransformOnePixelWithGamutCheck(p, wIn, wOut);
-                    memmove(CacheIn, wIn, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-                    memmove(CacheOut, wOut, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-            }
-
-            output = p -> ToOutput(p, wOut, output, Size);
-       }
-
-        LCMS_WRITE_LOCK(&p ->rwlock);
-           memmove(p->CacheIn,  CacheIn, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-           memmove(p->CacheOut, CacheOut, sizeof(cmsUInt16Number) * cmsMAXCHANNELS);
-        LCMS_UNLOCK(&p ->rwlock);
-}
-
-
-
-
-// Allocate transform struct and set it to defaults
-static
-_cmsTRANSFORM* AllocEmptyTransform(cmsContext ContextID, cmsUInt32Number InputFormat, cmsUInt32Number OutputFormat, cmsUInt32Number dwFlags)
-{
-    // Allocate needed memory
-    _cmsTRANSFORM* p = (_cmsTRANSFORM*) _cmsMallocZero(ContextID, sizeof(_cmsTRANSFORM));
-    if (!p) return NULL;
-
-    // Check whatever this is a true floating point transform
-    if (_cmsFormatterIsFloat(InputFormat) && _cmsFormatterIsFloat(OutputFormat)) {
-
-        // Get formatter function always return a valid union, but the contents of this union may be NULL.
-        p ->FromInputFloat = _cmsGetFormatter(InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_FLOAT).FmtFloat;
-        p ->ToOutputFloat  = _cmsGetFormatter(OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT).FmtFloat;
-        dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;
-
-        if (p ->FromInputFloat == NULL || p ->ToOutputFloat == NULL) {
-        
-            cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported raster format");
-            _cmsFree(ContextID, p);
-            return NULL;
-        }
-
-        // Float transforms don't use cach, always are non-NULL
-        p ->xform = FloatXFORM;
-    }
-    else {
-
-        if (InputFormat == 0 && OutputFormat == 0) {
-            p ->FromInput = p ->ToOutput = NULL;
-        }
-        else {
-
-            int BytesPerPixelInput;
-
-            p ->FromInput = _cmsGetFormatter(InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;
-            p ->ToOutput  = _cmsGetFormatter(OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;
-
-
-            if (p ->FromInput == NULL || p ->ToOutput == NULL) {
-
-                cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported raster format");
-                _cmsFree(ContextID, p);
-                return NULL;
-            }
-
-            BytesPerPixelInput = T_BYTES(p ->InputFormat);
-            if (BytesPerPixelInput == 0 || BytesPerPixelInput >= 2) 
-                   dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;
-
-        }
-
-        if (dwFlags & cmsFLAGS_NULLTRANSFORM) {
-
-            p ->xform = NullXFORM;
-        }
-        else {
-            if (dwFlags & cmsFLAGS_NOCACHE) {
-
-                if (dwFlags & cmsFLAGS_GAMUTCHECK) 
-                    p ->xform = PrecalculatedXFORMGamutCheck;  // Gamut check, no cach
-                else
-                    p ->xform = PrecalculatedXFORM;  // No cach, no gamut check
-            }
-            else {
-
-                if (dwFlags & cmsFLAGS_GAMUTCHECK) 
-                    p ->xform = CachedXFORMGamutCheck;    // Gamut check, cach
-                else
-                    p ->xform = CachedXFORM;  // No gamut check, cach
-
-            }
-        }
-    }
-
-    
-    // Create a mutex for shared memory
-    LCMS_CREATE_LOCK(&p->rwlock);
-
-    p ->InputFormat     = InputFormat;
-    p ->OutputFormat    = OutputFormat;
-    p ->dwOriginalFlags = dwFlags;
-    p ->ContextID       = ContextID;
-    return p;
-}
-
-static
-cmsBool GetXFormColorSpaces(int nProfiles, cmsHPROFILE hProfiles[], cmsColorSpaceSignature* Input, cmsColorSpaceSignature* Output) 
-{    
-    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut;   
-    cmsColorSpaceSignature PostColorSpace;   
-    int i;
-
-	if (hProfiles[0] == NULL) return FALSE;
-
-    *Input = PostColorSpace = cmsGetColorSpace(hProfiles[0]);
-
-    for (i=0; i < nProfiles; i++) {
-
-        cmsHPROFILE hProfile = hProfiles[i];
-
-        int lIsInput = (PostColorSpace != cmsSigXYZData) &&
-                       (PostColorSpace != cmsSigLabData);
-
-		if (hProfile == NULL) return FALSE;
-
-        if (lIsInput) {
-
-            ColorSpaceIn    = cmsGetColorSpace(hProfile);
-            ColorSpaceOut   = cmsGetPCS(hProfile);
-        }
-        else {
-
-            ColorSpaceIn    = cmsGetPCS(hProfile);
-            ColorSpaceOut   = cmsGetColorSpace(hProfile);
-        }
-
-        PostColorSpace = ColorSpaceOut;     
-    }  
-
-    *Output = PostColorSpace;
-
-	return TRUE;
-}
-
-// Check colorspace
-static
-cmsBool  IsProperColorSpace(cmsColorSpaceSignature Check, cmsUInt32Number dwFormat)
-{
-    int Space1 = T_COLORSPACE(dwFormat);
-    int Space2 = _cmsLCMScolorSpace(Check);
-
-    if (Space1 == PT_ANY) return TRUE;
-    if (Space1 == Space2) return TRUE;
-
-    if (Space1 == PT_LabV2 && Space2 == PT_Lab) return TRUE;
-    if (Space1 == PT_Lab   && Space2 == PT_LabV2) return TRUE;
-
-    return FALSE;
-}
-
-// ----------------------------------------------------------------------------------------------------------------
-
-// New to lcms 2.0 -- have all parameters available.
-cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
-                                                   cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[], 
-                                                   cmsBool  BPC[], 
-                                                   cmsUInt32Number Intents[], 
-                                                   cmsFloat64Number AdaptationStates[],
-                                                   cmsHPROFILE hGamutProfile,
-                                                   cmsUInt32Number nGamutPCSposition,           
-                                                   cmsUInt32Number InputFormat,
-                                                   cmsUInt32Number OutputFormat,
-                                                   cmsUInt32Number dwFlags)
-{
-    _cmsTRANSFORM* xform;
-    cmsBool  FloatTransform;
-    cmsColorSpaceSignature EntryColorSpace;
-    cmsColorSpaceSignature ExitColorSpace;
-    cmsPipeline* Lut;
-    cmsUInt32Number LastIntent = Intents[nProfiles-1];
-
-    // If gamut check is requested, make sure we have a gamut profile
-    if (dwFlags & cmsFLAGS_GAMUTCHECK) {
-        if (hGamutProfile == NULL) dwFlags &= ~cmsFLAGS_GAMUTCHECK;
-    }
-
-    // On floating point transforms, inhibit optimizations 
-    FloatTransform = (_cmsFormatterIsFloat(InputFormat) && _cmsFormatterIsFloat(OutputFormat));
-
-    if (_cmsFormatterIsFloat(InputFormat) || _cmsFormatterIsFloat(OutputFormat))
-        dwFlags |= cmsFLAGS_NOCACHE;
-
-    // Mark entry/exit spaces
-	if (!GetXFormColorSpaces(nProfiles, hProfiles, &EntryColorSpace, &ExitColorSpace)) {
-		cmsSignalError(ContextID, cmsERROR_NULL, "NULL input profiles on transform");        
-		return NULL;
-	}
-
-    // Check if proper colorspaces
-    if (!IsProperColorSpace(EntryColorSpace, InputFormat)) {        
-        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Wrong input color space on transform");        
-        return NULL;
-    }
-
-    if (!IsProperColorSpace(ExitColorSpace, OutputFormat)) {
-        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Wrong output color space on transform");       
-        return NULL;
-    }
-
-    // Create a pipeline with all transformations
-    Lut = _cmsLinkProfiles(ContextID, nProfiles, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
-    if (Lut == NULL) {
-        cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, "Couldn't link the profiles");   
-        return NULL;
-    }
-
-    // Optimize the LUT if possible
-    _cmsOptimizePipeline(&Lut, LastIntent, &InputFormat, &OutputFormat, &dwFlags);       
-
-
-    // All seems ok
-    xform = AllocEmptyTransform(ContextID, InputFormat, OutputFormat, dwFlags);
-    if (xform == NULL) {
-        cmsPipelineFree(Lut);
-        return NULL;
-    }
-
-    // Keep values
-    xform ->EntryColorSpace = EntryColorSpace;
-    xform ->ExitColorSpace  = ExitColorSpace;
-    xform ->Lut             = Lut;
-
-
-    // Create a gamut check LUT if requested
-    if (hGamutProfile != NULL && (dwFlags & cmsFLAGS_GAMUTCHECK))       
-        xform ->GamutCheck  = _cmsCreateGamutCheckPipeline(ContextID, hProfiles, 
-                                                        BPC, Intents, 
-                                                        AdaptationStates, 
-                                                        nGamutPCSposition, 
-                                                        hGamutProfile);
-
-
-    // Try to read input and output colorant table
-    if (cmsIsTag(hProfiles[0], cmsSigColorantTableTag)) {
-
-        // Input table can only come in this way.       
-        xform ->InputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[0], cmsSigColorantTableTag));
-    }
-
-    // Output is a little bit more complex.    
-    if (cmsGetDeviceClass(hProfiles[nProfiles-1]) == cmsSigLinkClass) {
-
-        // This tag may exist only on devicelink profiles.        
-        if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag)) {
-
-            // It may be NULL if error
-            xform ->OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag));
-        }
-
-    } else {
-
-        if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableTag)) {
-
-            xform -> OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableTag));
-        }     
-    }
-
-    // Store the sequence of profiles
-    if (dwFlags & cmsFLAGS_KEEP_SEQUENCE) {
-        xform ->Sequence = _cmsCompileProfileSequence(ContextID, nProfiles, hProfiles);
-    }
-    else 
-        xform ->Sequence = NULL;
-
-    // If this is a cached transform, init first value, which is zero (16 bits only)
-    if (!(dwFlags & cmsFLAGS_NOCACHE)) {
-
-        memset(&xform ->CacheIn, 0, sizeof(xform ->CacheIn));
-
-        if (xform ->GamutCheck != NULL) {
-            TransformOnePixelWithGamutCheck(xform, xform ->CacheIn, xform->CacheOut);
-        }
-        else {
-
-            xform ->Lut ->Eval16Fn(xform ->CacheIn, xform->CacheOut, xform -> Lut->Data);  
-        }
-
-    }
-
-    return (cmsHTRANSFORM) xform; 
-}
-
-// Multiprofile transforms: Gamut check is not available here, as it is unclear from which profile the gamut comes.
-
-cmsHTRANSFORM CMSEXPORT cmsCreateMultiprofileTransformTHR(cmsContext ContextID,
-                                                       cmsHPROFILE hProfiles[],
-                                                       cmsUInt32Number nProfiles,
-                                                       cmsUInt32Number InputFormat,
-                                                       cmsUInt32Number OutputFormat,
-                                                       cmsUInt32Number Intent,
-                                                       cmsUInt32Number dwFlags)
-{
-    cmsUInt32Number i;
-    cmsBool BPC[256];
-    cmsUInt32Number Intents[256];
-    cmsFloat64Number AdaptationStates[256];
-
-    if (nProfiles <= 0 || nProfiles > 255) {
-         cmsSignalError(ContextID, cmsERROR_RANGE, "Wrong number of profiles. 1..255 expected, %d found.", nProfiles);
-        return NULL;
-    }
-
-    for (i=0; i < nProfiles; i++) {
-        BPC[i] = dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION ? TRUE : FALSE;
-        Intents[i] = Intent;
-        AdaptationStates[i] = GlobalAdaptationState;
-    }
-
-
-    return cmsCreateExtendedTransform(ContextID, nProfiles, hProfiles, BPC, Intents, AdaptationStates, NULL, 0, InputFormat, OutputFormat, dwFlags);
-}
-
-
-
-cmsHTRANSFORM CMSEXPORT cmsCreateMultiprofileTransform(cmsHPROFILE hProfiles[],
-                                                  cmsUInt32Number nProfiles,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags)
-{
-
-    if (nProfiles <= 0 || nProfiles > 255) {
-         cmsSignalError(NULL, cmsERROR_RANGE, "Wrong number of profiles. 1..255 expected, %d found.", nProfiles);
-         return NULL;
-    }
-
-    return cmsCreateMultiprofileTransformTHR(cmsGetProfileContextID(hProfiles[0]),
-                                                  hProfiles,
-                                                  nProfiles,
-                                                  InputFormat,
-                                                  OutputFormat,
-                                                  Intent,
-                                                  dwFlags);
-}
-
-cmsHTRANSFORM CMSEXPORT cmsCreateTransformTHR(cmsContext ContextID,
-                                              cmsHPROFILE Input,
-                                              cmsUInt32Number InputFormat,
-                                              cmsHPROFILE Output,
-                                              cmsUInt32Number OutputFormat,
-                                              cmsUInt32Number Intent,
-                                              cmsUInt32Number dwFlags)
-{
-
-    cmsHPROFILE hArray[2];
-    
-    hArray[0] = Input;
-    hArray[1] = Output;
-
-    return cmsCreateMultiprofileTransformTHR(ContextID, hArray, Output == NULL ? 1 : 2, InputFormat, OutputFormat, Intent, dwFlags);
-}
-
-CMSAPI cmsHTRANSFORM CMSEXPORT cmsCreateTransform(cmsHPROFILE Input,
-                                                  cmsUInt32Number InputFormat,
-                                                  cmsHPROFILE Output,
-                                                  cmsUInt32Number OutputFormat,
-                                                  cmsUInt32Number Intent,
-                                                  cmsUInt32Number dwFlags)
-{
-    return cmsCreateTransformTHR(cmsGetProfileContextID(Input), Input, InputFormat, Output, OutputFormat, Intent, dwFlags);
-}
-
-
-cmsHTRANSFORM CMSEXPORT cmsCreateProofingTransformTHR(cmsContext ContextID,
-                                                   cmsHPROFILE InputProfile,
-                                                   cmsUInt32Number InputFormat,
-                                                   cmsHPROFILE OutputProfile,
-                                                   cmsUInt32Number OutputFormat,
-                                                   cmsHPROFILE ProofingProfile,
-                                                   cmsUInt32Number nIntent,
-                                                   cmsUInt32Number ProofingIntent,
-                                                   cmsUInt32Number dwFlags)
-{   
-    cmsHPROFILE hArray[4];
-    cmsUInt32Number Intents[4];
-    cmsBool  BPC[4];
-    cmsFloat64Number Adaptation[4];
-    cmsBool  DoBPC = (dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION) ? TRUE : FALSE;
-
-
-    hArray[0]  = InputProfile; hArray[1] = ProofingProfile; hArray[2]  = ProofingProfile;               hArray[3] = OutputProfile;
-    Intents[0] = nIntent;      Intents[1] = nIntent;        Intents[2] = INTENT_RELATIVE_COLORIMETRIC;  Intents[3] = ProofingIntent;
-    BPC[0]     = DoBPC;        BPC[1] = DoBPC;              BPC[2] = 0;                                 BPC[3] = 0;
-    
-    Adaptation[0] = Adaptation[1] = Adaptation[2] = Adaptation[3] = GlobalAdaptationState;
-
-    if (!(dwFlags & (cmsFLAGS_SOFTPROOFING|cmsFLAGS_GAMUTCHECK))) 
-        return cmsCreateTransformTHR(ContextID, InputProfile, InputFormat, OutputProfile, OutputFormat, nIntent, dwFlags);
-  
-    return cmsCreateExtendedTransform(ContextID, 4, hArray, BPC, Intents, Adaptation, 
-                                        ProofingProfile, 1, InputFormat, OutputFormat, dwFlags);
-
-}
-
-
-cmsHTRANSFORM CMSEXPORT cmsCreateProofingTransform(cmsHPROFILE InputProfile,
-                                                   cmsUInt32Number InputFormat,
-                                                   cmsHPROFILE OutputProfile,
-                                                   cmsUInt32Number OutputFormat,
-                                                   cmsHPROFILE ProofingProfile,
-                                                   cmsUInt32Number nIntent,
-                                                   cmsUInt32Number ProofingIntent,
-                                                   cmsUInt32Number dwFlags)
-{
-    return cmsCreateProofingTransformTHR(cmsGetProfileContextID(InputProfile), 
-                                                   InputProfile,
-                                                   InputFormat,
-                                                   OutputProfile,
-                                                   OutputFormat,
-                                                   ProofingProfile,
-                                                   nIntent,
-                                                   ProofingIntent,
-                                                   dwFlags);
-}
-
-
-// Grab the ContextID from an open transform. Returns NULL if a NULL transform is passed
-cmsContext CMSEXPORT cmsGetTransformContextID(cmsHTRANSFORM hTransform)
-{
-    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;
-
-    if (xform == NULL) return NULL;
-    return xform -> ContextID;
-}
-
-
-
-// For backwards compatibility
-cmsBool CMSEXPORT cmsChangeBuffersFormat(cmsHTRANSFORM hTransform, 
-                                         cmsUInt32Number InputFormat, 
-                                         cmsUInt32Number OutputFormat)
-{
-
-    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;
-    cmsFormatter16 FromInput, ToOutput;
-    cmsUInt32Number BytesPerPixelInput;
-
-    // We only can afford to change formatters if previous transform is at least 16 bits
-    BytesPerPixelInput = T_BYTES(xform ->InputFormat);
-    if (!(xform ->dwOriginalFlags & cmsFLAGS_CAN_CHANGE_FORMATTER)) {
-
-        cmsSignalError(xform ->ContextID, cmsERROR_NOT_SUITABLE, "cmsChangeBuffersFormat works only on transforms created originally with at least 16 bits of precision");
-        return FALSE;
-    }
-
-    FromInput = _cmsGetFormatter(InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;
-    ToOutput  = _cmsGetFormatter(OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;
-
-    if (FromInput == NULL || ToOutput == NULL) {
-
-        cmsSignalError(xform -> ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported raster format");
-        return FALSE;
-    }
-
-    xform ->InputFormat  = InputFormat;
-    xform ->OutputFormat = OutputFormat;
-    xform ->FromInput = FromInput;
-    xform ->ToOutput  = ToOutput;
-    return TRUE;
-}
diff --git a/thirdparty/liblcms2/src/lcms2.def b/thirdparty/liblcms2/src/lcms2.def
deleted file mode 100644
index d407502..0000000
--- a/thirdparty/liblcms2/src/lcms2.def
+++ /dev/null
@@ -1,300 +0,0 @@
-LIBRARY     LCMS2.DLL
-
-EXPORTS
-
-_cms15Fixed16toDouble                    =   _cms15Fixed16toDouble
-_cms8Fixed8toDouble                      =   _cms8Fixed8toDouble
-cmsAdaptToIlluminant                     =    cmsAdaptToIlluminant
-_cmsAdjustEndianess16                    =   _cmsAdjustEndianess16
-_cmsAdjustEndianess32                    =   _cmsAdjustEndianess32
-_cmsAdjustEndianess64                    =   _cmsAdjustEndianess64
-cmsAllocNamedColorList                   =   cmsAllocNamedColorList
-cmsAllocProfileSequenceDescription       =   cmsAllocProfileSequenceDescription
-cmsAppendNamedColor                      =   cmsAppendNamedColor
-cmsBFDdeltaE                             =   cmsBFDdeltaE
-cmsBuildGamma                            =   cmsBuildGamma
-cmsBuildParametricToneCurve              =   cmsBuildParametricToneCurve
-cmsBuildSegmentedToneCurve               =   cmsBuildSegmentedToneCurve
-cmsBuildTabulatedToneCurve16             =   cmsBuildTabulatedToneCurve16
-cmsBuildTabulatedToneCurveFloat          =   cmsBuildTabulatedToneCurveFloat
-_cmsCalloc                               =   _cmsCalloc
-cmsChannelsOf                            =    cmsChannelsOf
-cmsCIE2000DeltaE                         =    cmsCIE2000DeltaE
-cmsCIE94DeltaE                           =    cmsCIE94DeltaE
-cmsCIECAM02Done                          =    cmsCIECAM02Done
-cmsCIECAM02Forward                       =    cmsCIECAM02Forward
-cmsCIECAM02Init                          =    cmsCIECAM02Init
-cmsCIECAM02Reverse                       =    cmsCIECAM02Reverse
-cmsCloseIOhandler                        =    cmsCloseIOhandler
-cmsCloseProfile                          =    cmsCloseProfile
-cmsCMCdeltaE                             =    cmsCMCdeltaE
-cmsCreate_sRGBProfile                    =    cmsCreate_sRGBProfile
-cmsCreate_sRGBProfileTHR                 =    cmsCreate_sRGBProfileTHR
-cmsCreateBCHSWabstractProfile            =    cmsCreateBCHSWabstractProfile
-cmsCreateBCHSWabstractProfileTHR         =    cmsCreateBCHSWabstractProfileTHR
-cmsCreateExtendedTransform               =    cmsCreateExtendedTransform
-cmsCreateGrayProfile                     =    cmsCreateGrayProfile
-cmsCreateGrayProfileTHR                  =    cmsCreateGrayProfileTHR
-cmsCreateInkLimitingDeviceLink           =    cmsCreateInkLimitingDeviceLink
-cmsCreateInkLimitingDeviceLinkTHR        =    cmsCreateInkLimitingDeviceLinkTHR
-cmsCreateLab2Profile                     =    cmsCreateLab2Profile
-cmsCreateLab2ProfileTHR                  =    cmsCreateLab2ProfileTHR
-cmsCreateLab4Profile                     =    cmsCreateLab4Profile
-cmsCreateLab4ProfileTHR                  =    cmsCreateLab4ProfileTHR
-cmsCreateLinearizationDeviceLink         =    cmsCreateLinearizationDeviceLink
-cmsCreateLinearizationDeviceLinkTHR      =    cmsCreateLinearizationDeviceLinkTHR
-cmsCreateMultiprofileTransform           =    cmsCreateMultiprofileTransform
-cmsCreateMultiprofileTransformTHR        =    cmsCreateMultiprofileTransformTHR
-cmsCreateNULLProfile                     =    cmsCreateNULLProfile
-cmsCreateNULLProfileTHR                  =    cmsCreateNULLProfileTHR
-cmsCreateProfilePlaceholder              =    cmsCreateProfilePlaceholder
-cmsCreateProofingTransform               =    cmsCreateProofingTransform
-cmsCreateProofingTransformTHR            =    cmsCreateProofingTransformTHR
-cmsCreateRGBProfile                      =    cmsCreateRGBProfile
-cmsCreateRGBProfileTHR                   =    cmsCreateRGBProfileTHR
-cmsCreateTransform                       =    cmsCreateTransform
-cmsCreateTransformTHR                    =    cmsCreateTransformTHR
-cmsCreateXYZProfile                      =    cmsCreateXYZProfile
-cmsCreateXYZProfileTHR                   =    cmsCreateXYZProfileTHR
-cmsD50_xyY                               =    cmsD50_xyY
-cmsD50_XYZ                               =    cmsD50_XYZ
-_cmsDecodeDateTimeNumber                 =    _cmsDecodeDateTimeNumber
-_cmsDefaultICCintents                    =    _cmsDefaultICCintents
-cmsDeleteTransform                       =    cmsDeleteTransform
-cmsDeltaE                                =    cmsDeltaE
-cmsDetectBlackPoint                      =    cmsDetectBlackPoint
-cmsDetectTAC                             =    cmsDetectTAC
-cmsDesaturateLab                         =    cmsDesaturateLab
-cmsDoTransform                           =    cmsDoTransform
-_cmsDoubleTo15Fixed16                    =    _cmsDoubleTo15Fixed16
-_cmsDoubleTo8Fixed8                      =    _cmsDoubleTo8Fixed8
-_cmsDupMem                               =    _cmsDupMem
-cmsDupNamedColorList                     =    cmsDupNamedColorList
-cmsDupProfileSequenceDescription         =    cmsDupProfileSequenceDescription
-cmsDupToneCurve                          =    cmsDupToneCurve
-_cmsEncodeDateTimeNumber                 =    _cmsEncodeDateTimeNumber
-cmsEstimateGamma                         =    cmsEstimateGamma
-cmsEvalToneCurve16                       =    cmsEvalToneCurve16
-cmsEvalToneCurveFloat                    =    cmsEvalToneCurveFloat
-cmsfilelength                            =    cmsfilelength
-cmsFloat2LabEncoded                      =    cmsFloat2LabEncoded
-cmsFloat2LabEncodedV2                    =    cmsFloat2LabEncodedV2
-cmsFloat2XYZEncoded                      =    cmsFloat2XYZEncoded
-cmsFormatterForColorspaceOfProfile       =    cmsFormatterForColorspaceOfProfile
-cmsFormatterForPCSOfProfile              =    cmsFormatterForPCSOfProfile
-_cmsFree                                 =    _cmsFree
-cmsFreeNamedColorList                    =    cmsFreeNamedColorList
-cmsFreeProfileSequenceDescription        =    cmsFreeProfileSequenceDescription
-cmsFreeToneCurve                         =    cmsFreeToneCurve
-cmsFreeToneCurveTriple                   =    cmsFreeToneCurveTriple
-cmsGBDAlloc                              =    cmsGBDAlloc
-cmsGBDFree                               =    cmsGBDFree
-cmsGDBAddPoint                           =    cmsGDBAddPoint
-cmsGDBCheckPoint                         =    cmsGDBCheckPoint
-cmsGDBCompute                            =    cmsGDBCompute
-cmsGetAlarmCodes                         =    cmsGetAlarmCodes
-cmsGetColorSpace                         =    cmsGetColorSpace
-cmsGetDeviceClass                        =    cmsGetDeviceClass
-cmsGetEncodedICCversion                  =    cmsGetEncodedICCversion
-cmsGetHeaderAttributes                   =    cmsGetHeaderAttributes
-cmsGetHeaderCreationDateTime             =    cmsGetHeaderCreationDateTime
-cmsGetHeaderFlags                        =    cmsGetHeaderFlags
-cmsGetHeaderManufacturer                 =    cmsGetHeaderManufacturer
-cmsGetHeaderModel                        =    cmsGetHeaderModel
-cmsGetHeaderProfileID                    =    cmsGetHeaderProfileID
-cmsGetHeaderRenderingIntent              =    cmsGetHeaderRenderingIntent
-cmsGetNamedColorList                     =    cmsGetNamedColorList
-cmsGetPCS                                =    cmsGetPCS
-cmsGetPostScriptColorResource            =    cmsGetPostScriptColorResource
-cmsGetPostScriptCRD                      =    cmsGetPostScriptCRD
-cmsGetPostScriptCSA                      =    cmsGetPostScriptCSA
-cmsGetProfileInfo                        =    cmsGetProfileInfo
-cmsGetProfileInfoASCII                   =    cmsGetProfileInfoASCII
-cmsGetProfileContextID                    =    cmsGetProfileContextID
-cmsGetProfileVersion                     =    cmsGetProfileVersion
-cmsGetSupportedIntents                   =    cmsGetSupportedIntents
-cmsGetTagCount                           =    cmsGetTagCount
-cmsGetTagSignature                       =    cmsGetTagSignature
-cmsGetTransformContextID                  =    cmsGetTransformContextID
-_cmsICCcolorSpace                        =    _cmsICCcolorSpace
-_cmsIOPrintf                             =    _cmsIOPrintf
-cmsIsCLUT                                =    cmsIsCLUT
-cmsIsIntentSupported                     =    cmsIsIntentSupported
-cmsIsMatrixShaper                        =    cmsIsMatrixShaper
-cmsIsTag                                 =    cmsIsTag
-cmsIsToneCurveDescending                 =    cmsIsToneCurveDescending
-cmsIsToneCurveLinear                     =    cmsIsToneCurveLinear
-cmsIsToneCurveMonotonic                  =    cmsIsToneCurveMonotonic
-cmsIsToneCurveMultisegment               =    cmsIsToneCurveMultisegment
-cmsGetToneCurveParametricType            =    cmsGetToneCurveParametricType
-cmsIT8Alloc                              =    cmsIT8Alloc
-cmsIT8DefineDblFormat                    =    cmsIT8DefineDblFormat
-cmsIT8EnumDataFormat                     =    cmsIT8EnumDataFormat
-cmsIT8EnumProperties                     =    cmsIT8EnumProperties
-cmsIT8Free                               =    cmsIT8Free
-cmsIT8GetData                            =    cmsIT8GetData
-cmsIT8GetDataDbl                         =    cmsIT8GetDataDbl
-cmsIT8FindDataFormat                      =    cmsIT8FindDataFormat
-cmsIT8GetDataRowCol                      =    cmsIT8GetDataRowCol
-cmsIT8GetDataRowColDbl                   =    cmsIT8GetDataRowColDbl
-cmsIT8GetPatchName                       =    cmsIT8GetPatchName
-cmsIT8GetProperty                        =    cmsIT8GetProperty
-cmsIT8GetPropertyDbl                     =    cmsIT8GetPropertyDbl
-cmsIT8GetSheetType                       =    cmsIT8GetSheetType
-cmsIT8LoadFromFile                       =    cmsIT8LoadFromFile
-cmsIT8LoadFromMem                        =    cmsIT8LoadFromMem
-cmsIT8SaveToFile                         =    cmsIT8SaveToFile
-cmsIT8SaveToMem                          =    cmsIT8SaveToMem
-cmsIT8SetComment                         =    cmsIT8SetComment
-cmsIT8SetData                            =    cmsIT8SetData
-cmsIT8SetDataDbl                         =    cmsIT8SetDataDbl
-cmsIT8SetDataFormat                      =    cmsIT8SetDataFormat
-cmsIT8SetDataRowCol                      =    cmsIT8SetDataRowCol
-cmsIT8SetDataRowColDbl                   =    cmsIT8SetDataRowColDbl
-cmsIT8SetPropertyDbl                     =    cmsIT8SetPropertyDbl
-cmsIT8SetPropertyHex                     =    cmsIT8SetPropertyHex
-cmsIT8SetPropertyStr                     =    cmsIT8SetPropertyStr
-cmsIT8SetPropertyUncooked                =    cmsIT8SetPropertyUncooked
-cmsIT8SetSheetType                       =    cmsIT8SetSheetType
-cmsIT8SetTable                           =    cmsIT8SetTable
-cmsIT8SetTableByLabel                    =    cmsIT8SetTableByLabel
-cmsIT8TableCount                         =    cmsIT8TableCount
-cmsJoinToneCurve                         =    cmsJoinToneCurve
-cmsLab2LCh                               =    cmsLab2LCh
-cmsLab2XYZ                               =    cmsLab2XYZ
-cmsLabEncoded2Float                      =    cmsLabEncoded2Float
-cmsLabEncoded2FloatV2                    =    cmsLabEncoded2FloatV2
-cmsLCh2Lab                               =    cmsLCh2Lab
-_cmsLCMScolorSpace                       =    _cmsLCMScolorSpace
-cmsLinkTag                               =    cmsLinkTag
-cmsPipelineAlloc                         =    cmsPipelineAlloc
-cmsPipelineCat                           =    cmsPipelineCat
-cmsPipelineCheckAndRetreiveStages        =    cmsPipelineCheckAndRetreiveStages
-cmsPipelineDup                           =    cmsPipelineDup
-cmsPipelineStageCount                    =    cmsPipelineStageCount
-cmsPipelineEval16                        =    cmsPipelineEval16
-cmsPipelineEvalFloat                     =    cmsPipelineEvalFloat
-cmsPipelineEvalReverseFloat              =    cmsPipelineEvalReverseFloat
-cmsPipelineFree                          =    cmsPipelineFree
-cmsPipelineGetPtrToFirstStage            =    cmsPipelineGetPtrToFirstStage
-cmsPipelineGetPtrToLastStage             =    cmsPipelineGetPtrToLastStage
-cmsPipelineInputChannels                 =    cmsPipelineInputChannels
-cmsPipelineInsertStage                   =    cmsPipelineInsertStage
-cmsPipelineOutputChannels                =    cmsPipelineOutputChannels
-cmsPipelineSetSaveAs8bitsFlag            =    cmsPipelineSetSaveAs8bitsFlag
-_cmsPipelineSetOptimizationParameters    =    _cmsPipelineSetOptimizationParameters
-cmsPipelineUnlinkStage                   =    cmsPipelineUnlinkStage
-_cmsMalloc                               =    _cmsMalloc
-_cmsMallocZero                           =    _cmsMallocZero
-_cmsMAT3eval                             =    _cmsMAT3eval
-_cmsMAT3identity                         =    _cmsMAT3identity
-_cmsMAT3inverse                          =    _cmsMAT3inverse
-_cmsMAT3isIdentity                       =    _cmsMAT3isIdentity
-_cmsMAT3per                              =    _cmsMAT3per
-_cmsMAT3solve                            =    _cmsMAT3solve
-cmsMD5computeID                          =    cmsMD5computeID
-cmsMLUalloc                              =    cmsMLUalloc
-cmsMLUdup                                =    cmsMLUdup
-cmsMLUfree                               =    cmsMLUfree
-cmsMLUgetASCII                           =    cmsMLUgetASCII
-cmsMLUgetTranslation                     =    cmsMLUgetTranslation
-cmsMLUgetWide                            =    cmsMLUgetWide
-cmsMLUsetASCII                           =    cmsMLUsetASCII
-cmsMLUsetWide                            =    cmsMLUsetWide
-cmsStageAllocCLut16bit                   =    cmsStageAllocCLut16bit
-cmsStageAllocCLut16bitGranular           =    cmsStageAllocCLut16bitGranular
-cmsStageAllocCLutFloat                   =    cmsStageAllocCLutFloat
-cmsStageAllocCLutFloatGranular           =    cmsStageAllocCLutFloatGranular
-cmsStageAllocToneCurves                  =    cmsStageAllocToneCurves
-cmsStageAllocIdentity                    =    cmsStageAllocIdentity
-cmsStageAllocMatrix                      =    cmsStageAllocMatrix
-_cmsStageAllocPlaceholder                =    _cmsStageAllocPlaceholder
-cmsStageDup                              =    cmsStageDup
-cmsStageFree                             =    cmsStageFree
-cmsStageNext                             =    cmsStageNext
-cmsStageInputChannels                    =    cmsStageInputChannels
-cmsStageOutputChannels                   =    cmsStageOutputChannels
-cmsStageSampleCLut16bit                  =    cmsStageSampleCLut16bit
-cmsStageSampleCLutFloat                  =    cmsStageSampleCLutFloat
-cmsStageType                             =    cmsStageType
-cmsStageData                             =    cmsStageData
-cmsNamedColorCount                       =    cmsNamedColorCount
-cmsNamedColorIndex                       =    cmsNamedColorIndex
-cmsNamedColorInfo                        =    cmsNamedColorInfo
-cmsOpenIOhandlerFromFile                 =    cmsOpenIOhandlerFromFile
-cmsOpenIOhandlerFromMem                  =    cmsOpenIOhandlerFromMem
-cmsOpenIOhandlerFromNULL                 =    cmsOpenIOhandlerFromNULL
-cmsOpenIOhandlerFromStream               =    cmsOpenIOhandlerFromStream
-cmsOpenProfileFromFile                   =    cmsOpenProfileFromFile
-cmsOpenProfileFromFileTHR                =    cmsOpenProfileFromFileTHR
-cmsOpenProfileFromIOhandlerTHR           =    cmsOpenProfileFromIOhandlerTHR
-cmsOpenProfileFromMem                    =    cmsOpenProfileFromMem
-cmsOpenProfileFromMemTHR                 =    cmsOpenProfileFromMemTHR
-cmsOpenProfileFromStream                 =    cmsOpenProfileFromStream
-cmsOpenProfileFromStreamTHR              =    cmsOpenProfileFromStreamTHR
-cmsPlugin                                =    cmsPlugin
-_cmsRead15Fixed16Number                  =    _cmsRead15Fixed16Number
-_cmsReadAlignment                        =    _cmsReadAlignment
-_cmsReadFloat32Number                    =    _cmsReadFloat32Number
-cmsReadRawTag                            =    cmsReadRawTag
-cmsReadTag                               =    cmsReadTag
-_cmsReadTypeBase                         =    _cmsReadTypeBase
-_cmsReadUInt16Array                      =    _cmsReadUInt16Array
-_cmsReadUInt16Number                     =    _cmsReadUInt16Number
-_cmsReadUInt32Number                     =    _cmsReadUInt32Number
-_cmsReadUInt64Number                     =    _cmsReadUInt64Number
-_cmsReadUInt8Number                      =    _cmsReadUInt8Number
-_cmsReadXYZNumber                        =    _cmsReadXYZNumber
-_cmsRealloc                              =    _cmsRealloc
-cmsReverseToneCurve                      =    cmsReverseToneCurve
-cmsReverseToneCurveEx                    =    cmsReverseToneCurveEx
-cmsSaveProfileToFile                     =    cmsSaveProfileToFile
-cmsSaveProfileToIOhandler                =    cmsSaveProfileToIOhandler
-cmsSaveProfileToMem                      =    cmsSaveProfileToMem
-cmsSaveProfileToStream                   =    cmsSaveProfileToStream
-cmsSetAdaptationState                    =    cmsSetAdaptationState
-cmsSetAlarmCodes                         =    cmsSetAlarmCodes
-cmsSetColorSpace                         =    cmsSetColorSpace
-cmsSetDeviceClass                        =    cmsSetDeviceClass
-cmsSetEncodedICCversion                  =    cmsSetEncodedICCversion
-cmsSetHeaderAttributes                   =    cmsSetHeaderAttributes
-cmsSetHeaderFlags                        =    cmsSetHeaderFlags
-cmsSetHeaderManufacturer                 =    cmsSetHeaderManufacturer
-cmsSetHeaderModel                        =    cmsSetHeaderModel
-cmsSetHeaderProfileID                    =    cmsSetHeaderProfileID
-cmsSetHeaderRenderingIntent              =    cmsSetHeaderRenderingIntent
-cmsSetLogErrorHandler                    =    cmsSetLogErrorHandler
-cmsSetPCS                                =    cmsSetPCS
-cmsSetProfileVersion                     =    cmsSetProfileVersion
-cmsSignalError                           =    cmsSignalError
-cmsSmoothToneCurve                       =    cmsSmoothToneCurve
-cmsstrcasecmp                            =    cmsstrcasecmp
-cmsTempFromWhitePoint                    =    cmsTempFromWhitePoint
-cmsTransform2DeviceLink                  =    cmsTransform2DeviceLink
-cmsUnregisterPlugins                     =    cmsUnregisterPlugins
-_cmsVEC3cross                            =    _cmsVEC3cross
-_cmsVEC3distance                         =    _cmsVEC3distance
-_cmsVEC3dot                              =    _cmsVEC3dot
-_cmsVEC3init                             =    _cmsVEC3init
-_cmsVEC3length                           =    _cmsVEC3length
-_cmsVEC3minus                            =    _cmsVEC3minus
-cmsWhitePointFromTemp                    =    cmsWhitePointFromTemp
-_cmsWrite15Fixed16Number                 =    _cmsWrite15Fixed16Number
-_cmsWriteAlignment                       =    _cmsWriteAlignment
-_cmsWriteFloat32Number                   =    _cmsWriteFloat32Number
-cmsWriteRawTag                           =    cmsWriteRawTag
-cmsWriteTag                              =    cmsWriteTag
-_cmsWriteTypeBase                        =    _cmsWriteTypeBase
-_cmsWriteUInt16Array                     =    _cmsWriteUInt16Array
-_cmsWriteUInt16Number                    =    _cmsWriteUInt16Number
-_cmsWriteUInt32Number                    =    _cmsWriteUInt32Number
-_cmsWriteUInt64Number                    =    _cmsWriteUInt64Number
-_cmsWriteUInt8Number                     =    _cmsWriteUInt8Number
-_cmsWriteXYZNumber                       =    _cmsWriteXYZNumber
-cmsxyY2XYZ                               =    cmsxyY2XYZ
-cmsXYZ2Lab                               =    cmsXYZ2Lab
-cmsXYZ2xyY                               =   cmsXYZ2xyY
-cmsXYZEncoded2Float                      =   cmsXYZEncoded2Float
-cmsSliceSpace16                          =   cmsSliceSpace16
-cmsSliceSpaceFloat                       =   cmsSliceSpaceFloat
-cmsChangeBuffersFormat                   =   cmsChangeBuffersFormat
diff --git a/thirdparty/liblcms2/src/lcms2_internal.h b/thirdparty/liblcms2/src/lcms2_internal.h
deleted file mode 100644
index 84e5a80..0000000
--- a/thirdparty/liblcms2/src/lcms2_internal.h
+++ /dev/null
@@ -1,652 +0,0 @@
-
-//
-//  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
-//
-// Permission is hereby granted, free of charge, to any person obtaining 
-// a copy of this software and associated documentation files (the "Software"), 
-// to deal in the Software without restriction, including without limitation 
-// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-// and/or sell copies of the Software, and to permit persons to whom the Software 
-// is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
-// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-//---------------------------------------------------------------------------------
-//
-
-#ifndef _lcms_internal_H
-
-// Include plug-in foundation
-#ifndef _lcms_plugin_H
-#   include "lcms2_plugin.h"
-#endif
-
-// ctype is part of C99 as per 7.1.2
-#include <ctype.h>
-
-// assert macro is part of C99 as per 7.2
-#include <assert.h>
-
-// Some needed constants
-#ifndef M_PI
-#       define M_PI        3.14159265358979323846
-#endif
-
-#ifndef M_LOG10E
-#       define M_LOG10E    0.434294481903251827651
-#endif
-
-// BorlandC 5.5 is broken on that
-#ifdef __BORLANDC__
-#define sinf(x) (float)sin((float)x)
-#define sqrtf(x) (float)sqrt((float)x)
-#endif
-
-
-// Alignment of ICC file format uses 4 bytes (cmsUInt32Number)
-#define _cmsSIZEOFLONGMINUS1    (sizeof(cmsUInt32Number)-1)
-#define _cmsALIGNLONG(x) (((x)+_cmsSIZEOFLONGMINUS1) & ~(_cmsSIZEOFLONGMINUS1))     
-
-// Maximum encodeable values in floating point
-#define MAX_ENCODEABLE_XYZ  (1.0 + 32767.0/32768.0)
-#define MIN_ENCODEABLE_ab2  (-128.0)
-#define MAX_ENCODEABLE_ab2  ((65535.0/256.0) - 128.0)
-#define MIN_ENCODEABLE_ab4  (-128.0)
-#define MAX_ENCODEABLE_ab4  (127.0)
-
-// Maximum of channels for internal pipeline evaluation
-#define MAX_STAGE_CHANNELS	128
-
-// Unused parameter warning supression
-#define cmsUNUSED_PARAMETER(x) ((void)x) 
-
-// The specification for "inline" is section 6.7.4 of the C99 standard (ISO/IEC 9899:1999).
-// unfortunately VisualC++ does not conform that
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-#   define cmsINLINE __inline
-#else
-#   define cmsINLINE static inline
-#endif
-
-// Other replacement functions
-#ifdef _MSC_VER
-# ifndef snprintf
-#       define snprintf  _snprintf
-# endif
-# ifndef vsnprintf
-#       define vsnprintf  _vsnprintf
-# endif
-#endif
-
-// Pthreads. In windows we use the native WIN32 API instead
-#ifdef CMS_DONT_USE_PTHREADS
-typedef int LCMS_RWLOCK_T;             
-#   define LCMS_CREATE_LOCK(x)       
-#   define LCMS_FREE_LOCK(x)         
-#   define LCMS_READ_LOCK(x)         
-#   define LCMS_WRITE_LOCK(x)        
-#   define LCMS_UNLOCK(x)            
-#else
-#ifdef CMS_IS_WINDOWS_
-#   ifndef WIN32_LEAN_AND_MEAN
-#       define WIN32_LEAN_AND_MEAN
-#   endif
-#   include <windows.h>
-    typedef CRITICAL_SECTION LCMS_RWLOCK_T;
-#   define LCMS_CREATE_LOCK(x)       InitializeCriticalSection((x))
-#   define LCMS_FREE_LOCK(x)         DeleteCriticalSection((x))
-#   define LCMS_READ_LOCK(x)         EnterCriticalSection((x))
-#   define LCMS_WRITE_LOCK(x)        EnterCriticalSection((x))
-#   define LCMS_UNLOCK(x)            LeaveCriticalSection((x))
-#else
-#   include <pthread.h>
-    typedef    pthread_rwlock_t      LCMS_RWLOCK_T;
-#   define LCMS_CREATE_LOCK(x)       pthread_rwlock_init((x), NULL) 
-#   define LCMS_FREE_LOCK(x)         pthread_rwlock_destroy((x))
-#   define LCMS_READ_LOCK(x)         pthread_rwlock_rdlock((x))
-#   define LCMS_WRITE_LOCK(x)        pthread_rwlock_wrlock((x))
-#   define LCMS_UNLOCK(x)            pthread_rwlock_unlock((x))
-#endif
-#endif
-
-// A fast way to convert from/to 16 <-> 8 bits
-#define FROM_8_TO_16(rgb) (cmsUInt16Number) ((((cmsUInt16Number) (rgb)) << 8)|(rgb)) 
-#define FROM_16_TO_8(rgb) (cmsUInt8Number) ((((rgb) * 65281 + 8388608) >> 24) & 0xFF)
-
-// Code analysis is broken on asserts
-#ifdef _MSC_VER
-#    if (_MSC_VER >= 1500)
-#            define _cmsAssert(a)  { assert((a)); __analysis_assume((a)); }
-#     else
-#            define _cmsAssert(a)   assert((a))
-#     endif
-#else
-#      define _cmsAssert(a)   assert((a))
-#endif
-
-//---------------------------------------------------------------------------------
-
-// Determinant lower than that are assumed zero (used on matrix invert)
-#define MATRIX_DET_TOLERANCE    0.0001
-
-//---------------------------------------------------------------------------------
-
-// Fixed point
-#define FIXED_TO_INT(x)         ((x)>>16)
-#define FIXED_REST_TO_INT(x)    ((x)&0xFFFFU)
-#define ROUND_FIXED_TO_INT(x)   (((x)+0x8000)>>16)
-
-cmsINLINE cmsS15Fixed16Number _cmsToFixedDomain(int a)                   { return a + ((a + 0x7fff) / 0xffff); }
-cmsINLINE int                 _cmsFromFixedDomain(cmsS15Fixed16Number a) { return a - ((a + 0x7fff) >> 16); }   
-
-// -----------------------------------------------------------------------------------------------------------
-
-// Fast floor conversion logic. Thanks to Sree Kotay and Stuart Nixon 
-// note than this only works in the range ..-32767...+32767 because 
-// mantissa is interpreted as 15.16 fixed point.
-// The union is to avoid pointer aliasing overoptimization.
-cmsINLINE int _cmsQuickFloor(cmsFloat64Number val)
-{
-#ifdef CMS_DONT_USE_FAST_FLOOR
-    return (int) floor(val);
-#else
-    const cmsFloat64Number _lcms_double2fixmagic = 68719476736.0 * 1.5;  // 2^36 * 1.5, (52-16=36) uses limited precision to floor
-    union {
-        cmsFloat64Number val;
-        int halves[2];
-    } temp;
-    
-    temp.val = val + _lcms_double2fixmagic;
-    
-#ifdef CMS_USE_BIG_ENDIAN
-    return temp.halves[1] >> 16;
-#else
-    return temp.halves[0] >> 16;
-#endif
-#endif
-}
-
-// Fast floor restricted to 0..65535.0
-cmsINLINE cmsUInt16Number _cmsQuickFloorWord(cmsFloat64Number d) 
-{ 
-    return (cmsUInt16Number) _cmsQuickFloor(d - 32767.0) + 32767U; 
-}
-
-// Floor to word, taking care of saturation
-cmsINLINE cmsUInt16Number _cmsQuickSaturateWord(cmsFloat64Number d) 
-{
-    d += 0.5;
-    if (d <= 0) return 0;
-    if (d >= 65535.0) return 0xffff;
-
-    return _cmsQuickFloorWord(d);
-}
-
-// Plug-In registering ---------------------------------------------------------------
-
-// Specialized function for plug-in memory management. No pairing free() since whole pool is freed at once.
-void* _cmsPluginMalloc(cmsUInt32Number size);
-
-// Memory management
-cmsBool   _cmsRegisterMemHandlerPlugin(cmsPluginBase* Plugin);
-
-// Interpolation
-cmsBool  _cmsRegisterInterpPlugin(cmsPluginBase* Plugin);
-
-// Parametric curves
-cmsBool  _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Plugin);
-
-// Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Plugin);
-
-// Tag type management
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Plugin);
-
-// Tag management
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Plugin);
-
-// Intent management
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Plugin);
-
-// Multi Process elements
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Plugin);
-
-// Optimization
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Plugin);
-
-
-// ---------------------------------------------------------------------------------------------------------
-
-// Suballocators. Those are blocks of memory that is freed at the end on whole block.
-typedef struct _cmsSubAllocator_chunk_st {
-
-    cmsUInt8Number* Block;
-    cmsUInt32Number BlockSize;
-    cmsUInt32Number Used;
-
-    struct _cmsSubAllocator_chunk_st* next;
-
-} _cmsSubAllocator_chunk;
-
-
-typedef struct {
-
-    cmsContext ContextID;
-    _cmsSubAllocator_chunk* h;
-
-} _cmsSubAllocator;
-
-
-_cmsSubAllocator* _cmsCreateSubAlloc(cmsContext ContextID, cmsUInt32Number Initial);
-void              _cmsSubAllocDestroy(_cmsSubAllocator* s);
-void*             _cmsSubAlloc(_cmsSubAllocator* s, cmsUInt32Number size);
-
-// ----------------------------------------------------------------------------------
-
-// MLU internal representation
-typedef struct {
-
-    cmsUInt16Number Language;
-    cmsUInt16Number Country;   
-
-    cmsUInt32Number StrW;       // Offset to current unicode string
-    cmsUInt32Number Len;        // Lenght in bytes
-
-} _cmsMLUentry;
-
-struct _cms_MLU_struct {
- 
-    cmsContext ContextID;
-
-    // The directory
-    int AllocatedEntries; 
-    int UsedEntries;
-    _cmsMLUentry* Entries;     // Array of pointers to strings allocated in MemPool
-
-    // The Pool
-    cmsUInt32Number PoolSize;  // The maximum allocated size
-    cmsUInt32Number PoolUsed;  // The used size
-    void*  MemPool;            // Pointer to begin of memory pool  
-};
-
-// Named color list internal representation
-typedef struct {    
-
-    char Name[cmsMAX_PATH];
-    cmsUInt16Number PCS[3];
-    cmsUInt16Number DeviceColorant[cmsMAXCHANNELS];
-
-} _cmsNAMEDCOLOR;
-
-struct _cms_NAMEDCOLORLIST_struct {
-
-    cmsUInt32Number nColors;                
-    cmsUInt32Number Allocated;
-    cmsUInt32Number ColorantCount;  
-
-    char Prefix[33];      // Prefix and suffix are defined to be 32 characters at most
-    char Suffix[33];     
-
-    _cmsNAMEDCOLOR* List;
-
-    cmsContext ContextID;
-};
-
-
-// ----------------------------------------------------------------------------------
-
-// This is the internal struct holding profile details.
-
-// Maximum supported tags in a profile
-#define MAX_TABLE_TAG       100
-
-typedef struct _cms_iccprofile_struct {
-
-    // I/O handler
-    cmsIOHANDLER*            IOhandler;
-
-    // The thread ID
-    cmsContext               ContextID;
-
-    // Creation time
-    struct tm                Created;
-
-    // Only most important items found in ICC profiles   
-    cmsUInt32Number          Version;
-    cmsProfileClassSignature DeviceClass;
-    cmsColorSpaceSignature   ColorSpace;
-    cmsColorSpaceSignature   PCS;
-    cmsUInt32Number          RenderingIntent;
-    cmsUInt32Number          flags;
-    cmsUInt32Number          manufacturer, model;
-    cmsUInt64Number          attributes;
-
-    cmsProfileID             ProfileID;
-
-    // Dictionary
-    cmsUInt32Number          TagCount;
-    cmsTagSignature          TagNames[MAX_TABLE_TAG];
-    cmsTagSignature          TagLinked[MAX_TABLE_TAG];           // The tag to wich is linked (0=none)
-    cmsUInt32Number          TagSizes[MAX_TABLE_TAG];            // Size on disk
-    cmsUInt32Number          TagOffsets[MAX_TABLE_TAG];
-    cmsBool                  TagSaveAsRaw[MAX_TABLE_TAG];        // True to write uncooked
-    void *                   TagPtrs[MAX_TABLE_TAG];
-    cmsTagTypeHandler*       TagTypeHandlers[MAX_TABLE_TAG];     // Same structure may be serialized on different types
-                                                                 // depending on profile version, so we keep track of the                                                             // type handler for each tag in the list.
-    // Special
-    cmsBool                  IsWrite;
-    
-} _cmsICCPROFILE;
-
-// IO helpers for profiles
-cmsBool              _cmsReadHeader(_cmsICCPROFILE* Icc);
-cmsBool              _cmsWriteHeader(_cmsICCPROFILE* Icc, cmsUInt32Number UsedSpace);
-int                  _cmsSearchTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, cmsBool lFollowLinks);
-
-// Tag types
-cmsTagTypeHandler*   _cmsGetTagTypeHandler(cmsTagTypeSignature sig);
-cmsTagTypeSignature  _cmsGetTagTrueType(cmsHPROFILE hProfile, cmsTagSignature sig);
-cmsTagDescriptor*    _cmsGetTagDescriptor(cmsTagSignature sig);
-
-// Error logging ---------------------------------------------------------------------------------------------------------
-
-void                 _cmsTagSignature2String(char String[5], cmsTagSignature sig);
-
-// Interpolation ---------------------------------------------------------------------------------------------------------
-
-cmsInterpParams*     _cmsComputeInterpParams(cmsContext ContextID, int nSamples, int InputChan, int OutputChan, const void* Table, cmsUInt32Number dwFlags);
-cmsInterpParams*     _cmsComputeInterpParamsEx(cmsContext ContextID, const cmsUInt32Number nSamples[], int InputChan, int OutputChan, const void* Table, cmsUInt32Number dwFlags);
-void                 _cmsFreeInterpParams(cmsInterpParams* p);
-cmsBool              _cmsSetInterpolationRoutine(cmsInterpParams* p);
-
-// Curves ----------------------------------------------------------------------------------------------------------------
-
-// This struct holds information about a segment, plus a pointer to the function that implements the evaluation.
-// In the case of table-based, Eval pointer is set to NULL
-
-// The gamma function main structure
-struct _cms_curve_struct {
-
-    cmsInterpParams*  InterpParams;  // Private optimizations for interpolation
-
-    cmsUInt32Number   nSegments;     // Number of segments in the curve. Zero for a 16-bit based tables
-    cmsCurveSegment*  Segments;      // The segments
-    cmsInterpParams** SegInterp;     // Array of private optimizations for interpolation in table-based segments
-
-    cmsParametricCurveEvaluator* Evals;  // Evaluators (one per segment)
-
-    // 16 bit Table-based representation follows    
-    cmsUInt32Number    nEntries;      // Number of table elements
-    cmsUInt16Number*   Table16;       // The table itself. 
-}; 
-
-
-//  Pipelines & Stages ---------------------------------------------------------------------------------------------
-
-// A single stage
-struct _cmsStage_struct {
-    
-    cmsContext          ContextID;
-    
-    cmsStageSignature   Type;           // Identifies the stage
-    cmsStageSignature   Implements;     // Identifies the *function* of the stage (for optimizations)
-
-    cmsUInt32Number     InputChannels;  // Input channels -- for optimization purposes
-    cmsUInt32Number     OutputChannels; // Output channels -- for optimization purposes
-
-    _cmsStageEvalFn     EvalPtr;        // Points to fn that evaluates the stage (always in floating point)
-    _cmsStageDupElemFn  DupElemPtr;     // Points to a fn that duplicates the *data* of the stage
-    _cmsStageFreeElemFn FreePtr;        // Points to a fn that sets the *data* of the stage free
-
-    // A generic pointer to whatever memory needed by the stage
-    void*               Data;
-
-    // Maintains linked list (used internally)
-    struct _cmsStage_struct* Next;
-};
-
-// Data kept in "Element" member of cmsStage
-
-// Curves
-typedef struct {                
-    cmsUInt32Number nCurves;
-    cmsToneCurve**  TheCurves;
-
-} _cmsStageToneCurvesData;
-
-// Matrix
-typedef struct {                
-    cmsFloat64Number*  Double;          // floating point for the matrix
-    cmsFloat64Number*  Offset;          // The offset
-
-} _cmsStageMatrixData;
-
-// CLUT
-typedef struct {                    
-    
-    union {                       // Can have only one of both representations at same time
-        cmsUInt16Number*  T;      // Points to the table 16 bits table
-        cmsFloat32Number* TFloat; // Points to the cmsFloat32Number table
-
-    } Tab;
-
-    cmsInterpParams* Params;
-    cmsUInt32Number  nEntries;
-    cmsBool          HasFloatValues;
-
-} _cmsStageCLutData;
-
-
-// Special Stages (cannot be saved)
-cmsStage*        _cmsStageAllocLab2XYZ(cmsContext ContextID);
-cmsStage*        _cmsStageAllocXYZ2Lab(cmsContext ContextID);
-cmsStage*        _cmsStageAllocLabPrelin(cmsContext ContextID);
-cmsStage*        _cmsStageAllocLabV2ToV4(cmsContext ContextID);
-cmsStage*        _cmsStageAllocLabV2ToV4curves(cmsContext ContextID);
-cmsStage*        _cmsStageAllocLabV4ToV2(cmsContext ContextID);
-cmsStage*        _cmsStageAllocNamedColor(cmsNAMEDCOLORLIST* NamedColorList);
-cmsStage*        _cmsStageAllocIdentityCurves(cmsContext ContextID, int nChannels);
-cmsStage*        _cmsStageAllocIdentityCLut(cmsContext ContextID, int nChan);
-
-// For curve set only  
-cmsToneCurve**     _cmsStageGetPtrToCurveSet(const cmsStage* mpe);
-
-
-// Pipeline Evaluator (in floating point)
-typedef void (* _cmsPipelineEvalFloatFn)(const cmsFloat32Number In[], 
-                                         cmsFloat32Number Out[], 
-                                         const void* Data); 
-
-struct _cmsPipeline_struct {
-
-    cmsStage* Elements;                                // Points to elements chain 
-    cmsUInt32Number InputChannels, OutputChannels;  
-   
-    // Data & evaluators
-    void *Data;
-
-   _cmsOPTeval16Fn         Eval16Fn;
-   _cmsPipelineEvalFloatFn EvalFloatFn;
-   _cmsOPTfreeDataFn       FreeDataFn;
-   _cmsOPTdupDataFn        DupDataFn;
-    
-    cmsContext ContextID;            // Environment
-
-    cmsBool  SaveAs8Bits;            // Implemntation-specific: save as 8 bits if possible
-};
-
-// LUT reading & creation -------------------------------------------------------------------------------------------
-
-// Read tags using low-level function, provide necessary glue code to adapt versions, etc. All those return a brand new copy
-// of the LUTS, since ownership of original is up to the profile. The user should free allocated resources.
-
-cmsPipeline*      _cmsReadInputLUT(cmsHPROFILE hProfile, int Intent);
-cmsPipeline*      _cmsReadOutputLUT(cmsHPROFILE hProfile, int Intent);
-cmsPipeline*      _cmsReadDevicelinkLUT(cmsHPROFILE hProfile, int Intent);
-
-// Special values
-cmsBool           _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile);
-cmsBool           _cmsReadCHAD(cmsMAT3* Dest, cmsHPROFILE hProfile);
-
-// Profile linker --------------------------------------------------------------------------------------------------
-
-cmsPipeline* _cmsLinkProfiles(cmsContext         ContextID, 
-                              cmsUInt32Number    nProfiles,
-                              cmsUInt32Number    TheIntents[], 
-                              cmsHPROFILE        hProfiles[], 
-                              cmsBool            BPC[],
-                              cmsFloat64Number   AdaptationStates[],
-                              cmsUInt32Number    dwFlags);
-
-// Sequence --------------------------------------------------------------------------------------------------------
-
-cmsSEQ* _cmsReadProfileSequence(cmsHPROFILE hProfile);
-cmsBool _cmsWriteProfileSequence(cmsHPROFILE hProfile, const cmsSEQ* seq);
-cmsSEQ* _cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[]);
-
-
-// LUT optimization ------------------------------------------------------------------------------------------------
-
-cmsUInt16Number  _cmsQuantizeVal(cmsFloat64Number i, int MaxSamples);
-int              _cmsReasonableGridpointsByColorspace(cmsColorSpaceSignature Colorspace, cmsUInt32Number dwFlags);
-
-cmsBool          _cmsEndPointsBySpace(cmsColorSpaceSignature Space, 
-                                      cmsUInt16Number **White, 
-                                      cmsUInt16Number **Black,
-                                      cmsUInt32Number *nOutputs);
-
-cmsBool          _cmsOptimizePipeline(cmsPipeline**    Lut,                                              
-                                      int              Intent,
-                                      cmsUInt32Number* InputFormat, 
-                                      cmsUInt32Number* OutputFormat,
-                                      cmsUInt32Number* dwFlags );
-
-
-// Hi level LUT building ----------------------------------------------------------------------------------------------
-
-cmsPipeline*     _cmsCreateGamutCheckPipeline(cmsContext ContextID,
-                                              cmsHPROFILE hProfiles[], 
-                                              cmsBool  BPC[], 
-                                              cmsUInt32Number Intents[], 
-                                              cmsFloat64Number AdaptationStates[],
-                                              cmsUInt32Number nGamutPCSposition, 
-                                              cmsHPROFILE hGamut);
-
-
-// Formatters ------------------------------------------------------------------------------------------------------------
-
-#define cmsFLAGS_CAN_CHANGE_FORMATTER     0x02000000   // Allow change buffer format
-
-cmsBool         _cmsFormatterIsFloat(cmsUInt32Number Type);
-cmsBool         _cmsFormatterIs8bit(cmsUInt32Number Type);
-
-cmsFormatter    _cmsGetFormatter(cmsUInt32Number Type,          // Specific type, i.e. TYPE_RGB_8
-                                 cmsFormatterDirection Dir, 
-                                 cmsUInt32Number dwFlags);
-
-
-// Transform logic ------------------------------------------------------------------------------------------------------
-
-struct _cmstransform_struct;
-
-// Full xform
-typedef void (* _cmsTransformFn)(struct _cmstransform_struct *Transform,
-                                 const void* InputBuffer,
-                                 void* OutputBuffer, cmsUInt32Number Size);
-
-typedef struct {
-
-    cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference
-    cmsUInt32Number StrideIn, StrideOut;       // Planar support
-
-} cmsFormatterInfo;
-
-// Transformation
-typedef struct _cmstransform_struct {
-
-    cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference
-
-    // Points to transform code
-    _cmsTransformFn xform;
-
-    // Formatters, cannot be embedded into LUT because cache
-    cmsFormatter16 FromInput;
-    cmsFormatter16 ToOutput;
-
-    cmsFormatterFloat FromInputFloat;
-    cmsFormatterFloat ToOutputFloat;
-    
-    // 1-pixel cache (16 bits only)
-    cmsUInt16Number CacheIn[cmsMAXCHANNELS];
-    cmsUInt16Number CacheOut[cmsMAXCHANNELS];
-
-    // Semaphor for cache
-    LCMS_RWLOCK_T rwlock;
-    
-    // A MPE LUT holding the full (optimized) transform
-    cmsPipeline* Lut;
-    
-    // A MPE LUT holding the gamut check. It goes from the input space to bilevel
-    cmsPipeline* GamutCheck;
-
-    // Colorant tables
-    cmsNAMEDCOLORLIST* InputColorant;       // Input Colorant table
-    cmsNAMEDCOLORLIST* OutputColorant;      // Colorant table (for n chans > CMYK)
-
-    // Informational only
-    cmsColorSpaceSignature EntryColorSpace;
-    cmsColorSpaceSignature ExitColorSpace;
-    
-    // Profiles used to create the transform
-    cmsSEQ* Sequence;
-
-    cmsUInt32Number  dwOriginalFlags;      
-    cmsFloat64Number AdaptationState;              
-
-    // The intent of this transform. That is usually the last intent in the profilechain, but may differ
-    cmsUInt32Number RenderingIntent;
-
-    // An id that uniquely identifies the running context. May be null.
-    cmsContext ContextID;
-
-} _cmsTRANSFORM;
-
-// --------------------------------------------------------------------------------------------------
-
-cmsHTRANSFORM _cmsChain2Lab(cmsContext             ContextID,
-                            cmsUInt32Number        nProfiles,
-                            cmsUInt32Number        InputFormat,
-                            cmsUInt32Number        OutputFormat,
-                            const cmsUInt32Number  Intents[], 
-                            const cmsHPROFILE      hProfiles[], 
-                            const cmsBool          BPC[],
-                            const cmsFloat64Number AdaptationStates[],
-                            cmsUInt32Number        dwFlags);
-
-
-cmsToneCurve* _cmsBuildKToneCurve(cmsContext       ContextID, 
-                            cmsUInt32Number        nPoints,
-                            cmsUInt32Number        nProfiles,
-                            const cmsUInt32Number  Intents[], 
-                            const cmsHPROFILE      hProfiles[], 
-                            const cmsBool          BPC[],
-                            const cmsFloat64Number AdaptationStates[],
-                            cmsUInt32Number        dwFlags);
-
-cmsBool   _cmsAdaptationMatrix(cmsMAT3* r, const cmsMAT3* ConeMatrix, const cmsCIEXYZ* FromIll, const cmsCIEXYZ* ToIll);
-
-cmsBool   _cmsBuildRGB2XYZtransferMatrix(cmsMAT3* r, const cmsCIExyY* WhitePoint, const cmsCIExyYTRIPLE* Primaries);
-
-
-#define _lcms_internal_H
-#endif
diff --git a/thirdparty/libpng/CMakeLists.txt b/thirdparty/libpng/CMakeLists.txt
deleted file mode 100644
index 7f6456f..0000000
--- a/thirdparty/libpng/CMakeLists.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-PROJECT(libpng C)
-
-INCLUDE_DIRECTORIES(
-  "${CMAKE_CURRENT_SOURCE_DIR}"
-  ${OPENJPEG_SOURCE_DIR}/thirdparty/include
-)
-
-FILE(GLOB SRCS *.c)
-FILE(GLOB HDRS *.h)
-SET(EXT_HDRS 
- ${OPENJPEG_SOURCE_DIR}/thirdparty/include/zlib.h
- ${OPENJPEG_SOURCE_DIR}/thirdparty/include/zconf.h
-)
-#
-SET(LIBTARGET "png")
-#
-ADD_LIBRARY(${LIBTARGET} STATIC ${SRCS} ${HDRS} ${EXT_HDRS})
-#
-IF(MSVC)
-  SET_TARGET_PROPERTIES(${LIBTARGET} PROPERTIES PREFIX "lib")
-ENDIF(MSVC)
-#
-TARGET_LINK_LIBRARIES(${LIBTARGET} ${Z_LIBNAME} ${M_LIBRARY})
-#
-SET_TARGET_PROPERTIES(${LIBTARGET}
-	PROPERTIES 
-    OUTPUT_NAME "${LIBTARGET}"
-	ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/thirdparty/lib)
-#
diff --git a/thirdparty/libpng/LICENSE b/thirdparty/libpng/LICENSE
deleted file mode 100644
index 756ebd0..0000000
--- a/thirdparty/libpng/LICENSE
+++ /dev/null
@@ -1,111 +0,0 @@
-
-This copy of the libpng notices is provided for your convenience.  In case of
-any discrepancy between this copy and the notices in the file png.h that is
-included in the libpng distribution, the latter shall prevail.
-
-COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
-
-If you modify libpng you may insert additional notices immediately following
-this sentence.
-
-This code is released under the libpng license.
-
-libpng versions 1.2.6, August 15, 2004, through 1.4.4, September 23, 2010, are
-Copyright (c) 2004, 2006-2010 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.2.5
-with the following individual added to the list of Contributing Authors
-
-   Cosmin Truta
-
-libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are
-Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.0.6
-with the following individuals added to the list of Contributing Authors
-
-   Simon-Pierre Cadieux
-   Eric S. Raymond
-   Gilles Vollant
-
-and with the following additions to the disclaimer:
-
-   There is no warranty against interference with your enjoyment of the
-   library or against infringement.  There is no warranty that our
-   efforts or the library will fulfill any of your particular purposes
-   or needs.  This library is provided with all faults, and the entire
-   risk of satisfactory quality, performance, accuracy, and effort is with
-   the user.
-
-libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
-Copyright (c) 1998, 1999 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-0.96,
-with the following individuals added to the list of Contributing Authors:
-
-   Tom Lane
-   Glenn Randers-Pehrson
-   Willem van Schaik
-
-libpng versions 0.89, June 1996, through 0.96, May 1997, are
-Copyright (c) 1996, 1997 Andreas Dilger
-Distributed according to the same disclaimer and license as libpng-0.88,
-with the following individuals added to the list of Contributing Authors:
-
-   John Bowler
-   Kevin Bracey
-   Sam Bushell
-   Magnus Holmgren
-   Greg Roelofs
-   Tom Tanner
-
-libpng versions 0.5, May 1995, through 0.88, January 1996, are
-Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
-
-For the purposes of this copyright and license, "Contributing Authors"
-is defined as the following set of individuals:
-
-   Andreas Dilger
-   Dave Martindale
-   Guy Eric Schalnat
-   Paul Schmidt
-   Tim Wegner
-
-The PNG Reference Library is supplied "AS IS".  The Contributing Authors
-and Group 42, Inc. disclaim all warranties, expressed or implied,
-including, without limitation, the warranties of merchantability and of
-fitness for any purpose.  The Contributing Authors and Group 42, Inc.
-assume no liability for direct, indirect, incidental, special, exemplary,
-or consequential damages, which may result from the use of the PNG
-Reference Library, even if advised of the possibility of such damage.
-
-Permission is hereby granted to use, copy, modify, and distribute this
-source code, or portions hereof, for any purpose, without fee, subject
-to the following restrictions:
-
-1. The origin of this source code must not be misrepresented.
-
-2. Altered versions must be plainly marked as such and must not
-   be misrepresented as being the original source.
-
-3. This Copyright notice may not be removed or altered from any
-   source or altered source distribution.
-
-The Contributing Authors and Group 42, Inc. specifically permit, without
-fee, and encourage the use of this source code as a component to
-supporting the PNG file format in commercial products.  If you use this
-source code in a product, acknowledgment is not required but would be
-appreciated.
-
-
-A "png_get_copyright" function is available, for convenient use in "about"
-boxes and the like:
-
-   printf("%s",png_get_copyright(NULL));
-
-Also, the PNG logo (in PNG format, of course) is supplied in the
-files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
-
-Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
-certification mark of the Open Source Initiative.
-
-Glenn Randers-Pehrson
-glennrp at users.sourceforge.net
-September 23, 2010
diff --git a/thirdparty/libpng/example.c b/thirdparty/libpng/example.c
deleted file mode 100644
index d739173..0000000
--- a/thirdparty/libpng/example.c
+++ /dev/null
@@ -1,838 +0,0 @@
-
-#if 0 /* in case someone actually tries to compile this */
-
-/* example.c - an example of using libpng
- * Last changed in libpng 1.4.2 [May 6, 2010]
- * This file has been placed in the public domain by the authors.
- * Maintained 1998-2010 Glenn Randers-Pehrson
- * Maintained 1996, 1997 Andreas Dilger)
- * Written 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- */
-
-/* This is an example of how to use libpng to read and write PNG files.
- * The file libpng.txt is much more verbose then this.  If you have not
- * read it, do so first.  This was designed to be a starting point of an
- * implementation.  This is not officially part of libpng, is hereby placed
- * in the public domain, and therefore does not require a copyright notice.
- *
- * This file does not currently compile, because it is missing certain
- * parts, like allocating memory to hold an image.  You will have to
- * supply these parts to get it to compile.  For an example of a minimal
- * working PNG reader/writer, see pngtest.c, included in this distribution;
- * see also the programs in the contrib directory.
- */
-
-#include "png.h"
-
- /* The png_jmpbuf() macro, used in error handling, became available in
-  * libpng version 1.0.6.  If you want to be able to run your code with older
-  * versions of libpng, you must define the macro yourself (but only if it
-  * is not already defined by libpng!).
-  */
-
-#ifndef png_jmpbuf
-#  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
-#endif
-
-/* Check to see if a file is a PNG file using png_sig_cmp().  png_sig_cmp()
- * returns zero if the image is a PNG and nonzero if it isn't a PNG.
- *
- * The function check_if_png() shown here, but not used, returns nonzero (true)
- * if the file can be opened and is a PNG, 0 (false) otherwise.
- *
- * If this call is successful, and you are going to keep the file open,
- * you should call png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK); once
- * you have created the png_ptr, so that libpng knows your application
- * has read that many bytes from the start of the file.  Make sure you
- * don't call png_set_sig_bytes() with more than 8 bytes read or give it
- * an incorrect number of bytes read, or you will either have read too
- * many bytes (your fault), or you are telling libpng to read the wrong
- * number of magic bytes (also your fault).
- *
- * Many applications already read the first 2 or 4 bytes from the start
- * of the image to determine the file type, so it would be easiest just
- * to pass the bytes to png_sig_cmp() or even skip that if you know
- * you have a PNG file, and call png_set_sig_bytes().
- */
-#define PNG_BYTES_TO_CHECK 4
-int check_if_png(char *file_name, FILE **fp)
-{
-   char buf[PNG_BYTES_TO_CHECK];
-
-   /* Open the prospective PNG file. */
-   if ((*fp = fopen(file_name, "rb")) == NULL)
-      return 0;
-
-   /* Read in some of the signature bytes */
-   if (fread(buf, 1, PNG_BYTES_TO_CHECK, *fp) != PNG_BYTES_TO_CHECK)
-      return 0;
-
-   /* Compare the first PNG_BYTES_TO_CHECK bytes of the signature.
-      Return nonzero (true) if they match */
-
-   return(!png_sig_cmp(buf, (png_size_t)0, PNG_BYTES_TO_CHECK));
-}
-
-/* Read a PNG file.  You may want to return an error code if the read
- * fails (depending upon the failure).  There are two "prototypes" given
- * here - one where we are given the filename, and we need to open the
- * file, and the other where we are given an open file (possibly with
- * some or all of the magic bytes read - see comments above).
- */
-#ifdef open_file /* prototype 1 */
-void read_png(char *file_name)  /* We need to open the file */
-{
-   png_structp png_ptr;
-   png_infop info_ptr;
-   unsigned int sig_read = 0;
-   png_uint_32 width, height;
-   int bit_depth, color_type, interlace_type;
-   FILE *fp;
-
-   if ((fp = fopen(file_name, "rb")) == NULL)
-      return (ERROR);
-
-#else no_open_file /* prototype 2 */
-void read_png(FILE *fp, unsigned int sig_read)  /* File is already open */
-{
-   png_structp png_ptr;
-   png_infop info_ptr;
-   png_uint_32 width, height;
-   int bit_depth, color_type, interlace_type;
-#endif no_open_file /* Only use one prototype! */
-
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also supply the
-    * the compiler header file version, so that we know if the application
-    * was compiled with a compatible version of the library.  REQUIRED
-    */
-   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
-      png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (png_ptr == NULL)
-   {
-      fclose(fp);
-      return (ERROR);
-   }
-
-   /* Allocate/initialize the memory for image information.  REQUIRED. */
-   info_ptr = png_create_info_struct(png_ptr);
-   if (info_ptr == NULL)
-   {
-      fclose(fp);
-      png_destroy_read_struct(&png_ptr, NULL, NULL);
-      return (ERROR);
-   }
-
-   /* Set error handling if you are using the setjmp/longjmp method (this is
-    * the normal method of doing things with libpng).  REQUIRED unless you
-    * set up your own error handlers in the png_create_read_struct() earlier.
-    */
-
-   if (setjmp(png_jmpbuf(png_ptr)))
-   {
-      /* Free all of the memory associated with the png_ptr and info_ptr */
-      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-      fclose(fp);
-      /* If we get here, we had a problem reading the file */
-      return (ERROR);
-   }
-
-   /* One of the following I/O initialization methods is REQUIRED */
-#ifdef streams /* PNG file I/O method 1 */
-   /* Set up the input control if you are using standard C streams */
-   png_init_io(png_ptr, fp);
-
-#else no_streams /* PNG file I/O method 2 */
-   /* If you are using replacement read functions, instead of calling
-    * png_init_io() here you would call:
-    */
-   png_set_read_fn(png_ptr, (void *)user_io_ptr, user_read_fn);
-   /* where user_io_ptr is a structure you want available to the callbacks */
-#endif no_streams /* Use only one I/O method! */
-
-   /* If we have already read some of the signature */
-   png_set_sig_bytes(png_ptr, sig_read);
-
-#ifdef hilevel
-   /*
-    * If you have enough memory to read in the entire image at once,
-    * and you need to specify only transforms that can be controlled
-    * with one of the PNG_TRANSFORM_* bits (this presently excludes
-    * quantizing, filling, setting background, and doing gamma
-    * adjustment), then you can read the entire image (including
-    * pixels) into the info structure with this call:
-    */
-   png_read_png(png_ptr, info_ptr, png_transforms, NULL);
-
-#else
-   /* OK, you're doing it the hard way, with the lower-level functions */
-
-   /* The call to png_read_info() gives us all of the information from the
-    * PNG file before the first IDAT (image data chunk).  REQUIRED
-    */
-   png_read_info(png_ptr, info_ptr);
-
-   png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
-       &interlace_type, NULL, NULL);
-
-   /* Set up the data transformations you want.  Note that these are all
-    * optional.  Only call them if you want/need them.  Many of the
-    * transformations only work on specific types of images, and many
-    * are mutually exclusive.
-    */
-
-   /* Tell libpng to strip 16 bit/color files down to 8 bits/color */
-   png_set_strip_16(png_ptr);
-
-   /* Strip alpha bytes from the input data without combining with the
-    * background (not recommended).
-    */
-   png_set_strip_alpha(png_ptr);
-
-   /* Extract multiple pixels with bit depths of 1, 2, and 4 from a single
-    * byte into separate bytes (useful for paletted and grayscale images).
-    */
-   png_set_packing(png_ptr);
-
-   /* Change the order of packed pixels to least significant bit first
-    * (not useful if you are using png_set_packing). */
-   png_set_packswap(png_ptr);
-
-   /* Expand paletted colors into true RGB triplets */
-   if (color_type == PNG_COLOR_TYPE_PALETTE)
-      png_set_palette_to_rgb(png_ptr);
-
-   /* Expand grayscale images to the full 8 bits from 1, 2, or 4 bits/pixel */
-   if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
-      png_set_expand_gray_1_2_4_to_8(png_ptr);
-
-   /* Expand paletted or RGB images with transparency to full alpha channels
-    * so the data will be available as RGBA quartets.
-    */
-   if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
-      png_set_tRNS_to_alpha(png_ptr);
-
-   /* Set the background color to draw transparent and alpha images over.
-    * It is possible to set the red, green, and blue components directly
-    * for paletted images instead of supplying a palette index.  Note that
-    * even if the PNG file supplies a background, you are not required to
-    * use it - you should use the (solid) application background if it has one.
-    */
-
-   png_color_16 my_background, *image_background;
-
-   if (png_get_bKGD(png_ptr, info_ptr, &image_background))
-      png_set_background(png_ptr, image_background,
-                         PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
-   else
-      png_set_background(png_ptr, &my_background,
-                         PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
-
-   /* Some suggestions as to how to get a screen gamma value
-    *
-    * Note that screen gamma is the display_exponent, which includes
-    * the CRT_exponent and any correction for viewing conditions
-    */
-   if (/* We have a user-defined screen gamma value */)
-   {
-      screen_gamma = user-defined screen_gamma;
-   }
-   /* This is one way that applications share the same screen gamma value */
-   else if ((gamma_str = getenv("SCREEN_GAMMA")) != NULL)
-   {
-      screen_gamma = atof(gamma_str);
-   }
-   /* If we don't have another value */
-   else
-   {
-      screen_gamma = 2.2;  /* A good guess for a PC monitor in a dimly
-                              lit room */
-      screen_gamma = 1.7 or 1.0;  /* A good guess for Mac systems */
-   }
-
-   /* Tell libpng to handle the gamma conversion for you.  The final call
-    * is a good guess for PC generated images, but it should be configurable
-    * by the user at run time by the user.  It is strongly suggested that
-    * your application support gamma correction.
-    */
-
-   int intent;
-
-   if (png_get_sRGB(png_ptr, info_ptr, &intent))
-      png_set_gamma(png_ptr, screen_gamma, 0.45455);
-   else
-   {
-      double image_gamma;
-      if (png_get_gAMA(png_ptr, info_ptr, &image_gamma))
-         png_set_gamma(png_ptr, screen_gamma, image_gamma);
-      else
-         png_set_gamma(png_ptr, screen_gamma, 0.45455);
-   }
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   /* Quantize RGB files down to 8 bit palette or reduce palettes
-    * to the number of colors available on your screen.
-    */
-   if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      int num_palette;
-      png_colorp palette;
-
-      /* This reduces the image to the application supplied palette */
-      if (/* We have our own palette */)
-      {
-         /* An array of colors to which the image should be quantized */
-         png_color std_color_cube[MAX_SCREEN_COLORS];
-
-         /* Prior to libpng-1.4.2, this was png_set_dither(). */
-         png_set_quantize(png_ptr, std_color_cube, MAX_SCREEN_COLORS,
-            MAX_SCREEN_COLORS, NULL, 0);
-      }
-      /* This reduces the image to the palette supplied in the file */
-      else if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette))
-      {
-         png_uint_16p histogram = NULL;
-
-         png_get_hIST(png_ptr, info_ptr, &histogram);
-
-         png_set_quantize(png_ptr, palette, num_palette,
-                        max_screen_colors, histogram, 0);
-      }
-   }
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-
-   /* Invert monochrome files to have 0 as white and 1 as black */
-   png_set_invert_mono(png_ptr);
-
-   /* If you want to shift the pixel values from the range [0,255] or
-    * [0,65535] to the original [0,7] or [0,31], or whatever range the
-    * colors were originally in:
-    */
-   if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
-   {
-      png_color_8p sig_bit_p;
-
-      png_get_sBIT(png_ptr, info_ptr, &sig_bit_p);
-      png_set_shift(png_ptr, sig_bit_p);
-   }
-
-   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */
-   if (color_type & PNG_COLOR_MASK_COLOR)
-      png_set_bgr(png_ptr);
-
-   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
-   png_set_swap_alpha(png_ptr);
-
-   /* Swap bytes of 16 bit files to least significant byte first */
-   png_set_swap(png_ptr);
-
-   /* Add filler (or alpha) byte (before/after each RGB triplet) */
-   png_set_filler(png_ptr, 0xff, PNG_FILLER_AFTER);
-
-   /* Turn on interlace handling.  REQUIRED if you are not using
-    * png_read_image().  To see how to handle interlacing passes,
-    * see the png_read_row() method below:
-    */
-   number_passes = png_set_interlace_handling(png_ptr);
-
-   /* Optional call to gamma correct and add the background to the palette
-    * and update info structure.  REQUIRED if you are expecting libpng to
-    * update the palette for you (ie you selected such a transform above).
-    */
-   png_read_update_info(png_ptr, info_ptr);
-
-   /* Allocate the memory to hold the image using the fields of info_ptr. */
-
-   /* The easiest way to read the image: */
-   png_bytep row_pointers[height];
-
-   /* Clear the pointer array */
-   for (row = 0; row < height; row++)
-      row_pointers[row] = NULL;
-
-   for (row = 0; row < height; row++)
-      row_pointers[row] = png_malloc(png_ptr, png_get_rowbytes(png_ptr,
-         info_ptr));
-
-   /* Now it's time to read the image.  One of these methods is REQUIRED */
-#ifdef entire /* Read the entire image in one go */
-   png_read_image(png_ptr, row_pointers);
-
-#else no_entire /* Read the image one or more scanlines at a time */
-   /* The other way to read images - deal with interlacing: */
-
-   for (pass = 0; pass < number_passes; pass++)
-   {
-#ifdef single /* Read the image a single row at a time */
-      for (y = 0; y < height; y++)
-      {
-         png_read_rows(png_ptr, &row_pointers[y], NULL, 1);
-      }
-
-#else no_single /* Read the image several rows at a time */
-      for (y = 0; y < height; y += number_of_rows)
-      {
-#ifdef sparkle /* Read the image using the "sparkle" effect. */
-         png_read_rows(png_ptr, &row_pointers[y], NULL,
-            number_of_rows);
-#else no_sparkle /* Read the image using the "rectangle" effect */
-         png_read_rows(png_ptr, NULL, &row_pointers[y],
-            number_of_rows);
-#endif no_sparkle /* Use only one of these two methods */
-      }
-
-      /* If you want to display the image after every pass, do so here */
-#endif no_single /* Use only one of these two methods */
-   }
-#endif no_entire /* Use only one of these two methods */
-
-   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
-   png_read_end(png_ptr, info_ptr);
-#endif hilevel
-
-   /* At this point you have read the entire image */
-
-   /* Clean up after the read, and free any memory allocated - REQUIRED */
-   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-
-   /* Close the file */
-   fclose(fp);
-
-   /* That's it */
-   return (OK);
-}
-
-/* Progressively read a file */
-
-int
-initialize_png_reader(png_structp *png_ptr, png_infop *info_ptr)
-{
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also check that
-    * the library version is compatible in case we are using dynamically
-    * linked libraries.
-    */
-   *png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
-       png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (*png_ptr == NULL)
-   {
-      *info_ptr = NULL;
-      return (ERROR);
-   }
-
-   *info_ptr = png_create_info_struct(png_ptr);
-
-   if (*info_ptr == NULL)
-   {
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   if (setjmp(png_jmpbuf((*png_ptr))))
-   {
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   /* This one's new.  You will need to provide all three
-    * function callbacks, even if you aren't using them all.
-    * If you aren't using all functions, you can specify NULL
-    * parameters.  Even when all three functions are NULL,
-    * you need to call png_set_progressive_read_fn().
-    * These functions shouldn't be dependent on global or
-    * static variables if you are decoding several images
-    * simultaneously.  You should store stream specific data
-    * in a separate struct, given as the second parameter,
-    * and retrieve the pointer from inside the callbacks using
-    * the function png_get_progressive_ptr(png_ptr).
-    */
-   png_set_progressive_read_fn(*png_ptr, (void *)stream_data,
-      info_callback, row_callback, end_callback);
-
-   return (OK);
-}
-
-int
-process_data(png_structp *png_ptr, png_infop *info_ptr,
-   png_bytep buffer, png_uint_32 length)
-{
-   if (setjmp(png_jmpbuf((*png_ptr))))
-   {
-      /* Free the png_ptr and info_ptr memory on error */
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   /* This one's new also.  Simply give it chunks of data as
-    * they arrive from the data stream (in order, of course).
-    * On segmented machines, don't give it any more than 64K.
-    * The library seems to run fine with sizes of 4K, although
-    * you can give it much less if necessary (I assume you can
-    * give it chunks of 1 byte, but I haven't tried with less
-    * than 256 bytes yet).  When this function returns, you may
-    * want to display any rows that were generated in the row
-    * callback, if you aren't already displaying them there.
-    */
-   png_process_data(*png_ptr, *info_ptr, buffer, length);
-   return (OK);
-}
-
-info_callback(png_structp png_ptr, png_infop info)
-{
-   /* Do any setup here, including setting any of the transformations
-    * mentioned in the Reading PNG files section.  For now, you _must_
-    * call either png_start_read_image() or png_read_update_info()
-    * after all the transformations are set (even if you don't set
-    * any).  You may start getting rows before png_process_data()
-    * returns, so this is your last chance to prepare for that.
-    */
-}
-
-row_callback(png_structp png_ptr, png_bytep new_row,
-   png_uint_32 row_num, int pass)
-{
-   /*
-    * This function is called for every row in the image.  If the
-    * image is interlaced, and you turned on the interlace handler,
-    * this function will be called for every row in every pass.
-    *
-    * In this function you will receive a pointer to new row data from
-    * libpng called new_row that is to replace a corresponding row (of
-    * the same data format) in a buffer allocated by your application.
-    *
-    * The new row data pointer "new_row" may be NULL, indicating there is
-    * no new data to be replaced (in cases of interlace loading).
-    *
-    * If new_row is not NULL then you need to call
-    * png_progressive_combine_row() to replace the corresponding row as
-    * shown below:
-    */
-
-   /* Get pointer to corresponding row in our
-    * PNG read buffer.
-    */
-   png_bytep old_row = ((png_bytep *)our_data)[row_num];
-
-   /* If both rows are allocated then copy the new row
-    * data to the corresponding row data.
-    */
-   if ((old_row != NULL) && (new_row != NULL))
-   png_progressive_combine_row(png_ptr, old_row, new_row);
-
-   /*
-    * The rows and passes are called in order, so you don't really
-    * need the row_num and pass, but I'm supplying them because it
-    * may make your life easier.
-    *
-    * For the non-NULL rows of interlaced images, you must call
-    * png_progressive_combine_row() passing in the new row and the
-    * old row, as demonstrated above.  You can call this function for
-    * NULL rows (it will just return) and for non-interlaced images
-    * (it just does the png_memcpy for you) if it will make the code
-    * easier.  Thus, you can just do this for all cases:
-    */
-
-   png_progressive_combine_row(png_ptr, old_row, new_row);
-
-   /* where old_row is what was displayed for previous rows.  Note
-    * that the first pass (pass == 0 really) will completely cover
-    * the old row, so the rows do not have to be initialized.  After
-    * the first pass (and only for interlaced images), you will have
-    * to pass the current row as new_row, and the function will combine
-    * the old row and the new row.
-    */
-}
-
-end_callback(png_structp png_ptr, png_infop info)
-{
-   /* This function is called when the whole image has been read,
-    * including any chunks after the image (up to and including
-    * the IEND).  You will usually have the same info chunk as you
-    * had in the header, although some data may have been added
-    * to the comments and time fields.
-    *
-    * Most people won't do much here, perhaps setting a flag that
-    * marks the image as finished.
-    */
-}
-
-/* Write a png file */
-void write_png(char *file_name /* , ... other image information ... */)
-{
-   FILE *fp;
-   png_structp png_ptr;
-   png_infop info_ptr;
-   png_colorp palette;
-
-   /* Open the file */
-   fp = fopen(file_name, "wb");
-   if (fp == NULL)
-      return (ERROR);
-
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also check that
-    * the library version is compatible with the one used at compile time,
-    * in case we are using dynamically linked libraries.  REQUIRED.
-    */
-   png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-      png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (png_ptr == NULL)
-   {
-      fclose(fp);
-      return (ERROR);
-   }
-
-   /* Allocate/initialize the image information data.  REQUIRED */
-   info_ptr = png_create_info_struct(png_ptr);
-   if (info_ptr == NULL)
-   {
-      fclose(fp);
-      png_destroy_write_struct(&png_ptr,  NULL);
-      return (ERROR);
-   }
-
-   /* Set error handling.  REQUIRED if you aren't supplying your own
-    * error handling functions in the png_create_write_struct() call.
-    */
-   if (setjmp(png_jmpbuf(png_ptr)))
-   {
-      /* If we get here, we had a problem writing the file */
-      fclose(fp);
-      png_destroy_write_struct(&png_ptr, &info_ptr);
-      return (ERROR);
-   }
-
-   /* One of the following I/O initialization functions is REQUIRED */
-
-#ifdef streams /* I/O initialization method 1 */
-   /* Set up the output control if you are using standard C streams */
-   png_init_io(png_ptr, fp);
-
-#else no_streams /* I/O initialization method 2 */
-   /* If you are using replacement write functions, instead of calling
-    * png_init_io() here you would call
-    */
-   png_set_write_fn(png_ptr, (void *)user_io_ptr, user_write_fn,
-      user_IO_flush_function);
-   /* where user_io_ptr is a structure you want available to the callbacks */
-#endif no_streams /* Only use one initialization method */
-
-#ifdef hilevel
-   /* This is the easy way.  Use it if you already have all the
-    * image info living in the structure.  You could "|" many
-    * PNG_TRANSFORM flags into the png_transforms integer here.
-    */
-   png_write_png(png_ptr, info_ptr, png_transforms, NULL);
-
-#else
-   /* This is the hard way */
-
-   /* Set the image information here.  Width and height are up to 2^31,
-    * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
-    * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
-    * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
-    * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
-    * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
-    * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
-    */
-   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, PNG_COLOR_TYPE_???,
-      PNG_INTERLACE_????, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-   /* Set the palette if there is one.  REQUIRED for indexed-color images */
-   palette = (png_colorp)png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH
-             * png_sizeof(png_color));
-   /* ... Set palette colors ... */
-   png_set_PLTE(png_ptr, info_ptr, palette, PNG_MAX_PALETTE_LENGTH);
-   /* You must not free palette here, because png_set_PLTE only makes a link to
-    * the palette that you malloced.  Wait until you are about to destroy
-    * the png structure.
-    */
-
-   /* Optional significant bit (sBIT) chunk */
-   png_color_8 sig_bit;
-   /* If we are dealing with a grayscale image then */
-   sig_bit.gray = true_bit_depth;
-   /* Otherwise, if we are dealing with a color image then */
-   sig_bit.red = true_red_bit_depth;
-   sig_bit.green = true_green_bit_depth;
-   sig_bit.blue = true_blue_bit_depth;
-   /* If the image has an alpha channel then */
-   sig_bit.alpha = true_alpha_bit_depth;
-   png_set_sBIT(png_ptr, info_ptr, &sig_bit);
-
-
-   /* Optional gamma chunk is strongly suggested if you have any guess
-    * as to the correct gamma of the image.
-    */
-   png_set_gAMA(png_ptr, info_ptr, gamma);
-
-   /* Optionally write comments into the image */
-   text_ptr[0].key = "Title";
-   text_ptr[0].text = "Mona Lisa";
-   text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;
-   text_ptr[1].key = "Author";
-   text_ptr[1].text = "Leonardo DaVinci";
-   text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;
-   text_ptr[2].key = "Description";
-   text_ptr[2].text = "<long text>";
-   text_ptr[2].compression = PNG_TEXT_COMPRESSION_zTXt;
-#ifdef PNG_iTXt_SUPPORTED
-   text_ptr[0].lang = NULL;
-   text_ptr[0].lang_key = NULL;
-   text_ptr[1].lang = NULL;
-   text_ptr[1].lang_key = NULL;
-   text_ptr[2].lang = NULL;
-   text_ptr[2].lang_key = NULL;
-#endif
-   png_set_text(png_ptr, info_ptr, text_ptr, 3);
-
-   /* Other optional chunks like cHRM, bKGD, tRNS, tIME, oFFs, pHYs */
-
-   /* Note that if sRGB is present the gAMA and cHRM chunks must be ignored
-    * on read and, if your application chooses to write them, they must
-    * be written in accordance with the sRGB profile
-    */
-
-   /* Write the file header information.  REQUIRED */
-   png_write_info(png_ptr, info_ptr);
-
-   /* If you want, you can write the info in two steps, in case you need to
-    * write your private chunk ahead of PLTE:
-    *
-    *   png_write_info_before_PLTE(write_ptr, write_info_ptr);
-    *   write_my_chunk();
-    *   png_write_info(png_ptr, info_ptr);
-    *
-    * However, given the level of known- and unknown-chunk support in 1.2.0
-    * and up, this should no longer be necessary.
-    */
-
-   /* Once we write out the header, the compression type on the text
-    * chunks gets changed to PNG_TEXT_COMPRESSION_NONE_WR or
-    * PNG_TEXT_COMPRESSION_zTXt_WR, so it doesn't get written out again
-    * at the end.
-    */
-
-   /* Set up the transformations you want.  Note that these are
-    * all optional.  Only call them if you want them.
-    */
-
-   /* Invert monochrome pixels */
-   png_set_invert_mono(png_ptr);
-
-   /* Shift the pixels up to a legal bit depth and fill in
-    * as appropriate to correctly scale the image.
-    */
-   png_set_shift(png_ptr, &sig_bit);
-
-   /* Pack pixels into bytes */
-   png_set_packing(png_ptr);
-
-   /* Swap location of alpha bytes from ARGB to RGBA */
-   png_set_swap_alpha(png_ptr);
-
-   /* Get rid of filler (OR ALPHA) bytes, pack XRGB/RGBX/ARGB/RGBA into
-    * RGB (4 channels -> 3 channels). The second parameter is not used.
-    */
-   png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-
-   /* Flip BGR pixels to RGB */
-   png_set_bgr(png_ptr);
-
-   /* Swap bytes of 16-bit files to most significant byte first */
-   png_set_swap(png_ptr);
-
-   /* Swap bits of 1, 2, 4 bit packed pixel formats */
-   png_set_packswap(png_ptr);
-
-   /* Turn on interlace handling if you are not using png_write_image() */
-   if (interlacing)
-      number_passes = png_set_interlace_handling(png_ptr);
-   else
-      number_passes = 1;
-
-   /* The easiest way to write the image (you may have a different memory
-    * layout, however, so choose what fits your needs best).  You need to
-    * use the first method if you aren't handling interlacing yourself.
-    */
-   png_uint_32 k, height, width;
-   png_byte image[height][width*bytes_per_pixel];
-   png_bytep row_pointers[height];
-
-   if (height > PNG_UINT_32_MAX/png_sizeof(png_bytep))
-     png_error (png_ptr, "Image is too tall to process in memory");
-
-   for (k = 0; k < height; k++)
-     row_pointers[k] = image + k*width*bytes_per_pixel;
-
-   /* One of the following output methods is REQUIRED */
-
-#ifdef entire /* Write out the entire image data in one call */
-   png_write_image(png_ptr, row_pointers);
-
-   /* The other way to write the image - deal with interlacing */
-
-#else no_entire /* Write out the image data by one or more scanlines */
-
-   /* The number of passes is either 1 for non-interlaced images,
-    * or 7 for interlaced images.
-    */
-   for (pass = 0; pass < number_passes; pass++)
-   {
-      /* Write a few rows at a time. */
-      png_write_rows(png_ptr, &row_pointers[first_row], number_of_rows);
-
-      /* If you are only writing one row at a time, this works */
-      for (y = 0; y < height; y++)
-         png_write_rows(png_ptr, &row_pointers[y], 1);
-   }
-#endif no_entire /* Use only one output method */
-
-   /* You can write optional chunks like tEXt, zTXt, and tIME at the end
-    * as well.  Shouldn't be necessary in 1.2.0 and up as all the public
-    * chunks are supported and you can use png_set_unknown_chunks() to
-    * register unknown chunks into the info structure to be written out.
-    */
-
-   /* It is REQUIRED to call this to finish writing the rest of the file */
-   png_write_end(png_ptr, info_ptr);
-#endif hilevel
-
-   /* If you png_malloced a palette, free it here (don't free info_ptr->palette,
-    * as recommended in versions 1.0.5m and earlier of this example; if
-    * libpng mallocs info_ptr->palette, libpng will free it).  If you
-    * allocated it with malloc() instead of png_malloc(), use free() instead
-    * of png_free().
-    */
-   png_free(png_ptr, palette);
-   palette = NULL;
-
-   /* Similarly, if you png_malloced any data that you passed in with
-    * png_set_something(), such as a hist or trans array, free it here,
-    * when you can be sure that libpng is through with it.
-    */
-   png_free(png_ptr, trans);
-   trans = NULL;
-   /* Whenever you use png_free() it is a good idea to set the pointer to
-    * NULL in case your application inadvertently tries to png_free() it
-    * again.  When png_free() sees a NULL it returns without action, thus
-    * avoiding the double-free security problem.
-    */
-
-   /* Clean up after the write, and free any memory allocated */
-   png_destroy_write_struct(&png_ptr, &info_ptr);
-
-   /* Close the file */
-   fclose(fp);
-
-   /* That's it */
-   return (OK);
-}
-
-#endif /* if 0 */
diff --git a/thirdparty/libpng/png.c b/thirdparty/libpng/png.c
deleted file mode 100644
index f2e5888..0000000
--- a/thirdparty/libpng/png.c
+++ /dev/null
@@ -1,918 +0,0 @@
-
-/* png.c - location for general purpose libpng functions
- *
- * Last changed in libpng 1.4.2 [May 6, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#define PNG_NO_EXTERN
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#include "pngpriv.h"
-
-/* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_4_4 Your_png_h_is_not_version_1_4_4;
-
-/* Version information for C files.  This had better match the version
- * string defined in png.h.
- */
-
-/* Tells libpng that we have already handled the first "num_bytes" bytes
- * of the PNG file signature.  If the PNG data is embedded into another
- * stream we can set num_bytes = 8 so that libpng will not attempt to read
- * or write any of the magic bytes before it starts on the IHDR.
- */
-
-#ifdef PNG_READ_SUPPORTED
-void PNGAPI
-png_set_sig_bytes(png_structp png_ptr, int num_bytes)
-{
-   png_debug(1, "in png_set_sig_bytes");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (num_bytes > 8)
-      png_error(png_ptr, "Too many bytes for PNG signature");
-
-   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
-}
-
-/* Checks whether the supplied bytes match the PNG signature.  We allow
- * checking less than the full 8-byte signature so that those apps that
- * already read the first few bytes of a file to determine the file type
- * can simply check the remaining bytes for extra assurance.  Returns
- * an integer less than, equal to, or greater than zero if sig is found,
- * respectively, to be less than, to match, or be greater than the correct
- * PNG signature (this is the same behaviour as strcmp, memcmp, etc).
- */
-int PNGAPI
-png_sig_cmp(png_bytep sig, png_size_t start, png_size_t num_to_check)
-{
-   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
-   if (num_to_check > 8)
-      num_to_check = 8;
-   else if (num_to_check < 1)
-      return (-1);
-
-   if (start > 7)
-      return (-1);
-
-   if (start + num_to_check > 8)
-      num_to_check = 8 - start;
-
-   return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
-}
-
-#endif /* PNG_READ_SUPPORTED */
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-/* Function to allocate memory for zlib and clear it to 0. */
-voidpf /* PRIVATE */
-png_zalloc(voidpf png_ptr, uInt items, uInt size)
-{
-   png_voidp ptr;
-   png_structp p=(png_structp)png_ptr;
-   png_uint_32 save_flags=p->flags;
-   png_alloc_size_t num_bytes;
-
-   if (png_ptr == NULL)
-      return (NULL);
-   if (items > PNG_UINT_32_MAX/size)
-   {
-     png_warning (p, "Potential overflow in png_zalloc()");
-     return (NULL);
-   }
-   num_bytes = (png_alloc_size_t)items * size;
-
-   p->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
-   ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
-   p->flags=save_flags;
-
-   return ((voidpf)ptr);
-}
-
-/* Function to free memory for zlib */
-void /* PRIVATE */
-png_zfree(voidpf png_ptr, voidpf ptr)
-{
-   png_free((png_structp)png_ptr, (png_voidp)ptr);
-}
-
-/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
- * in case CRC is > 32 bits to leave the top bits 0.
- */
-void /* PRIVATE */
-png_reset_crc(png_structp png_ptr)
-{
-   png_ptr->crc = crc32(0, Z_NULL, 0);
-}
-
-/* Calculate the CRC over a section of data.  We can only pass as
- * much data to this routine as the largest single buffer size.  We
- * also check that this data will actually be used before going to the
- * trouble of calculating it.
- */
-void /* PRIVATE */
-png_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length)
-{
-   int need_crc = 1;
-
-   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
-   {
-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
-          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
-         need_crc = 0;
-   }
-   else                                                    /* critical */
-   {
-      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
-         need_crc = 0;
-   }
-
-   if (need_crc)
-      png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
-}
-
-/* Allocate the memory for an info_struct for the application.  We don't
- * really need the png_ptr, but it could potentially be useful in the
- * future.  This should be used in favour of malloc(png_sizeof(png_info))
- * and png_info_init() so that applications that want to use a shared
- * libpng don't have to be recompiled if png_info changes size.
- */
-png_infop PNGAPI
-png_create_info_struct(png_structp png_ptr)
-{
-   png_infop info_ptr;
-
-   png_debug(1, "in png_create_info_struct");
-
-   if (png_ptr == NULL)
-      return (NULL);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
-      png_ptr->malloc_fn, png_ptr->mem_ptr);
-#else
-   info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
-#endif
-   if (info_ptr != NULL)
-      png_info_init_3(&info_ptr, png_sizeof(png_info));
-
-   return (info_ptr);
-}
-
-/* This function frees the memory associated with a single info struct.
- * Normally, one would use either png_destroy_read_struct() or
- * png_destroy_write_struct() to free an info struct, but this may be
- * useful for some applications.
- */
-void PNGAPI
-png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
-{
-   png_infop info_ptr = NULL;
-
-   png_debug(1, "in png_destroy_info_struct");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (info_ptr_ptr != NULL)
-      info_ptr = *info_ptr_ptr;
-
-   if (info_ptr != NULL)
-   {
-      png_info_destroy(png_ptr, info_ptr);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn,
-          png_ptr->mem_ptr);
-#else
-      png_destroy_struct((png_voidp)info_ptr);
-#endif
-      *info_ptr_ptr = NULL;
-   }
-}
-
-/* Initialize the info structure.  This is now an internal function (0.89)
- * and applications using it are urged to use png_create_info_struct()
- * instead.
- */
-
-void PNGAPI
-png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
-{
-   png_infop info_ptr = *ptr_ptr;
-
-   png_debug(1, "in png_info_init_3");
-
-   if (info_ptr == NULL)
-      return;
-
-   if (png_sizeof(png_info) > png_info_struct_size)
-   {
-      png_destroy_struct(info_ptr);
-      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
-      *ptr_ptr = info_ptr;
-   }
-
-   /* Set everything to 0 */
-   png_memset(info_ptr, 0, png_sizeof(png_info));
-}
-
-void PNGAPI
-png_data_freer(png_structp png_ptr, png_infop info_ptr,
-   int freer, png_uint_32 mask)
-{
-   png_debug(1, "in png_data_freer");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (freer == PNG_DESTROY_WILL_FREE_DATA)
-      info_ptr->free_me |= mask;
-   else if (freer == PNG_USER_WILL_FREE_DATA)
-      info_ptr->free_me &= ~mask;
-   else
-      png_warning(png_ptr,
-         "Unknown freer parameter in png_data_freer");
-}
-
-void PNGAPI
-png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
-   int num)
-{
-   png_debug(1, "in png_free_data");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-#ifdef PNG_TEXT_SUPPORTED
-   /* Free text item num or (if num == -1) all text items */
-   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-         if (info_ptr->text && info_ptr->text[num].key)
-         {
-            png_free(png_ptr, info_ptr->text[num].key);
-            info_ptr->text[num].key = NULL;
-         }
-      }
-      else
-      {
-         int i;
-         for (i = 0; i < info_ptr->num_text; i++)
-             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
-         png_free(png_ptr, info_ptr->text);
-         info_ptr->text = NULL;
-         info_ptr->num_text=0;
-      }
-   }
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-   /* Free any tRNS entry */
-   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->trans_alpha);
-      info_ptr->trans_alpha = NULL;
-      info_ptr->valid &= ~PNG_INFO_tRNS;
-   }
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-   /* Free any sCAL entry */
-   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
-   {
-#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
-      png_free(png_ptr, info_ptr->scal_s_width);
-      png_free(png_ptr, info_ptr->scal_s_height);
-      info_ptr->scal_s_width = NULL;
-      info_ptr->scal_s_height = NULL;
-#endif
-      info_ptr->valid &= ~PNG_INFO_sCAL;
-   }
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-   /* Free any pCAL entry */
-   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->pcal_purpose);
-      png_free(png_ptr, info_ptr->pcal_units);
-      info_ptr->pcal_purpose = NULL;
-      info_ptr->pcal_units = NULL;
-      if (info_ptr->pcal_params != NULL)
-         {
-            int i;
-            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
-            {
-               png_free(png_ptr, info_ptr->pcal_params[i]);
-               info_ptr->pcal_params[i] = NULL;
-            }
-            png_free(png_ptr, info_ptr->pcal_params);
-            info_ptr->pcal_params = NULL;
-         }
-      info_ptr->valid &= ~PNG_INFO_pCAL;
-   }
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-   /* Free any iCCP entry */
-   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->iccp_name);
-      png_free(png_ptr, info_ptr->iccp_profile);
-      info_ptr->iccp_name = NULL;
-      info_ptr->iccp_profile = NULL;
-      info_ptr->valid &= ~PNG_INFO_iCCP;
-   }
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
-   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-         if (info_ptr->splt_palettes)
-         {
-            png_free(png_ptr, info_ptr->splt_palettes[num].name);
-            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
-            info_ptr->splt_palettes[num].name = NULL;
-            info_ptr->splt_palettes[num].entries = NULL;
-         }
-      }
-      else
-      {
-         if (info_ptr->splt_palettes_num)
-         {
-            int i;
-            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
-               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
-
-            png_free(png_ptr, info_ptr->splt_palettes);
-            info_ptr->splt_palettes = NULL;
-            info_ptr->splt_palettes_num = 0;
-         }
-         info_ptr->valid &= ~PNG_INFO_sPLT;
-      }
-   }
-#endif
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   if (png_ptr->unknown_chunk.data)
-   {
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-
-   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-          if (info_ptr->unknown_chunks)
-          {
-             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
-             info_ptr->unknown_chunks[num].data = NULL;
-          }
-      }
-      else
-      {
-         int i;
-
-         if (info_ptr->unknown_chunks_num)
-         {
-            for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
-               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
-
-            png_free(png_ptr, info_ptr->unknown_chunks);
-            info_ptr->unknown_chunks = NULL;
-            info_ptr->unknown_chunks_num = 0;
-         }
-      }
-   }
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-   /* Free any hIST entry */
-   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->hist);
-      info_ptr->hist = NULL;
-      info_ptr->valid &= ~PNG_INFO_hIST;
-   }
-#endif
-
-   /* Free any PLTE entry that was internally allocated */
-   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
-   {
-      png_zfree(png_ptr, info_ptr->palette);
-      info_ptr->palette = NULL;
-      info_ptr->valid &= ~PNG_INFO_PLTE;
-      info_ptr->num_palette = 0;
-   }
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-   /* Free any image bits attached to the info structure */
-   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
-   {
-      if (info_ptr->row_pointers)
-      {
-         int row;
-         for (row = 0; row < (int)info_ptr->height; row++)
-         {
-            png_free(png_ptr, info_ptr->row_pointers[row]);
-            info_ptr->row_pointers[row] = NULL;
-         }
-         png_free(png_ptr, info_ptr->row_pointers);
-         info_ptr->row_pointers = NULL;
-      }
-      info_ptr->valid &= ~PNG_INFO_IDAT;
-   }
-#endif
-
-   if (num == -1)
-      info_ptr->free_me &= ~mask;
-   else
-      info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
-}
-
-/* This is an internal routine to free any memory that the info struct is
- * pointing to before re-using it or freeing the struct itself.  Recall
- * that png_free() checks for NULL pointers for us.
- */
-void /* PRIVATE */
-png_info_destroy(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_info_destroy");
-
-   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-   if (png_ptr->num_chunk_list)
-   {
-      png_free(png_ptr, png_ptr->chunk_list);
-      png_ptr->chunk_list = NULL;
-      png_ptr->num_chunk_list = 0;
-   }
-#endif
-
-   png_info_init_3(&info_ptr, png_sizeof(png_info));
-}
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
-
-/* This function returns a pointer to the io_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy() or png_read_destroy() are called.
- */
-png_voidp PNGAPI
-png_get_io_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-   return (png_ptr->io_ptr);
-}
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#ifdef PNG_STDIO_SUPPORTED
-/* Initialize the default input/output functions for the PNG file.  If you
- * use your own read or write routines, you can call either png_set_read_fn()
- * or png_set_write_fn() instead of png_init_io().  If you have defined
- * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
- * necessarily available.
- */
-void PNGAPI
-png_init_io(png_structp png_ptr, png_FILE_p fp)
-{
-   png_debug(1, "in png_init_io");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->io_ptr = (png_voidp)fp;
-}
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-/* Convert the supplied time into an RFC 1123 string suitable for use in
- * a "Creation Time" or other text-based time string.
- */
-png_charp PNGAPI
-png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
-{
-   static PNG_CONST char short_months[12][4] =
-        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
-         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
-
-   if (png_ptr == NULL)
-      return (NULL);
-   if (png_ptr->time_buffer == NULL)
-   {
-      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
-         png_sizeof(char)));
-   }
-
-#ifdef USE_FAR_KEYWORD
-   {
-      char near_time_buf[29];
-      png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000",
-          ptime->day % 32, short_months[(ptime->month - 1) % 12],
-          ptime->year, ptime->hour % 24, ptime->minute % 60,
-          ptime->second % 61);
-      png_memcpy(png_ptr->time_buffer, near_time_buf,
-          29*png_sizeof(char));
-   }
-#else
-   png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000",
-       ptime->day % 32, short_months[(ptime->month - 1) % 12],
-       ptime->year, ptime->hour % 24, ptime->minute % 60,
-       ptime->second % 61);
-#endif
-   return ((png_charp)png_ptr->time_buffer);
-}
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
-
-png_charp PNGAPI
-png_get_copyright(png_structp png_ptr)
-{
-   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
-#ifdef PNG_STRING_COPYRIGHT
-      return PNG_STRING_COPYRIGHT
-#else
-#ifdef __STDC__
-   return ((png_charp) PNG_STRING_NEWLINE \
-     "libpng version 1.4.4 - September 23, 2010" PNG_STRING_NEWLINE \
-     "Copyright (c) 1998-2010 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
-     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
-     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
-     PNG_STRING_NEWLINE);
-#else
-      return ((png_charp) "libpng version 1.4.4 - September 23, 2010\
-      Copyright (c) 1998-2010 Glenn Randers-Pehrson\
-      Copyright (c) 1996-1997 Andreas Dilger\
-      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.");
-#endif
-#endif
-}
-
-/* The following return the library version as a short string in the
- * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
- * used with your application, print out PNG_LIBPNG_VER_STRING, which
- * is defined in png.h.
- * Note: now there is no difference between png_get_libpng_ver() and
- * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
- * it is guaranteed that png.c uses the correct version of png.h.
- */
-png_charp PNGAPI
-png_get_libpng_ver(png_structp png_ptr)
-{
-   /* Version of *.c files used when building libpng */
-   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
-   return ((png_charp) PNG_LIBPNG_VER_STRING);
-}
-
-png_charp PNGAPI
-png_get_header_ver(png_structp png_ptr)
-{
-   /* Version of *.h files used when building libpng */
-   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
-   return ((png_charp) PNG_LIBPNG_VER_STRING);
-}
-
-png_charp PNGAPI
-png_get_header_version(png_structp png_ptr)
-{
-   /* Returns longer string containing both version and date */
-   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
-#ifdef __STDC__
-   return ((png_charp) PNG_HEADER_VERSION_STRING
-#ifndef PNG_READ_SUPPORTED
-   "     (NO READ SUPPORT)"
-#endif
-   PNG_STRING_NEWLINE);
-#else
-   return ((png_charp) PNG_HEADER_VERSION_STRING);
-#endif
-}
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-int PNGAPI
-png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)
-{
-   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
-   int i;
-   png_bytep p;
-   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
-      return 0;
-   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;
-   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)
-      if (!png_memcmp(chunk_name, p, 4))
-        return ((int)*(p + 4));
-   return 0;
-}
-#endif
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
-
-#ifdef PNG_READ_SUPPORTED
-/* This function, added to libpng-1.0.6g, is untested. */
-int PNGAPI
-png_reset_zstream(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return Z_STREAM_ERROR;
-   return (inflateReset(&png_ptr->zstream));
-}
-#endif /* PNG_READ_SUPPORTED */
-
-/* This function was added to libpng-1.0.7 */
-png_uint_32 PNGAPI
-png_access_version_number(void)
-{
-   /* Version of *.c files used when building libpng */
-   return((png_uint_32) PNG_LIBPNG_VER);
-}
-
-
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#ifdef PNG_SIZE_T
-/* Added at libpng version 1.2.6 */
-   PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size));
-png_size_t PNGAPI
-png_convert_size(size_t size)
-{
-   if (size > (png_size_t)-1)
-      PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
-   return ((png_size_t)size);
-}
-#endif /* PNG_SIZE_T */
-
-/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-
-/*
- *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
- *    arithmetic, to produce a 64 bit result in the HI/LO words.
- *
- *                  A B
- *                x C D
- *               ------
- *              AD || BD
- *        AC || CB || 0
- *
- *    where A and B are the high and low 16-bit words of V1,
- *    C and D are the 16-bit words of V2, AD is the product of
- *    A and D, and X || Y is (X << 16) + Y.
-*/
-
-void /* PRIVATE */
-png_64bit_product (long v1, long v2, unsigned long *hi_product,
-   unsigned long *lo_product)
-{
-   int a, b, c, d;
-   long lo, hi, x, y;
-
-   a = (v1 >> 16) & 0xffff;
-   b = v1 & 0xffff;
-   c = (v2 >> 16) & 0xffff;
-   d = v2 & 0xffff;
-
-   lo = b * d;                   /* BD */
-   x = a * d + c * b;            /* AD + CB */
-   y = ((lo >> 16) & 0xffff) + x;
-
-   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
-   hi = (y >> 16) & 0xffff;
-
-   hi += a * c;                  /* AC */
-
-   *hi_product = (unsigned long)hi;
-   *lo_product = (unsigned long)lo;
-}
-
-int /* PRIVATE */
-png_check_cHRM_fixed(png_structp png_ptr,
-   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
-   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
-   png_fixed_point blue_x, png_fixed_point blue_y)
-{
-   int ret = 1;
-   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;
-
-   png_debug(1, "in function png_check_cHRM_fixed");
-
-   if (png_ptr == NULL)
-      return 0;
-
-   if (white_x < 0 || white_y <= 0 ||
-         red_x < 0 ||   red_y <  0 ||
-       green_x < 0 || green_y <  0 ||
-        blue_x < 0 ||  blue_y <  0)
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set negative chromaticity value");
-      ret = 0;
-   }
-   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
-       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
-         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
-         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
-       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
-       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
-        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
-        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set chromaticity value exceeding 21474.83");
-      ret = 0;
-   }
-   if (white_x > 100000L - white_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM white point");
-      ret = 0;
-   }
-   if (red_x > 100000L - red_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM red point");
-      ret = 0;
-   }
-   if (green_x > 100000L - green_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM green point");
-      ret = 0;
-   }
-   if (blue_x > 100000L - blue_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM blue point");
-      ret = 0;
-   }
-
-   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
-   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);
-
-   if (xy_hi == yx_hi && xy_lo == yx_lo)
-   {
-      png_warning(png_ptr,
-         "Ignoring attempt to set cHRM RGB triangle with zero area");
-      ret = 0;
-   }
-
-   return ret;
-}
-#endif /* PNG_CHECK_cHRM_SUPPORTED */
-#endif /* PNG_cHRM_SUPPORTED */
-
-void /* PRIVATE */
-png_check_IHDR(png_structp png_ptr,
-   png_uint_32 width, png_uint_32 height, int bit_depth,
-   int color_type, int interlace_type, int compression_type,
-   int filter_type)
-{
-   int error = 0;
-
-   /* Check for width and height valid values */
-   if (width == 0)
-   {
-      png_warning(png_ptr, "Image width is zero in IHDR");
-      error = 1;
-   }
-
-   if (height == 0)
-   {
-      png_warning(png_ptr, "Image height is zero in IHDR");
-      error = 1;
-   }
-
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (width > png_ptr->user_width_max || width > PNG_USER_WIDTH_MAX)
-#else
-   if (width > PNG_USER_WIDTH_MAX)
-#endif
-   {
-      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
-      error = 1;
-   }
-
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (height > png_ptr->user_height_max || height > PNG_USER_HEIGHT_MAX)
-#else
-   if (height > PNG_USER_HEIGHT_MAX)
-#endif
-   {
-      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
-      error = 1;
-   }
-
-   if (width > PNG_UINT_31_MAX)
-   {
-      png_warning(png_ptr, "Invalid image width in IHDR");
-      error = 1;
-   }
-
-   if ( height > PNG_UINT_31_MAX)
-   {
-      png_warning(png_ptr, "Invalid image height in IHDR");
-      error = 1;
-   }
-
-   if ( width > (PNG_UINT_32_MAX
-                 >> 3)      /* 8-byte RGBA pixels */
-                 - 64       /* bigrowbuf hack */
-                 - 1        /* filter byte */
-                 - 7*8      /* rounding of width to multiple of 8 pixels */
-                 - 8)       /* extra max_pixel_depth pad */
-      png_warning(png_ptr, "Width is too large for libpng to process pixels");
-
-   /* Check other values */
-   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
-       bit_depth != 8 && bit_depth != 16)
-   {
-      png_warning(png_ptr, "Invalid bit depth in IHDR");
-      error = 1;
-   }
-
-   if (color_type < 0 || color_type == 1 ||
-       color_type == 5 || color_type > 6)
-   {
-      png_warning(png_ptr, "Invalid color type in IHDR");
-      error = 1;
-   }
-
-   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
-       ((color_type == PNG_COLOR_TYPE_RGB ||
-         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
-   {
-      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
-      error = 1;
-   }
-
-   if (interlace_type >= PNG_INTERLACE_LAST)
-   {
-      png_warning(png_ptr, "Unknown interlace method in IHDR");
-      error = 1;
-   }
-
-   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Unknown compression method in IHDR");
-      error = 1;
-   }
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   /* Accept filter_method 64 (intrapixel differencing) only if
-    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
-    * 2. Libpng did not read a PNG signature (this filter_method is only
-    *    used in PNG datastreams that are embedded in MNG datastreams) and
-    * 3. The application called png_permit_mng_features with a mask that
-    *    included PNG_FLAG_MNG_FILTER_64 and
-    * 4. The filter_method is 64 and
-    * 5. The color_type is RGB or RGBA
-    */
-   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
-       png_ptr->mng_features_permitted)
-      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
-
-   if (filter_type != PNG_FILTER_TYPE_BASE)
-   {
-      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-         (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
-         ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
-         (color_type == PNG_COLOR_TYPE_RGB ||
-         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
-      {
-         png_warning(png_ptr, "Unknown filter method in IHDR");
-         error = 1;
-      }
-
-      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
-      {
-         png_warning(png_ptr, "Invalid filter method in IHDR");
-         error = 1;
-      }
-   }
-
-#else
-   if (filter_type != PNG_FILTER_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Unknown filter method in IHDR");
-      error = 1;
-   }
-#endif
-
-   if (error == 1)
-      png_error(png_ptr, "Invalid IHDR data");
-}
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
diff --git a/thirdparty/libpng/png.h b/thirdparty/libpng/png.h
deleted file mode 100644
index 805be12..0000000
--- a/thirdparty/libpng/png.h
+++ /dev/null
@@ -1,2699 +0,0 @@
-
-/* png.h - header file for PNG reference library
- *
- * libpng version 1.4.4 - September 23, 2010
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license (See LICENSE, below)
- *
- * Authors and maintainers:
- *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
- *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *  libpng versions 0.97, January 1998, through 1.4.4 - September 23, 2010: Glenn
- *  See also "Contributing Authors", below.
- *
- * Note about libpng version numbers:
- *
- *    Due to various miscommunications, unforeseen code incompatibilities
- *    and occasional factors outside the authors' control, version numbering
- *    on the library has not always been consistent and straightforward.
- *    The following table summarizes matters since version 0.89c, which was
- *    the first widely used release:
- *
- *    source                 png.h  png.h  shared-lib
- *    version                string   int  version
- *    -------                ------ -----  ----------
- *    0.89c "1.0 beta 3"     0.89      89  1.0.89
- *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
- *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
- *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
- *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
- *    0.97c                  0.97      97  2.0.97
- *    0.98                   0.98      98  2.0.98
- *    0.99                   0.99      98  2.0.99
- *    0.99a-m                0.99      99  2.0.99
- *    1.00                   1.00     100  2.1.0 [100 should be 10000]
- *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
- *    1.0.1       png.h string is   10001  2.1.0
- *    1.0.1a-e    identical to the  10002  from here on, the shared library
- *    1.0.2       source version)   10002  is 2.V where V is the source code
- *    1.0.2a-b                      10003  version, except as noted.
- *    1.0.3                         10003
- *    1.0.3a-d                      10004
- *    1.0.4                         10004
- *    1.0.4a-f                      10005
- *    1.0.5 (+ 2 patches)           10005
- *    1.0.5a-d                      10006
- *    1.0.5e-r                      10100 (not source compatible)
- *    1.0.5s-v                      10006 (not binary compatible)
- *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
- *    1.0.6d-f                      10007 (still binary incompatible)
- *    1.0.6g                        10007
- *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
- *    1.0.6i                        10007  10.6i
- *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
- *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
- *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
- *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
- *    1.0.7                    1    10007  (still compatible)
- *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4
- *    1.0.8rc1                 1    10008  2.1.0.8rc1
- *    1.0.8                    1    10008  2.1.0.8
- *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6
- *    1.0.9rc1                 1    10009  2.1.0.9rc1
- *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10
- *    1.0.9rc2                 1    10009  2.1.0.9rc2
- *    1.0.9                    1    10009  2.1.0.9
- *    1.0.10beta1              1    10010  2.1.0.10beta1
- *    1.0.10rc1                1    10010  2.1.0.10rc1
- *    1.0.10                   1    10010  2.1.0.10
- *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3
- *    1.0.11rc1                1    10011  2.1.0.11rc1
- *    1.0.11                   1    10011  2.1.0.11
- *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2
- *    1.0.12rc1                2    10012  2.1.0.12rc1
- *    1.0.12                   2    10012  2.1.0.12
- *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)
- *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2
- *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5
- *    1.2.0rc1                 3    10200  3.1.2.0rc1
- *    1.2.0                    3    10200  3.1.2.0
- *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4
- *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2
- *    1.2.1                    3    10201  3.1.2.1
- *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6
- *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1
- *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1
- *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1
- *    1.0.13                  10    10013  10.so.0.1.0.13
- *    1.2.2                   12    10202  12.so.0.1.2.2
- *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6
- *    1.2.3                   12    10203  12.so.0.1.2.3
- *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3
- *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1
- *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1
- *    1.0.14                  10    10014  10.so.0.1.0.14
- *    1.2.4                   13    10204  12.so.0.1.2.4
- *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2
- *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3
- *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3
- *    1.0.15                  10    10015  10.so.0.1.0.15
- *    1.2.5                   13    10205  12.so.0.1.2.5
- *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4
- *    1.0.16                  10    10016  10.so.0.1.0.16
- *    1.2.6                   13    10206  12.so.0.1.2.6
- *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2
- *    1.0.17rc1               10    10017  12.so.0.1.0.17rc1
- *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1
- *    1.0.17                  10    10017  12.so.0.1.0.17
- *    1.2.7                   13    10207  12.so.0.1.2.7
- *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5
- *    1.0.18rc1-5             10    10018  12.so.0.1.0.18rc1-5
- *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5
- *    1.0.18                  10    10018  12.so.0.1.0.18
- *    1.2.8                   13    10208  12.so.0.1.2.8
- *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3
- *    1.2.9beta4-11           13    10209  12.so.0.9[.0]
- *    1.2.9rc1                13    10209  12.so.0.9[.0]
- *    1.2.9                   13    10209  12.so.0.9[.0]
- *    1.2.10beta1-7           13    10210  12.so.0.10[.0]
- *    1.2.10rc1-2             13    10210  12.so.0.10[.0]
- *    1.2.10                  13    10210  12.so.0.10[.0]
- *    1.4.0beta1-5            14    10400  14.so.0.0[.0]
- *    1.2.11beta1-4           13    10211  12.so.0.11[.0]
- *    1.4.0beta7-8            14    10400  14.so.0.0[.0]
- *    1.2.11                  13    10211  12.so.0.11[.0]
- *    1.2.12                  13    10212  12.so.0.12[.0]
- *    1.4.0beta9-14           14    10400  14.so.0.0[.0]
- *    1.2.13                  13    10213  12.so.0.13[.0]
- *    1.4.0beta15-36          14    10400  14.so.0.0[.0]
- *    1.4.0beta37-87          14    10400  14.so.14.0[.0]
- *    1.4.0rc01               14    10400  14.so.14.0[.0]
- *    1.4.0beta88-109         14    10400  14.so.14.0[.0]
- *    1.4.0rc02-08            14    10400  14.so.14.0[.0]
- *    1.4.0                   14    10400  14.so.14.0[.0]
- *    1.4.1beta01-03          14    10401  14.so.14.1[.0]
- *    1.4.1rc01               14    10401  14.so.14.1[.0]
- *    1.4.1beta04-12          14    10401  14.so.14.1[.0]
- *    1.4.1rc02-04            14    10401  14.so.14.1[.0]
- *    1.4.1                   14    10401  14.so.14.1[.0]
- *    1.4.2beta01             14    10402  14.so.14.2[.0]
- *    1.4.2rc02-06            14    10402  14.so.14.2[.0]
- *    1.4.2                   14    10402  14.so.14.2[.0]
- *    1.4.3beta01-05          14    10403  14.so.14.3[.0]
- *    1.4.3rc01-03            14    10403  14.so.14.3[.0]
- *    1.4.3                   14    10403  14.so.14.3[.0]
- *    1.4.4beta01-08          14    10404  14.so.14.4[.0]
- *    1.4.4rc01-06            14    10404  14.so.14.4[.0]
- *
- *    Henceforth the source version will match the shared-library major
- *    and minor numbers; the shared-library major version number will be
- *    used for changes in backward compatibility, as it is intended.  The
- *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
- *    for applications, is an unsigned integer of the form xyyzz corresponding
- *    to the source version x.y.z (leading zeros in y and z).  Beta versions
- *    were given the previous public release number plus a letter, until
- *    version 1.0.6j; from then on they were given the upcoming public
- *    release number plus "betaNN" or "rcN".
- *
- *    Binary incompatibility exists only when applications make direct access
- *    to the info_ptr or png_ptr members through png.h, and the compiled
- *    application is loaded with a different version of the library.
- *
- *    DLLNUM will change each time there are forward or backward changes
- *    in binary compatibility (e.g., when a new feature is added).
- *
- * See libpng.txt or libpng.3 for more information.  The PNG specification
- * is available as a W3C Recommendation and as an ISO Specification,
- * <http://www.w3.org/TR/2003/REC-PNG-20031110/
- */
-
-/*
- * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
- *
- * If you modify libpng you may insert additional notices immediately following
- * this sentence.
- *
- * This code is released under the libpng license.
- *
- * libpng versions 1.2.6, August 15, 2004, through 1.4.4, September 23, 2010, are
- * Copyright (c) 2004, 2006-2010 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-1.2.5
- * with the following individual added to the list of Contributing Authors:
- *
- *    Cosmin Truta
- *
- * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are
- * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-1.0.6
- * with the following individuals added to the list of Contributing Authors:
- *
- *    Simon-Pierre Cadieux
- *    Eric S. Raymond
- *    Gilles Vollant
- *
- * and with the following additions to the disclaimer:
- *
- *    There is no warranty against interference with your enjoyment of the
- *    library or against infringement.  There is no warranty that our
- *    efforts or the library will fulfill any of your particular purposes
- *    or needs.  This library is provided with all faults, and the entire
- *    risk of satisfactory quality, performance, accuracy, and effort is with
- *    the user.
- *
- * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
- * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-0.96,
- * with the following individuals added to the list of Contributing Authors:
- *
- *    Tom Lane
- *    Glenn Randers-Pehrson
- *    Willem van Schaik
- *
- * libpng versions 0.89, June 1996, through 0.96, May 1997, are
- * Copyright (c) 1996, 1997 Andreas Dilger
- * Distributed according to the same disclaimer and license as libpng-0.88,
- * with the following individuals added to the list of Contributing Authors:
- *
- *    John Bowler
- *    Kevin Bracey
- *    Sam Bushell
- *    Magnus Holmgren
- *    Greg Roelofs
- *    Tom Tanner
- *
- * libpng versions 0.5, May 1995, through 0.88, January 1996, are
- * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
- *
- * For the purposes of this copyright and license, "Contributing Authors"
- * is defined as the following set of individuals:
- *
- *    Andreas Dilger
- *    Dave Martindale
- *    Guy Eric Schalnat
- *    Paul Schmidt
- *    Tim Wegner
- *
- * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
- * and Group 42, Inc. disclaim all warranties, expressed or implied,
- * including, without limitation, the warranties of merchantability and of
- * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
- * assume no liability for direct, indirect, incidental, special, exemplary,
- * or consequential damages, which may result from the use of the PNG
- * Reference Library, even if advised of the possibility of such damage.
- *
- * Permission is hereby granted to use, copy, modify, and distribute this
- * source code, or portions hereof, for any purpose, without fee, subject
- * to the following restrictions:
- *
- * 1. The origin of this source code must not be misrepresented.
- *
- * 2. Altered versions must be plainly marked as such and
- * must not be misrepresented as being the original source.
- *
- * 3. This Copyright notice may not be removed or altered from
- *    any source or altered source distribution.
- *
- * The Contributing Authors and Group 42, Inc. specifically permit, without
- * fee, and encourage the use of this source code as a component to
- * supporting the PNG file format in commercial products.  If you use this
- * source code in a product, acknowledgment is not required but would be
- * appreciated.
- */
-
-/*
- * A "png_get_copyright" function is available, for convenient use in "about"
- * boxes and the like:
- *
- *     printf("%s",png_get_copyright(NULL));
- *
- * Also, the PNG logo (in PNG format, of course) is supplied in the
- * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
- */
-
-/*
- * Libpng is OSI Certified Open Source Software.  OSI Certified is a
- * certification mark of the Open Source Initiative.
- */
-
-/*
- * The contributing authors would like to thank all those who helped
- * with testing, bug fixes, and patience.  This wouldn't have been
- * possible without all of you.
- *
- * Thanks to Frank J. T. Wojcik for helping with the documentation.
- */
-
-/*
- * Y2K compliance in libpng:
- * =========================
- *
- *    September 23, 2010
- *
- *    Since the PNG Development group is an ad-hoc body, we can't make
- *    an official declaration.
- *
- *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.4.4 are Y2K compliant.  It is my belief that earlier
- *    versions were also Y2K compliant.
- *
- *    Libpng only has three year fields.  One is a 2-byte unsigned integer
- *    that will hold years up to 65535.  The other two hold the date in text
- *    format, and will hold years up to 9999.
- *
- *    The integer is
- *        "png_uint_16 year" in png_time_struct.
- *
- *    The strings are
- *        "png_charp time_buffer" in png_struct and
- *        "near_time_buffer", which is a local character string in png.c.
- *
- *    There are seven time-related functions:
- *        png.c: png_convert_to_rfc_1123() in png.c
- *          (formerly png_convert_to_rfc_1152() in error)
- *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
- *        png_convert_from_time_t() in pngwrite.c
- *        png_get_tIME() in pngget.c
- *        png_handle_tIME() in pngrutil.c, called in pngread.c
- *        png_set_tIME() in pngset.c
- *        png_write_tIME() in pngwutil.c, called in pngwrite.c
- *
- *    All handle dates properly in a Y2K environment.  The
- *    png_convert_from_time_t() function calls gmtime() to convert from system
- *    clock time, which returns (year - 1900), which we properly convert to
- *    the full 4-digit year.  There is a possibility that applications using
- *    libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
- *    function, or that they are incorrectly passing only a 2-digit year
- *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
- *    but this is not under our control.  The libpng documentation has always
- *    stated that it works with 4-digit years, and the APIs have been
- *    documented as such.
- *
- *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
- *    integer to hold the year, and can hold years as large as 65535.
- *
- *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
- *    no date-related code.
- *
- *       Glenn Randers-Pehrson
- *       libpng maintainer
- *       PNG Development Group
- */
-
-#ifndef PNG_H
-#define PNG_H
-
-/* This is not the place to learn how to use libpng.  The file libpng.txt
- * describes how to use libpng, and the file example.c summarizes it
- * with some code on which to build.  This file is useful for looking
- * at the actual function definitions and structure components.
- */
-
-/* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.4.4"
-#define PNG_HEADER_VERSION_STRING \
-   " libpng version 1.4.4 - September 23, 2010\n"
-
-#define PNG_LIBPNG_VER_SONUM   14
-#define PNG_LIBPNG_VER_DLLNUM  14
-
-/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
-#define PNG_LIBPNG_VER_MAJOR   1
-#define PNG_LIBPNG_VER_MINOR   4
-#define PNG_LIBPNG_VER_RELEASE 4
-/* This should match the numeric part of the final component of
- * PNG_LIBPNG_VER_STRING, omitting any leading zero:
- */
-
-#define PNG_LIBPNG_VER_BUILD  0
-
-/* Release Status */
-#define PNG_LIBPNG_BUILD_ALPHA    1
-#define PNG_LIBPNG_BUILD_BETA     2
-#define PNG_LIBPNG_BUILD_RC       3
-#define PNG_LIBPNG_BUILD_STABLE   4
-#define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7
-
-/* Release-Specific Flags */
-#define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
-                                       PNG_LIBPNG_BUILD_STABLE only */
-#define PNG_LIBPNG_BUILD_PRIVATE 16 /* Cannot be OR'ed with
-                                       PNG_LIBPNG_BUILD_SPECIAL */
-#define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
-                                       PNG_LIBPNG_BUILD_PRIVATE */
-
-#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_BETA
-
-/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
- * We must not include leading zeros.
- * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
- * version 1.0.0 was mis-numbered 100 instead of 10000).  From
- * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
- */
-#define PNG_LIBPNG_VER 10404 /* 1.4.4 */
-
-#ifndef PNG_VERSION_INFO_ONLY
-/* Include the compression library's header */
-#include "zlib.h"
-#endif
-
-/* Include all user configurable info, including optional assembler routines */
-#include "pngconf.h"
-
-/*
- * Added at libpng-1.2.8
- *
- * Ref MSDN: Private as priority over Special
- * VS_FF_PRIVATEBUILD File *was not* built using standard release
- * procedures. If this value is given, the StringFileInfo block must
- * contain a PrivateBuild string.
- *
- * VS_FF_SPECIALBUILD File *was* built by the original company using
- * standard release procedures but is a variation of the standard
- * file of the same version number. If this value is given, the
- * StringFileInfo block must contain a SpecialBuild string.
- */
-
-#ifdef PNG_USER_PRIVATEBUILD
-#  define PNG_LIBPNG_BUILD_TYPE \
-          (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
-#else
-#  ifdef PNG_LIBPNG_SPECIALBUILD
-#    define PNG_LIBPNG_BUILD_TYPE \
-            (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
-#  else
-#    define PNG_LIBPNG_BUILD_TYPE (PNG_LIBPNG_BUILD_BASE_TYPE)
-#  endif
-#endif
-
-#ifndef PNG_VERSION_INFO_ONLY
-
-/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* This file is arranged in several sections.  The first section contains
- * structure and type definitions.  The second section contains the external
- * library functions, while the third has the internal library functions,
- * which applications aren't expected to use directly.
- */
-
-/* Variables declared in png.c - only it needs to define PNG_NO_EXTERN */
-#if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
-/* Version information for C files, stored in png.c.  This had better match
- * the version above.
- */
-#define png_libpng_ver png_get_header_ver(NULL)
-
-#endif /* PNG_NO_EXTERN */
-
-/* Three color definitions.  The order of the red, green, and blue, (and the
- * exact size) is not important, although the size of the fields need to
- * be png_byte or png_uint_16 (as defined below).
- */
-typedef struct png_color_struct
-{
-   png_byte red;
-   png_byte green;
-   png_byte blue;
-} png_color;
-typedef png_color FAR * png_colorp;
-typedef png_color FAR * FAR * png_colorpp;
-
-typedef struct png_color_16_struct
-{
-   png_byte index;    /* used for palette files */
-   png_uint_16 red;   /* for use in red green blue files */
-   png_uint_16 green;
-   png_uint_16 blue;
-   png_uint_16 gray;  /* for use in grayscale files */
-} png_color_16;
-typedef png_color_16 FAR * png_color_16p;
-typedef png_color_16 FAR * FAR * png_color_16pp;
-
-typedef struct png_color_8_struct
-{
-   png_byte red;   /* for use in red green blue files */
-   png_byte green;
-   png_byte blue;
-   png_byte gray;  /* for use in grayscale files */
-   png_byte alpha; /* for alpha channel files */
-} png_color_8;
-typedef png_color_8 FAR * png_color_8p;
-typedef png_color_8 FAR * FAR * png_color_8pp;
-
-/*
- * The following two structures are used for the in-core representation
- * of sPLT chunks.
- */
-typedef struct png_sPLT_entry_struct
-{
-   png_uint_16 red;
-   png_uint_16 green;
-   png_uint_16 blue;
-   png_uint_16 alpha;
-   png_uint_16 frequency;
-} png_sPLT_entry;
-typedef png_sPLT_entry FAR * png_sPLT_entryp;
-typedef png_sPLT_entry FAR * FAR * png_sPLT_entrypp;
-
-/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
- *  occupy the LSB of their respective members, and the MSB of each member
- *  is zero-filled.  The frequency member always occupies the full 16 bits.
- */
-
-typedef struct png_sPLT_struct
-{
-   png_charp name;           /* palette name */
-   png_byte depth;           /* depth of palette samples */
-   png_sPLT_entryp entries;  /* palette entries */
-   png_int_32 nentries;      /* number of palette entries */
-} png_sPLT_t;
-typedef png_sPLT_t FAR * png_sPLT_tp;
-typedef png_sPLT_t FAR * FAR * png_sPLT_tpp;
-
-#ifdef PNG_TEXT_SUPPORTED
-/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
- * and whether that contents is compressed or not.  The "key" field
- * points to a regular zero-terminated C string.  The "text", "lang", and
- * "lang_key" fields can be regular C strings, empty strings, or NULL pointers.
- * However, the * structure returned by png_get_text() will always contain
- * regular zero-terminated C strings (possibly empty), never NULL pointers,
- * so they can be safely used in printf() and other string-handling functions.
- */
-typedef struct png_text_struct
-{
-   int  compression;       /* compression value:
-                             -1: tEXt, none
-                              0: zTXt, deflate
-                              1: iTXt, none
-                              2: iTXt, deflate  */
-   png_charp key;          /* keyword, 1-79 character description of "text" */
-   png_charp text;         /* comment, may be an empty string (ie "")
-                              or a NULL pointer */
-   png_size_t text_length; /* length of the text string */
-#ifdef PNG_iTXt_SUPPORTED
-   png_size_t itxt_length; /* length of the itxt string */
-   png_charp lang;         /* language code, 0-79 characters
-                              or a NULL pointer */
-   png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
-                              chars or a NULL pointer */
-#endif
-} png_text;
-typedef png_text FAR * png_textp;
-typedef png_text FAR * FAR * png_textpp;
-#endif
-
-/* Supported compression types for text in PNG files (tEXt, and zTXt).
- * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
-#define PNG_TEXT_COMPRESSION_NONE_WR -3
-#define PNG_TEXT_COMPRESSION_zTXt_WR -2
-#define PNG_TEXT_COMPRESSION_NONE    -1
-#define PNG_TEXT_COMPRESSION_zTXt     0
-#define PNG_ITXT_COMPRESSION_NONE     1
-#define PNG_ITXT_COMPRESSION_zTXt     2
-#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */
-
-/* png_time is a way to hold the time in an machine independent way.
- * Two conversions are provided, both from time_t and struct tm.  There
- * is no portable way to convert to either of these structures, as far
- * as I know.  If you know of a portable way, send it to me.  As a side
- * note - PNG has always been Year 2000 compliant!
- */
-typedef struct png_time_struct
-{
-   png_uint_16 year; /* full year, as in, 1995 */
-   png_byte month;   /* month of year, 1 - 12 */
-   png_byte day;     /* day of month, 1 - 31 */
-   png_byte hour;    /* hour of day, 0 - 23 */
-   png_byte minute;  /* minute of hour, 0 - 59 */
-   png_byte second;  /* second of minute, 0 - 60 (for leap seconds) */
-} png_time;
-typedef png_time FAR * png_timep;
-typedef png_time FAR * FAR * png_timepp;
-
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) || \
- defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
-/* png_unknown_chunk is a structure to hold queued chunks for which there is
- * no specific support.  The idea is that we can use this to queue
- * up private chunks for output even though the library doesn't actually
- * know about their semantics.
- */
-typedef struct png_unknown_chunk_t
-{
-    png_byte name[5];
-    png_byte *data;
-    png_size_t size;
-
-    /* libpng-using applications should NOT directly modify this byte. */
-    png_byte location; /* mode of operation at read time */
-}
-png_unknown_chunk;
-typedef png_unknown_chunk FAR * png_unknown_chunkp;
-typedef png_unknown_chunk FAR * FAR * png_unknown_chunkpp;
-#endif
-
-/* png_info is a structure that holds the information in a PNG file so
- * that the application can find out the characteristics of the image.
- * If you are reading the file, this structure will tell you what is
- * in the PNG file.  If you are writing the file, fill in the information
- * you want to put into the PNG file, then call png_write_info().
- * The names chosen should be very close to the PNG specification, so
- * consult that document for information about the meaning of each field.
- *
- * With libpng < 0.95, it was only possible to directly set and read the
- * the values in the png_info_struct, which meant that the contents and
- * order of the values had to remain fixed.  With libpng 0.95 and later,
- * however, there are now functions that abstract the contents of
- * png_info_struct from the application, so this makes it easier to use
- * libpng with dynamic libraries, and even makes it possible to use
- * libraries that don't have all of the libpng ancillary chunk-handing
- * functionality.
- *
- * In any case, the order of the parameters in png_info_struct should NOT
- * be changed for as long as possible to keep compatibility with applications
- * that use the old direct-access method with png_info_struct.
- *
- * The following members may have allocated storage attached that should be
- * cleaned up before the structure is discarded: palette, trans, text,
- * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,
- * splt_palettes, scal_unit, row_pointers, and unknowns.   By default, these
- * are automatically freed when the info structure is deallocated, if they were
- * allocated internally by libpng.  This behavior can be changed by means
- * of the png_data_freer() function.
- *
- * More allocation details: all the chunk-reading functions that
- * change these members go through the corresponding png_set_*
- * functions.  A function to clear these members is available: see
- * png_free_data().  The png_set_* functions do not depend on being
- * able to point info structure members to any of the storage they are
- * passed (they make their own copies), EXCEPT that the png_set_text
- * functions use the same storage passed to them in the text_ptr or
- * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns
- * functions do not make their own copies.
- */
-typedef struct png_info_struct
-{
-   /* the following are necessary for every PNG file */
-   png_uint_32 width PNG_DEPSTRUCT;  /* width of image in pixels (from IHDR) */
-   png_uint_32 height PNG_DEPSTRUCT; /* height of image in pixels (from IHDR) */
-   png_uint_32 valid PNG_DEPSTRUCT;  /* valid chunk data (see PNG_INFO_
-                                        below) */
-   png_size_t rowbytes PNG_DEPSTRUCT; /* bytes needed to hold an untransformed
-                                         row */
-   png_colorp palette PNG_DEPSTRUCT;      /* array of color values
-                                             (valid & PNG_INFO_PLTE) */
-   png_uint_16 num_palette PNG_DEPSTRUCT; /* number of color entries in
-                                             "palette" (PLTE) */
-   png_uint_16 num_trans PNG_DEPSTRUCT;   /* number of transparent palette
-                                             color (tRNS) */
-   png_byte bit_depth PNG_DEPSTRUCT;      /* 1, 2, 4, 8, or 16 bits/channel
-                                             (from IHDR) */
-   png_byte color_type PNG_DEPSTRUCT;     /* see PNG_COLOR_TYPE_ below
-                                             (from IHDR) */
-   /* The following three should have been named *_method not *_type */
-   png_byte compression_type PNG_DEPSTRUCT; /* must be
-                                             PNG_COMPRESSION_TYPE_BASE (IHDR) */
-   png_byte filter_type PNG_DEPSTRUCT;    /* must be PNG_FILTER_TYPE_BASE
-                                             (from IHDR) */
-   png_byte interlace_type PNG_DEPSTRUCT; /* One of PNG_INTERLACE_NONE,
-                                             PNG_INTERLACE_ADAM7 */
-
-   /* The following is informational only on read, and not used on writes. */
-   png_byte channels PNG_DEPSTRUCT;       /* number of data channels per
-                                             pixel (1, 2, 3, 4) */
-   png_byte pixel_depth PNG_DEPSTRUCT;    /* number of bits per pixel */
-   png_byte spare_byte PNG_DEPSTRUCT;     /* to align the data, and for
-                                             future use */
-   png_byte signature[8] PNG_DEPSTRUCT;   /* magic bytes read by libpng
-                                             from start of file */
-
-   /* The rest of the data is optional.  If you are reading, check the
-    * valid field to see if the information in these are valid.  If you
-    * are writing, set the valid field to those chunks you want written,
-    * and initialize the appropriate fields below.
-    */
-
-#if defined(PNG_gAMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
-   /* The gAMA chunk describes the gamma characteristics of the system
-    * on which the image was created, normally in the range [1.0, 2.5].
-    * Data is valid if (valid & PNG_INFO_gAMA) is non-zero.
-    */
-   float gamma PNG_DEPSTRUCT; /* gamma value of image,
-                                 if (valid & PNG_INFO_gAMA) */
-#endif
-
-#ifdef PNG_sRGB_SUPPORTED
-    /* GR-P, 0.96a */
-    /* Data valid if (valid & PNG_INFO_sRGB) non-zero. */
-   png_byte srgb_intent PNG_DEPSTRUCT; /* sRGB rendering intent
-                                          [0, 1, 2, or 3] */
-#endif
-
-#ifdef PNG_TEXT_SUPPORTED
-   /* The tEXt, and zTXt chunks contain human-readable textual data in
-    * uncompressed, compressed, and optionally compressed forms, respectively.
-    * The data in "text" is an array of pointers to uncompressed,
-    * null-terminated C strings. Each chunk has a keyword that describes the
-    * textual data contained in that chunk.  Keywords are not required to be
-    * unique, and the text string may be empty.  Any number of text chunks may
-    * be in an image.
-    */
-   int num_text PNG_DEPSTRUCT; /* number of comments read/to write */
-   int max_text PNG_DEPSTRUCT; /* current size of text array */
-   png_textp text PNG_DEPSTRUCT; /* array of comments read/to write */
-#endif /* PNG_TEXT_SUPPORTED */
-
-#ifdef PNG_tIME_SUPPORTED
-   /* The tIME chunk holds the last time the displayed image data was
-    * modified.  See the png_time struct for the contents of this struct.
-    */
-   png_time mod_time PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_sBIT_SUPPORTED
-   /* The sBIT chunk specifies the number of significant high-order bits
-    * in the pixel data.  Values are in the range [1, bit_depth], and are
-    * only specified for the channels in the pixel data.  The contents of
-    * the low-order bits is not specified.  Data is valid if
-    * (valid & PNG_INFO_sBIT) is non-zero.
-    */
-   png_color_8 sig_bit PNG_DEPSTRUCT; /* significant bits in color channels */
-#endif
-
-#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_EXPAND_SUPPORTED) || \
-defined(PNG_READ_BACKGROUND_SUPPORTED)
-   /* The tRNS chunk supplies transparency data for paletted images and
-    * other image types that don't need a full alpha channel.  There are
-    * "num_trans" transparency values for a paletted image, stored in the
-    * same order as the palette colors, starting from index 0.  Values
-    * for the data are in the range [0, 255], ranging from fully transparent
-    * to fully opaque, respectively.  For non-paletted images, there is a
-    * single color specified that should be treated as fully transparent.
-    * Data is valid if (valid & PNG_INFO_tRNS) is non-zero.
-    */
-   png_bytep trans_alpha PNG_DEPSTRUCT;    /* alpha values for paletted
-                                              image */
-   png_color_16 trans_color PNG_DEPSTRUCT; /* transparent color for
-                                              non-palette image */
-#endif
-
-#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   /* The bKGD chunk gives the suggested image background color if the
-    * display program does not have its own background color and the image
-    * is needs to composited onto a background before display.  The colors
-    * in "background" are normally in the same color space/depth as the
-    * pixel data.  Data is valid if (valid & PNG_INFO_bKGD) is non-zero.
-    */
-   png_color_16 background PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_oFFs_SUPPORTED
-   /* The oFFs chunk gives the offset in "offset_unit_type" units rightwards
-    * and downwards from the top-left corner of the display, page, or other
-    * application-specific co-ordinate space.  See the PNG_OFFSET_ defines
-    * below for the unit types.  Valid if (valid & PNG_INFO_oFFs) non-zero.
-    */
-   png_int_32 x_offset PNG_DEPSTRUCT; /* x offset on page */
-   png_int_32 y_offset PNG_DEPSTRUCT; /* y offset on page */
-   png_byte offset_unit_type PNG_DEPSTRUCT; /* offset units type */
-#endif
-
-#ifdef PNG_pHYs_SUPPORTED
-   /* The pHYs chunk gives the physical pixel density of the image for
-    * display or printing in "phys_unit_type" units (see PNG_RESOLUTION_
-    * defines below).  Data is valid if (valid & PNG_INFO_pHYs) is non-zero.
-    */
-   png_uint_32 x_pixels_per_unit PNG_DEPSTRUCT; /* horizontal pixel density */
-   png_uint_32 y_pixels_per_unit PNG_DEPSTRUCT; /* vertical pixel density */
-   png_byte phys_unit_type PNG_DEPSTRUCT; /* resolution type (see
-                                             PNG_RESOLUTION_ below) */
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-   /* The hIST chunk contains the relative frequency or importance of the
-    * various palette entries, so that a viewer can intelligently select a
-    * reduced-color palette, if required.  Data is an array of "num_palette"
-    * values in the range [0,65535]. Data valid if (valid & PNG_INFO_hIST)
-    * is non-zero.
-    */
-   png_uint_16p hist PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-   /* The cHRM chunk describes the CIE color characteristics of the monitor
-    * on which the PNG was created.  This data allows the viewer to do gamut
-    * mapping of the input image to ensure that the viewer sees the same
-    * colors in the image as the creator.  Values are in the range
-    * [0.0, 0.8].  Data valid if (valid & PNG_INFO_cHRM) non-zero.
-    */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float x_white PNG_DEPSTRUCT;
-   float y_white PNG_DEPSTRUCT;
-   float x_red PNG_DEPSTRUCT;
-   float y_red PNG_DEPSTRUCT;
-   float x_green PNG_DEPSTRUCT;
-   float y_green PNG_DEPSTRUCT;
-   float x_blue PNG_DEPSTRUCT;
-   float y_blue PNG_DEPSTRUCT;
-#endif
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-   /* The pCAL chunk describes a transformation between the stored pixel
-    * values and original physical data values used to create the image.
-    * The integer range [0, 2^bit_depth - 1] maps to the floating-point
-    * range given by [pcal_X0, pcal_X1], and are further transformed by a
-    * (possibly non-linear) transformation function given by "pcal_type"
-    * and "pcal_params" into "pcal_units".  Please see the PNG_EQUATION_
-    * defines below, and the PNG-Group's PNG extensions document for a
-    * complete description of the transformations and how they should be
-    * implemented, and for a description of the ASCII parameter strings.
-    * Data values are valid if (valid & PNG_INFO_pCAL) non-zero.
-    */
-   png_charp pcal_purpose PNG_DEPSTRUCT;  /* pCAL chunk description string */
-   png_int_32 pcal_X0 PNG_DEPSTRUCT;      /* minimum value */
-   png_int_32 pcal_X1 PNG_DEPSTRUCT;      /* maximum value */
-   png_charp pcal_units PNG_DEPSTRUCT;    /* Latin-1 string giving physical
-                                             units */
-   png_charpp pcal_params PNG_DEPSTRUCT;  /* ASCII strings containing
-                                             parameter values */
-   png_byte pcal_type PNG_DEPSTRUCT;      /* equation type
-                                             (see PNG_EQUATION_ below) */
-   png_byte pcal_nparams PNG_DEPSTRUCT;   /* number of parameters given
-                                             in pcal_params */
-#endif
-
-/* New members added in libpng-1.0.6 */
-   png_uint_32 free_me PNG_DEPSTRUCT;     /* flags items libpng is
-                                             responsible for freeing */
-
-#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) || \
- defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
-   /* Storage for unknown chunks that the library doesn't recognize. */
-   png_unknown_chunkp unknown_chunks PNG_DEPSTRUCT;
-   png_size_t unknown_chunks_num PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-   /* iCCP chunk data. */
-   png_charp iccp_name PNG_DEPSTRUCT;     /* profile name */
-   png_charp iccp_profile PNG_DEPSTRUCT;  /* International Color Consortium
-                                             profile data */
-                            /* Note to maintainer: should be png_bytep */
-   png_uint_32 iccp_proflen PNG_DEPSTRUCT;  /* ICC profile data length */
-   png_byte iccp_compression PNG_DEPSTRUCT; /* Always zero */
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-   /* Data on sPLT chunks (there may be more than one). */
-   png_sPLT_tp splt_palettes PNG_DEPSTRUCT;
-   png_uint_32 splt_palettes_num PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-   /* The sCAL chunk describes the actual physical dimensions of the
-    * subject matter of the graphic.  The chunk contains a unit specification
-    * a byte value, and two ASCII strings representing floating-point
-    * values.  The values are width and height corresponsing to one pixel
-    * in the image.  This external representation is converted to double
-    * here.  Data values are valid if (valid & PNG_INFO_sCAL) is non-zero.
-    */
-   png_byte scal_unit PNG_DEPSTRUCT;         /* unit of physical scale */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   double scal_pixel_width PNG_DEPSTRUCT;    /* width of one pixel */
-   double scal_pixel_height PNG_DEPSTRUCT;   /* height of one pixel */
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_charp scal_s_width PNG_DEPSTRUCT;     /* string containing height */
-   png_charp scal_s_height PNG_DEPSTRUCT;    /* string containing width */
-#endif
-#endif
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-   /* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS)
-      non-zero */
-   /* Data valid if (valid & PNG_INFO_IDAT) non-zero */
-   png_bytepp row_pointers PNG_DEPSTRUCT;        /* the image bits */
-#endif
-
-#if defined(PNG_FIXED_POINT_SUPPORTED) && defined(PNG_gAMA_SUPPORTED)
-   png_fixed_point int_gamma PNG_DEPSTRUCT; /* gamma of image,
-                                               if (valid & PNG_INFO_gAMA) */
-#endif
-
-#if defined(PNG_cHRM_SUPPORTED) && defined(PNG_FIXED_POINT_SUPPORTED)
-   png_fixed_point int_x_white PNG_DEPSTRUCT;
-   png_fixed_point int_y_white PNG_DEPSTRUCT;
-   png_fixed_point int_x_red PNG_DEPSTRUCT;
-   png_fixed_point int_y_red PNG_DEPSTRUCT;
-   png_fixed_point int_x_green PNG_DEPSTRUCT;
-   png_fixed_point int_y_green PNG_DEPSTRUCT;
-   png_fixed_point int_x_blue PNG_DEPSTRUCT;
-   png_fixed_point int_y_blue PNG_DEPSTRUCT;
-#endif
-
-} png_info;
-
-typedef png_info FAR * png_infop;
-typedef png_info FAR * FAR * png_infopp;
-
-/* Maximum positive integer used in PNG is (2^31)-1 */
-#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
-#define PNG_UINT_32_MAX ((png_uint_32)(-1))
-#define PNG_SIZE_MAX ((png_size_t)(-1))
-
-/* These describe the color_type field in png_info. */
-/* color type masks */
-#define PNG_COLOR_MASK_PALETTE    1
-#define PNG_COLOR_MASK_COLOR      2
-#define PNG_COLOR_MASK_ALPHA      4
-
-/* color types.  Note that not all combinations are legal */
-#define PNG_COLOR_TYPE_GRAY 0
-#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
-#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
-#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
-#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
-/* aliases */
-#define PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
-#define PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA
-
-/* This is for compression type. PNG 1.0-1.2 only define the single type. */
-#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
-#define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE
-
-/* This is for filter type. PNG 1.0-1.2 only define the single type. */
-#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
-#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
-#define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE
-
-/* These are for the interlacing type.  These values should NOT be changed. */
-#define PNG_INTERLACE_NONE        0 /* Non-interlaced image */
-#define PNG_INTERLACE_ADAM7       1 /* Adam7 interlacing */
-#define PNG_INTERLACE_LAST        2 /* Not a valid value */
-
-/* These are for the oFFs chunk.  These values should NOT be changed. */
-#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
-#define PNG_OFFSET_MICROMETER     1 /* Offset in micrometers (1/10^6 meter) */
-#define PNG_OFFSET_LAST           2 /* Not a valid value */
-
-/* These are for the pCAL chunk.  These values should NOT be changed. */
-#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
-#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
-#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
-#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
-#define PNG_EQUATION_LAST         4 /* Not a valid value */
-
-/* These are for the sCAL chunk.  These values should NOT be changed. */
-#define PNG_SCALE_UNKNOWN         0 /* unknown unit (image scale) */
-#define PNG_SCALE_METER           1 /* meters per pixel */
-#define PNG_SCALE_RADIAN          2 /* radians per pixel */
-#define PNG_SCALE_LAST            3 /* Not a valid value */
-
-/* These are for the pHYs chunk.  These values should NOT be changed. */
-#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
-#define PNG_RESOLUTION_METER      1 /* pixels/meter */
-#define PNG_RESOLUTION_LAST       2 /* Not a valid value */
-
-/* These are for the sRGB chunk.  These values should NOT be changed. */
-#define PNG_sRGB_INTENT_PERCEPTUAL 0
-#define PNG_sRGB_INTENT_RELATIVE   1
-#define PNG_sRGB_INTENT_SATURATION 2
-#define PNG_sRGB_INTENT_ABSOLUTE   3
-#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */
-
-/* This is for text chunks */
-#define PNG_KEYWORD_MAX_LENGTH     79
-
-/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
-#define PNG_MAX_PALETTE_LENGTH    256
-
-/* These determine if an ancillary chunk's data has been successfully read
- * from the PNG header, or if the application has filled in the corresponding
- * data in the info_struct to be written into the output file.  The values
- * of the PNG_INFO_<chunk> defines should NOT be changed.
- */
-#define PNG_INFO_gAMA 0x0001
-#define PNG_INFO_sBIT 0x0002
-#define PNG_INFO_cHRM 0x0004
-#define PNG_INFO_PLTE 0x0008
-#define PNG_INFO_tRNS 0x0010
-#define PNG_INFO_bKGD 0x0020
-#define PNG_INFO_hIST 0x0040
-#define PNG_INFO_pHYs 0x0080
-#define PNG_INFO_oFFs 0x0100
-#define PNG_INFO_tIME 0x0200
-#define PNG_INFO_pCAL 0x0400
-#define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
-#define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
-#define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
-#define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
-#define PNG_INFO_IDAT 0x8000L  /* ESR, 1.0.6 */
-
-/* This is used for the transformation routines, as some of them
- * change these values for the row.  It also should enable using
- * the routines for other purposes.
- */
-typedef struct png_row_info_struct
-{
-   png_uint_32 width; /* width of row */
-   png_size_t rowbytes; /* number of bytes in row */
-   png_byte color_type; /* color type of row */
-   png_byte bit_depth; /* bit depth of row */
-   png_byte channels; /* number of channels (1, 2, 3, or 4) */
-   png_byte pixel_depth; /* bits per pixel (depth * channels) */
-} png_row_info;
-
-typedef png_row_info FAR * png_row_infop;
-typedef png_row_info FAR * FAR * png_row_infopp;
-
-/* These are the function types for the I/O functions and for the functions
- * that allow the user to override the default I/O functions with his or her
- * own.  The png_error_ptr type should match that of user-supplied warning
- * and error functions, while the png_rw_ptr type should match that of the
- * user read/write data functions.
- */
-typedef struct png_struct_def png_struct;
-typedef png_struct FAR * png_structp;
-
-typedef void (PNGAPI *png_error_ptr) PNGARG((png_structp, png_const_charp));
-typedef void (PNGAPI *png_rw_ptr) PNGARG((png_structp, png_bytep, png_size_t));
-typedef void (PNGAPI *png_flush_ptr) PNGARG((png_structp));
-typedef void (PNGAPI *png_read_status_ptr) PNGARG((png_structp, png_uint_32,
-   int));
-typedef void (PNGAPI *png_write_status_ptr) PNGARG((png_structp, png_uint_32,
-   int));
-
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-typedef void (PNGAPI *png_progressive_info_ptr) PNGARG((png_structp,
-   png_infop));
-typedef void (PNGAPI *png_progressive_end_ptr) PNGARG((png_structp, png_infop));
-typedef void (PNGAPI *png_progressive_row_ptr) PNGARG((png_structp, png_bytep,
-   png_uint_32, int));
-#endif
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-typedef void (PNGAPI *png_user_transform_ptr) PNGARG((png_structp,
-    png_row_infop, png_bytep));
-#endif
-
-#ifdef PNG_USER_CHUNKS_SUPPORTED
-typedef int (PNGAPI *png_user_chunk_ptr) PNGARG((png_structp,
-   png_unknown_chunkp));
-#endif
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-typedef void (PNGAPI *png_unknown_chunk_ptr) PNGARG((png_structp));
-#endif
-#ifdef PNG_SETJMP_SUPPORTED
-/* This must match the function definition in <setjmp.h>, and the
- * application must include this before png.h to obtain the definition
- * of jmp_buf.
- */
-typedef void (PNGAPI *png_longjmp_ptr) PNGARG((jmp_buf, int));
-#endif
-
-/* Transform masks for the high-level interface */
-#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
-#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
-#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
-#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
-#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
-#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
-#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
-#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
-#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
-#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
-#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
-#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
-#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
-/* Added to libpng-1.2.34 */
-#define PNG_TRANSFORM_STRIP_FILLER_BEFORE PNG_TRANSFORM_STRIP_FILLER
-#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
-/* Added to libpng-1.4.0 */
-#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
-
-/* Flags for MNG supported features */
-#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
-#define PNG_FLAG_MNG_FILTER_64      0x04
-#define PNG_ALL_MNG_FEATURES        0x05
-
-typedef png_voidp (*png_malloc_ptr) PNGARG((png_structp, png_alloc_size_t));
-typedef void (*png_free_ptr) PNGARG((png_structp, png_voidp));
-
-/* The structure that holds the information to read and write PNG files.
- * The only people who need to care about what is inside of this are the
- * people who will be modifying the library for their own special needs.
- * It should NOT be accessed directly by an application, except to store
- * the jmp_buf.
- */
-
-struct png_struct_def
-{
-#ifdef PNG_SETJMP_SUPPORTED
-   jmp_buf jmpbuf PNG_DEPSTRUCT;            /* used in png_error */
-   png_longjmp_ptr longjmp_fn PNG_DEPSTRUCT;/* setjmp non-local goto
-                                               function. */
-#endif
-   png_error_ptr error_fn PNG_DEPSTRUCT;    /* function for printing
-                                               errors and aborting */
-   png_error_ptr warning_fn PNG_DEPSTRUCT;  /* function for printing
-                                               warnings */
-   png_voidp error_ptr PNG_DEPSTRUCT;       /* user supplied struct for
-                                               error functions */
-   png_rw_ptr write_data_fn PNG_DEPSTRUCT;  /* function for writing
-                                               output data */
-   png_rw_ptr read_data_fn PNG_DEPSTRUCT;   /* function for reading
-                                               input data */
-   png_voidp io_ptr PNG_DEPSTRUCT;          /* ptr to application struct
-                                               for I/O functions */
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   png_user_transform_ptr read_user_transform_fn PNG_DEPSTRUCT; /* user read
-                                                                 transform */
-#endif
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-   png_user_transform_ptr write_user_transform_fn PNG_DEPSTRUCT; /* user write
-                                                                  transform */
-#endif
-
-/* These were added in libpng-1.0.2 */
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-   png_voidp user_transform_ptr PNG_DEPSTRUCT; /* user supplied struct
-                                                  for user transform */
-   png_byte user_transform_depth PNG_DEPSTRUCT;    /* bit depth of user
-                                                      transformed pixels */
-   png_byte user_transform_channels PNG_DEPSTRUCT; /* channels in user
-                                                      transformed pixels */
-#endif
-#endif
-
-   png_uint_32 mode PNG_DEPSTRUCT;          /* tells us where we are in
-                                               the PNG file */
-   png_uint_32 flags PNG_DEPSTRUCT;         /* flags indicating various
-                                               things to libpng */
-   png_uint_32 transformations PNG_DEPSTRUCT; /* which transformations
-                                                 to perform */
-
-   z_stream zstream PNG_DEPSTRUCT;          /* pointer to decompression
-                                               structure (below) */
-   png_bytep zbuf PNG_DEPSTRUCT;            /* buffer for zlib */
-   png_size_t zbuf_size PNG_DEPSTRUCT;      /* size of zbuf */
-   int zlib_level PNG_DEPSTRUCT;            /* holds zlib compression level */
-   int zlib_method PNG_DEPSTRUCT;           /* holds zlib compression method */
-   int zlib_window_bits PNG_DEPSTRUCT;      /* holds zlib compression window
-                                               bits */
-   int zlib_mem_level PNG_DEPSTRUCT;        /* holds zlib compression memory
-                                               level */
-   int zlib_strategy PNG_DEPSTRUCT;         /* holds zlib compression
-                                               strategy */
-
-   png_uint_32 width PNG_DEPSTRUCT;         /* width of image in pixels */
-   png_uint_32 height PNG_DEPSTRUCT;        /* height of image in pixels */
-   png_uint_32 num_rows PNG_DEPSTRUCT;      /* number of rows in current pass */
-   png_uint_32 usr_width PNG_DEPSTRUCT;     /* width of row at start of write */
-   png_size_t rowbytes PNG_DEPSTRUCT;       /* size of row in bytes */
-#if 0 /* Replaced with the following in libpng-1.4.1 */
-   png_size_t irowbytes PNG_DEPSTRUCT;
-#endif
-/* Added in libpng-1.4.1 */
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   /* Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk
-    * can occupy when decompressed.  0 means unlimited.
-    * We will change the typedef from png_size_t to png_alloc_size_t
-    * in libpng-1.6.0
-    */
-   png_alloc_size_t user_chunk_malloc_max PNG_DEPSTRUCT;
-#endif
-   png_uint_32 iwidth PNG_DEPSTRUCT;        /* width of current interlaced
-                                               row in pixels */
-   png_uint_32 row_number PNG_DEPSTRUCT;    /* current row in interlace pass */
-   png_bytep prev_row PNG_DEPSTRUCT;        /* buffer to save previous
-                                               (unfiltered) row */
-   png_bytep row_buf PNG_DEPSTRUCT;         /* buffer to save current
-                                               (unfiltered) row */
-   png_bytep sub_row PNG_DEPSTRUCT;         /* buffer to save "sub" row
-                                               when filtering */
-   png_bytep up_row PNG_DEPSTRUCT;          /* buffer to save "up" row
-                                               when filtering */
-   png_bytep avg_row PNG_DEPSTRUCT;         /* buffer to save "avg" row
-                                               when filtering */
-   png_bytep paeth_row PNG_DEPSTRUCT;       /* buffer to save "Paeth" row
-                                               when filtering */
-   png_row_info row_info PNG_DEPSTRUCT;     /* used for transformation
-                                               routines */
-
-   png_uint_32 idat_size PNG_DEPSTRUCT;     /* current IDAT size for read */
-   png_uint_32 crc PNG_DEPSTRUCT;           /* current chunk CRC value */
-   png_colorp palette PNG_DEPSTRUCT;        /* palette from the input file */
-   png_uint_16 num_palette PNG_DEPSTRUCT;   /* number of color entries in
-                                               palette */
-   png_uint_16 num_trans PNG_DEPSTRUCT;     /* number of transparency values */
-   png_byte chunk_name[5] PNG_DEPSTRUCT;    /* null-terminated name of current
-                                               chunk */
-   png_byte compression PNG_DEPSTRUCT;      /* file compression type
-                                               (always 0) */
-   png_byte filter PNG_DEPSTRUCT;           /* file filter type (always 0) */
-   png_byte interlaced PNG_DEPSTRUCT;       /* PNG_INTERLACE_NONE,
-                                               PNG_INTERLACE_ADAM7 */
-   png_byte pass PNG_DEPSTRUCT;             /* current interlace pass (0 - 6) */
-   png_byte do_filter PNG_DEPSTRUCT;        /* row filter flags (see
-                                               PNG_FILTER_ below ) */
-   png_byte color_type PNG_DEPSTRUCT;       /* color type of file */
-   png_byte bit_depth PNG_DEPSTRUCT;        /* bit depth of file */
-   png_byte usr_bit_depth PNG_DEPSTRUCT;    /* bit depth of users row */
-   png_byte pixel_depth PNG_DEPSTRUCT;      /* number of bits per pixel */
-   png_byte channels PNG_DEPSTRUCT;         /* number of channels in file */
-   png_byte usr_channels PNG_DEPSTRUCT;     /* channels at start of write */
-   png_byte sig_bytes PNG_DEPSTRUCT;        /* magic bytes read/written from
-                                               start of file */
-
-#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
-   png_uint_16 filler PNG_DEPSTRUCT;           /* filler bytes for pixel
-                                                  expansion */
-#endif
-
-#ifdef PNG_bKGD_SUPPORTED
-   png_byte background_gamma_type PNG_DEPSTRUCT;
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-   float background_gamma PNG_DEPSTRUCT;
-#  endif
-   png_color_16 background PNG_DEPSTRUCT;   /* background color in
-                                               screen gamma space */
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   png_color_16 background_1 PNG_DEPSTRUCT; /* background normalized
-                                               to gamma 1.0 */
-#endif
-#endif /* PNG_bKGD_SUPPORTED */
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-   png_flush_ptr output_flush_fn PNG_DEPSTRUCT; /* Function for flushing
-                                               output */
-   png_uint_32 flush_dist PNG_DEPSTRUCT;    /* how many rows apart to flush,
-                                               0 - no flush */
-   png_uint_32 flush_rows PNG_DEPSTRUCT;    /* number of rows written since
-                                               last flush */
-#endif
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   int gamma_shift PNG_DEPSTRUCT;      /* number of "insignificant" bits
-                                          16-bit gamma */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float gamma PNG_DEPSTRUCT;          /* file gamma value */
-   float screen_gamma PNG_DEPSTRUCT;   /* screen gamma value
-                                          (display_exponent) */
-#endif
-#endif
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_bytep gamma_table PNG_DEPSTRUCT;     /* gamma table for 8-bit
-                                               depth files */
-   png_bytep gamma_from_1 PNG_DEPSTRUCT;    /* converts from 1.0 to screen */
-   png_bytep gamma_to_1 PNG_DEPSTRUCT;      /* converts from file to 1.0 */
-   png_uint_16pp gamma_16_table PNG_DEPSTRUCT; /* gamma table for 16-bit
-                                                  depth files */
-   png_uint_16pp gamma_16_from_1 PNG_DEPSTRUCT; /* converts from 1.0 to
-                                                   screen */
-   png_uint_16pp gamma_16_to_1 PNG_DEPSTRUCT; /* converts from file to 1.0 */
-#endif
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
-   png_color_8 sig_bit PNG_DEPSTRUCT;       /* significant bits in each
-                                               available channel */
-#endif
-
-#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-   png_color_8 shift PNG_DEPSTRUCT;         /* shift for significant bit
-                                               tranformation */
-#endif
-
-#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
- || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_bytep trans_alpha PNG_DEPSTRUCT;           /* alpha values for
-                                                     paletted files */
-   png_color_16 trans_color PNG_DEPSTRUCT;  /* transparent color for
-                                               non-paletted files */
-#endif
-
-   png_read_status_ptr read_row_fn PNG_DEPSTRUCT;   /* called after each
-                                                       row is decoded */
-   png_write_status_ptr write_row_fn PNG_DEPSTRUCT; /* called after each
-                                                       row is encoded */
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-   png_progressive_info_ptr info_fn PNG_DEPSTRUCT; /* called after header
-                                                      data fully read */
-   png_progressive_row_ptr row_fn PNG_DEPSTRUCT;   /* called after each
-                                                      prog. row is decoded */
-   png_progressive_end_ptr end_fn PNG_DEPSTRUCT;   /* called after image
-                                                      is complete */
-   png_bytep save_buffer_ptr PNG_DEPSTRUCT;        /* current location in
-                                                      save_buffer */
-   png_bytep save_buffer PNG_DEPSTRUCT;            /* buffer for previously
-                                                      read data */
-   png_bytep current_buffer_ptr PNG_DEPSTRUCT;     /* current location in
-                                                      current_buffer */
-   png_bytep current_buffer PNG_DEPSTRUCT;         /* buffer for recently
-                                                      used data */
-   png_uint_32 push_length PNG_DEPSTRUCT;          /* size of current input
-                                                      chunk */
-   png_uint_32 skip_length PNG_DEPSTRUCT;          /* bytes to skip in
-                                                      input data */
-   png_size_t save_buffer_size PNG_DEPSTRUCT;      /* amount of data now
-                                                      in save_buffer */
-   png_size_t save_buffer_max PNG_DEPSTRUCT;       /* total size of
-                                                      save_buffer */
-   png_size_t buffer_size PNG_DEPSTRUCT;           /* total amount of
-                                                      available input data */
-   png_size_t current_buffer_size PNG_DEPSTRUCT;   /* amount of data now
-                                                      in current_buffer */
-   int process_mode PNG_DEPSTRUCT;                 /* what push library
-                                                      is currently doing */
-   int cur_palette PNG_DEPSTRUCT;                  /* current push library
-                                                      palette index */
-
-#  ifdef PNG_TEXT_SUPPORTED
-     png_size_t current_text_size PNG_DEPSTRUCT;   /* current size of
-                                                      text input data */
-     png_size_t current_text_left PNG_DEPSTRUCT;   /* how much text left
-                                                      to read in input */
-     png_charp current_text PNG_DEPSTRUCT;         /* current text chunk
-                                                      buffer */
-     png_charp current_text_ptr PNG_DEPSTRUCT;     /* current location
-                                                      in current_text */
-#  endif /* PNG_PROGRESSIVE_READ_SUPPORTED && PNG_TEXT_SUPPORTED */
-
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
-#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
-/* For the Borland special 64K segment handler */
-   png_bytepp offset_table_ptr PNG_DEPSTRUCT;
-   png_bytep offset_table PNG_DEPSTRUCT;
-   png_uint_16 offset_table_number PNG_DEPSTRUCT;
-   png_uint_16 offset_table_count PNG_DEPSTRUCT;
-   png_uint_16 offset_table_count_free PNG_DEPSTRUCT;
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   png_bytep palette_lookup PNG_DEPSTRUCT; /* lookup table for quantizing */
-   png_bytep quantize_index PNG_DEPSTRUCT; /* index translation for palette
-                                              files */
-#endif
-
-#if defined(PNG_READ_QUANTIZE_SUPPORTED) || defined(PNG_hIST_SUPPORTED)
-   png_uint_16p hist PNG_DEPSTRUCT;                /* histogram */
-#endif
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_byte heuristic_method PNG_DEPSTRUCT;        /* heuristic for row
-                                                      filter selection */
-   png_byte num_prev_filters PNG_DEPSTRUCT;        /* number of weights
-                                                      for previous rows */
-   png_bytep prev_filters PNG_DEPSTRUCT;           /* filter type(s) of
-                                                      previous row(s) */
-   png_uint_16p filter_weights PNG_DEPSTRUCT;      /* weight(s) for previous
-                                                      line(s) */
-   png_uint_16p inv_filter_weights PNG_DEPSTRUCT;  /* 1/weight(s) for
-                                                      previous line(s) */
-   png_uint_16p filter_costs PNG_DEPSTRUCT;        /* relative filter
-                                                      calculation cost */
-   png_uint_16p inv_filter_costs PNG_DEPSTRUCT;    /* 1/relative filter
-                                                      calculation cost */
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_charp time_buffer PNG_DEPSTRUCT; /* String to hold RFC 1123 time text */
-#endif
-
-/* New members added in libpng-1.0.6 */
-
-   png_uint_32 free_me PNG_DEPSTRUCT;    /* flags items libpng is
-                                            responsible for freeing */
-
-#ifdef PNG_USER_CHUNKS_SUPPORTED
-   png_voidp user_chunk_ptr PNG_DEPSTRUCT;
-   png_user_chunk_ptr read_user_chunk_fn PNG_DEPSTRUCT; /* user read
-                                                           chunk handler */
-#endif
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-   int num_chunk_list PNG_DEPSTRUCT;
-   png_bytep chunk_list PNG_DEPSTRUCT;
-#endif
-
-/* New members added in libpng-1.0.3 */
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-   png_byte rgb_to_gray_status PNG_DEPSTRUCT;
-   /* These were changed from png_byte in libpng-1.0.6 */
-   png_uint_16 rgb_to_gray_red_coeff PNG_DEPSTRUCT;
-   png_uint_16 rgb_to_gray_green_coeff PNG_DEPSTRUCT;
-   png_uint_16 rgb_to_gray_blue_coeff PNG_DEPSTRUCT;
-#endif
-
-/* New member added in libpng-1.0.4 (renamed in 1.0.9) */
-#if defined(PNG_MNG_FEATURES_SUPPORTED) || \
-    defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
-    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
-/* Changed from png_byte to png_uint_32 at version 1.2.0 */
-   png_uint_32 mng_features_permitted PNG_DEPSTRUCT;
-#endif
-
-/* New member added in libpng-1.0.7 */
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   png_fixed_point int_gamma PNG_DEPSTRUCT;
-#endif
-
-/* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   png_byte filter_type PNG_DEPSTRUCT;
-#endif
-
-/* New members added in libpng-1.2.0 */
-
-/* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_voidp mem_ptr PNG_DEPSTRUCT;             /* user supplied struct for
-                                                   mem functions */
-   png_malloc_ptr malloc_fn PNG_DEPSTRUCT;      /* function for
-                                                   allocating memory */
-   png_free_ptr free_fn PNG_DEPSTRUCT;          /* function for
-                                                   freeing memory */
-#endif
-
-/* New member added in libpng-1.0.13 and 1.2.0 */
-   png_bytep big_row_buf PNG_DEPSTRUCT;         /* buffer to save current
-                                                   (unfiltered) row */
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-/* The following three members were added at version 1.0.14 and 1.2.4 */
-   png_bytep quantize_sort PNG_DEPSTRUCT;          /* working sort array */
-   png_bytep index_to_palette PNG_DEPSTRUCT;       /* where the original
-                                                     index currently is
-                                                     in the palette */
-   png_bytep palette_to_index PNG_DEPSTRUCT;       /* which original index
-                                                      points to this
-                                                      palette color */
-#endif
-
-/* New members added in libpng-1.0.16 and 1.2.6 */
-   png_byte compression_type PNG_DEPSTRUCT;
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   png_uint_32 user_width_max PNG_DEPSTRUCT;
-   png_uint_32 user_height_max PNG_DEPSTRUCT;
-   /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
-    * chunks that can be stored (0 means unlimited).
-    */
-   png_uint_32 user_chunk_cache_max PNG_DEPSTRUCT;
-#endif
-
-/* New member added in libpng-1.0.25 and 1.2.17 */
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   /* Storage for unknown chunk that the library doesn't recognize. */
-   png_unknown_chunk unknown_chunk PNG_DEPSTRUCT;
-#endif
-
-/* New members added in libpng-1.2.26 */
-  png_uint_32 old_big_row_buf_size PNG_DEPSTRUCT;
-  png_uint_32 old_prev_row_size PNG_DEPSTRUCT;
-
-/* New member added in libpng-1.2.30 */
-  png_charp chunkdata PNG_DEPSTRUCT;  /* buffer for reading chunk data */
-
-#ifdef PNG_IO_STATE_SUPPORTED
-/* New member added in libpng-1.4.0 */
-   png_uint_32 io_state PNG_DEPSTRUCT;
-#endif
-};
-
-
-/* This triggers a compiler error in png.c, if png.c and png.h
- * do not agree upon the version number.
- */
-typedef png_structp version_1_4_4;
-
-typedef png_struct FAR * FAR * png_structpp;
-
-/* Here are the function definitions most commonly used.  This is not
- * the place to find out how to use libpng.  See libpng.txt for the
- * full explanation, see example.c for the summary.  This just provides
- * a simple one line description of the use of each function.
- */
-
-/* Returns the version number of the library */
-PNG_EXPORT(png_uint_32,png_access_version_number) PNGARG((void));
-
-/* Tell lib we have already handled the first <num_bytes> magic bytes.
- * Handling more than 8 bytes from the beginning of the file is an error.
- */
-PNG_EXPORT(void,png_set_sig_bytes) PNGARG((png_structp png_ptr,
-   int num_bytes));
-
-/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
- * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
- * signature, and non-zero otherwise.  Having num_to_check == 0 or
- * start > 7 will always fail (ie return non-zero).
- */
-PNG_EXPORT(int,png_sig_cmp) PNGARG((png_bytep sig, png_size_t start,
-   png_size_t num_to_check));
-
-/* Simple signature checking function.  This is the same as calling
- * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
- */
-#define png_check_sig(sig,n) !png_sig_cmp((sig), 0, (n))
-
-/* Allocate and initialize png_ptr struct for reading, and any other memory. */
-PNG_EXPORT(png_structp,png_create_read_struct)
-   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn)) PNG_ALLOCATED;
-
-/* Allocate and initialize png_ptr struct for writing, and any other memory */
-PNG_EXPORT(png_structp,png_create_write_struct)
-   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn)) PNG_ALLOCATED;
-
-PNG_EXPORT(png_size_t,png_get_compression_buffer_size)
-   PNGARG((png_structp png_ptr));
-
-PNG_EXPORT(void,png_set_compression_buffer_size)
-   PNGARG((png_structp png_ptr, png_size_t size));
-
-/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
- * match up.
- */
-#ifdef PNG_SETJMP_SUPPORTED
-/* This function returns the jmp_buf built in to *png_ptr.  It must be
- * supplied with an appropriate 'longjmp' function to use on that jmp_buf
- * unless the default error function is overridden in which case NULL is
- * acceptable.  The size of the jmp_buf is checked against the actual size
- * allocated by the library - the call will return NULL on a mismatch
- * indicating an ABI mismatch.
- */
-PNG_EXPORT(jmp_buf*, png_set_longjmp_fn)
-   PNGARG((png_structp png_ptr, png_longjmp_ptr longjmp_fn, size_t
-       jmp_buf_size));
-#  define png_jmpbuf(png_ptr) \
-   (*png_set_longjmp_fn((png_ptr), longjmp, sizeof (jmp_buf)))
-#else
-#  define png_jmpbuf(png_ptr) \
-   (LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
-#endif
-
-#ifdef PNG_READ_SUPPORTED
-/* Reset the compression stream */
-PNG_EXPORT(int,png_reset_zstream) PNGARG((png_structp png_ptr));
-#endif
-
-/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
-#ifdef PNG_USER_MEM_SUPPORTED
-PNG_EXPORT(png_structp,png_create_read_struct_2)
-   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn)) PNG_ALLOCATED;
-PNG_EXPORT(png_structp,png_create_write_struct_2)
-   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn)) PNG_ALLOCATED;
-#endif
-
-/* Write the PNG file signature. */
-PNG_EXPORT(void,png_write_sig) PNGARG((png_structp png_ptr));
-
-/* Write a PNG chunk - size, type, (optional) data, CRC. */
-PNG_EXPORT(void,png_write_chunk) PNGARG((png_structp png_ptr,
-   png_bytep chunk_name, png_bytep data, png_size_t length));
-
-/* Write the start of a PNG chunk - length and chunk name. */
-PNG_EXPORT(void,png_write_chunk_start) PNGARG((png_structp png_ptr,
-   png_bytep chunk_name, png_uint_32 length));
-
-/* Write the data of a PNG chunk started with png_write_chunk_start(). */
-PNG_EXPORT(void,png_write_chunk_data) PNGARG((png_structp png_ptr,
-   png_bytep data, png_size_t length));
-
-/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
-PNG_EXPORT(void,png_write_chunk_end) PNGARG((png_structp png_ptr));
-
-/* Allocate and initialize the info structure */
-PNG_EXPORT(png_infop,png_create_info_struct)
-   PNGARG((png_structp png_ptr)) PNG_ALLOCATED;
-
-PNG_EXPORT(void,png_info_init_3) PNGARG((png_infopp info_ptr,
-    png_size_t png_info_struct_size));
-
-/* Writes all the PNG information before the image. */
-PNG_EXPORT(void,png_write_info_before_PLTE) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXPORT(void,png_write_info) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the information before the actual image data. */
-PNG_EXPORT(void,png_read_info) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-PNG_EXPORT(png_charp,png_convert_to_rfc1123)
-   PNGARG((png_structp png_ptr, png_timep ptime));
-#endif
-
-#ifdef PNG_CONVERT_tIME_SUPPORTED
-/* Convert from a struct tm to png_time */
-PNG_EXPORT(void,png_convert_from_struct_tm) PNGARG((png_timep ptime,
-   struct tm FAR * ttime));
-
-/* Convert from time_t to png_time.  Uses gmtime() */
-PNG_EXPORT(void,png_convert_from_time_t) PNGARG((png_timep ptime,
-   time_t ttime));
-#endif /* PNG_CONVERT_tIME_SUPPORTED */
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
-PNG_EXPORT(void,png_set_expand) PNGARG((png_structp png_ptr));
-PNG_EXPORT(void,png_set_expand_gray_1_2_4_to_8) PNGARG((png_structp
-  png_ptr));
-PNG_EXPORT(void,png_set_palette_to_rgb) PNGARG((png_structp png_ptr));
-PNG_EXPORT(void,png_set_tRNS_to_alpha) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* Use blue, green, red order for pixels. */
-PNG_EXPORT(void,png_set_bgr) PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-/* Expand the grayscale to 24-bit RGB if necessary. */
-PNG_EXPORT(void,png_set_gray_to_rgb) PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-/* Reduce RGB to grayscale. */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_rgb_to_gray) PNGARG((png_structp png_ptr,
-   int error_action, double red, double green ));
-#endif
-PNG_EXPORT(void,png_set_rgb_to_gray_fixed) PNGARG((png_structp png_ptr,
-   int error_action, png_fixed_point red, png_fixed_point green ));
-PNG_EXPORT(png_byte,png_get_rgb_to_gray_status) PNGARG((png_structp
-   png_ptr));
-#endif
-
-PNG_EXPORT(void,png_build_grayscale_palette) PNGARG((int bit_depth,
-   png_colorp palette));
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-PNG_EXPORT(void,png_set_strip_alpha) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
-PNG_EXPORT(void,png_set_swap_alpha) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
-PNG_EXPORT(void,png_set_invert_alpha) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
-/* Add a filler byte to 8-bit Gray or 24-bit RGB images. */
-PNG_EXPORT(void,png_set_filler) PNGARG((png_structp png_ptr,
-   png_uint_32 filler, int flags));
-/* The values of the PNG_FILLER_ defines should NOT be changed */
-#define PNG_FILLER_BEFORE 0
-#define PNG_FILLER_AFTER 1
-/* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */
-PNG_EXPORT(void,png_set_add_alpha) PNGARG((png_structp png_ptr,
-   png_uint_32 filler, int flags));
-#endif /* PNG_READ_FILLER_SUPPORTED || PNG_WRITE_FILLER_SUPPORTED */
-
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* Swap bytes in 16-bit depth files. */
-PNG_EXPORT(void,png_set_swap) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
-/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
-PNG_EXPORT(void,png_set_packing) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
-    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-/* Swap packing order of pixels in bytes. */
-PNG_EXPORT(void,png_set_packswap) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-/* Converts files to legal bit depths. */
-PNG_EXPORT(void,png_set_shift) PNGARG((png_structp png_ptr,
-   png_color_8p true_bits));
-#endif
-
-#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
-    defined(PNG_WRITE_INTERLACING_SUPPORTED)
-/* Have the code handle the interlacing.  Returns the number of passes. */
-PNG_EXPORT(int,png_set_interlace_handling) PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
-/* Invert monochrome files */
-PNG_EXPORT(void,png_set_invert_mono) PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-/* Handle alpha and tRNS by replacing with a background color. */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_background) PNGARG((png_structp png_ptr,
-   png_color_16p background_color, int background_gamma_code,
-   int need_expand, double background_gamma));
-#endif
-#define PNG_BACKGROUND_GAMMA_UNKNOWN 0
-#define PNG_BACKGROUND_GAMMA_SCREEN  1
-#define PNG_BACKGROUND_GAMMA_FILE    2
-#define PNG_BACKGROUND_GAMMA_UNIQUE  3
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-/* Strip the second byte of information from a 16-bit depth file. */
-PNG_EXPORT(void,png_set_strip_16) PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-/* Turn on quantizing, and reduce the palette to the number of colors
- * available.  Prior to libpng-1.4.2, this was png_set_dither().
- */
-PNG_EXPORT(void,png_set_quantize) PNGARG((png_structp png_ptr,
-   png_colorp palette, int num_palette, int maximum_colors,
-   png_uint_16p histogram, int full_quantize));
-#endif
-/* This migration aid will be removed from libpng-1.5.0 */
-#define png_set_dither png_set_quantize
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-/* Handle gamma correction. Screen_gamma=(display_exponent) */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_gamma) PNGARG((png_structp png_ptr,
-   double screen_gamma, double default_file_gamma));
-#endif
-#endif
-
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-/* Set how many lines between output flushes - 0 for no flushing */
-PNG_EXPORT(void,png_set_flush) PNGARG((png_structp png_ptr, int nrows));
-/* Flush the current PNG output buffer */
-PNG_EXPORT(void,png_write_flush) PNGARG((png_structp png_ptr));
-#endif
-
-/* Optional update palette with requested transformations */
-PNG_EXPORT(void,png_start_read_image) PNGARG((png_structp png_ptr));
-
-/* Optional call to update the users info structure */
-PNG_EXPORT(void,png_read_update_info) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read one or more rows of image data. */
-PNG_EXPORT(void,png_read_rows) PNGARG((png_structp png_ptr,
-   png_bytepp row, png_bytepp display_row, png_uint_32 num_rows));
-#endif
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read a row of data. */
-PNG_EXPORT(void,png_read_row) PNGARG((png_structp png_ptr,
-   png_bytep row,
-   png_bytep display_row));
-#endif
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the whole image into memory at once. */
-PNG_EXPORT(void,png_read_image) PNGARG((png_structp png_ptr,
-   png_bytepp image));
-#endif
-
-/* Write a row of image data */
-PNG_EXPORT(void,png_write_row) PNGARG((png_structp png_ptr,
-   png_bytep row));
-
-/* Write a few rows of image data */
-PNG_EXPORT(void,png_write_rows) PNGARG((png_structp png_ptr,
-   png_bytepp row, png_uint_32 num_rows));
-
-/* Write the image data */
-PNG_EXPORT(void,png_write_image) PNGARG((png_structp png_ptr,
-   png_bytepp image));
-
-/* Write the end of the PNG file. */
-PNG_EXPORT(void,png_write_end) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the end of the PNG file. */
-PNG_EXPORT(void,png_read_end) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-
-/* Free any memory associated with the png_info_struct */
-PNG_EXPORT(void,png_destroy_info_struct) PNGARG((png_structp png_ptr,
-   png_infopp info_ptr_ptr));
-
-/* Free any memory associated with the png_struct and the png_info_structs */
-PNG_EXPORT(void,png_destroy_read_struct) PNGARG((png_structpp
-   png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));
-
-/* Free any memory associated with the png_struct and the png_info_structs */
-PNG_EXPORT(void,png_destroy_write_struct)
-   PNGARG((png_structpp png_ptr_ptr, png_infopp info_ptr_ptr));
-
-/* Set the libpng method of handling chunk CRC errors */
-PNG_EXPORT(void,png_set_crc_action) PNGARG((png_structp png_ptr,
-   int crit_action, int ancil_action));
-
-/* Values for png_set_crc_action() to say how to handle CRC errors in
- * ancillary and critical chunks, and whether to use the data contained
- * therein.  Note that it is impossible to "discard" data in a critical
- * chunk.  For versions prior to 0.90, the action was always error/quit,
- * whereas in version 0.90 and later, the action for CRC errors in ancillary
- * chunks is warn/discard.  These values should NOT be changed.
- *
- *      value                       action:critical     action:ancillary
- */
-#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
-#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
-#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
-#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
-#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
-#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */
-
-/* These functions give the user control over the scan-line filtering in
- * libpng and the compression methods used by zlib.  These functions are
- * mainly useful for testing, as the defaults should work with most users.
- * Those users who are tight on memory or want faster performance at the
- * expense of compression can modify them.  See the compression library
- * header file (zlib.h) for an explination of the compression functions.
- */
-
-/* Set the filtering method(s) used by libpng.  Currently, the only valid
- * value for "method" is 0.
- */
-PNG_EXPORT(void,png_set_filter) PNGARG((png_structp png_ptr, int method,
-   int filters));
-
-/* Flags for png_set_filter() to say which filters to use.  The flags
- * are chosen so that they don't conflict with real filter types
- * below, in case they are supplied instead of the #defined constants.
- * These values should NOT be changed.
- */
-#define PNG_NO_FILTERS     0x00
-#define PNG_FILTER_NONE    0x08
-#define PNG_FILTER_SUB     0x10
-#define PNG_FILTER_UP      0x20
-#define PNG_FILTER_AVG     0x40
-#define PNG_FILTER_PAETH   0x80
-#define PNG_ALL_FILTERS (PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP | \
-                         PNG_FILTER_AVG | PNG_FILTER_PAETH)
-
-/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
- * These defines should NOT be changed.
- */
-#define PNG_FILTER_VALUE_NONE  0
-#define PNG_FILTER_VALUE_SUB   1
-#define PNG_FILTER_VALUE_UP    2
-#define PNG_FILTER_VALUE_AVG   3
-#define PNG_FILTER_VALUE_PAETH 4
-#define PNG_FILTER_VALUE_LAST  5
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* EXPERIMENTAL */
-/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_
- * defines, either the default (minimum-sum-of-absolute-differences), or
- * the experimental method (weighted-minimum-sum-of-absolute-differences).
- *
- * Weights are factors >= 1.0, indicating how important it is to keep the
- * filter type consistent between rows.  Larger numbers mean the current
- * filter is that many times as likely to be the same as the "num_weights"
- * previous filters.  This is cumulative for each previous row with a weight.
- * There needs to be "num_weights" values in "filter_weights", or it can be
- * NULL if the weights aren't being specified.  Weights have no influence on
- * the selection of the first row filter.  Well chosen weights can (in theory)
- * improve the compression for a given image.
- *
- * Costs are factors >= 1.0 indicating the relative decoding costs of a
- * filter type.  Higher costs indicate more decoding expense, and are
- * therefore less likely to be selected over a filter with lower computational
- * costs.  There needs to be a value in "filter_costs" for each valid filter
- * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't
- * setting the costs.  Costs try to improve the speed of decompression without
- * unduly increasing the compressed image size.
- *
- * A negative weight or cost indicates the default value is to be used, and
- * values in the range [0.0, 1.0) indicate the value is to remain unchanged.
- * The default values for both weights and costs are currently 1.0, but may
- * change if good general weighting/cost heuristics can be found.  If both
- * the weights and costs are set to 1.0, this degenerates the WEIGHTED method
- * to the UNWEIGHTED method, but with added encoding time/computation.
- */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_filter_heuristics) PNGARG((png_structp png_ptr,
-   int heuristic_method, int num_weights, png_doublep filter_weights,
-   png_doublep filter_costs));
-#endif
-#endif /*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
-
-/* Heuristic used for row filter selection.  These defines should NOT be
- * changed.
- */
-#define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
-#define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
-#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
-#define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */
-
-/* Set the library compression level.  Currently, valid values range from
- * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
- * (0 - no compression, 9 - "maximal" compression).  Note that tests have
- * shown that zlib compression levels 3-6 usually perform as well as level 9
- * for PNG images, and do considerably fewer caclulations.  In the future,
- * these values may not correspond directly to the zlib compression levels.
- */
-PNG_EXPORT(void,png_set_compression_level) PNGARG((png_structp png_ptr,
-   int level));
-
-PNG_EXPORT(void,png_set_compression_mem_level)
-   PNGARG((png_structp png_ptr, int mem_level));
-
-PNG_EXPORT(void,png_set_compression_strategy)
-   PNGARG((png_structp png_ptr, int strategy));
-
-PNG_EXPORT(void,png_set_compression_window_bits)
-   PNGARG((png_structp png_ptr, int window_bits));
-
-PNG_EXPORT(void,png_set_compression_method) PNGARG((png_structp png_ptr,
-   int method));
-
-/* These next functions are called for input/output, memory, and error
- * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
- * and call standard C I/O routines such as fread(), fwrite(), and
- * fprintf().  These functions can be made to use other I/O routines
- * at run time for those applications that need to handle I/O in a
- * different manner by calling png_set_???_fn().  See libpng.txt for
- * more information.
- */
-
-#ifdef PNG_STDIO_SUPPORTED
-/* Initialize the input/output for the PNG file to the default functions. */
-PNG_EXPORT(void,png_init_io) PNGARG((png_structp png_ptr,
-    png_FILE_p fp));
-#endif
-
-/* Replace the (error and abort), and warning functions with user
- * supplied functions.  If no messages are to be printed you must still
- * write and use replacement functions. The replacement error_fn should
- * still do a longjmp to the last setjmp location if you are using this
- * method of error handling.  If error_fn or warning_fn is NULL, the
- * default function will be used.
- */
-
-PNG_EXPORT(void,png_set_error_fn) PNGARG((png_structp png_ptr,
-   png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn));
-
-/* Return the user pointer associated with the error functions */
-PNG_EXPORT(png_voidp,png_get_error_ptr) PNGARG((png_structp png_ptr));
-
-/* Replace the default data output functions with a user supplied one(s).
- * If buffered output is not used, then output_flush_fn can be set to NULL.
- * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
- * output_flush_fn will be ignored (and thus can be NULL).
- * It is probably a mistake to use NULL for output_flush_fn if
- * write_data_fn is not also NULL unless you have built libpng with
- * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
- * default flush function, which uses the standard *FILE structure, will
- * be used.
- */
-PNG_EXPORT(void,png_set_write_fn) PNGARG((png_structp png_ptr,
-   png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));
-
-/* Replace the default data input function with a user supplied one. */
-PNG_EXPORT(void,png_set_read_fn) PNGARG((png_structp png_ptr,
-   png_voidp io_ptr, png_rw_ptr read_data_fn));
-
-/* Return the user pointer associated with the I/O functions */
-PNG_EXPORT(png_voidp,png_get_io_ptr) PNGARG((png_structp png_ptr));
-
-PNG_EXPORT(void,png_set_read_status_fn) PNGARG((png_structp png_ptr,
-   png_read_status_ptr read_row_fn));
-
-PNG_EXPORT(void,png_set_write_status_fn) PNGARG((png_structp png_ptr,
-   png_write_status_ptr write_row_fn));
-
-#ifdef PNG_USER_MEM_SUPPORTED
-/* Replace the default memory allocation functions with user supplied one(s). */
-PNG_EXPORT(void,png_set_mem_fn) PNGARG((png_structp png_ptr,
-   png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn));
-/* Return the user pointer associated with the memory functions */
-PNG_EXPORT(png_voidp,png_get_mem_ptr) PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-PNG_EXPORT(void,png_set_read_user_transform_fn) PNGARG((png_structp
-   png_ptr, png_user_transform_ptr read_user_transform_fn));
-#endif
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-PNG_EXPORT(void,png_set_write_user_transform_fn) PNGARG((png_structp
-   png_ptr, png_user_transform_ptr write_user_transform_fn));
-#endif
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-PNG_EXPORT(void,png_set_user_transform_info) PNGARG((png_structp
-   png_ptr, png_voidp user_transform_ptr, int user_transform_depth,
-   int user_transform_channels));
-/* Return the user pointer associated with the user transform functions */
-PNG_EXPORT(png_voidp,png_get_user_transform_ptr)
-   PNGARG((png_structp png_ptr));
-#endif
-
-#ifdef PNG_USER_CHUNKS_SUPPORTED
-PNG_EXPORT(void,png_set_read_user_chunk_fn) PNGARG((png_structp png_ptr,
-   png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
-PNG_EXPORT(png_voidp,png_get_user_chunk_ptr) PNGARG((png_structp
-   png_ptr));
-#endif
-
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-/* Sets the function callbacks for the push reader, and a pointer to a
- * user-defined structure available to the callback functions.
- */
-PNG_EXPORT(void,png_set_progressive_read_fn) PNGARG((png_structp png_ptr,
-   png_voidp progressive_ptr,
-   png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
-   png_progressive_end_ptr end_fn));
-
-/* Returns the user pointer associated with the push read functions */
-PNG_EXPORT(png_voidp,png_get_progressive_ptr)
-   PNGARG((png_structp png_ptr));
-
-/* Function to be called when data becomes available */
-PNG_EXPORT(void,png_process_data) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_bytep buffer, png_size_t buffer_size));
-
-/* Function that combines rows.  Not very much different than the
- * png_combine_row() call.  Is this even used?????
- */
-PNG_EXPORT(void,png_progressive_combine_row) PNGARG((png_structp png_ptr,
-   png_bytep old_row, png_bytep new_row));
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
-PNG_EXPORT(png_voidp,png_malloc) PNGARG((png_structp png_ptr,
-   png_alloc_size_t size)) PNG_ALLOCATED;
-/* Added at libpng version 1.4.0 */
-PNG_EXPORT(png_voidp,png_calloc) PNGARG((png_structp png_ptr,
-   png_alloc_size_t size)) PNG_ALLOCATED;
-
-/* Added at libpng version 1.2.4 */
-PNG_EXPORT(png_voidp,png_malloc_warn) PNGARG((png_structp png_ptr,
-   png_alloc_size_t size)) PNG_ALLOCATED;
-
-/* Frees a pointer allocated by png_malloc() */
-PNG_EXPORT(void,png_free) PNGARG((png_structp png_ptr, png_voidp ptr));
-
-/* Free data that was allocated internally */
-PNG_EXPORT(void,png_free_data) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 free_me, int num));
-/* Reassign responsibility for freeing existing data, whether allocated
- * by libpng or by the application */
-PNG_EXPORT(void,png_data_freer) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int freer, png_uint_32 mask));
-/* Assignments for png_data_freer */
-#define PNG_DESTROY_WILL_FREE_DATA 1
-#define PNG_SET_WILL_FREE_DATA 1
-#define PNG_USER_WILL_FREE_DATA 2
-/* Flags for png_ptr->free_me and info_ptr->free_me */
-#define PNG_FREE_HIST 0x0008
-#define PNG_FREE_ICCP 0x0010
-#define PNG_FREE_SPLT 0x0020
-#define PNG_FREE_ROWS 0x0040
-#define PNG_FREE_PCAL 0x0080
-#define PNG_FREE_SCAL 0x0100
-#define PNG_FREE_UNKN 0x0200
-#define PNG_FREE_LIST 0x0400
-#define PNG_FREE_PLTE 0x1000
-#define PNG_FREE_TRNS 0x2000
-#define PNG_FREE_TEXT 0x4000
-#define PNG_FREE_ALL  0x7fff
-#define PNG_FREE_MUL  0x4220 /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
-
-#ifdef PNG_USER_MEM_SUPPORTED
-PNG_EXPORT(png_voidp,png_malloc_default) PNGARG((png_structp png_ptr,
-   png_alloc_size_t size)) PNG_ALLOCATED;
-PNG_EXPORT(void,png_free_default) PNGARG((png_structp png_ptr,
-   png_voidp ptr));
-#endif
-
-#ifndef PNG_NO_ERROR_TEXT
-/* Fatal error in PNG image of libpng - can't continue */
-PNG_EXPORT(void,png_error) PNGARG((png_structp png_ptr,
-   png_const_charp error_message)) PNG_NORETURN;
-
-/* The same, but the chunk name is prepended to the error string. */
-PNG_EXPORT(void,png_chunk_error) PNGARG((png_structp png_ptr,
-   png_const_charp error_message)) PNG_NORETURN;
-
-#else
-/* Fatal error in PNG image of libpng - can't continue */
-PNG_EXPORT(void,png_err) PNGARG((png_structp png_ptr)) PNG_NORETURN;
-#endif
-
-/* Non-fatal error in libpng.  Can continue, but may have a problem. */
-PNG_EXPORT(void,png_warning) PNGARG((png_structp png_ptr,
-   png_const_charp warning_message));
-
-/* Non-fatal error in libpng, chunk name is prepended to message. */
-PNG_EXPORT(void,png_chunk_warning) PNGARG((png_structp png_ptr,
-   png_const_charp warning_message));
-
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-/* Benign error in libpng.  Can continue, but may have a problem.
- * User can choose whether to handle as a fatal error or as a warning. */
-PNG_EXPORT(void,png_benign_error) PNGARG((png_structp png_ptr,
-   png_const_charp warning_message));
-
-/* Same, chunk name is prepended to message. */
-PNG_EXPORT(void,png_chunk_benign_error) PNGARG((png_structp png_ptr,
-   png_const_charp warning_message));
-
-PNG_EXPORT(void,png_set_benign_errors) PNGARG((png_structp
-   png_ptr, int allowed));
-#endif
-
-/* The png_set_<chunk> functions are for storing values in the png_info_struct.
- * Similarly, the png_get_<chunk> calls are used to read values from the
- * png_info_struct, either storing the parameters in the passed variables, or
- * setting pointers into the png_info_struct where the data is stored.  The
- * png_get_<chunk> functions return a non-zero value if the data was available
- * in info_ptr, or return zero and do not change any of the parameters if the
- * data was not available.
- *
- * These functions should be used instead of directly accessing png_info
- * to avoid problems with future changes in the size and internal layout of
- * png_info_struct.
- */
-/* Returns "flag" if chunk data is valid in info_ptr. */
-PNG_EXPORT(png_uint_32,png_get_valid) PNGARG((png_structp png_ptr,
-png_infop info_ptr, png_uint_32 flag));
-
-/* Returns number of bytes needed to hold a transformed row. */
-PNG_EXPORT(png_size_t,png_get_rowbytes) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-/* Returns row_pointers, which is an array of pointers to scanlines that was
- * returned from png_read_png().
- */
-PNG_EXPORT(png_bytepp,png_get_rows) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-/* Set row_pointers, which is an array of pointers to scanlines for use
- * by png_write_png().
- */
-PNG_EXPORT(void,png_set_rows) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_bytepp row_pointers));
-#endif
-
-/* Returns number of color channels in image. */
-PNG_EXPORT(png_byte,png_get_channels) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-#ifdef PNG_EASY_ACCESS_SUPPORTED
-/* Returns image width in pixels. */
-PNG_EXPORT(png_uint_32, png_get_image_width) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image height in pixels. */
-PNG_EXPORT(png_uint_32, png_get_image_height) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image bit_depth. */
-PNG_EXPORT(png_byte, png_get_bit_depth) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image color_type. */
-PNG_EXPORT(png_byte, png_get_color_type) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image filter_type. */
-PNG_EXPORT(png_byte, png_get_filter_type) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image interlace_type. */
-PNG_EXPORT(png_byte, png_get_interlace_type) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image compression_type. */
-PNG_EXPORT(png_byte, png_get_compression_type) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns image resolution in pixels per meter, from pHYs chunk data. */
-PNG_EXPORT(png_uint_32, png_get_pixels_per_meter) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-PNG_EXPORT(png_uint_32, png_get_x_pixels_per_meter) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-PNG_EXPORT(png_uint_32, png_get_y_pixels_per_meter) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(float, png_get_pixel_aspect_ratio) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-#endif
-
-/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
-PNG_EXPORT(png_int_32, png_get_x_offset_pixels) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-PNG_EXPORT(png_int_32, png_get_y_offset_pixels) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-PNG_EXPORT(png_int_32, png_get_x_offset_microns) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-PNG_EXPORT(png_int_32, png_get_y_offset_microns) PNGARG((png_structp
-png_ptr, png_infop info_ptr));
-
-#endif /* PNG_EASY_ACCESS_SUPPORTED */
-
-/* Returns pointer to signature string read from PNG header */
-PNG_EXPORT(png_bytep,png_get_signature) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-#ifdef PNG_bKGD_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_bKGD) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_color_16p *background));
-#endif
-
-#ifdef PNG_bKGD_SUPPORTED
-PNG_EXPORT(void,png_set_bKGD) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_color_16p background));
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_cHRM) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, double *white_x, double *white_y, double *red_x,
-   double *red_y, double *green_x, double *green_y, double *blue_x,
-   double *blue_y));
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_cHRM_fixed) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_fixed_point *int_white_x, png_fixed_point
-   *int_white_y, png_fixed_point *int_red_x, png_fixed_point *int_red_y,
-   png_fixed_point *int_green_x, png_fixed_point *int_green_y, png_fixed_point
-   *int_blue_x, png_fixed_point *int_blue_y));
-#endif
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_cHRM) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, double white_x, double white_y, double red_x,
-   double red_y, double green_x, double green_y, double blue_x, double blue_y));
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_cHRM_fixed) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_fixed_point int_white_x, png_fixed_point int_white_y,
-   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
-   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
-   png_fixed_point int_blue_y));
-#endif
-#endif
-
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_gAMA) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, double *file_gamma));
-#endif
-PNG_EXPORT(png_uint_32,png_get_gAMA_fixed) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_fixed_point *int_file_gamma));
-#endif
-
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_gAMA) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, double file_gamma));
-#endif
-PNG_EXPORT(void,png_set_gAMA_fixed) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_fixed_point int_file_gamma));
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_hIST) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_16p *hist));
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-PNG_EXPORT(void,png_set_hIST) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_16p hist));
-#endif
-
-PNG_EXPORT(png_uint_32,png_get_IHDR) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 *width, png_uint_32 *height,
-   int *bit_depth, int *color_type, int *interlace_method,
-   int *compression_method, int *filter_method));
-
-PNG_EXPORT(void,png_set_IHDR) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,
-   int color_type, int interlace_method, int compression_method,
-   int filter_method));
-
-#ifdef PNG_oFFs_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_oFFs) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
-   int *unit_type));
-#endif
-
-#ifdef PNG_oFFs_SUPPORTED
-PNG_EXPORT(void,png_set_oFFs) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_int_32 offset_x, png_int_32 offset_y,
-   int unit_type));
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_pCAL) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_charp *purpose, png_int_32 *X0, png_int_32 *X1,
-   int *type, int *nparams, png_charp *units, png_charpp *params));
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-PNG_EXPORT(void,png_set_pCAL) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_charp purpose, png_int_32 X0, png_int_32 X1,
-   int type, int nparams, png_charp units, png_charpp params));
-#endif
-
-#ifdef PNG_pHYs_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_pHYs) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
-#endif
-
-#ifdef PNG_pHYs_SUPPORTED
-PNG_EXPORT(void,png_set_pHYs) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
-#endif
-
-PNG_EXPORT(png_uint_32,png_get_PLTE) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_colorp *palette, int *num_palette));
-
-PNG_EXPORT(void,png_set_PLTE) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_colorp palette, int num_palette));
-
-#ifdef PNG_sBIT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_sBIT) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_color_8p *sig_bit));
-#endif
-
-#ifdef PNG_sBIT_SUPPORTED
-PNG_EXPORT(void,png_set_sBIT) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_color_8p sig_bit));
-#endif
-
-#ifdef PNG_sRGB_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_sRGB) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int *intent));
-#endif
-
-#ifdef PNG_sRGB_SUPPORTED
-PNG_EXPORT(void,png_set_sRGB) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int intent));
-PNG_EXPORT(void,png_set_sRGB_gAMA_and_cHRM) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int intent));
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_iCCP) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_charpp name, int *compression_type,
-   png_charpp profile, png_uint_32 *proflen));
-   /* Note to maintainer: profile should be png_bytepp */
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-PNG_EXPORT(void,png_set_iCCP) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_charp name, int compression_type,
-   png_charp profile, png_uint_32 proflen));
-   /* Note to maintainer: profile should be png_bytep */
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_sPLT) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_sPLT_tpp entries));
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-PNG_EXPORT(void,png_set_sPLT) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_sPLT_tp entries, int nentries));
-#endif
-
-#ifdef PNG_TEXT_SUPPORTED
-/* png_get_text also returns the number of text chunks in *num_text */
-PNG_EXPORT(png_uint_32,png_get_text) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_textp *text_ptr, int *num_text));
-#endif
-
-/* Note while png_set_text() will accept a structure whose text,
- * language, and  translated keywords are NULL pointers, the structure
- * returned by png_get_text will always contain regular
- * zero-terminated C strings.  They might be empty strings but
- * they will never be NULL pointers.
- */
-
-#ifdef PNG_TEXT_SUPPORTED
-PNG_EXPORT(void,png_set_text) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_textp text_ptr, int num_text));
-#endif
-
-#ifdef PNG_tIME_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_tIME) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_timep *mod_time));
-#endif
-
-#ifdef PNG_tIME_SUPPORTED
-PNG_EXPORT(void,png_set_tIME) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_timep mod_time));
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_tRNS) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_bytep *trans_alpha, int *num_trans,
-   png_color_16p *trans_color));
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-PNG_EXPORT(void,png_set_tRNS) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_bytep trans_alpha, int num_trans,
-   png_color_16p trans_color));
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_sCAL) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int *unit, double *width, double *height));
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_sCAL_s) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int *unit, png_charpp swidth, png_charpp sheight));
-#endif
-#endif
-#endif /* PNG_sCAL_SUPPORTED */
-
-#ifdef PNG_sCAL_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_sCAL) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int unit, double width, double height));
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXPORT(void,png_set_sCAL_s) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int unit, png_charp swidth, png_charp sheight));
-#endif
-#endif
-#endif /* PNG_sCAL_SUPPORTED || PNG_WRITE_sCAL_SUPPORTED */
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-/* Provide a list of chunks and how they are to be handled, if the built-in
-   handling or default unknown chunk handling is not desired.  Any chunks not
-   listed will be handled in the default manner.  The IHDR and IEND chunks
-   must not be listed.
-      keep = 0: follow default behaviour
-           = 1: do not keep
-           = 2: keep only if safe-to-copy
-           = 3: keep even if unsafe-to-copy
-*/
-PNG_EXPORT(void, png_set_keep_unknown_chunks) PNGARG((png_structp
-   png_ptr, int keep, png_bytep chunk_list, int num_chunks));
-PNG_EXPORT(int,png_handle_as_unknown) PNGARG((png_structp png_ptr, png_bytep
-   chunk_name));
-#endif
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-PNG_EXPORT(void, png_set_unknown_chunks) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns));
-PNG_EXPORT(void, png_set_unknown_chunk_location)
-   PNGARG((png_structp png_ptr, png_infop info_ptr, int chunk, int location));
-PNG_EXPORT(png_uint_32,png_get_unknown_chunks) PNGARG((png_structp
-   png_ptr, png_infop info_ptr, png_unknown_chunkpp entries));
-#endif
-
-/* Png_free_data() will turn off the "valid" flag for anything it frees.
- * If you need to turn it off for a chunk that your application has freed,
- * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
- */
-PNG_EXPORT(void, png_set_invalid) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, int mask));
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-/* The "params" pointer is currently not used and is for future expansion. */
-PNG_EXPORT(void, png_read_png) PNGARG((png_structp png_ptr,
-                        png_infop info_ptr,
-                        int transforms,
-                        png_voidp params));
-PNG_EXPORT(void, png_write_png) PNGARG((png_structp png_ptr,
-                        png_infop info_ptr,
-                        int transforms,
-                        png_voidp params));
-#endif
-
-PNG_EXPORT(png_charp,png_get_copyright) PNGARG((png_structp png_ptr));
-PNG_EXPORT(png_charp,png_get_header_ver) PNGARG((png_structp png_ptr));
-PNG_EXPORT(png_charp,png_get_header_version) PNGARG((png_structp
-    png_ptr));
-PNG_EXPORT(png_charp,png_get_libpng_ver) PNGARG((png_structp png_ptr));
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-PNG_EXPORT(png_uint_32,png_permit_mng_features) PNGARG((png_structp
-   png_ptr, png_uint_32 mng_features_permitted));
-#endif
-
-/* For use in png_set_keep_unknown, added to version 1.2.6 */
-#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
-#define PNG_HANDLE_CHUNK_NEVER        1
-#define PNG_HANDLE_CHUNK_IF_SAFE      2
-#define PNG_HANDLE_CHUNK_ALWAYS       3
-
-/* Strip the prepended error numbers ("#nnn ") from error and warning
- * messages before passing them to the error or warning handler.
- */
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-PNG_EXPORT(void,png_set_strip_error_numbers) PNGARG((png_structp
-   png_ptr, png_uint_32 strip_mode));
-#endif
-
-/* Added in libpng-1.2.6 */
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-PNG_EXPORT(void,png_set_user_limits) PNGARG((png_structp
-   png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max));
-PNG_EXPORT(png_uint_32,png_get_user_width_max) PNGARG((png_structp
-   png_ptr));
-PNG_EXPORT(png_uint_32,png_get_user_height_max) PNGARG((png_structp
-   png_ptr));
-/* Added in libpng-1.4.0 */
-PNG_EXPORT(void,png_set_chunk_cache_max) PNGARG((png_structp
-   png_ptr, png_uint_32 user_chunk_cache_max));
-PNG_EXPORT(png_uint_32,png_get_chunk_cache_max)
-   PNGARG((png_structp png_ptr));
-/* Added in libpng-1.4.1 */
-PNG_EXPORT(void,png_set_chunk_malloc_max) PNGARG((png_structp
-   png_ptr, png_alloc_size_t user_chunk_cache_max));
-PNG_EXPORT(png_alloc_size_t,png_get_chunk_malloc_max)
-   PNGARG((png_structp png_ptr));
-#endif
-
-#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
-PNG_EXPORT(png_uint_32,png_get_pixels_per_inch) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-PNG_EXPORT(png_uint_32,png_get_x_pixels_per_inch) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-PNG_EXPORT(png_uint_32,png_get_y_pixels_per_inch) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-PNG_EXPORT(float,png_get_x_offset_inches) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-PNG_EXPORT(float,png_get_y_offset_inches) PNGARG((png_structp png_ptr,
-png_infop info_ptr));
-
-#ifdef PNG_pHYs_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_pHYs_dpi) PNGARG((png_structp png_ptr,
-png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
-#endif /* PNG_pHYs_SUPPORTED */
-#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */
-
-/* Added in libpng-1.4.0 */
-#ifdef PNG_IO_STATE_SUPPORTED
-PNG_EXPORT(png_uint_32,png_get_io_state) PNGARG((png_structp png_ptr));
-
-PNG_EXPORT(png_bytep,png_get_io_chunk_name)
-   PNGARG((png_structp png_ptr));
-
-/* The flags returned by png_get_io_state() are the following: */
-#define PNG_IO_NONE        0x0000   /* no I/O at this moment */
-#define PNG_IO_READING     0x0001   /* currently reading */
-#define PNG_IO_WRITING     0x0002   /* currently writing */
-#define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
-#define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
-#define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
-#define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
-#define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
-#define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
-#endif /* ?PNG_IO_STATE_SUPPORTED */
-
-/* Maintainer: Put new public prototypes here ^, in libpng.3, and project
- * defs
- */
-
-#ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
-/* With these routines we avoid an integer divide, which will be slower on
- * most machines.  However, it does take more operations than the corresponding
- * divide method, so it may be slower on a few RISC systems.  There are two
- * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
- *
- * Note that the rounding factors are NOT supposed to be the same!  128 and
- * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
- * standard method.
- *
- * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
- */
-
- /* fg and bg should be in `gamma 1.0' space; alpha is the opacity          */
-
-#  define png_composite(composite, fg, alpha, bg)         \
-     { png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
-           * (png_uint_16)(alpha)                         \
-           + (png_uint_16)(bg)*(png_uint_16)(255          \
-           - (png_uint_16)(alpha)) + (png_uint_16)128);   \
-       (composite) = (png_byte)((temp + (temp >> 8)) >> 8); }
-
-#  define png_composite_16(composite, fg, alpha, bg)       \
-     { png_uint_32 temp = (png_uint_32)((png_uint_32)(fg)  \
-           * (png_uint_32)(alpha)                          \
-           + (png_uint_32)(bg)*(png_uint_32)(65535L        \
-           - (png_uint_32)(alpha)) + (png_uint_32)32768L); \
-       (composite) = (png_uint_16)((temp + (temp >> 16)) >> 16); }
-
-#else  /* Standard method using integer division */
-
-#  define png_composite(composite, fg, alpha, bg)                            \
-     (composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) +    \
-       (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) +       \
-       (png_uint_16)127) / 255)
-
-#  define png_composite_16(composite, fg, alpha, bg)                         \
-     (composite) = (png_uint_16)(((png_uint_32)(fg) * (png_uint_32)(alpha) + \
-       (png_uint_32)(bg)*(png_uint_32)(65535L - (png_uint_32)(alpha)) +      \
-       (png_uint_32)32767) / (png_uint_32)65535L)
-#endif /* PNG_READ_COMPOSITE_NODIV_SUPPORTED */
-
-#ifdef PNG_USE_READ_MACROS
-/* Inline macros to do direct reads of bytes from the input buffer.
- * The png_get_int_32() routine assumes we are using two's complement
- * format for negative values, which is almost certainly true.
- */
-#  define png_get_uint_32(buf) \
-     (((png_uint_32)(*(buf)) << 24) + \
-      ((png_uint_32)(*((buf) + 1)) << 16) + \
-      ((png_uint_32)(*((buf) + 2)) << 8) + \
-      ((png_uint_32)(*((buf) + 3))))
-#  define png_get_uint_16(buf) \
-     (((png_uint_32)(*(buf)) << 8) + \
-      ((png_uint_32)(*((buf) + 1))))
-#  define png_get_int_32(buf) \
-     ((png_int_32)((*(buf) & 0x80) \
-      ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffff)+1)) \
-      : (png_int_32)png_get_uint_32(buf)))
-#else
-PNG_EXPORT(png_uint_32,png_get_uint_32) PNGARG((png_bytep buf));
-PNG_EXPORT(png_uint_16,png_get_uint_16) PNGARG((png_bytep buf));
-#ifdef PNG_GET_INT_32_SUPPORTED
-PNG_EXPORT(png_int_32,png_get_int_32) PNGARG((png_bytep buf));
-#endif
-#endif
-PNG_EXPORT(png_uint_32,png_get_uint_31)
-  PNGARG((png_structp png_ptr, png_bytep buf));
-/* No png_get_int_16 -- may be added if there's a real need for it. */
-
-/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
-PNG_EXPORT(void,png_save_uint_32)
-   PNGARG((png_bytep buf, png_uint_32 i));
-PNG_EXPORT(void,png_save_int_32)
-   PNGARG((png_bytep buf, png_int_32 i));
-
-/* Place a 16-bit number into a buffer in PNG byte order.
- * The parameter is declared unsigned int, not png_uint_16,
- * just to avoid potential problems on pre-ANSI C compilers.
- */
-PNG_EXPORT(void,png_save_uint_16)
-   PNGARG((png_bytep buf, unsigned int i));
-/* No png_save_int_16 -- may be added if there's a real need for it. */
-
-/* ************************************************************************* */
-
-/* Various modes of operation.  Note that after an init, mode is set to
- * zero automatically when the structure is created.
- */
-#define PNG_HAVE_IHDR               0x01
-#define PNG_HAVE_PLTE               0x02
-#define PNG_HAVE_IDAT               0x04
-#define PNG_AFTER_IDAT              0x08 /* Have complete zlib datastream */
-#define PNG_HAVE_IEND               0x10
-#define PNG_HAVE_gAMA               0x20
-#define PNG_HAVE_cHRM               0x40
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PNG_VERSION_INFO_ONLY */
-/* Do not put anything past this line */
-#endif /* PNG_H */
diff --git a/thirdparty/libpng/pngconf.h b/thirdparty/libpng/pngconf.h
deleted file mode 100644
index 41b13e9..0000000
--- a/thirdparty/libpng/pngconf.h
+++ /dev/null
@@ -1,1540 +0,0 @@
-
-/* pngconf.h - machine configurable file for libpng
- *
- * libpng version 1.4.4 - September 23, 2010
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- */
-
-/* Any machine specific code is near the front of this file, so if you
- * are configuring libpng for a machine, you may want to read the section
- * starting here down to where it starts to typedef png_color, png_text,
- * and png_info.
- */
-
-#ifndef PNGCONF_H
-#define PNGCONF_H
-
-#ifndef PNG_NO_LIMITS_H
-#  include <limits.h>
-#endif
-
-/* Added at libpng-1.2.9 */
-
-/* config.h is created by and PNG_CONFIGURE_LIBPNG is set by the "configure"
- * script.
- */
-#ifdef PNG_CONFIGURE_LIBPNG
-#  ifdef HAVE_CONFIG_H
-#    include "config.h"
-#  endif
-#endif
-
-/*
- * Added at libpng-1.2.8
- *
- * PNG_USER_CONFIG has to be defined on the compiler command line. This
- * includes the resource compiler for Windows DLL configurations.
- */
-#ifdef PNG_USER_CONFIG
-#  include "pngusr.h"
-#  ifndef PNG_USER_PRIVATEBUILD
-#    define PNG_USER_PRIVATEBUILD
-#  endif
-#endif
-
-/*
- * If you create a private DLL you should define in "pngusr.h" the following:
- * #define PNG_USER_PRIVATEBUILD <Describes by whom and why this version of
- *        the DLL was built>
- *  e.g. #define PNG_USER_PRIVATEBUILD "Build by MyCompany for xyz reasons."
- * #define PNG_USER_DLLFNAME_POSTFIX <two-letter postfix that serve to
- *        distinguish your DLL from those of the official release. These
- *        correspond to the trailing letters that come after the version
- *        number and must match your private DLL name>
- *  e.g. // private DLL "libpng14gx.dll"
- *       #define PNG_USER_DLLFNAME_POSTFIX "gx"
- *
- * The following macros are also at your disposal if you want to complete the
- * DLL VERSIONINFO structure.
- * - PNG_USER_VERSIONINFO_COMMENTS
- * - PNG_USER_VERSIONINFO_COMPANYNAME
- * - PNG_USER_VERSIONINFO_LEGALTRADEMARKS
- */
-
-#ifdef __STDC__
-#  ifdef SPECIALBUILD
-#    pragma message("PNG_LIBPNG_SPECIALBUILD (and deprecated SPECIALBUILD)\
-     are now LIBPNG reserved macros. Use PNG_USER_PRIVATEBUILD instead.")
-#  endif
-
-#  ifdef PRIVATEBUILD
-#    pragma message("PRIVATEBUILD is deprecated.\
-     Use PNG_USER_PRIVATEBUILD instead.")
-#    define PNG_USER_PRIVATEBUILD PRIVATEBUILD
-#  endif
-#endif /* __STDC__ */
-
-/* End of material added to libpng-1.2.8 */
-
-#ifndef PNG_VERSION_INFO_ONLY
-
-/* This is the size of the compression buffer, and thus the size of
- * an IDAT chunk.  Make this whatever size you feel is best for your
- * machine.  One of these will be allocated per png_struct.  When this
- * is full, it writes the data to the disk, and does some other
- * calculations.  Making this an extremely small size will slow
- * the library down, but you may want to experiment to determine
- * where it becomes significant, if you are concerned with memory
- * usage.  Note that zlib allocates at least 32Kb also.  For readers,
- * this describes the size of the buffer available to read the data in.
- * Unless this gets smaller than the size of a row (compressed),
- * it should not make much difference how big this is.
- */
-
-#ifndef PNG_ZBUF_SIZE
-#  define PNG_ZBUF_SIZE 8192
-#endif
-
-/* Enable if you want a write-only libpng */
-
-#ifndef PNG_NO_READ_SUPPORTED
-#  define PNG_READ_SUPPORTED
-#endif
-
-/* Enable if you want a read-only libpng */
-
-#ifndef PNG_NO_WRITE_SUPPORTED
-#  define PNG_WRITE_SUPPORTED
-#endif
-
-/* Enabled in 1.4.0. */
-#ifdef PNG_ALLOW_BENIGN_ERRORS
-#  define png_benign_error png_warning
-#  define png_chunk_benign_error png_chunk_warning
-#else
-#  ifndef PNG_BENIGN_ERRORS_SUPPORTED
-#    define png_benign_error png_error
-#    define png_chunk_benign_error png_chunk_error
-#  endif
-#endif
-
-/* Added at libpng version 1.4.0 */
-#if !defined(PNG_NO_WARNINGS) && !defined(PNG_WARNINGS_SUPPORTED)
-#  define PNG_WARNINGS_SUPPORTED
-#endif
-
-/* Added at libpng version 1.4.0 */
-#if !defined(PNG_NO_ERROR_TEXT) && !defined(PNG_ERROR_TEXT_SUPPORTED)
-#  define PNG_ERROR_TEXT_SUPPORTED
-#endif
-
-/* Added at libpng version 1.4.0 */
-#if !defined(PNG_NO_CHECK_cHRM) && !defined(PNG_CHECK_cHRM_SUPPORTED)
-#  define PNG_CHECK_cHRM_SUPPORTED
-#endif
-
-/* Added at libpng version 1.4.0 */
-#if !defined(PNG_NO_ALIGNED_MEMORY) && !defined(PNG_ALIGNED_MEMORY_SUPPORTED)
-#  define PNG_ALIGNED_MEMORY_SUPPORTED
-#endif
-
-/* Enabled by default in 1.2.0.  You can disable this if you don't need to
-   support PNGs that are embedded in MNG datastreams */
-#ifndef PNG_NO_MNG_FEATURES
-#  ifndef PNG_MNG_FEATURES_SUPPORTED
-#    define PNG_MNG_FEATURES_SUPPORTED
-#  endif
-#endif
-
-/* Added at libpng version 1.4.0 */
-#ifndef PNG_NO_FLOATING_POINT_SUPPORTED
-#  ifndef PNG_FLOATING_POINT_SUPPORTED
-#    define PNG_FLOATING_POINT_SUPPORTED
-#  endif
-#endif
-
-/* Added at libpng-1.4.0beta49 for testing (this test is no longer used
-   in libpng and png_calloc() is always present)
- */
-#define PNG_CALLOC_SUPPORTED
-
-/* If you are running on a machine where you cannot allocate more
- * than 64K of memory at once, uncomment this.  While libpng will not
- * normally need that much memory in a chunk (unless you load up a very
- * large file), zlib needs to know how big of a chunk it can use, and
- * libpng thus makes sure to check any memory allocation to verify it
- * will fit into memory.
-#define PNG_MAX_MALLOC_64K
- */
-#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
-#  define PNG_MAX_MALLOC_64K
-#endif
-
-/* Special munging to support doing things the 'cygwin' way:
- * 'Normal' png-on-win32 defines/defaults:
- *   PNG_BUILD_DLL -- building dll
- *   PNG_USE_DLL   -- building an application, linking to dll
- *   (no define)   -- building static library, or building an
- *                    application and linking to the static lib
- * 'Cygwin' defines/defaults:
- *   PNG_BUILD_DLL -- (ignored) building the dll
- *   (no define)   -- (ignored) building an application, linking to the dll
- *   PNG_STATIC    -- (ignored) building the static lib, or building an
- *                    application that links to the static lib.
- *   ALL_STATIC    -- (ignored) building various static libs, or building an
- *                    application that links to the static libs.
- * Thus,
- * a cygwin user should define either PNG_BUILD_DLL or PNG_STATIC, and
- * this bit of #ifdefs will define the 'correct' config variables based on
- * that. If a cygwin user *wants* to define 'PNG_USE_DLL' that's okay, but
- * unnecessary.
- *
- * Also, the precedence order is:
- *   ALL_STATIC (since we can't #undef something outside our namespace)
- *   PNG_BUILD_DLL
- *   PNG_STATIC
- *   (nothing) == PNG_USE_DLL
- *
- * CYGWIN (2002-01-20): The preceding is now obsolete. With the advent
- *   of auto-import in binutils, we no longer need to worry about
- *   __declspec(dllexport) / __declspec(dllimport) and friends.  Therefore,
- *   we don't need to worry about PNG_STATIC or ALL_STATIC when it comes
- *   to __declspec() stuff.  However, we DO need to worry about
- *   PNG_BUILD_DLL and PNG_STATIC because those change some defaults
- *   such as CONSOLE_IO.
- */
-#ifdef __CYGWIN__
-#  ifdef ALL_STATIC
-#    ifdef PNG_BUILD_DLL
-#      undef PNG_BUILD_DLL
-#    endif
-#    ifdef PNG_USE_DLL
-#      undef PNG_USE_DLL
-#    endif
-#    ifdef PNG_DLL
-#      undef PNG_DLL
-#    endif
-#    ifndef PNG_STATIC
-#      define PNG_STATIC
-#    endif
-#  else
-#    ifdef PNG_BUILD_DLL
-#      ifdef PNG_STATIC
-#        undef PNG_STATIC
-#      endif
-#      ifdef PNG_USE_DLL
-#        undef PNG_USE_DLL
-#      endif
-#      ifndef PNG_DLL
-#        define PNG_DLL
-#      endif
-#    else
-#      ifdef PNG_STATIC
-#        ifdef PNG_USE_DLL
-#          undef PNG_USE_DLL
-#        endif
-#        ifdef PNG_DLL
-#          undef PNG_DLL
-#        endif
-#      else
-#        ifndef PNG_USE_DLL
-#          define PNG_USE_DLL
-#        endif
-#        ifndef PNG_DLL
-#          define PNG_DLL
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* This protects us against compilers that run on a windowing system
- * and thus don't have or would rather us not use the stdio types:
- * stdin, stdout, and stderr.  The only one currently used is stderr
- * in png_error() and png_warning().  #defining PNG_NO_CONSOLE_IO will
- * prevent these from being compiled and used. #defining PNG_NO_STDIO
- * will also prevent these, plus will prevent the entire set of stdio
- * macros and functions (FILE *, printf, etc.) from being compiled and used,
- * unless (PNG_DEBUG > 0) has been #defined.
- *
- * #define PNG_NO_CONSOLE_IO
- * #define PNG_NO_STDIO
- */
-
-#ifdef _WIN32_WCE
-#  define PNG_NO_CONSOLE_IO
-#  define PNG_NO_STDIO
-#  define PNG_NO_TIME_RFC1123
-#  ifdef PNG_DEBUG
-#    undef PNG_DEBUG
-#  endif
-#endif
-
-#if !defined(PNG_NO_STDIO) && !defined(PNG_STDIO_SUPPORTED)
-#  define PNG_STDIO_SUPPORTED
-#endif
-
-#ifdef PNG_BUILD_DLL
-#  if !defined(PNG_CONSOLE_IO_SUPPORTED) && !defined(PNG_NO_CONSOLE_IO)
-#    define PNG_NO_CONSOLE_IO
-#  endif
-#endif
-
-#  ifdef PNG_NO_STDIO
-#    ifndef PNG_NO_CONSOLE_IO
-#      define PNG_NO_CONSOLE_IO
-#    endif
-#    ifdef PNG_DEBUG
-#      if (PNG_DEBUG > 0)
-#        include <stdio.h>
-#      endif
-#    endif
-#  else
-#    include <stdio.h>
-#  endif
-
-#if !(defined PNG_NO_CONSOLE_IO) && !defined(PNG_CONSOLE_IO_SUPPORTED)
-#  define PNG_CONSOLE_IO_SUPPORTED
-#endif
-
-/* This macro protects us against machines that don't have function
- * prototypes (ie K&R style headers).  If your compiler does not handle
- * function prototypes, define this macro and use the included ansi2knr.
- * I've always been able to use _NO_PROTO as the indicator, but you may
- * need to drag the empty declaration out in front of here, or change the
- * ifdef to suit your own needs.
- */
-#ifndef PNGARG
-
-#ifdef OF /* zlib prototype munger */
-#  define PNGARG(arglist) OF(arglist)
-#else
-
-#ifdef _NO_PROTO
-#  define PNGARG(arglist) ()
-#else
-#  define PNGARG(arglist) arglist
-#endif /* _NO_PROTO */
-
-#endif /* OF */
-
-#endif /* PNGARG */
-
-/* Try to determine if we are compiling on a Mac.  Note that testing for
- * just __MWERKS__ is not good enough, because the Codewarrior is now used
- * on non-Mac platforms.
- */
-#ifndef MACOS
-#  if (defined(__MWERKS__) && defined(macintosh)) || defined(applec) || \
-      defined(THINK_C) || defined(__SC__) || defined(TARGET_OS_MAC)
-#    define MACOS
-#  endif
-#endif
-
-/* Enough people need this for various reasons to include it here */
-#if !defined(MACOS) && !defined(RISCOS)
-#  include <sys/types.h>
-#endif
-
-/* PNG_SETJMP_NOT_SUPPORTED and PNG_NO_SETJMP_SUPPORTED are deprecated. */
-#if !defined(PNG_NO_SETJMP) && \
-    !defined(PNG_SETJMP_NOT_SUPPORTED) && !defined(PNG_NO_SETJMP_SUPPORTED)
-#  define PNG_SETJMP_SUPPORTED
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-/* This is an attempt to force a single setjmp behaviour on Linux.  If
- * the X config stuff didn't define _BSD_SOURCE we wouldn't need this.
- *
- * You can bypass this test if you know that your application uses exactly
- * the same setjmp.h that was included when libpng was built.  Only define
- * PNG_SKIP_SETJMP_CHECK while building your application, prior to the
- * application's '#include "png.h"'. Don't define PNG_SKIP_SETJMP_CHECK
- * while building a separate libpng library for general use.
- */
-
-#  ifndef PNG_SKIP_SETJMP_CHECK
-#    ifdef __linux__
-#      ifdef _BSD_SOURCE
-#        define PNG_SAVE_BSD_SOURCE
-#        undef _BSD_SOURCE
-#      endif
-#      ifdef _SETJMP_H
-       /* If you encounter a compiler error here, see the explanation
-        * near the end of INSTALL.
-        */
-           __pngconf.h__ in libpng already includes setjmp.h;
-           __dont__ include it again.;
-#      endif
-#    endif /* __linux__ */
-#  endif /* PNG_SKIP_SETJMP_CHECK */
-
-   /* Include setjmp.h for error handling */
-#  include <setjmp.h>
-
-#  ifdef __linux__
-#    ifdef PNG_SAVE_BSD_SOURCE
-#      ifdef _BSD_SOURCE
-#        undef _BSD_SOURCE
-#      endif
-#      define _BSD_SOURCE
-#      undef PNG_SAVE_BSD_SOURCE
-#    endif
-#  endif /* __linux__ */
-#endif /* PNG_SETJMP_SUPPORTED */
-
-#ifdef BSD
-#  include <strings.h>
-#else
-#  include <string.h>
-#endif
-
-/* Other defines for things like memory and the like can go here.  */
-
-/* This controls how fine the quantizing gets.  As this allocates
- * a largish chunk of memory (32K), those who are not as concerned
- * with quantizing quality can decrease some or all of these.
- */
-
-/* Prior to libpng-1.4.2, these were PNG_DITHER_*_BITS
- * These migration aids will be removed from libpng-1.5.0.
- */
-#ifdef PNG_DITHER_RED_BITS
-#  define PNG_QUANTIZE_RED_BITS PNG_DITHER_RED_BITS
-#endif
-#ifdef PNG_DITHER_GREEN_BITS
-#  define PNG_QUANTIZE_GREEN_BITS PNG_DITHER_GREEN_BITS
-#endif
-#ifdef PNG_DITHER_BLUE_BITS
-#  define PNG_QUANTIZE_BLUE_BITS PNG_DITHER_BLUE_BITS
-#endif
-
-#ifndef PNG_QUANTIZE_RED_BITS
-#  define PNG_QUANTIZE_RED_BITS 5
-#endif
-#ifndef PNG_QUANTIZE_GREEN_BITS
-#  define PNG_QUANTIZE_GREEN_BITS 5
-#endif
-#ifndef PNG_QUANTIZE_BLUE_BITS
-#  define PNG_QUANTIZE_BLUE_BITS 5
-#endif
-
-/* This controls how fine the gamma correction becomes when you
- * are only interested in 8 bits anyway.  Increasing this value
- * results in more memory being used, and more pow() functions
- * being called to fill in the gamma tables.  Don't set this value
- * less then 8, and even that may not work (I haven't tested it).
- */
-
-#ifndef PNG_MAX_GAMMA_8
-#  define PNG_MAX_GAMMA_8 11
-#endif
-
-/* This controls how much a difference in gamma we can tolerate before
- * we actually start doing gamma conversion.
- */
-#ifndef PNG_GAMMA_THRESHOLD
-#  define PNG_GAMMA_THRESHOLD 0.05
-#endif
-
-/* The following uses const char * instead of char * for error
- * and warning message functions, so some compilers won't complain.
- * If you do not want to use const, define PNG_NO_CONST.
- */
-
-#ifndef PNG_CONST
-#  ifndef PNG_NO_CONST
-#    define PNG_CONST const
-#  else
-#    define PNG_CONST
-#  endif
-#endif
-
-/* The following defines give you the ability to remove code from the
- * library that you will not be using.  I wish I could figure out how to
- * automate this, but I can't do that without making it seriously hard
- * on the users.  So if you are not using an ability, change the #define
- * to an #undef, or pass in PNG_NO_feature and that part of the library
- * will not be compiled.
-
- * If your linker can't find a function, you may want to make sure the
- * ability is defined here.  Some of these depend upon some others being
- * defined.  I haven't figured out all the interactions here, so you may
- * have to experiment awhile to get everything to compile.  If you are
- * creating or using a shared library, you probably shouldn't touch this,
- * as it will affect the size of the structures, and this will cause bad
- * things to happen if the library and/or application ever change.
- */
-
-/* Any features you will not be using can be undef'ed here */
-
-/* GR-P, 0.96a: Set "*TRANSFORMS_SUPPORTED as default but allow user
- * to turn it off with PNG_NO_READ|WRITE_TRANSFORMS on the compile line,
- * then pick and choose which ones to define without having to edit this
- * file. It is safe to use the PNG_NO_READ|WRITE_TRANSFORMS
- * if you only want to have a png-compliant reader/writer but don't need
- * any of the extra transformations.  This saves about 80 kbytes in a
- * typical installation of the library. (PNG_NO_* form added in version
- * 1.0.1c, for consistency; PNG_*_TRANSFORMS_NOT_SUPPORTED deprecated in
- * 1.4.0)
- */
-
-/* Ignore attempt to turn off both floating and fixed point support */
-#if !defined(PNG_FLOATING_POINT_SUPPORTED) || \
-    !defined(PNG_NO_FIXED_POINT_SUPPORTED)
-#  define PNG_FIXED_POINT_SUPPORTED
-#endif
-
-#ifdef PNG_READ_SUPPORTED
-
-/* PNG_READ_TRANSFORMS_NOT_SUPPORTED is deprecated. */
-#if !defined(PNG_READ_TRANSFORMS_NOT_SUPPORTED) && \
-      !defined(PNG_NO_READ_TRANSFORMS)
-#  define PNG_READ_TRANSFORMS_SUPPORTED
-#endif
-
-#ifdef PNG_READ_TRANSFORMS_SUPPORTED
-#  ifndef PNG_NO_READ_EXPAND
-#    define PNG_READ_EXPAND_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_SHIFT
-#    define PNG_READ_SHIFT_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_PACK
-#    define PNG_READ_PACK_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_BGR
-#    define PNG_READ_BGR_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_SWAP
-#    define PNG_READ_SWAP_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_PACKSWAP
-#    define PNG_READ_PACKSWAP_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_INVERT
-#    define PNG_READ_INVERT_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_QUANTIZE
-     /* Prior to libpng-1.4.0 this was PNG_READ_DITHER_SUPPORTED */
-#    ifndef PNG_NO_READ_DITHER  /* This migration aid will be removed */
-#      define PNG_READ_QUANTIZE_SUPPORTED
-#    endif
-#  endif
-#  ifndef PNG_NO_READ_BACKGROUND
-#    define PNG_READ_BACKGROUND_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_16_TO_8
-#    define PNG_READ_16_TO_8_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_FILLER
-#    define PNG_READ_FILLER_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_GAMMA
-#    define PNG_READ_GAMMA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_GRAY_TO_RGB
-#    define PNG_READ_GRAY_TO_RGB_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_SWAP_ALPHA
-#    define PNG_READ_SWAP_ALPHA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_INVERT_ALPHA
-#    define PNG_READ_INVERT_ALPHA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_STRIP_ALPHA
-#    define PNG_READ_STRIP_ALPHA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_USER_TRANSFORM
-#    define PNG_READ_USER_TRANSFORM_SUPPORTED
-#  endif
-#  ifndef PNG_NO_READ_RGB_TO_GRAY
-#    define PNG_READ_RGB_TO_GRAY_SUPPORTED
-#  endif
-#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
-
-/* PNG_PROGRESSIVE_READ_NOT_SUPPORTED is deprecated. */
-#if !defined(PNG_NO_PROGRESSIVE_READ) && \
- !defined(PNG_PROGRESSIVE_READ_NOT_SUPPORTED)  /* if you don't do progressive */
-#  define PNG_PROGRESSIVE_READ_SUPPORTED     /* reading.  This is not talking */
-#endif                               /* about interlacing capability!  You'll */
-            /* still have interlacing unless you change the following define: */
-
-#define PNG_READ_INTERLACING_SUPPORTED /* required for PNG-compliant decoders */
-
-/* PNG_NO_SEQUENTIAL_READ_SUPPORTED is deprecated. */
-#if !defined(PNG_NO_SEQUENTIAL_READ) && \
-    !defined(PNG_SEQUENTIAL_READ_SUPPORTED) && \
-    !defined(PNG_NO_SEQUENTIAL_READ_SUPPORTED)
-#  define PNG_SEQUENTIAL_READ_SUPPORTED
-#endif
-
-#ifndef PNG_NO_READ_COMPOSITE_NODIV
-#  ifndef PNG_NO_READ_COMPOSITED_NODIV  /* libpng-1.0.x misspelling */
-#    define PNG_READ_COMPOSITE_NODIV_SUPPORTED   /* well tested on Intel, SGI */
-#  endif
-#endif
-
-#if !defined(PNG_NO_GET_INT_32) || defined(PNG_READ_oFFS_SUPPORTED) || \
-    defined(PNG_READ_pCAL_SUPPORTED)
-#  ifndef PNG_GET_INT_32_SUPPORTED
-#    define PNG_GET_INT_32_SUPPORTED
-#  endif
-#endif
-
-#endif /* PNG_READ_SUPPORTED */
-
-#ifdef PNG_WRITE_SUPPORTED
-
-/* PNG_WRITE_TRANSFORMS_NOT_SUPPORTED is deprecated. */
-#if !defined(PNG_WRITE_TRANSFORMS_NOT_SUPPORTED) && \
-    !defined(PNG_NO_WRITE_TRANSFORMS)
-#  define PNG_WRITE_TRANSFORMS_SUPPORTED
-#endif
-
-#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
-#  ifndef PNG_NO_WRITE_SHIFT
-#    define PNG_WRITE_SHIFT_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_PACK
-#    define PNG_WRITE_PACK_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_BGR
-#    define PNG_WRITE_BGR_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_SWAP
-#    define PNG_WRITE_SWAP_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_PACKSWAP
-#    define PNG_WRITE_PACKSWAP_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_INVERT
-#    define PNG_WRITE_INVERT_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_FILLER
-#    define PNG_WRITE_FILLER_SUPPORTED   /* same as WRITE_STRIP_ALPHA */
-#  endif
-#  ifndef PNG_NO_WRITE_SWAP_ALPHA
-#    define PNG_WRITE_SWAP_ALPHA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_INVERT_ALPHA
-#    define PNG_WRITE_INVERT_ALPHA_SUPPORTED
-#  endif
-#  ifndef PNG_NO_WRITE_USER_TRANSFORM
-#    define PNG_WRITE_USER_TRANSFORM_SUPPORTED
-#  endif
-#endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */
-
-#if !defined(PNG_NO_WRITE_INTERLACING_SUPPORTED) && \
-    !defined(PNG_WRITE_INTERLACING_SUPPORTED)
-    /* This is not required for PNG-compliant encoders, but can cause
-     * trouble if left undefined
-    */
-#  define PNG_WRITE_INTERLACING_SUPPORTED
-#endif
-
-#if !defined(PNG_NO_WRITE_WEIGHTED_FILTER) && \
-    !defined(PNG_WRITE_WEIGHTED_FILTER) && \
-     defined(PNG_FLOATING_POINT_SUPPORTED)
-#  define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-#endif
-
-#ifndef PNG_NO_WRITE_FLUSH
-#  define PNG_WRITE_FLUSH_SUPPORTED
-#endif
-
-#if !defined(PNG_NO_SAVE_INT_32) || defined(PNG_WRITE_oFFS_SUPPORTED) || \
-    defined(PNG_WRITE_pCAL_SUPPORTED)
-#  ifndef PNG_SAVE_INT_32_SUPPORTED
-#    define PNG_SAVE_INT_32_SUPPORTED
-#  endif
-#endif
-
-#endif /* PNG_WRITE_SUPPORTED */
-
-#define PNG_NO_ERROR_NUMBERS
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-#  ifndef PNG_NO_USER_TRANSFORM_PTR
-#    define PNG_USER_TRANSFORM_PTR_SUPPORTED
-#  endif
-#endif
-
-#if defined(PNG_STDIO_SUPPORTED) && !defined(PNG_TIME_RFC1123_SUPPORTED)
-#  define PNG_TIME_RFC1123_SUPPORTED
-#endif
-
-/* This adds extra functions in pngget.c for accessing data from the
- * info pointer (added in version 0.99)
- * png_get_image_width()
- * png_get_image_height()
- * png_get_bit_depth()
- * png_get_color_type()
- * png_get_compression_type()
- * png_get_filter_type()
- * png_get_interlace_type()
- * png_get_pixel_aspect_ratio()
- * png_get_pixels_per_meter()
- * png_get_x_offset_pixels()
- * png_get_y_offset_pixels()
- * png_get_x_offset_microns()
- * png_get_y_offset_microns()
- */
-#if !defined(PNG_NO_EASY_ACCESS) && !defined(PNG_EASY_ACCESS_SUPPORTED)
-#  define PNG_EASY_ACCESS_SUPPORTED
-#endif
-
-/* Added at libpng-1.2.0 */
-#if !defined(PNG_NO_USER_MEM) && !defined(PNG_USER_MEM_SUPPORTED)
-#  define PNG_USER_MEM_SUPPORTED
-#endif
-
-/* Added at libpng-1.2.6 */
-#ifndef PNG_NO_SET_USER_LIMITS
-#  ifndef PNG_SET_USER_LIMITS_SUPPORTED
-#    define PNG_SET_USER_LIMITS_SUPPORTED
-#  endif
-  /* Feature added at libpng-1.4.0, this flag added at 1.4.1 */
-#  ifndef PNG_SET_CHUNK_CACHE_LIMIT_SUPPORTED
-#    define PNG_SET_CHUNK_CACHE_LIMIT_SUPPORTED
-#  endif
-  /* Feature added at libpng-1.4.1, this flag added at 1.4.1 */
-#  ifndef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-#    define PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-#  endif
-#endif
-
-/* Added at libpng-1.2.43 */
-#ifndef PNG_USER_LIMITS_SUPPORTED
-#  ifndef PNG_NO_USER_LIMITS
-#    define PNG_USER_LIMITS_SUPPORTED
-#  endif
-#endif
-
-/* Added at libpng-1.0.16 and 1.2.6.  To accept all valid PNGs no matter
- * how large, set these two limits to 0x7fffffffL
- */
-#ifndef PNG_USER_WIDTH_MAX
-#  define PNG_USER_WIDTH_MAX 1000000L
-#endif
-#ifndef PNG_USER_HEIGHT_MAX
-#  define PNG_USER_HEIGHT_MAX 1000000L
-#endif
-
-/* Added at libpng-1.2.43.  To accept all valid PNGs no matter
- * how large, set these two limits to 0.
- */
-#ifndef PNG_USER_CHUNK_CACHE_MAX
-#  define PNG_USER_CHUNK_CACHE_MAX 0
-#endif
-
-/* Added at libpng-1.2.43 */
-#ifndef PNG_USER_CHUNK_MALLOC_MAX
-#  define PNG_USER_CHUNK_MALLOC_MAX 0
-#endif
-
-/* Added at libpng-1.4.0 */
-#if !defined(PNG_NO_IO_STATE) && !defined(PNG_IO_STATE_SUPPORTED)
-#  define PNG_IO_STATE_SUPPORTED
-#endif
-
-#ifndef PNG_LITERAL_SHARP
-#  define PNG_LITERAL_SHARP 0x23
-#endif
-#ifndef PNG_LITERAL_LEFT_SQUARE_BRACKET
-#  define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
-#endif
-#ifndef PNG_LITERAL_RIGHT_SQUARE_BRACKET
-#  define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
-#endif
-#ifndef PNG_STRING_NEWLINE
-#define PNG_STRING_NEWLINE "\n"
-#endif
-
-/* These are currently experimental features, define them if you want */
-
-/* Very little testing */
-/*
-#ifdef PNG_READ_SUPPORTED
-#  ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-#    define PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-#  endif
-#endif
-*/
-
-/* This is only for PowerPC big-endian and 680x0 systems */
-/* some testing */
-/*
-#ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
-#  define PNG_READ_BIG_ENDIAN_SUPPORTED
-#endif
-*/
-
-#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
-#  define PNG_USE_READ_MACROS
-#endif
-
-/* Buggy compilers (e.g., gcc 2.7.2.2) need PNG_NO_POINTER_INDEXING */
-
-#if !defined(PNG_NO_POINTER_INDEXING) && \
-    !defined(PNG_POINTER_INDEXING_SUPPORTED)
-#  define PNG_POINTER_INDEXING_SUPPORTED
-#endif
-
-
-/* Any chunks you are not interested in, you can undef here.  The
- * ones that allocate memory may be expecially important (hIST,
- * tEXt, zTXt, tRNS, pCAL).  Others will just save time and make png_info
- * a bit smaller.
- */
-
-/* The size of the png_text structure changed in libpng-1.0.6 when
- * iTXt support was added.  iTXt support was turned off by default through
- * libpng-1.2.x, to support old apps that malloc the png_text structure
- * instead of calling png_set_text() and letting libpng malloc it.  It
- * was turned on by default in libpng-1.4.0.
- */
-
-/* PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED is deprecated. */
-#if defined(PNG_READ_SUPPORTED) && \
-    !defined(PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED) && \
-    !defined(PNG_NO_READ_ANCILLARY_CHUNKS)
-#  define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
-#endif
-
-/* PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED is deprecated. */
-#if defined(PNG_WRITE_SUPPORTED) && \
-    !defined(PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED) && \
-    !defined(PNG_NO_WRITE_ANCILLARY_CHUNKS)
-#  define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
-#endif
-
-#ifdef PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
-
-#ifdef PNG_NO_READ_TEXT
-#  define PNG_NO_READ_iTXt
-#  define PNG_NO_READ_tEXt
-#  define PNG_NO_READ_zTXt
-#endif
-
-#ifndef PNG_NO_READ_bKGD
-#  define PNG_READ_bKGD_SUPPORTED
-#  define PNG_bKGD_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_cHRM
-#  define PNG_READ_cHRM_SUPPORTED
-#  define PNG_cHRM_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_gAMA
-#  define PNG_READ_gAMA_SUPPORTED
-#  define PNG_gAMA_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_hIST
-#  define PNG_READ_hIST_SUPPORTED
-#  define PNG_hIST_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_iCCP
-#  define PNG_READ_iCCP_SUPPORTED
-#  define PNG_iCCP_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_iTXt
-#  ifndef PNG_READ_iTXt_SUPPORTED
-#    define PNG_READ_iTXt_SUPPORTED
-#  endif
-#  ifndef PNG_iTXt_SUPPORTED
-#    define PNG_iTXt_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_READ_oFFs
-#  define PNG_READ_oFFs_SUPPORTED
-#  define PNG_oFFs_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_pCAL
-#  define PNG_READ_pCAL_SUPPORTED
-#  define PNG_pCAL_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_sCAL
-#  define PNG_READ_sCAL_SUPPORTED
-#  define PNG_sCAL_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_pHYs
-#  define PNG_READ_pHYs_SUPPORTED
-#  define PNG_pHYs_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_sBIT
-#  define PNG_READ_sBIT_SUPPORTED
-#  define PNG_sBIT_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_sPLT
-#  define PNG_READ_sPLT_SUPPORTED
-#  define PNG_sPLT_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_sRGB
-#  define PNG_READ_sRGB_SUPPORTED
-#  define PNG_sRGB_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_tEXt
-#  define PNG_READ_tEXt_SUPPORTED
-#  define PNG_tEXt_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_tIME
-#  define PNG_READ_tIME_SUPPORTED
-#  define PNG_tIME_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_tRNS
-#  define PNG_READ_tRNS_SUPPORTED
-#  define PNG_tRNS_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_zTXt
-#  define PNG_READ_zTXt_SUPPORTED
-#  define PNG_zTXt_SUPPORTED
-#endif
-#ifndef PNG_NO_READ_OPT_PLTE
-#  define PNG_READ_OPT_PLTE_SUPPORTED /* only affects support of the */
-#endif                      /* optional PLTE chunk in RGB and RGBA images */
-#if defined(PNG_READ_iTXt_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) || \
-    defined(PNG_READ_zTXt_SUPPORTED)
-#  define PNG_READ_TEXT_SUPPORTED
-#  define PNG_TEXT_SUPPORTED
-#endif
-
-#endif /* PNG_READ_ANCILLARY_CHUNKS_SUPPORTED */
-
-#ifndef PNG_NO_READ_UNKNOWN_CHUNKS
-#  ifndef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-#    define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-#  endif
-#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
-#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
-#  endif
-#  ifndef PNG_READ_USER_CHUNKS_SUPPORTED
-#    define PNG_READ_USER_CHUNKS_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_READ_USER_CHUNKS
-#  ifndef PNG_READ_USER_CHUNKS_SUPPORTED
-#    define PNG_READ_USER_CHUNKS_SUPPORTED
-#  endif
-#  ifndef PNG_USER_CHUNKS_SUPPORTED
-#    define PNG_USER_CHUNKS_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_HANDLE_AS_UNKNOWN
-#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#  endif
-#endif
-
-#ifdef PNG_WRITE_SUPPORTED
-#ifdef PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
-
-#ifdef PNG_NO_WRITE_TEXT
-#  define PNG_NO_WRITE_iTXt
-#  define PNG_NO_WRITE_tEXt
-#  define PNG_NO_WRITE_zTXt
-#endif
-#ifndef PNG_NO_WRITE_bKGD
-#  define PNG_WRITE_bKGD_SUPPORTED
-#  ifndef PNG_bKGD_SUPPORTED
-#    define PNG_bKGD_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_cHRM
-#  define PNG_WRITE_cHRM_SUPPORTED
-#  ifndef PNG_cHRM_SUPPORTED
-#    define PNG_cHRM_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_gAMA
-#  define PNG_WRITE_gAMA_SUPPORTED
-#  ifndef PNG_gAMA_SUPPORTED
-#    define PNG_gAMA_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_hIST
-#  define PNG_WRITE_hIST_SUPPORTED
-#  ifndef PNG_hIST_SUPPORTED
-#    define PNG_hIST_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_iCCP
-#  define PNG_WRITE_iCCP_SUPPORTED
-#  ifndef PNG_iCCP_SUPPORTED
-#    define PNG_iCCP_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_iTXt
-#  ifndef PNG_WRITE_iTXt_SUPPORTED
-#    define PNG_WRITE_iTXt_SUPPORTED
-#  endif
-#  ifndef PNG_iTXt_SUPPORTED
-#    define PNG_iTXt_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_oFFs
-#  define PNG_WRITE_oFFs_SUPPORTED
-#  ifndef PNG_oFFs_SUPPORTED
-#    define PNG_oFFs_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_pCAL
-#  define PNG_WRITE_pCAL_SUPPORTED
-#  ifndef PNG_pCAL_SUPPORTED
-#    define PNG_pCAL_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_sCAL
-#  define PNG_WRITE_sCAL_SUPPORTED
-#  ifndef PNG_sCAL_SUPPORTED
-#    define PNG_sCAL_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_pHYs
-#  define PNG_WRITE_pHYs_SUPPORTED
-#  ifndef PNG_pHYs_SUPPORTED
-#    define PNG_pHYs_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_sBIT
-#  define PNG_WRITE_sBIT_SUPPORTED
-#  ifndef PNG_sBIT_SUPPORTED
-#    define PNG_sBIT_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_sPLT
-#  define PNG_WRITE_sPLT_SUPPORTED
-#  ifndef PNG_sPLT_SUPPORTED
-#    define PNG_sPLT_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_sRGB
-#  define PNG_WRITE_sRGB_SUPPORTED
-#  ifndef PNG_sRGB_SUPPORTED
-#    define PNG_sRGB_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_tEXt
-#  define PNG_WRITE_tEXt_SUPPORTED
-#  ifndef PNG_tEXt_SUPPORTED
-#    define PNG_tEXt_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_tIME
-#  define PNG_WRITE_tIME_SUPPORTED
-#  ifndef PNG_tIME_SUPPORTED
-#    define PNG_tIME_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_tRNS
-#  define PNG_WRITE_tRNS_SUPPORTED
-#  ifndef PNG_tRNS_SUPPORTED
-#    define PNG_tRNS_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_WRITE_zTXt
-#  define PNG_WRITE_zTXt_SUPPORTED
-#  ifndef PNG_zTXt_SUPPORTED
-#    define PNG_zTXt_SUPPORTED
-#  endif
-#endif
-#if defined(PNG_WRITE_iTXt_SUPPORTED) || defined(PNG_WRITE_tEXt_SUPPORTED) || \
-    defined(PNG_WRITE_zTXt_SUPPORTED)
-#  define PNG_WRITE_TEXT_SUPPORTED
-#  ifndef PNG_TEXT_SUPPORTED
-#    define PNG_TEXT_SUPPORTED
-#  endif
-#endif
-
-#ifdef PNG_WRITE_tIME_SUPPORTED
-#  ifndef PNG_NO_CONVERT_tIME
-#    ifndef _WIN32_WCE
-/*   The "tm" structure is not supported on WindowsCE */
-#      ifndef PNG_CONVERT_tIME_SUPPORTED
-#        define PNG_CONVERT_tIME_SUPPORTED
-#      endif
-#   endif
-#  endif
-#endif
-
-#endif /* PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED */
-
-#ifndef PNG_NO_WRITE_FILTER
-#  ifndef PNG_WRITE_FILTER_SUPPORTED
-#    define PNG_WRITE_FILTER_SUPPORTED
-#  endif
-#endif
-
-#ifndef PNG_NO_WRITE_UNKNOWN_CHUNKS
-#  define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
-#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
-#  endif
-#endif
-#ifndef PNG_NO_HANDLE_AS_UNKNOWN
-#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#  endif
-#endif
-#endif /* PNG_WRITE_SUPPORTED */
-
-/* Turn this off to disable png_read_png() and
- * png_write_png() and leave the row_pointers member
- * out of the info structure.
- */
-#ifndef PNG_NO_INFO_IMAGE
-#  define PNG_INFO_IMAGE_SUPPORTED
-#endif
-
-/* Need the time information for converting tIME chunks */
-#ifdef PNG_CONVERT_tIME_SUPPORTED
-     /* "time.h" functions are not supported on WindowsCE */
-#    include <time.h>
-#endif
-
-/* Some typedefs to get us started.  These should be safe on most of the
- * common platforms.  The typedefs should be at least as large as the
- * numbers suggest (a png_uint_32 must be at least 32 bits long), but they
- * don't have to be exactly that size.  Some compilers dislike passing
- * unsigned shorts as function parameters, so you may be better off using
- * unsigned int for png_uint_16.
- */
-
-#if defined(INT_MAX) && (INT_MAX > 0x7ffffffeL)
-typedef unsigned int png_uint_32;
-typedef int png_int_32;
-#else
-typedef unsigned long png_uint_32;
-typedef long png_int_32;
-#endif
-typedef unsigned short png_uint_16;
-typedef short png_int_16;
-typedef unsigned char png_byte;
-
-#ifdef PNG_NO_SIZE_T
-   typedef unsigned int png_size_t;
-#else
-   typedef size_t png_size_t;
-#endif
-#define png_sizeof(x) (sizeof (x))
-
-/* The following is needed for medium model support.  It cannot be in the
- * pngpriv.h header.  Needs modification for other compilers besides
- * MSC.  Model independent support declares all arrays and pointers to be
- * large using the far keyword.  The zlib version used must also support
- * model independent data.  As of version zlib 1.0.4, the necessary changes
- * have been made in zlib.  The USE_FAR_KEYWORD define triggers other
- * changes that are needed. (Tim Wegner)
- */
-
-/* Separate compiler dependencies (problem here is that zlib.h always
- * defines FAR. (SJT)
- */
-#ifdef __BORLANDC__
-#  if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
-#    define LDATA 1
-#  else
-#    define LDATA 0
-#  endif
-   /* GRR:  why is Cygwin in here?  Cygwin is not Borland C... */
-#  if !defined(__WIN32__) && !defined(__FLAT__) && !defined(__CYGWIN__)
-#    define PNG_MAX_MALLOC_64K
-#    if (LDATA != 1)
-#      ifndef FAR
-#        define FAR __far
-#      endif
-#      define USE_FAR_KEYWORD
-#    endif   /* LDATA != 1 */
-     /* Possibly useful for moving data out of default segment.
-      * Uncomment it if you want. Could also define FARDATA as
-      * const if your compiler supports it. (SJT)
-#    define FARDATA FAR
-      */
-#  endif  /* __WIN32__, __FLAT__, __CYGWIN__ */
-#endif   /* __BORLANDC__ */
-
-
-/* Suggest testing for specific compiler first before testing for
- * FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
- * making reliance oncertain keywords suspect. (SJT)
- */
-
-/* MSC Medium model */
-#ifdef FAR
-#  ifdef M_I86MM
-#    define USE_FAR_KEYWORD
-#    define FARDATA FAR
-#    include <dos.h>
-#  endif
-#endif
-
-/* SJT: default case */
-#ifndef FAR
-#  define FAR
-#endif
-
-/* At this point FAR is always defined */
-#ifndef FARDATA
-#  define FARDATA
-#endif
-
-/* Typedef for floating-point numbers that are converted
-   to fixed-point with a multiple of 100,000, e.g., int_gamma */
-typedef png_int_32 png_fixed_point;
-
-/* Add typedefs for pointers */
-typedef void            FAR * png_voidp;
-typedef png_byte        FAR * png_bytep;
-typedef png_uint_32     FAR * png_uint_32p;
-typedef png_int_32      FAR * png_int_32p;
-typedef png_uint_16     FAR * png_uint_16p;
-typedef png_int_16      FAR * png_int_16p;
-typedef PNG_CONST char  FAR * png_const_charp;
-typedef char            FAR * png_charp;
-typedef png_fixed_point FAR * png_fixed_point_p;
-
-#ifndef PNG_NO_STDIO
-typedef FILE                * png_FILE_p;
-#endif
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-typedef double          FAR * png_doublep;
-#endif
-
-/* Pointers to pointers; i.e. arrays */
-typedef png_byte        FAR * FAR * png_bytepp;
-typedef png_uint_32     FAR * FAR * png_uint_32pp;
-typedef png_int_32      FAR * FAR * png_int_32pp;
-typedef png_uint_16     FAR * FAR * png_uint_16pp;
-typedef png_int_16      FAR * FAR * png_int_16pp;
-typedef PNG_CONST char  FAR * FAR * png_const_charpp;
-typedef char            FAR * FAR * png_charpp;
-typedef png_fixed_point FAR * FAR * png_fixed_point_pp;
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-typedef double          FAR * FAR * png_doublepp;
-#endif
-
-/* Pointers to pointers to pointers; i.e., pointer to array */
-typedef char            FAR * FAR * FAR * png_charppp;
-
-/* Define PNG_BUILD_DLL if the module being built is a Windows
- * LIBPNG DLL.
- *
- * Define PNG_USE_DLL if you want to *link* to the Windows LIBPNG DLL.
- * It is equivalent to Microsoft predefined macro _DLL that is
- * automatically defined when you compile using the share
- * version of the CRT (C Run-Time library)
- *
- * The cygwin mods make this behavior a little different:
- * Define PNG_BUILD_DLL if you are building a dll for use with cygwin
- * Define PNG_STATIC if you are building a static library for use with cygwin,
- *   -or- if you are building an application that you want to link to the
- *   static library.
- * PNG_USE_DLL is defined by default (no user action needed) unless one of
- *   the other flags is defined.
- */
-
-#if !defined(PNG_DLL) && (defined(PNG_BUILD_DLL) || defined(PNG_USE_DLL))
-#  define PNG_DLL
-#endif
-
-/* If you define PNGAPI, e.g., with compiler option "-DPNGAPI=__stdcall",
- * you may get warnings regarding the linkage of png_zalloc and png_zfree.
- * Don't ignore those warnings; you must also reset the default calling
- * convention in your compiler to match your PNGAPI, and you must build
- * zlib and your applications the same way you build libpng.
- */
-
-#ifdef __CYGWIN__
-#  undef PNGAPI
-#  define PNGAPI __cdecl
-#  undef PNG_IMPEXP
-#  define PNG_IMPEXP
-#endif
-
-#ifdef __WATCOMC__
-#  ifndef PNGAPI
-#    define PNGAPI
-#  endif
-#endif
-
-#if defined(__MINGW32__) && !defined(PNG_MODULEDEF)
-#  ifndef PNG_NO_MODULEDEF
-#    define PNG_NO_MODULEDEF
-#  endif
-#endif
-
-#if !defined(PNG_IMPEXP) && defined(PNG_BUILD_DLL) && !defined(PNG_NO_MODULEDEF)
-#  define PNG_IMPEXP
-#endif
-
-#if defined(PNG_DLL) || defined(_DLL) || defined(__DLL__ ) || \
-    (( defined(_Windows) || defined(_WINDOWS) || \
-       defined(WIN32) || defined(_WIN32) || defined(__WIN32__) ))
-
-#  ifndef PNGAPI
-#     if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
-#        define PNGAPI __cdecl
-#     else
-#        define PNGAPI _cdecl
-#     endif
-#  endif
-
-#  if !defined(PNG_IMPEXP) && (!defined(PNG_DLL) || \
-       0 /* WINCOMPILER_WITH_NO_SUPPORT_FOR_DECLIMPEXP */)
-#     define PNG_IMPEXP
-#  endif
-
-#  ifndef PNG_IMPEXP
-
-#    define PNG_EXPORT_TYPE1(type,symbol)  PNG_IMPEXP type PNGAPI symbol
-#    define PNG_EXPORT_TYPE2(type,symbol)  type PNG_IMPEXP PNGAPI symbol
-
-     /* Borland/Microsoft */
-#    if defined(_MSC_VER) || defined(__BORLANDC__)
-#      if (_MSC_VER >= 800) || (__BORLANDC__ >= 0x500)
-#         define PNG_EXPORT PNG_EXPORT_TYPE1
-#      else
-#         define PNG_EXPORT PNG_EXPORT_TYPE2
-#         ifdef PNG_BUILD_DLL
-#            define PNG_IMPEXP __export
-#         else
-#            define PNG_IMPEXP /*__import */ /* doesn't exist AFAIK in VC++ */
-#         endif                              /* Exists in Borland C++ for
-                                                C++ classes (== huge) */
-#      endif
-#    endif
-
-#    ifndef PNG_IMPEXP
-#      ifdef PNG_BUILD_DLL
-#        define PNG_IMPEXP __declspec(dllexport)
-#      else
-#        define PNG_IMPEXP __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* PNG_IMPEXP */
-#else /* !(DLL || non-cygwin WINDOWS) */
-#   if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
-#     ifndef PNGAPI
-#       define PNGAPI _System
-#     endif
-#   else
-#     if 0 /* ... other platforms, with other meanings */
-#     endif
-#   endif
-#endif
-
-#ifndef PNGAPI
-#  define PNGAPI
-#endif
-#ifndef PNG_IMPEXP
-#  define PNG_IMPEXP
-#endif
-
-#ifdef PNG_BUILDSYMS
-#  ifndef PNG_EXPORT
-#    define PNG_EXPORT(type,symbol) PNG_FUNCTION_EXPORT symbol END
-#  endif
-#endif
-
-#ifndef PNG_EXPORT
-#  define PNG_EXPORT(type,symbol) PNG_IMPEXP type PNGAPI symbol
-#endif
-
-#define PNG_USE_LOCAL_ARRAYS /* Not used in libpng, defined for legacy apps */
-
-/* Support for compiler specific function attributes.  These are used
- * so that where compiler support is available incorrect use of API
- * functions in png.h will generate compiler warnings.
- *
- * Added at libpng-1.2.41.
- */
-
-#ifndef PNG_NO_PEDANTIC_WARNINGS
-#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
-#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
-#  endif
-#endif
-
-#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
-/* Support for compiler specific function attributes.  These are used
- * so that where compiler support is available incorrect use of API
- * functions in png.h will generate compiler warnings.  Added at libpng
- * version 1.2.41.
- */
-#  ifdef __GNUC__
-#    ifndef PNG_USE_RESULT
-#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
-#    endif
-#    ifndef PNG_NORETURN
-#      define PNG_NORETURN   __attribute__((__noreturn__))
-#    endif
-#    ifndef PNG_ALLOCATED
-#      define PNG_ALLOCATED  __attribute__((__malloc__))
-#    endif
-
-    /* This specifically protects structure members that should only be
-     * accessed from within the library, therefore should be empty during
-     * a library build.
-     */
-#    ifndef PNG_DEPRECATED
-#      define PNG_DEPRECATED __attribute__((__deprecated__))
-#    endif
-#    ifndef PNG_DEPSTRUCT
-#      define PNG_DEPSTRUCT  __attribute__((__deprecated__))
-#    endif
-#    ifndef PNG_PRIVATE
-#      if 0 /* Doesn't work so we use deprecated instead*/
-#        define PNG_PRIVATE \
-          __attribute__((warning("This function is not exported by libpng.")))
-#      else
-#        define PNG_PRIVATE \
-          __attribute__((__deprecated__))
-#      endif
-#    endif /* PNG_PRIVATE */
-#  endif /* __GNUC__ */
-#endif /* PNG_PEDANTIC_WARNINGS */
-
-#ifndef PNG_DEPRECATED
-#  define PNG_DEPRECATED  /* Use of this function is deprecated */
-#endif
-#ifndef PNG_USE_RESULT
-#  define PNG_USE_RESULT  /* The result of this function must be checked */
-#endif
-#ifndef PNG_NORETURN
-#  define PNG_NORETURN    /* This function does not return */
-#endif
-#ifndef PNG_ALLOCATED
-#  define PNG_ALLOCATED   /* The result of the function is new memory */
-#endif
-#ifndef PNG_DEPSTRUCT
-#  define PNG_DEPSTRUCT   /* Access to this struct member is deprecated */
-#endif
-#ifndef PNG_PRIVATE
-#  define PNG_PRIVATE     /* This is a private libpng function */
-#endif
-
-/* Users may want to use these so they are not private.  Any library
- * functions that are passed far data must be model-independent.
- */
-
-/* memory model/platform independent fns */
-#ifndef PNG_ABORT
-#  if (defined(_Windows) || defined(_WINDOWS) || defined(_WINDOWS_))
-#     define PNG_ABORT() ExitProcess(0)
-#  else
-#     define PNG_ABORT() abort()
-#  endif
-#endif
-
-#ifdef USE_FAR_KEYWORD
-/* Use this to make far-to-near assignments */
-#  define CHECK   1
-#  define NOCHECK 0
-#  define CVT_PTR(ptr) (png_far_to_near(png_ptr,ptr,CHECK))
-#  define CVT_PTR_NOCHECK(ptr) (png_far_to_near(png_ptr,ptr,NOCHECK))
-#  define png_strcpy  _fstrcpy
-#  define png_strncpy _fstrncpy   /* Added to v 1.2.6 */
-#  define png_strlen  _fstrlen
-#  define png_memcmp  _fmemcmp    /* SJT: added */
-#  define png_memcpy  _fmemcpy
-#  define png_memset  _fmemset
-#  define png_sprintf sprintf
-#else
-#  if (defined(_Windows) || defined(_WINDOWS) || defined(_WINDOWS_))
-#    /* Favor Windows over C runtime fns */
-#    define CVT_PTR(ptr)         (ptr)
-#    define CVT_PTR_NOCHECK(ptr) (ptr)
-#    define png_strcpy  lstrcpyA
-#    define png_strncpy lstrcpynA
-#    define png_strlen  lstrlenA
-#    define png_memcmp  memcmp
-#    define png_memcpy  CopyMemory
-#    define png_memset  memset
-#    define png_sprintf wsprintfA
-#  else
-#    define CVT_PTR(ptr)         (ptr)
-#    define CVT_PTR_NOCHECK(ptr) (ptr)
-#    define png_strcpy  strcpy
-#    define png_strncpy strncpy     /* Added to v 1.2.6 */
-#    define png_strlen  strlen
-#    define png_memcmp  memcmp      /* SJT: added */
-#    define png_memcpy  memcpy
-#    define png_memset  memset
-#    define png_sprintf sprintf
-#  endif
-#endif
-
-#ifndef PNG_NO_SNPRINTF
-#  ifdef _MSC_VER
-#    define png_snprintf _snprintf   /* Added to v 1.2.19 */
-#    define png_snprintf2 _snprintf
-#    define png_snprintf6 _snprintf
-#  else
-#    define png_snprintf snprintf   /* Added to v 1.2.19 */
-#    define png_snprintf2 snprintf
-#    define png_snprintf6 snprintf
-#  endif
-#else
-   /* You don't have or don't want to use snprintf().  Caution: Using
-    * sprintf instead of snprintf exposes your application to accidental
-    * or malevolent buffer overflows.  If you don't have snprintf()
-    * as a general rule you should provide one (you can get one from
-    * Portable OpenSSH).
-    */
-#  define png_snprintf(s1,n,fmt,x1) png_sprintf(s1,fmt,x1)
-#  define png_snprintf2(s1,n,fmt,x1,x2) png_sprintf(s1,fmt,x1,x2)
-#  define png_snprintf6(s1,n,fmt,x1,x2,x3,x4,x5,x6) \
-      png_sprintf(s1,fmt,x1,x2,x3,x4,x5,x6)
-#endif
-
-/* png_alloc_size_t is guaranteed to be no smaller than png_size_t,
- * and no smaller than png_uint_32.  Casts from png_size_t or png_uint_32
- * to png_alloc_size_t are not necessary; in fact, it is recommended
- * not to use them at all so that the compiler can complain when something
- * turns out to be problematic.
- * Casts in the other direction (from png_alloc_size_t to png_size_t or
- * png_uint_32) should be explicitly applied; however, we do not expect
- * to encounter practical situations that require such conversions.
- */
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   typedef unsigned long png_alloc_size_t;
-#else
-#  if defined(_MSC_VER) && defined(MAXSEG_64K)
-     typedef unsigned long    png_alloc_size_t;
-#  else
-     /* This is an attempt to detect an old Windows system where (int) is
-      * actually 16 bits, in that case png_malloc must have an argument with a
-      * bigger size to accomodate the requirements of the library.
-      */
-#    if (defined(_Windows) || defined(_WINDOWS) || defined(_WINDOWS_)) && \
-        (!defined(INT_MAX) || INT_MAX <= 0x7ffffffeL)
-       typedef DWORD         png_alloc_size_t;
-#    else
-       typedef png_size_t    png_alloc_size_t;
-#    endif
-#  endif
-#endif
-/* End of memory model/platform independent support */
-
-/* Just a little check that someone hasn't tried to define something
- * contradictory.
- */
-#if (PNG_ZBUF_SIZE > 65536L) && defined(PNG_MAX_MALLOC_64K)
-#  undef PNG_ZBUF_SIZE
-#  define PNG_ZBUF_SIZE 65536L
-#endif
-
-
-/* Added at libpng-1.2.8 */
-#endif /* PNG_VERSION_INFO_ONLY */
-
-#endif /* PNGCONF_H */
diff --git a/thirdparty/libpng/pngerror.c b/thirdparty/libpng/pngerror.c
deleted file mode 100644
index 633eae2..0000000
--- a/thirdparty/libpng/pngerror.c
+++ /dev/null
@@ -1,402 +0,0 @@
-
-/* pngerror.c - stub functions for i/o and memory allocation
- *
- * Last changed in libpng 1.4.0 [January 3, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all error handling.  Users who
- * need special error handling are expected to write replacement functions
- * and use png_set_error_fn() to use those functions.  See the instructions
- * at each function.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#include "pngpriv.h"
-
-static void /* PRIVATE */
-png_default_error PNGARG((png_structp png_ptr,
-  png_const_charp error_message)) PNG_NORETURN;
-#ifdef PNG_WARNINGS_SUPPORTED
-static void /* PRIVATE */
-png_default_warning PNGARG((png_structp png_ptr,
-  png_const_charp warning_message));
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-/* This function is called whenever there is a fatal error.  This function
- * should not be changed.  If there is a need to handle errors differently,
- * you should supply a replacement error function and use png_set_error_fn()
- * to replace the error function at run-time.
- */
-#ifdef PNG_ERROR_TEXT_SUPPORTED
-void PNGAPI
-png_error(png_structp png_ptr, png_const_charp error_message)
-{
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   char msg[16];
-   if (png_ptr != NULL)
-   {
-     if (png_ptr->flags&
-       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
-     {
-       if (*error_message == PNG_LITERAL_SHARP)
-       {
-           /* Strip "#nnnn " from beginning of error message. */
-           int offset;
-           for (offset = 1; offset<15; offset++)
-              if (error_message[offset] == ' ')
-                  break;
-           if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
-           {
-              int i;
-              for (i = 0; i < offset - 1; i++)
-                 msg[i] = error_message[i + 1];
-              msg[i - 1] = '\0';
-              error_message = msg;
-           }
-           else
-              error_message += offset;
-       }
-       else
-       {
-           if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
-           {
-              msg[0] = '0';
-              msg[1] = '\0';
-              error_message = msg;
-           }
-       }
-     }
-   }
-#endif
-   if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, error_message);
-
-   /* If the custom handler doesn't exist, or if it returns,
-      use the default handler, which will not return. */
-   png_default_error(png_ptr, error_message);
-}
-#else
-void PNGAPI
-png_err(png_structp png_ptr)
-{
-   if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, '\0');
-
-   /* If the custom handler doesn't exist, or if it returns,
-      use the default handler, which will not return. */
-   png_default_error(png_ptr, '\0');
-}
-#endif /* PNG_ERROR_TEXT_SUPPORTED */
-
-#ifdef PNG_WARNINGS_SUPPORTED
-/* This function is called whenever there is a non-fatal error.  This function
- * should not be changed.  If there is a need to handle warnings differently,
- * you should supply a replacement warning function and use
- * png_set_error_fn() to replace the warning function at run-time.
- */
-void PNGAPI
-png_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-   int offset = 0;
-   if (png_ptr != NULL)
-   {
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (png_ptr->flags&
-     (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
-#endif
-     {
-       if (*warning_message == PNG_LITERAL_SHARP)
-       {
-           for (offset = 1; offset < 15; offset++)
-              if (warning_message[offset] == ' ')
-                  break;
-       }
-     }
-   }
-   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
-      (*(png_ptr->warning_fn))(png_ptr, warning_message + offset);
-   else
-      png_default_warning(png_ptr, warning_message + offset);
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-void PNGAPI
-png_benign_error(png_structp png_ptr, png_const_charp error_message)
-{
-  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
-    png_warning(png_ptr, error_message);
-  else
-    png_error(png_ptr, error_message);
-}
-#endif
-
-/* These utilities are used internally to build an error message that relates
- * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
- * this is used to prefix the message.  The message is limited in length
- * to 63 bytes, the name characters are output as hex digits wrapped in []
- * if the character is invalid.
- */
-#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
-static PNG_CONST char png_digit[16] = {
-   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-   'A', 'B', 'C', 'D', 'E', 'F'
-};
-
-#define PNG_MAX_ERROR_TEXT 64
-#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_ERROR_TEXT_SUPPORTED)
-static void /* PRIVATE */
-png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
-   error_message)
-{
-   int iout = 0, iin = 0;
-
-   while (iin < 4)
-   {
-      int c = png_ptr->chunk_name[iin++];
-      if (isnonalpha(c))
-      {
-         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
-         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
-         buffer[iout++] = png_digit[c & 0x0f];
-         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
-      }
-      else
-      {
-         buffer[iout++] = (png_byte)c;
-      }
-   }
-
-   if (error_message == NULL)
-      buffer[iout] = '\0';
-   else
-   {
-      buffer[iout++] = ':';
-      buffer[iout++] = ' ';
-      png_memcpy(buffer + iout, error_message, PNG_MAX_ERROR_TEXT);
-      buffer[iout + PNG_MAX_ERROR_TEXT - 1] = '\0';
-   }
-}
-
-#ifdef PNG_READ_SUPPORTED
-void PNGAPI
-png_chunk_error(png_structp png_ptr, png_const_charp error_message)
-{
-   char msg[18+PNG_MAX_ERROR_TEXT];
-   if (png_ptr == NULL)
-     png_error(png_ptr, error_message);
-   else
-   {
-     png_format_buffer(png_ptr, msg, error_message);
-     png_error(png_ptr, msg);
-   }
-}
-#endif /* PNG_READ_SUPPORTED */
-#endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */
-
-#ifdef PNG_WARNINGS_SUPPORTED
-void PNGAPI
-png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-   char msg[18+PNG_MAX_ERROR_TEXT];
-   if (png_ptr == NULL)
-     png_warning(png_ptr, warning_message);
-   else
-   {
-     png_format_buffer(png_ptr, msg, warning_message);
-     png_warning(png_ptr, msg);
-   }
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-#ifdef PNG_READ_SUPPORTED
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-void PNGAPI
-png_chunk_benign_error(png_structp png_ptr, png_const_charp error_message)
-{
-  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
-    png_chunk_warning(png_ptr, error_message);
-  else
-    png_chunk_error(png_ptr, error_message);
-}
-#endif
-#endif /* PNG_READ_SUPPORTED */
-
-#ifdef PNG_SETJMP_SUPPORTED
-/* This API only exists if ANSI-C style error handling is used,
- * otherwise it is necessary for png_default_error to be overridden.
- */
-jmp_buf* PNGAPI
-png_set_longjmp_fn(png_structp png_ptr, png_longjmp_ptr longjmp_fn,
-    size_t jmp_buf_size)
-{
-   if (png_ptr == NULL || jmp_buf_size != png_sizeof(jmp_buf))
-      return NULL;
-
-   png_ptr->longjmp_fn = longjmp_fn;
-   return &png_ptr->jmpbuf;
-}
-#endif
-
-/* This is the default error handling function.  Note that replacements for
- * this function MUST NOT RETURN, or the program will likely crash.  This
- * function is used by default, or if the program supplies NULL for the
- * error function pointer in png_set_error_fn().
- */
-static void /* PRIVATE */
-png_default_error(png_structp png_ptr, png_const_charp error_message)
-{
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*error_message == PNG_LITERAL_SHARP)
-   {
-     /* Strip "#nnnn " from beginning of error message. */
-     int offset;
-     char error_number[16];
-     for (offset = 0; offset<15; offset++)
-     {
-         error_number[offset] = error_message[offset + 1];
-         if (error_message[offset] == ' ')
-             break;
-     }
-     if ((offset > 1) && (offset < 15))
-     {
-       error_number[offset - 1] = '\0';
-       fprintf(stderr, "libpng error no. %s: %s",
-          error_number, error_message + offset + 1);
-       fprintf(stderr, PNG_STRING_NEWLINE);
-     }
-     else
-     {
-       fprintf(stderr, "libpng error: %s, offset=%d",
-          error_message, offset);
-       fprintf(stderr, PNG_STRING_NEWLINE);
-     }
-   }
-   else
-#endif
-   {
-      fprintf(stderr, "libpng error: %s", error_message);
-      fprintf(stderr, PNG_STRING_NEWLINE);
-   }
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   if (png_ptr && png_ptr->longjmp_fn)
-   {
-#  ifdef USE_FAR_KEYWORD
-   {
-      jmp_buf jmpbuf;
-      png_memcpy(jmpbuf, png_ptr->jmpbuf, png_sizeof(jmp_buf));
-     png_ptr->longjmp_fn(jmpbuf, 1);
-   }
-#  else
-   png_ptr->longjmp_fn(png_ptr->jmpbuf, 1);
-#  endif
-   }
-#endif
-   /* Here if not setjmp support or if png_ptr is null. */
-   PNG_ABORT();
-#ifndef PNG_CONSOLE_IO_SUPPORTED
-   error_message = error_message; /* Make compiler happy */
-#endif
-}
-
-#ifdef PNG_WARNINGS_SUPPORTED
-/* This function is called when there is a warning, but the library thinks
- * it can continue anyway.  Replacement functions don't have to do anything
- * here if you don't want them to.  In the default configuration, png_ptr is
- * not used, but it is passed in case it may be useful.
- */
-static void /* PRIVATE */
-png_default_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*warning_message == PNG_LITERAL_SHARP)
-   {
-     int offset;
-     char warning_number[16];
-     for (offset = 0; offset < 15; offset++)
-     {
-        warning_number[offset] = warning_message[offset + 1];
-        if (warning_message[offset] == ' ')
-            break;
-     }
-     if ((offset > 1) && (offset < 15))
-     {
-       warning_number[offset + 1] = '\0';
-       fprintf(stderr, "libpng warning no. %s: %s",
-          warning_number, warning_message + offset);
-       fprintf(stderr, PNG_STRING_NEWLINE);
-     }
-     else
-     {
-       fprintf(stderr, "libpng warning: %s",
-          warning_message);
-       fprintf(stderr, PNG_STRING_NEWLINE);
-     }
-   }
-   else
-#  endif
-   {
-     fprintf(stderr, "libpng warning: %s", warning_message);
-     fprintf(stderr, PNG_STRING_NEWLINE);
-   }
-#else
-   warning_message = warning_message; /* Make compiler happy */
-#endif
-   png_ptr = png_ptr; /* Make compiler happy */
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-/* This function is called when the application wants to use another method
- * of handling errors and warnings.  Note that the error function MUST NOT
- * return to the calling routine or serious problems will occur.  The return
- * method used in the default routine calls longjmp(png_ptr->jmpbuf, 1)
- */
-void PNGAPI
-png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warning_fn)
-{
-   if (png_ptr == NULL)
-      return;
-   png_ptr->error_ptr = error_ptr;
-   png_ptr->error_fn = error_fn;
-   png_ptr->warning_fn = warning_fn;
-}
-
-
-/* This function returns a pointer to the error_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy and png_read_destroy are called.
- */
-png_voidp PNGAPI
-png_get_error_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return NULL;
-   return ((png_voidp)png_ptr->error_ptr);
-}
-
-
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-void PNGAPI
-png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
-{
-   if (png_ptr != NULL)
-   {
-     png_ptr->flags &=
-       ((~(PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
-   }
-}
-#endif
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngget.c b/thirdparty/libpng/pngget.c
deleted file mode 100644
index abe721b..0000000
--- a/thirdparty/libpng/pngget.c
+++ /dev/null
@@ -1,925 +0,0 @@
-
-/* pngget.c - retrieval of values from info struct
- *
- * Last changed in libpng 1.4.2 [May 6, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#include "pngpriv.h"
-
-png_uint_32 PNGAPI
-png_get_valid(png_structp png_ptr, png_infop info_ptr, png_uint_32 flag)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return(info_ptr->valid & flag);
-
-   else
-      return(0);
-}
-
-png_size_t PNGAPI
-png_get_rowbytes(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return(info_ptr->rowbytes);
-
-   else
-      return(0);
-}
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-png_bytepp PNGAPI
-png_get_rows(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return(info_ptr->row_pointers);
-
-   else
-      return(0);
-}
-#endif
-
-#ifdef PNG_EASY_ACCESS_SUPPORTED
-/* Easy access to info, added in libpng-0.99 */
-png_uint_32 PNGAPI
-png_get_image_width(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->width;
-
-   return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_image_height(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->height;
-
-   return (0);
-}
-
-png_byte PNGAPI
-png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->bit_depth;
-
-   return (0);
-}
-
-png_byte PNGAPI
-png_get_color_type(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->color_type;
-
-   return (0);
-}
-
-png_byte PNGAPI
-png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->filter_type;
-
-   return (0);
-}
-
-png_byte PNGAPI
-png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->interlace_type;
-
-   return (0);
-}
-
-png_byte PNGAPI
-png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return info_ptr->compression_type;
-
-   return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-#ifdef PNG_pHYs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_pHYs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_x_pixels_per_meter");
-
-      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
-          return (0);
-
-      else
-          return (info_ptr->x_pixels_per_unit);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-#ifdef PNG_pHYs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_pHYs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_y_pixels_per_meter");
-
-      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
-          return (0);
-
-      else
-          return (info_ptr->y_pixels_per_unit);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-#ifdef PNG_pHYs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_pHYs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");
-
-      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
-         info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
-          return (0);
-
-      else
-          return (info_ptr->x_pixels_per_unit);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-float PNGAPI
-png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
-   {
-   if (png_ptr != NULL && info_ptr != NULL)
-#ifdef PNG_pHYs_SUPPORTED
-
-   if (info_ptr->valid & PNG_INFO_pHYs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio");
-
-      if (info_ptr->x_pixels_per_unit == 0)
-         return ((float)0.0);
-
-      else
-         return ((float)((float)info_ptr->y_pixels_per_unit
-            /(float)info_ptr->x_pixels_per_unit));
-   }
-#else
-      return (0.0);
-#endif
-   return ((float)0.0);
-}
-#endif
-
-png_int_32 PNGAPI
-png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-#ifdef PNG_oFFs_SUPPORTED
-
-   if (info_ptr->valid & PNG_INFO_oFFs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
-
-      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
-          return (0);
-
-      else
-          return (info_ptr->x_offset);
-   }
-#else
-      return (0);
-#endif
-   return (0);
-}
-
-png_int_32 PNGAPI
-png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-
-#ifdef PNG_oFFs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_oFFs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
-
-      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
-          return (0);
-
-      else
-          return (info_ptr->y_offset);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-png_int_32 PNGAPI
-png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-
-#ifdef PNG_oFFs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_oFFs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
-
-      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
-          return (0);
-
-      else
-          return (info_ptr->x_offset);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-png_int_32 PNGAPI
-png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-
-#ifdef PNG_oFFs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_oFFs)
-   {
-      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
-
-      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
-          return (0);
-
-      else
-          return (info_ptr->y_offset);
-   }
-#else
-   return (0);
-#endif
-   return (0);
-}
-
-#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
-png_uint_32 PNGAPI
-png_get_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
-{
-   return ((png_uint_32)((float)png_get_pixels_per_meter(png_ptr, info_ptr)
-     *.0254 +.5));
-}
-
-png_uint_32 PNGAPI
-png_get_x_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
-{
-   return ((png_uint_32)((float)png_get_x_pixels_per_meter(png_ptr, info_ptr)
-     *.0254 +.5));
-}
-
-png_uint_32 PNGAPI
-png_get_y_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
-{
-   return ((png_uint_32)((float)png_get_y_pixels_per_meter(png_ptr, info_ptr)
-     *.0254 +.5));
-}
-
-float PNGAPI
-png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)
-{
-   return ((float)png_get_x_offset_microns(png_ptr, info_ptr)
-     *.00003937);
-}
-
-float PNGAPI
-png_get_y_offset_inches(png_structp png_ptr, png_infop info_ptr)
-{
-   return ((float)png_get_y_offset_microns(png_ptr, info_ptr)
-     *.00003937);
-}
-
-#ifdef PNG_pHYs_SUPPORTED
-png_uint_32 PNGAPI
-png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
-{
-   png_uint_32 retval = 0;
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
-   {
-      png_debug1(1, "in %s retrieval function", "pHYs");
-
-      if (res_x != NULL)
-      {
-         *res_x = info_ptr->x_pixels_per_unit;
-         retval |= PNG_INFO_pHYs;
-      }
-      if (res_y != NULL)
-      {
-         *res_y = info_ptr->y_pixels_per_unit;
-         retval |= PNG_INFO_pHYs;
-      }
-      if (unit_type != NULL)
-      {
-         *unit_type = (int)info_ptr->phys_unit_type;
-         retval |= PNG_INFO_pHYs;
-         if (*unit_type == 1)
-         {
-            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
-            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
-         }
-      }
-   }
-   return (retval);
-}
-#endif /* PNG_pHYs_SUPPORTED */
-#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */
-
-/* png_get_channels really belongs in here, too, but it's been around longer */
-
-#endif  /* PNG_EASY_ACCESS_SUPPORTED */
-
-png_byte PNGAPI
-png_get_channels(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return(info_ptr->channels);
-   else
-      return (0);
-}
-
-png_bytep PNGAPI
-png_get_signature(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr != NULL && info_ptr != NULL)
-      return(info_ptr->signature);
-   else
-      return (NULL);
-}
-
-#ifdef PNG_bKGD_SUPPORTED
-png_uint_32 PNGAPI
-png_get_bKGD(png_structp png_ptr, png_infop info_ptr,
-   png_color_16p *background)
-{
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
-      && background != NULL)
-   {
-      png_debug1(1, "in %s retrieval function", "bKGD");
-
-      *background = &(info_ptr->background);
-      return (PNG_INFO_bKGD);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_cHRM(png_structp png_ptr, png_infop info_ptr,
-   double *white_x, double *white_y, double *red_x, double *red_y,
-   double *green_x, double *green_y, double *blue_x, double *blue_y)
-{
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
-   {
-      png_debug1(1, "in %s retrieval function", "cHRM");
-
-      if (white_x != NULL)
-         *white_x = (double)info_ptr->x_white;
-      if (white_y != NULL)
-         *white_y = (double)info_ptr->y_white;
-      if (red_x != NULL)
-         *red_x = (double)info_ptr->x_red;
-      if (red_y != NULL)
-         *red_y = (double)info_ptr->y_red;
-      if (green_x != NULL)
-         *green_x = (double)info_ptr->x_green;
-      if (green_y != NULL)
-         *green_y = (double)info_ptr->y_green;
-      if (blue_x != NULL)
-         *blue_x = (double)info_ptr->x_blue;
-      if (blue_y != NULL)
-         *blue_y = (double)info_ptr->y_blue;
-      return (PNG_INFO_cHRM);
-   }
-   return (0);
-}
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
-   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
-   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
-   png_fixed_point *blue_x, png_fixed_point *blue_y)
-{
-   png_debug1(1, "in %s retrieval function", "cHRM");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
-   {
-      if (white_x != NULL)
-         *white_x = info_ptr->int_x_white;
-      if (white_y != NULL)
-         *white_y = info_ptr->int_y_white;
-      if (red_x != NULL)
-         *red_x = info_ptr->int_x_red;
-      if (red_y != NULL)
-         *red_y = info_ptr->int_y_red;
-      if (green_x != NULL)
-         *green_x = info_ptr->int_x_green;
-      if (green_y != NULL)
-         *green_y = info_ptr->int_y_green;
-      if (blue_x != NULL)
-         *blue_x = info_ptr->int_x_blue;
-      if (blue_y != NULL)
-         *blue_y = info_ptr->int_y_blue;
-      return (PNG_INFO_cHRM);
-   }
-   return (0);
-}
-#endif
-#endif
-
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_gAMA(png_structp png_ptr, png_infop info_ptr, double *file_gamma)
-{
-   png_debug1(1, "in %s retrieval function", "gAMA");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
-      && file_gamma != NULL)
-   {
-      *file_gamma = (double)info_ptr->gamma;
-      return (PNG_INFO_gAMA);
-   }
-   return (0);
-}
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
-    png_fixed_point *int_file_gamma)
-{
-   png_debug1(1, "in %s retrieval function", "gAMA");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
-      && int_file_gamma != NULL)
-   {
-      *int_file_gamma = info_ptr->int_gamma;
-      return (PNG_INFO_gAMA);
-   }
-   return (0);
-}
-#endif
-#endif
-
-#ifdef PNG_sRGB_SUPPORTED
-png_uint_32 PNGAPI
-png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
-{
-   png_debug1(1, "in %s retrieval function", "sRGB");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
-      && file_srgb_intent != NULL)
-   {
-      *file_srgb_intent = (int)info_ptr->srgb_intent;
-      return (PNG_INFO_sRGB);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-png_uint_32 PNGAPI
-png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
-             png_charpp name, int *compression_type,
-             png_charpp profile, png_uint_32 *proflen)
-{
-   png_debug1(1, "in %s retrieval function", "iCCP");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
-      && name != NULL && profile != NULL && proflen != NULL)
-   {
-      *name = info_ptr->iccp_name;
-      *profile = info_ptr->iccp_profile;
-      /* Compression_type is a dummy so the API won't have to change
-       * if we introduce multiple compression types later.
-       */
-      *proflen = (int)info_ptr->iccp_proflen;
-      *compression_type = (int)info_ptr->iccp_compression;
-      return (PNG_INFO_iCCP);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
-             png_sPLT_tpp spalettes)
-{
-   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
-   {
-     *spalettes = info_ptr->splt_palettes;
-     return ((png_uint_32)info_ptr->splt_palettes_num);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-png_uint_32 PNGAPI
-png_get_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist)
-{
-   png_debug1(1, "in %s retrieval function", "hIST");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
-      && hist != NULL)
-   {
-      *hist = info_ptr->hist;
-      return (PNG_INFO_hIST);
-   }
-   return (0);
-}
-#endif
-
-png_uint_32 PNGAPI
-png_get_IHDR(png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 *width, png_uint_32 *height, int *bit_depth,
-   int *color_type, int *interlace_type, int *compression_type,
-   int *filter_type)
-
-{
-   png_debug1(1, "in %s retrieval function", "IHDR");
-
-   if (png_ptr == NULL || info_ptr == NULL || width == NULL ||
-       height == NULL || bit_depth == NULL || color_type == NULL)
-      return (0);
-
-   *width = info_ptr->width;
-   *height = info_ptr->height;
-   *bit_depth = info_ptr->bit_depth;
-   *color_type = info_ptr->color_type;
-
-   if (compression_type != NULL)
-      *compression_type = info_ptr->compression_type;
-
-   if (filter_type != NULL)
-      *filter_type = info_ptr->filter_type;
-
-   if (interlace_type != NULL)
-      *interlace_type = info_ptr->interlace_type;
-
-   /* This is redundant if we can be sure that the info_ptr values were all
-    * assigned in png_set_IHDR().  We do the check anyhow in case an
-    * application has ignored our advice not to mess with the members
-    * of info_ptr directly.
-    */
-   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
-       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
-       info_ptr->compression_type, info_ptr->filter_type);
-
-   return (1);
-}
-
-#ifdef PNG_oFFs_SUPPORTED
-png_uint_32 PNGAPI
-png_get_oFFs(png_structp png_ptr, png_infop info_ptr,
-   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
-{
-   png_debug1(1, "in %s retrieval function", "oFFs");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
-      && offset_x != NULL && offset_y != NULL && unit_type != NULL)
-   {
-      *offset_x = info_ptr->x_offset;
-      *offset_y = info_ptr->y_offset;
-      *unit_type = (int)info_ptr->offset_unit_type;
-      return (PNG_INFO_oFFs);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-png_uint_32 PNGAPI
-png_get_pCAL(png_structp png_ptr, png_infop info_ptr,
-   png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
-   png_charp *units, png_charpp *params)
-{
-   png_debug1(1, "in %s retrieval function", "pCAL");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
-       && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
-       nparams != NULL && units != NULL && params != NULL)
-   {
-      *purpose = info_ptr->pcal_purpose;
-      *X0 = info_ptr->pcal_X0;
-      *X1 = info_ptr->pcal_X1;
-      *type = (int)info_ptr->pcal_type;
-      *nparams = (int)info_ptr->pcal_nparams;
-      *units = info_ptr->pcal_units;
-      *params = info_ptr->pcal_params;
-      return (PNG_INFO_pCAL);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
-             int *unit, double *width, double *height)
-{
-    if (png_ptr != NULL && info_ptr != NULL &&
-        (info_ptr->valid & PNG_INFO_sCAL))
-    {
-        *unit = info_ptr->scal_unit;
-        *width = info_ptr->scal_pixel_width;
-        *height = info_ptr->scal_pixel_height;
-        return (PNG_INFO_sCAL);
-    }
-    return(0);
-}
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
-             int *unit, png_charpp width, png_charpp height)
-{
-    if (png_ptr != NULL && info_ptr != NULL &&
-        (info_ptr->valid & PNG_INFO_sCAL))
-    {
-        *unit = info_ptr->scal_unit;
-        *width = info_ptr->scal_s_width;
-        *height = info_ptr->scal_s_height;
-        return (PNG_INFO_sCAL);
-    }
-    return(0);
-}
-#endif
-#endif
-#endif
-
-#ifdef PNG_pHYs_SUPPORTED
-png_uint_32 PNGAPI
-png_get_pHYs(png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
-{
-   png_uint_32 retval = 0;
-
-   png_debug1(1, "in %s retrieval function", "pHYs");
-
-   if (png_ptr != NULL && info_ptr != NULL &&
-      (info_ptr->valid & PNG_INFO_pHYs))
-   {
-      if (res_x != NULL)
-      {
-         *res_x = info_ptr->x_pixels_per_unit;
-         retval |= PNG_INFO_pHYs;
-      }
-
-      if (res_y != NULL)
-      {
-         *res_y = info_ptr->y_pixels_per_unit;
-         retval |= PNG_INFO_pHYs;
-      }
-
-      if (unit_type != NULL)
-      {
-         *unit_type = (int)info_ptr->phys_unit_type;
-         retval |= PNG_INFO_pHYs;
-      }
-   }
-   return (retval);
-}
-#endif
-
-png_uint_32 PNGAPI
-png_get_PLTE(png_structp png_ptr, png_infop info_ptr, png_colorp *palette,
-   int *num_palette)
-{
-   png_debug1(1, "in %s retrieval function", "PLTE");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
-       && palette != NULL)
-   {
-      *palette = info_ptr->palette;
-      *num_palette = info_ptr->num_palette;
-      png_debug1(3, "num_palette = %d", *num_palette);
-      return (PNG_INFO_PLTE);
-   }
-   return (0);
-}
-
-#ifdef PNG_sBIT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_sBIT(png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit)
-{
-   png_debug1(1, "in %s retrieval function", "sBIT");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
-      && sig_bit != NULL)
-   {
-      *sig_bit = &(info_ptr->sig_bit);
-      return (PNG_INFO_sBIT);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_TEXT_SUPPORTED
-png_uint_32 PNGAPI
-png_get_text(png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr,
-   int *num_text)
-{
-   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
-   {
-      png_debug1(1, "in %s retrieval function",
-         (png_ptr->chunk_name[0] == '\0' ? "text"
-             : (png_const_charp)png_ptr->chunk_name));
-
-      if (text_ptr != NULL)
-         *text_ptr = info_ptr->text;
-
-      if (num_text != NULL)
-         *num_text = info_ptr->num_text;
-
-      return ((png_uint_32)info_ptr->num_text);
-   }
-   if (num_text != NULL)
-     *num_text = 0;
-   return(0);
-}
-#endif
-
-#ifdef PNG_tIME_SUPPORTED
-png_uint_32 PNGAPI
-png_get_tIME(png_structp png_ptr, png_infop info_ptr, png_timep *mod_time)
-{
-   png_debug1(1, "in %s retrieval function", "tIME");
-
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
-       && mod_time != NULL)
-   {
-      *mod_time = &(info_ptr->mod_time);
-      return (PNG_INFO_tIME);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-png_uint_32 PNGAPI
-png_get_tRNS(png_structp png_ptr, png_infop info_ptr,
-   png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)
-{
-   png_uint_32 retval = 0;
-   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
-   {
-      png_debug1(1, "in %s retrieval function", "tRNS");
-
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-          if (trans_alpha != NULL)
-          {
-             *trans_alpha = info_ptr->trans_alpha;
-             retval |= PNG_INFO_tRNS;
-          }
-
-          if (trans_color != NULL)
-             *trans_color = &(info_ptr->trans_color);
-      }
-      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
-      {
-          if (trans_color != NULL)
-          {
-             *trans_color = &(info_ptr->trans_color);
-             retval |= PNG_INFO_tRNS;
-          }
-
-          if (trans_alpha != NULL)
-             *trans_alpha = NULL;
-      }
-      if (num_trans != NULL)
-      {
-         *num_trans = info_ptr->num_trans;
-         retval |= PNG_INFO_tRNS;
-      }
-   }
-   return (retval);
-}
-#endif
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-png_uint_32 PNGAPI
-png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
-             png_unknown_chunkpp unknowns)
-{
-   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
-   {
-     *unknowns = info_ptr->unknown_chunks;
-     return ((png_uint_32)info_ptr->unknown_chunks_num);
-   }
-   return (0);
-}
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-png_byte PNGAPI
-png_get_rgb_to_gray_status (png_structp png_ptr)
-{
-   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
-}
-#endif
-
-#ifdef PNG_USER_CHUNKS_SUPPORTED
-png_voidp PNGAPI
-png_get_user_chunk_ptr(png_structp png_ptr)
-{
-   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
-}
-#endif
-
-png_size_t PNGAPI
-png_get_compression_buffer_size(png_structp png_ptr)
-{
-   return (png_ptr ? png_ptr->zbuf_size : 0L);
-}
-
-
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-/* These functions were added to libpng 1.2.6 and were enabled
- * by default in libpng-1.4.0 */
-png_uint_32 PNGAPI
-png_get_user_width_max (png_structp png_ptr)
-{
-    return (png_ptr? png_ptr->user_width_max : 0);
-}
-png_uint_32 PNGAPI
-png_get_user_height_max (png_structp png_ptr)
-{
-    return (png_ptr? png_ptr->user_height_max : 0);
-}
-/* This function was added to libpng 1.4.0 */
-png_uint_32 PNGAPI
-png_get_chunk_cache_max (png_structp png_ptr)
-{
-    return (png_ptr? png_ptr->user_chunk_cache_max : 0);
-}
-/* This function was added to libpng 1.4.1 */
-png_alloc_size_t PNGAPI
-png_get_chunk_malloc_max (png_structp png_ptr)
-{
-    return (png_ptr?
-       png_ptr->user_chunk_malloc_max : 0);
-}
-#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */
-
-/* These functions were added to libpng 1.4.0 */
-#ifdef PNG_IO_STATE_SUPPORTED
-png_uint_32 PNGAPI
-png_get_io_state (png_structp png_ptr)
-{
-    return png_ptr->io_state;
-}
-
-png_bytep PNGAPI
-png_get_io_chunk_name (png_structp png_ptr)
-{
-   return png_ptr->chunk_name;
-}
-#endif /* ?PNG_IO_STATE_SUPPORTED */
-
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngmem.c b/thirdparty/libpng/pngmem.c
deleted file mode 100644
index c8a3f6f..0000000
--- a/thirdparty/libpng/pngmem.c
+++ /dev/null
@@ -1,611 +0,0 @@
-
-/* pngmem.c - stub functions for memory allocation
- *
- * Last changed in libpng 1.4.2 [May 6, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all memory allocation.  Users who
- * need special memory handling are expected to supply replacement
- * functions for png_malloc() and png_free(), and to use
- * png_create_read_struct_2() and png_create_write_struct_2() to
- * identify the replacement functions.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#include "pngpriv.h"
-
-/* Borland DOS special memory handler */
-#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
-/* If you change this, be sure to change the one in png.h also */
-
-/* Allocate memory for a png_struct.  The malloc and memset can be replaced
-   by a single call to calloc() if this is thought to improve performance. */
-png_voidp /* PRIVATE */
-png_create_struct(int type)
-{
-#ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_struct_2(type, NULL, NULL));
-}
-
-/* Alternate version of png_create_struct, for use with user-defined malloc. */
-png_voidp /* PRIVATE */
-png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-   png_size_t size;
-   png_voidp struct_ptr;
-
-   if (type == PNG_STRUCT_INFO)
-      size = png_sizeof(png_info);
-   else if (type == PNG_STRUCT_PNG)
-      size = png_sizeof(png_struct);
-   else
-      return (png_get_copyright(NULL));
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (malloc_fn != NULL)
-   {
-      png_struct dummy_struct;
-      png_structp png_ptr = &dummy_struct;
-      png_ptr->mem_ptr=mem_ptr;
-      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);
-   }
-   else
-#endif /* PNG_USER_MEM_SUPPORTED */
-   struct_ptr = (png_voidp)farmalloc(size);
-   if (struct_ptr != NULL)
-      png_memset(struct_ptr, 0, size);
-   return (struct_ptr);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct(png_voidp struct_ptr)
-{
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_destroy_struct_2(struct_ptr, NULL, NULL);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
-    png_voidp mem_ptr)
-{
-#endif
-   if (struct_ptr != NULL)
-   {
-#ifdef PNG_USER_MEM_SUPPORTED
-      if (free_fn != NULL)
-      {
-         png_struct dummy_struct;
-         png_structp png_ptr = &dummy_struct;
-         png_ptr->mem_ptr=mem_ptr;
-         (*(free_fn))(png_ptr, struct_ptr);
-         return;
-      }
-#endif /* PNG_USER_MEM_SUPPORTED */
-      farfree (struct_ptr);
-   }
-}
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information. zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- *
- * Borland seems to have a problem in DOS mode for exactly 64K.
- * It gives you a segment with an offset of 8 (perhaps to store its
- * memory stuff).  zlib doesn't like this at all, so we have to
- * detect and deal with it.  This code should not be needed in
- * Windows or OS/2 modes, and only in 16 bit mode.  This code has
- * been updated by Alexander Lehmann for version 0.89 to waste less
- * memory.
- *
- * Note that we can't use png_size_t for the "size" declaration,
- * since on some systems a png_size_t is a 16-bit quantity, and as a
- * result, we would be truncating potentially larger memory requests
- * (which should cause a fatal error) and introducing major problems.
- */
-png_voidp PNGAPI
-png_calloc(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-
-   ret = (png_malloc(png_ptr, size));
-   if (ret != NULL)
-      png_memset(ret,0,(png_size_t)size);
-   return (ret);
-}
-
-png_voidp PNGAPI
-png_malloc(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->malloc_fn != NULL)
-      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
-   else
-      ret = (png_malloc_default(png_ptr, size));
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-       png_error(png_ptr, "Out of memory");
-   return (ret);
-}
-
-png_voidp PNGAPI
-png_malloc_default(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#ifdef PNG_MAX_MALLOC_64K
-   if (size > (png_uint_32)65536L)
-   {
-      png_warning(png_ptr, "Cannot Allocate > 64K");
-      ret = NULL;
-   }
-   else
-#endif
-
-   if (size != (size_t)size)
-      ret = NULL;
-   else if (size == (png_uint_32)65536L)
-   {
-      if (png_ptr->offset_table == NULL)
-      {
-         /* Try to see if we need to do any of this fancy stuff */
-         ret = farmalloc(size);
-         if (ret == NULL || ((png_size_t)ret & 0xffff))
-         {
-            int num_blocks;
-            png_uint_32 total_size;
-            png_bytep table;
-            int i;
-            png_byte huge * hptr;
-
-            if (ret != NULL)
-            {
-               farfree(ret);
-               ret = NULL;
-            }
-
-            if (png_ptr->zlib_window_bits > 14)
-               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
-            else
-               num_blocks = 1;
-            if (png_ptr->zlib_mem_level >= 7)
-               num_blocks += (int)(1 << (png_ptr->zlib_mem_level - 7));
-            else
-               num_blocks++;
-
-            total_size = ((png_uint_32)65536L) * (png_uint_32)num_blocks+16;
-
-            table = farmalloc(total_size);
-
-            if (table == NULL)
-            {
-#ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of Memory"); /* Note "O", "M" */
-               else
-                  png_warning(png_ptr, "Out Of Memory");
-#endif
-               return (NULL);
-            }
-
-            if ((png_size_t)table & 0xfff0)
-            {
-#ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr,
-                    "Farmalloc didn't return normalized pointer");
-               else
-                  png_warning(png_ptr,
-                    "Farmalloc didn't return normalized pointer");
-#endif
-               return (NULL);
-            }
-
-            png_ptr->offset_table = table;
-            png_ptr->offset_table_ptr = farmalloc(num_blocks *
-               png_sizeof(png_bytep));
-
-            if (png_ptr->offset_table_ptr == NULL)
-            {
-#ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of memory"); /* Note "O", "m" */
-               else
-                  png_warning(png_ptr, "Out Of memory");
-#endif
-               return (NULL);
-            }
-
-            hptr = (png_byte huge *)table;
-            if ((png_size_t)hptr & 0xf)
-            {
-               hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
-               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
-            }
-            for (i = 0; i < num_blocks; i++)
-            {
-               png_ptr->offset_table_ptr[i] = (png_bytep)hptr;
-               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
-            }
-
-            png_ptr->offset_table_number = num_blocks;
-            png_ptr->offset_table_count = 0;
-            png_ptr->offset_table_count_free = 0;
-         }
-      }
-
-      if (png_ptr->offset_table_count >= png_ptr->offset_table_number)
-      {
-#ifndef PNG_USER_MEM_SUPPORTED
-         if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-            png_error(png_ptr, "Out of Memory"); /* Note "o" and "M" */
-         else
-            png_warning(png_ptr, "Out of Memory");
-#endif
-         return (NULL);
-      }
-
-      ret = png_ptr->offset_table_ptr[png_ptr->offset_table_count++];
-   }
-   else
-      ret = farmalloc(size);
-
-#ifndef PNG_USER_MEM_SUPPORTED
-   if (ret == NULL)
-   {
-      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-         png_error(png_ptr, "Out of memory"); /* Note "o" and "m" */
-      else
-         png_warning(png_ptr, "Out of memory"); /* Note "o" and "m" */
-   }
-#endif
-
-   return (ret);
-}
-
-/* Free a pointer allocated by png_malloc().  In the default
- * configuration, png_ptr is not used, but is passed in case it
- * is needed.  If ptr is NULL, return without taking any action.
- */
-void PNGAPI
-png_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->free_fn != NULL)
-   {
-      (*(png_ptr->free_fn))(png_ptr, ptr);
-      return;
-   }
-   else
-      png_free_default(png_ptr, ptr);
-}
-
-void PNGAPI
-png_free_default(png_structp png_ptr, png_voidp ptr)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-   if (png_ptr->offset_table != NULL)
-   {
-      int i;
-
-      for (i = 0; i < png_ptr->offset_table_count; i++)
-      {
-         if (ptr == png_ptr->offset_table_ptr[i])
-         {
-            ptr = NULL;
-            png_ptr->offset_table_count_free++;
-            break;
-         }
-      }
-      if (png_ptr->offset_table_count_free == png_ptr->offset_table_count)
-      {
-         farfree(png_ptr->offset_table);
-         farfree(png_ptr->offset_table_ptr);
-         png_ptr->offset_table = NULL;
-         png_ptr->offset_table_ptr = NULL;
-      }
-   }
-
-   if (ptr != NULL)
-   {
-      farfree(ptr);
-   }
-}
-
-#else /* Not the Borland DOS special memory handler */
-
-/* Allocate memory for a png_struct or a png_info.  The malloc and
-   memset can be replaced by a single call to calloc() if this is thought
-   to improve performance noticably. */
-png_voidp /* PRIVATE */
-png_create_struct(int type)
-{
-#ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_struct_2(type, NULL, NULL));
-}
-
-/* Allocate memory for a png_struct or a png_info.  The malloc and
-   memset can be replaced by a single call to calloc() if this is thought
-   to improve performance noticably. */
-png_voidp /* PRIVATE */
-png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-   png_size_t size;
-   png_voidp struct_ptr;
-
-   if (type == PNG_STRUCT_INFO)
-      size = png_sizeof(png_info);
-   else if (type == PNG_STRUCT_PNG)
-      size = png_sizeof(png_struct);
-   else
-      return (NULL);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (malloc_fn != NULL)
-   {
-      png_struct dummy_struct;
-      png_structp png_ptr = &dummy_struct;
-      png_ptr->mem_ptr=mem_ptr;
-      struct_ptr = (*(malloc_fn))(png_ptr, size);
-      if (struct_ptr != NULL)
-         png_memset(struct_ptr, 0, size);
-      return (struct_ptr);
-   }
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   struct_ptr = (png_voidp)farmalloc(size);
-#else
-# if defined(_MSC_VER) && defined(MAXSEG_64K)
-   struct_ptr = (png_voidp)halloc(size, 1);
-# else
-   struct_ptr = (png_voidp)malloc(size);
-# endif
-#endif
-   if (struct_ptr != NULL)
-      png_memset(struct_ptr, 0, size);
-
-   return (struct_ptr);
-}
-
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct(png_voidp struct_ptr)
-{
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_destroy_struct_2(struct_ptr, NULL, NULL);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
-    png_voidp mem_ptr)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-   if (struct_ptr != NULL)
-   {
-#ifdef PNG_USER_MEM_SUPPORTED
-      if (free_fn != NULL)
-      {
-         png_struct dummy_struct;
-         png_structp png_ptr = &dummy_struct;
-         png_ptr->mem_ptr=mem_ptr;
-         (*(free_fn))(png_ptr, struct_ptr);
-         return;
-      }
-#endif /* PNG_USER_MEM_SUPPORTED */
-#if defined(__TURBOC__) && !defined(__FLAT__)
-      farfree(struct_ptr);
-#else
-# if defined(_MSC_VER) && defined(MAXSEG_64K)
-      hfree(struct_ptr);
-# else
-      free(struct_ptr);
-# endif
-#endif
-   }
-}
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information.  zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- */
-
-png_voidp PNGAPI
-png_calloc(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-
-   ret = (png_malloc(png_ptr, size));
-   if (ret != NULL)
-      png_memset(ret,0,(png_size_t)size);
-   return (ret);
-}
-
-png_voidp PNGAPI
-png_malloc(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-   if (png_ptr->malloc_fn != NULL)
-      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
-   else
-      ret = (png_malloc_default(png_ptr, size));
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-       png_error(png_ptr, "Out of Memory");
-   return (ret);
-}
-
-png_voidp PNGAPI
-png_malloc_default(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ret;
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#ifdef PNG_MAX_MALLOC_64K
-   if (size > (png_uint_32)65536L)
-   {
-#ifndef PNG_USER_MEM_SUPPORTED
-      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-         png_error(png_ptr, "Cannot Allocate > 64K");
-      else
-#endif
-         return NULL;
-   }
-#endif
-
-   /* Check for overflow */
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   if (size != (unsigned long)size)
-      ret = NULL;
-   else
-      ret = farmalloc(size);
-#else
-# if defined(_MSC_VER) && defined(MAXSEG_64K)
-   if (size != (unsigned long)size)
-      ret = NULL;
-   else
-      ret = halloc(size, 1);
-# else
-   if (size != (size_t)size)
-      ret = NULL;
-   else
-      ret = malloc((size_t)size);
-# endif
-#endif
-
-#ifndef PNG_USER_MEM_SUPPORTED
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-      png_error(png_ptr, "Out of Memory");
-#endif
-
-   return (ret);
-}
-
-/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
- * without taking any action.
- */
-void PNGAPI
-png_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->free_fn != NULL)
-   {
-      (*(png_ptr->free_fn))(png_ptr, ptr);
-      return;
-   }
-   else
-      png_free_default(png_ptr, ptr);
-}
-void PNGAPI
-png_free_default(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   farfree(ptr);
-#else
-# if defined(_MSC_VER) && defined(MAXSEG_64K)
-   hfree(ptr);
-# else
-   free(ptr);
-# endif
-#endif
-}
-
-#endif /* Not Borland DOS special memory handler */
-
-/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
- * function will set up png_malloc() to issue a png_warning and return NULL
- * instead of issuing a png_error, if it fails to allocate the requested
- * memory.
- */
-png_voidp PNGAPI
-png_malloc_warn(png_structp png_ptr, png_alloc_size_t size)
-{
-   png_voidp ptr;
-   png_uint_32 save_flags;
-   if (png_ptr == NULL)
-      return (NULL);
-
-   save_flags = png_ptr->flags;
-   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
-   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
-   png_ptr->flags=save_flags;
-   return(ptr);
-}
-
-
-#ifdef PNG_USER_MEM_SUPPORTED
-/* This function is called when the application wants to use another method
- * of allocating and freeing memory.
- */
-void PNGAPI
-png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
-  malloc_fn, png_free_ptr free_fn)
-{
-   if (png_ptr != NULL)
-   {
-      png_ptr->mem_ptr = mem_ptr;
-      png_ptr->malloc_fn = malloc_fn;
-      png_ptr->free_fn = free_fn;
-   }
-}
-
-/* This function returns a pointer to the mem_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy and png_read_destroy are called.
- */
-png_voidp PNGAPI
-png_get_mem_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-   return ((png_voidp)png_ptr->mem_ptr);
-}
-#endif /* PNG_USER_MEM_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngpread.c b/thirdparty/libpng/pngpread.c
deleted file mode 100644
index e33b428..0000000
--- a/thirdparty/libpng/pngpread.c
+++ /dev/null
@@ -1,1765 +0,0 @@
-
-/* pngpread.c - read a png file in push mode
- *
- * Last changed in libpng 1.4.3 [June 26, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-#include "pngpriv.h"
-
-/* Push model modes */
-#define PNG_READ_SIG_MODE   0
-#define PNG_READ_CHUNK_MODE 1
-#define PNG_READ_IDAT_MODE  2
-#define PNG_SKIP_MODE       3
-#define PNG_READ_tEXt_MODE  4
-#define PNG_READ_zTXt_MODE  5
-#define PNG_READ_DONE_MODE  6
-#define PNG_READ_iTXt_MODE  7
-#define PNG_ERROR_MODE      8
-
-void PNGAPI
-png_process_data(png_structp png_ptr, png_infop info_ptr,
-   png_bytep buffer, png_size_t buffer_size)
-{
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   png_push_restore_buffer(png_ptr, buffer, buffer_size);
-
-   while (png_ptr->buffer_size)
-   {
-      png_process_some_data(png_ptr, info_ptr);
-   }
-}
-
-/* What we do with the incoming data depends on what we were previously
- * doing before we ran out of data...
- */
-void /* PRIVATE */
-png_process_some_data(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr == NULL)
-      return;
-
-   switch (png_ptr->process_mode)
-   {
-      case PNG_READ_SIG_MODE:
-      {
-         png_push_read_sig(png_ptr, info_ptr);
-         break;
-      }
-
-      case PNG_READ_CHUNK_MODE:
-      {
-         png_push_read_chunk(png_ptr, info_ptr);
-         break;
-      }
-
-      case PNG_READ_IDAT_MODE:
-      {
-         png_push_read_IDAT(png_ptr);
-         break;
-      }
-
-#ifdef PNG_READ_tEXt_SUPPORTED
-      case PNG_READ_tEXt_MODE:
-      {
-         png_push_read_tEXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      case PNG_READ_zTXt_MODE:
-      {
-         png_push_read_zTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      case PNG_READ_iTXt_MODE:
-      {
-         png_push_read_iTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-      case PNG_SKIP_MODE:
-      {
-         png_push_crc_finish(png_ptr);
-         break;
-      }
-
-      default:
-      {
-         png_ptr->buffer_size = 0;
-         break;
-      }
-   }
-}
-
-/* Read any remaining signature bytes from the stream and compare them with
- * the correct PNG signature.  It is possible that this routine is called
- * with bytes already read from the signature, either because they have been
- * checked by the calling application, or because of multiple calls to this
- * routine.
- */
-void /* PRIVATE */
-png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
-{
-   png_size_t num_checked = png_ptr->sig_bytes,
-             num_to_check = 8 - num_checked;
-
-   if (png_ptr->buffer_size < num_to_check)
-   {
-      num_to_check = png_ptr->buffer_size;
-   }
-
-   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
-      num_to_check);
-   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);
-
-   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
-   {
-      if (num_checked < 4 &&
-          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
-         png_error(png_ptr, "Not a PNG file");
-      else
-         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
-   }
-   else
-   {
-      if (png_ptr->sig_bytes >= 8)
-      {
-         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
-      }
-   }
-}
-
-void /* PRIVATE */
-png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
-{
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
-
-   /* First we make sure we have enough data for the 4 byte chunk name
-    * and the 4 byte chunk length before proceeding with decoding the
-    * chunk data.  To fully decode each of these chunks, we also make
-    * sure we have enough data in the buffer for the 4 byte CRC at the
-    * end of every chunk (except IDAT, which is handled separately).
-    */
-   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
-   {
-      png_byte chunk_length[4];
-
-      if (png_ptr->buffer_size < 8)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
-      png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-      png_check_chunk_name(png_ptr, png_ptr->chunk_name);
-      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
-   }
-
-   if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-     if (png_ptr->mode & PNG_AFTER_IDAT)
-        png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
-
-   if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
-   {
-      if (png_ptr->push_length != 13)
-         png_error(png_ptr, "Invalid IHDR length");
-
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-   else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);
-
-      png_ptr->process_mode = PNG_READ_DONE_MODE;
-      png_push_have_end(png_ptr, info_ptr);
-   }
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-   else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-         png_ptr->mode |= PNG_HAVE_IDAT;
-
-      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
-
-      if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
-         png_ptr->mode |= PNG_HAVE_PLTE;
-
-      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-      {
-         if (!(png_ptr->mode & PNG_HAVE_IHDR))
-            png_error(png_ptr, "Missing IHDR before IDAT");
-
-         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-                  !(png_ptr->mode & PNG_HAVE_PLTE))
-            png_error(png_ptr, "Missing PLTE before IDAT");
-      }
-   }
-
-#endif
-   else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-   else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-   {
-      /* If we reach an IDAT chunk, this means we have read all of the
-       * header chunks, and we can start reading the image (or if this
-       * is called after the image has been read - we have an error).
-       */
-
-      if (!(png_ptr->mode & PNG_HAVE_IHDR))
-         png_error(png_ptr, "Missing IHDR before IDAT");
-
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-          !(png_ptr->mode & PNG_HAVE_PLTE))
-         png_error(png_ptr, "Missing PLTE before IDAT");
-
-      if (png_ptr->mode & PNG_HAVE_IDAT)
-      {
-         if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
-            if (png_ptr->push_length == 0)
-               return;
-
-         if (png_ptr->mode & PNG_AFTER_IDAT)
-            png_benign_error(png_ptr, "Too many IDATs found");
-      }
-
-      png_ptr->idat_size = png_ptr->push_length;
-      png_ptr->mode |= PNG_HAVE_IDAT;
-      png_ptr->process_mode = PNG_READ_IDAT_MODE;
-      png_push_have_info(png_ptr, info_ptr);
-      png_ptr->zstream.avail_out =
-          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
-          png_ptr->iwidth) + 1;
-      png_ptr->zstream.next_out = png_ptr->row_buf;
-      return;
-   }
-
-#ifdef PNG_READ_gAMA_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_bKGD_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
-   }
-#endif
-
-#ifdef PNG_READ_pCAL_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-#endif
-   else
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
-   }
-
-   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-}
-
-void /* PRIVATE */
-png_push_crc_skip(png_structp png_ptr, png_uint_32 skip)
-{
-   png_ptr->process_mode = PNG_SKIP_MODE;
-   png_ptr->skip_length = skip;
-}
-
-void /* PRIVATE */
-png_push_crc_finish(png_structp png_ptr)
-{
-   if (png_ptr->skip_length && png_ptr->save_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (png_ptr->skip_length < (png_uint_32)png_ptr->save_buffer_size)
-         save_size = (png_size_t)png_ptr->skip_length;
-      else
-         save_size = png_ptr->save_buffer_size;
-
-      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);
-
-      png_ptr->skip_length -= save_size;
-      png_ptr->buffer_size -= save_size;
-      png_ptr->save_buffer_size -= save_size;
-      png_ptr->save_buffer_ptr += save_size;
-   }
-   if (png_ptr->skip_length && png_ptr->current_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (png_ptr->skip_length < (png_uint_32)png_ptr->current_buffer_size)
-         save_size = (png_size_t)png_ptr->skip_length;
-      else
-         save_size = png_ptr->current_buffer_size;
-
-      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);
-
-      png_ptr->skip_length -= save_size;
-      png_ptr->buffer_size -= save_size;
-      png_ptr->current_buffer_size -= save_size;
-      png_ptr->current_buffer_ptr += save_size;
-   }
-   if (!png_ptr->skip_length)
-   {
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_crc_finish(png_ptr, 0);
-      png_ptr->process_mode = PNG_READ_CHUNK_MODE;
-   }
-}
-
-void PNGAPI
-png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
-{
-   png_bytep ptr;
-
-   if (png_ptr == NULL)
-      return;
-
-   ptr = buffer;
-   if (png_ptr->save_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (length < png_ptr->save_buffer_size)
-         save_size = length;
-      else
-         save_size = png_ptr->save_buffer_size;
-
-      png_memcpy(ptr, png_ptr->save_buffer_ptr, save_size);
-      length -= save_size;
-      ptr += save_size;
-      png_ptr->buffer_size -= save_size;
-      png_ptr->save_buffer_size -= save_size;
-      png_ptr->save_buffer_ptr += save_size;
-   }
-   if (length && png_ptr->current_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (length < png_ptr->current_buffer_size)
-         save_size = length;
-
-      else
-         save_size = png_ptr->current_buffer_size;
-
-      png_memcpy(ptr, png_ptr->current_buffer_ptr, save_size);
-      png_ptr->buffer_size -= save_size;
-      png_ptr->current_buffer_size -= save_size;
-      png_ptr->current_buffer_ptr += save_size;
-   }
-}
-
-void /* PRIVATE */
-png_push_save_buffer(png_structp png_ptr)
-{
-   if (png_ptr->save_buffer_size)
-   {
-      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
-      {
-         png_size_t i, istop;
-         png_bytep sp;
-         png_bytep dp;
-
-         istop = png_ptr->save_buffer_size;
-         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
-            i < istop; i++, sp++, dp++)
-         {
-            *dp = *sp;
-         }
-      }
-   }
-   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
-      png_ptr->save_buffer_max)
-   {
-      png_size_t new_max;
-      png_bytep old_buffer;
-
-      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -
-         (png_ptr->current_buffer_size + 256))
-      {
-        png_error(png_ptr, "Potential overflow of save_buffer");
-      }
-
-      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
-      old_buffer = png_ptr->save_buffer;
-      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
-         (png_size_t)new_max);
-      if (png_ptr->save_buffer == NULL)
-      {
-        png_free(png_ptr, old_buffer);
-        png_error(png_ptr, "Insufficient memory for save_buffer");
-      }
-      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
-      png_free(png_ptr, old_buffer);
-      png_ptr->save_buffer_max = new_max;
-   }
-   if (png_ptr->current_buffer_size)
-   {
-      png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
-         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);
-      png_ptr->save_buffer_size += png_ptr->current_buffer_size;
-      png_ptr->current_buffer_size = 0;
-   }
-   png_ptr->save_buffer_ptr = png_ptr->save_buffer;
-   png_ptr->buffer_size = 0;
-}
-
-void /* PRIVATE */
-png_push_restore_buffer(png_structp png_ptr, png_bytep buffer,
-   png_size_t buffer_length)
-{
-   png_ptr->current_buffer = buffer;
-   png_ptr->current_buffer_size = buffer_length;
-   png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;
-   png_ptr->current_buffer_ptr = png_ptr->current_buffer;
-}
-
-void /* PRIVATE */
-png_push_read_IDAT(png_structp png_ptr)
-{
-   PNG_IDAT;
-   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
-   {
-      png_byte chunk_length[4];
-
-      if (png_ptr->buffer_size < 8)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
-      png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
-
-      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-      {
-         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
-         if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
-            png_error(png_ptr, "Not enough compressed data");
-         return;
-      }
-
-      png_ptr->idat_size = png_ptr->push_length;
-   }
-   if (png_ptr->idat_size && png_ptr->save_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)
-      {
-         save_size = (png_size_t)png_ptr->idat_size;
-
-         /* Check for overflow */
-         if ((png_uint_32)save_size != png_ptr->idat_size)
-            png_error(png_ptr, "save_size overflowed in pngpread");
-      }
-      else
-         save_size = png_ptr->save_buffer_size;
-
-      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);
-
-      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);
-
-      png_ptr->idat_size -= save_size;
-      png_ptr->buffer_size -= save_size;
-      png_ptr->save_buffer_size -= save_size;
-      png_ptr->save_buffer_ptr += save_size;
-   }
-   if (png_ptr->idat_size && png_ptr->current_buffer_size)
-   {
-      png_size_t save_size;
-
-      if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)
-      {
-         save_size = (png_size_t)png_ptr->idat_size;
-
-         /* Check for overflow */
-         if ((png_uint_32)save_size != png_ptr->idat_size)
-            png_error(png_ptr, "save_size overflowed in pngpread");
-      }
-      else
-         save_size = png_ptr->current_buffer_size;
-
-      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);
-
-      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);
-
-      png_ptr->idat_size -= save_size;
-      png_ptr->buffer_size -= save_size;
-      png_ptr->current_buffer_size -= save_size;
-      png_ptr->current_buffer_ptr += save_size;
-   }
-   if (!png_ptr->idat_size)
-   {
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_crc_finish(png_ptr, 0);
-      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-      png_ptr->mode |= PNG_AFTER_IDAT;
-   }
-}
-
-void /* PRIVATE */
-png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
-   png_size_t buffer_length)
-{
-   /* The caller checks for a non-zero buffer length. */
-   if (!(buffer_length > 0) || buffer == NULL)
-      png_error(png_ptr, "No IDAT data (internal error)");
-
-   /* This routine must process all the data it has been given
-    * before returning, calling the row callback as required to
-    * handle the uncompressed results.
-    */
-   png_ptr->zstream.next_in = buffer;
-   png_ptr->zstream.avail_in = (uInt)buffer_length;
-
-   /* Keep going until the decompressed data is all processed
-    * or the stream marked as finished.
-    */
-   while (png_ptr->zstream.avail_in > 0 &&
-      !(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
-   {
-      int ret;
-
-      /* We have data for zlib, but we must check that zlib
-       * has somewhere to put the results.  It doesn't matter
-       * if we don't expect any results -- it may be the input
-       * data is just the LZ end code.
-       */
-      if (!(png_ptr->zstream.avail_out > 0))
-      {
-         png_ptr->zstream.avail_out =
-             (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
-             png_ptr->iwidth) + 1;
-         png_ptr->zstream.next_out = png_ptr->row_buf;
-      }
-
-      /* Using Z_SYNC_FLUSH here means that an unterminated
-       * LZ stream can still be handled (a stream with a missing
-       * end code), otherwise (Z_NO_FLUSH) a future zlib
-       * implementation might defer output and, therefore,
-       * change the current behavior.  (See comments in inflate.c
-       * for why this doesn't happen at present with zlib 1.2.5.)
-       */
-      ret = inflate(&png_ptr->zstream, Z_SYNC_FLUSH);
-
-      /* Check for any failure before proceeding. */
-      if (ret != Z_OK && ret != Z_STREAM_END)
-      {
-         /* Terminate the decompression. */
-         png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-
-         /* This may be a truncated stream (missing or
-          * damaged end code).  Treat that as a warning.
-          */
-         if (png_ptr->row_number >= png_ptr->num_rows ||
-             png_ptr->pass > 6)
-            png_warning(png_ptr, "Truncated compressed data in IDAT");
-         else
-            png_error(png_ptr, "Decompression error in IDAT");
-
-         /* Skip the check on unprocessed input */
-         return;
-      }
-
-      /* Did inflate output any data? */
-      if (png_ptr->zstream.next_out != png_ptr->row_buf)
-      {
-         /* Is this unexpected data after the last row?
-          * If it is, artificially terminate the LZ output
-          * here.
-          */
-         if (png_ptr->row_number >= png_ptr->num_rows ||
-             png_ptr->pass > 6)
-         {
-            /* Extra data. */
-            png_warning(png_ptr, "Extra compressed data in IDAT");
-            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-            /* Do no more processing; skip the unprocessed
-             * input check below.
-             */
-            return;
-         }
-
-         /* Do we have a complete row? */
-         if (png_ptr->zstream.avail_out == 0)
-            png_push_process_row(png_ptr);
-      }
-
-      /* And check for the end of the stream. */
-      if (ret == Z_STREAM_END)
-         png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-   }
-
-   /* All the data should have been processed, if anything
-    * is left at this point we have bytes of IDAT data
-    * after the zlib end code.
-    */
-   if (png_ptr->zstream.avail_in > 0)
-      png_warning(png_ptr, "Extra compression data");
-}
-
-void /* PRIVATE */
-png_push_process_row(png_structp png_ptr)
-{
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->iwidth;
-   png_ptr->row_info.channels = png_ptr->channels;
-   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
-   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
-
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-       png_ptr->row_info.width);
-
-   png_read_filter_row(png_ptr, &(png_ptr->row_info),
-       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
-       (int)(png_ptr->row_buf[0]));
-
-   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
-
-   if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
-      png_do_read_transformations(png_ptr);
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* Blow up interlaced rows to full size */
-   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
-   {
-      if (png_ptr->pass < 6)
-/*       old interface (pre-1.0.9):
-         png_do_read_interlace(&(png_ptr->row_info),
-             png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
- */
-         png_do_read_interlace(png_ptr);
-
-    switch (png_ptr->pass)
-    {
-         case 0:
-         {
-            int i;
-            for (i = 0; i < 8 && png_ptr->pass == 0; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr); /* Updates png_ptr->pass */
-            }
-
-            if (png_ptr->pass == 2) /* Pass 1 might be empty */
-            {
-               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
-               {
-                  png_push_have_row(png_ptr, NULL);
-                  png_read_push_finish_row(png_ptr);
-               }
-            }
-
-            if (png_ptr->pass == 4 && png_ptr->height <= 4)
-            {
-               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
-               {
-                  png_push_have_row(png_ptr, NULL);
-                  png_read_push_finish_row(png_ptr);
-               }
-            }
-
-            if (png_ptr->pass == 6 && png_ptr->height <= 4)
-            {
-                png_push_have_row(png_ptr, NULL);
-                png_read_push_finish_row(png_ptr);
-            }
-
-            break;
-         }
-
-         case 1:
-         {
-            int i;
-            for (i = 0; i < 8 && png_ptr->pass == 1; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            if (png_ptr->pass == 2) /* Skip top 4 generated rows */
-            {
-               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
-               {
-                  png_push_have_row(png_ptr, NULL);
-                  png_read_push_finish_row(png_ptr);
-               }
-            }
-
-            break;
-         }
-
-         case 2:
-         {
-            int i;
-
-            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
-            {
-               png_push_have_row(png_ptr, NULL);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            if (png_ptr->pass == 4) /* Pass 3 might be empty */
-            {
-               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
-               {
-                  png_push_have_row(png_ptr, NULL);
-                  png_read_push_finish_row(png_ptr);
-               }
-            }
-
-            break;
-         }
-
-         case 3:
-         {
-            int i;
-
-            for (i = 0; i < 4 && png_ptr->pass == 3; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            if (png_ptr->pass == 4) /* Skip top two generated rows */
-            {
-               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
-               {
-                  png_push_have_row(png_ptr, NULL);
-                  png_read_push_finish_row(png_ptr);
-               }
-            }
-
-            break;
-         }
-
-         case 4:
-         {
-            int i;
-
-            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
-            {
-               png_push_have_row(png_ptr, NULL);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            if (png_ptr->pass == 6) /* Pass 5 might be empty */
-            {
-               png_push_have_row(png_ptr, NULL);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            break;
-         }
-
-         case 5:
-         {
-            int i;
-
-            for (i = 0; i < 2 && png_ptr->pass == 5; i++)
-            {
-               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            if (png_ptr->pass == 6) /* Skip top generated row */
-            {
-               png_push_have_row(png_ptr, NULL);
-               png_read_push_finish_row(png_ptr);
-            }
-
-            break;
-         }
-         case 6:
-         {
-            png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-            png_read_push_finish_row(png_ptr);
-
-            if (png_ptr->pass != 6)
-               break;
-
-            png_push_have_row(png_ptr, NULL);
-            png_read_push_finish_row(png_ptr);
-         }
-      }
-   }
-   else
-#endif
-   {
-      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
-      png_read_push_finish_row(png_ptr);
-   }
-}
-
-void /* PRIVATE */
-png_read_push_finish_row(png_structp png_ptr)
-{
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
-
-   /* Start of interlace block in the y direction */
-   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
-
-   /* Offset to next interlace block in the y direction */
-   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
-
-   /* Height of interlace block.  This is not currently used - if you need
-    * it, uncomment it here and in png.h
-   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
-   */
-
-   png_ptr->row_number++;
-   if (png_ptr->row_number < png_ptr->num_rows)
-      return;
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   if (png_ptr->interlaced)
-   {
-      png_ptr->row_number = 0;
-      png_memset(png_ptr->prev_row, 0,
-         png_ptr->rowbytes + 1);
-      do
-      {
-         png_ptr->pass++;
-         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
-             (png_ptr->pass == 3 && png_ptr->width < 3) ||
-             (png_ptr->pass == 5 && png_ptr->width < 2))
-           png_ptr->pass++;
-
-         if (png_ptr->pass > 7)
-            png_ptr->pass--;
-
-         if (png_ptr->pass >= 7)
-            break;
-
-         png_ptr->iwidth = (png_ptr->width +
-            png_pass_inc[png_ptr->pass] - 1 -
-            png_pass_start[png_ptr->pass]) /
-            png_pass_inc[png_ptr->pass];
-
-         if (png_ptr->transformations & PNG_INTERLACE)
-            break;
-
-         png_ptr->num_rows = (png_ptr->height +
-            png_pass_yinc[png_ptr->pass] - 1 -
-            png_pass_ystart[png_ptr->pass]) /
-            png_pass_yinc[png_ptr->pass];
-
-      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);
-   }
-#endif /* PNG_READ_INTERLACING_SUPPORTED */
-}
-
-#ifdef PNG_READ_tEXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place tEXt");
-         info_ptr = info_ptr; /* To quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-      (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_tEXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-         png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
-      text_ptr->key = key;
-#ifdef PNG_iTXt_SUPPORTED
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-#endif
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-      png_ptr->current_text = NULL;
-
-      if (ret)
-        png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_zTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place zTXt");
-         info_ptr = info_ptr; /* To quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We can't handle zTXt chunks > 64K, since we don't have enough space
-    * to be able to store the uncompressed data.  Actually, the threshold
-    * is probably around 32K, but it isn't as definite as 64K is.
-    */
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
-      png_push_crc_skip(png_ptr, length);
-      return;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-      (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_zTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-      png_size_t text_size, key_size;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      /* zTXt can't have zero text */
-      if (text >= key + png_ptr->current_text_size)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* Check compression byte */
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      png_ptr->zstream.next_in = (png_bytep )text;
-      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
-         (text - key));
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-
-      key_size = text - key;
-      text_size = 0;
-      text = NULL;
-      ret = Z_STREAM_END;
-
-      while (png_ptr->zstream.avail_in)
-      {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
-            png_ptr->current_text = NULL;
-            png_free(png_ptr, key);
-            png_free(png_ptr, text);
-            return;
-         }
-         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
-         {
-            if (text == NULL)
-            {
-               text = (png_charp)png_malloc(png_ptr,
-                     (png_ptr->zbuf_size
-                     - png_ptr->zstream.avail_out + key_size + 1));
-
-               png_memcpy(text + key_size, png_ptr->zbuf,
-                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               png_memcpy(text, key, key_size);
-
-               text_size = key_size + png_ptr->zbuf_size -
-                  png_ptr->zstream.avail_out;
-
-               *(text + text_size) = '\0';
-            }
-            else
-            {
-               png_charp tmp;
-
-               tmp = text;
-               text = (png_charp)png_malloc(png_ptr, text_size +
-                  (png_ptr->zbuf_size
-                  - png_ptr->zstream.avail_out + 1));
-
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = '\0';
-            }
-            if (ret != Z_STREAM_END)
-            {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            }
-         }
-         else
-         {
-            break;
-         }
-
-         if (ret == Z_STREAM_END)
-            break;
-      }
-
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      if (ret != Z_STREAM_END)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         png_free(png_ptr, text);
-         return;
-      }
-
-      png_ptr->current_text = NULL;
-      png_free(png_ptr, key);
-      key = text;
-      text += key_size;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
-      text_ptr->key = key;
-#ifdef PNG_iTXt_SUPPORTED
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-#endif
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-
-      if (ret)
-        png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_iTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         png_error(png_ptr, "Out of place iTXt");
-         info_ptr = info_ptr; /* To quiet some compiler warnings */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-      (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_iTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
-{
-
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp key;
-      int comp_flag;
-      png_charp lang;
-      png_charp lang_key;
-      png_charp text;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (lang = key; *lang; lang++)
-         /* Empty loop */ ;
-
-      if (lang < key + png_ptr->current_text_size - 3)
-         lang++;
-
-      comp_flag = *lang++;
-      lang++;     /* Skip comp_type, always zero */
-
-      for (lang_key = lang; *lang_key; lang_key++)
-         /* Empty loop */ ;
-
-      lang_key++;        /* Skip NUL separator */
-
-      text=lang_key;
-
-      if (lang_key < key + png_ptr->current_text_size - 1)
-      {
-        for (; *text; text++)
-           /* Empty loop */ ;
-      }
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-         png_sizeof(png_text));
-
-      text_ptr->compression = comp_flag + 2;
-      text_ptr->key = key;
-      text_ptr->lang = lang;
-      text_ptr->lang_key = lang_key;
-      text_ptr->text = text;
-      text_ptr->text_length = 0;
-      text_ptr->itxt_length = png_strlen(text);
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_ptr->current_text = NULL;
-
-      png_free(png_ptr, text_ptr);
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store iTXt chunk");
-   }
-}
-#endif
-
-/* This function is called when we haven't found a handler for this
- * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
- * name or a critical chunk), the chunk is (currently) silently ignored.
- */
-void /* PRIVATE */
-png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   png_uint_32 skip = 0;
-
-   if (!(png_ptr->chunk_name[0] & 0x20))
-   {
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-         PNG_HANDLE_CHUNK_ALWAYS
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-         && png_ptr->read_user_chunk_fn == NULL
-#endif
-         )
-#endif
-         png_chunk_error(png_ptr, "unknown critical chunk");
-
-      info_ptr = info_ptr; /* To quiet some compiler warnings */
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
-   {
-#ifdef PNG_MAX_MALLOC_64K
-      if (length > (png_uint_32)65535L)
-      {
-          png_warning(png_ptr, "unknown chunk too large to fit in memory");
-          skip = length - (png_uint_32)65535L;
-          length = (png_uint_32)65535L;
-      }
-#endif
-      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-                 (png_charp)png_ptr->chunk_name,
-                 png_sizeof(png_ptr->unknown_chunk.name));
-      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name) - 1]
-        = '\0';
-
-      png_ptr->unknown_chunk.size = (png_size_t)length;
-
-      if (length == 0)
-         png_ptr->unknown_chunk.data = NULL;
-
-      else
-      {
-         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,
-            (png_size_t)length);
-         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
-      }
-
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-      if (png_ptr->read_user_chunk_fn != NULL)
-      {
-         /* Callback to user unknown chunk handler */
-         int ret;
-         ret = (*(png_ptr->read_user_chunk_fn))
-           (png_ptr, &png_ptr->unknown_chunk);
-
-         if (ret < 0)
-            png_chunk_error(png_ptr, "error in user chunk");
-
-         if (ret == 0)
-         {
-            if (!(png_ptr->chunk_name[0] & 0x20))
-               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-                    PNG_HANDLE_CHUNK_ALWAYS)
-                  png_chunk_error(png_ptr, "unknown critical chunk");
-            png_set_unknown_chunks(png_ptr, info_ptr,
-               &png_ptr->unknown_chunk, 1);
-         }
-      }
-
-      else
-#endif
-        png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-
-   else
-#endif
-      skip=length;
-   png_push_crc_skip(png_ptr, skip);
-}
-
-void /* PRIVATE */
-png_push_have_info(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->info_fn != NULL)
-      (*(png_ptr->info_fn))(png_ptr, info_ptr);
-}
-
-void /* PRIVATE */
-png_push_have_end(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->end_fn != NULL)
-      (*(png_ptr->end_fn))(png_ptr, info_ptr);
-}
-
-void /* PRIVATE */
-png_push_have_row(png_structp png_ptr, png_bytep row)
-{
-   if (png_ptr->row_fn != NULL)
-      (*(png_ptr->row_fn))(png_ptr, row, png_ptr->row_number,
-         (int)png_ptr->pass);
-}
-
-void PNGAPI
-png_progressive_combine_row (png_structp png_ptr,
-   png_bytep old_row, png_bytep new_row)
-{
-   PNG_CONST int FARDATA png_pass_dsp_mask[7] =
-      {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
-
-   if (png_ptr == NULL)
-      return;
-
-   if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
-      png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
-}
-
-void PNGAPI
-png_set_progressive_read_fn(png_structp png_ptr, png_voidp progressive_ptr,
-   png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
-   png_progressive_end_ptr end_fn)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->info_fn = info_fn;
-   png_ptr->row_fn = row_fn;
-   png_ptr->end_fn = end_fn;
-
-   png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
-}
-
-png_voidp PNGAPI
-png_get_progressive_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-
-   return png_ptr->io_ptr;
-}
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
diff --git a/thirdparty/libpng/pngpriv.h b/thirdparty/libpng/pngpriv.h
deleted file mode 100644
index 8b0621c..0000000
--- a/thirdparty/libpng/pngpriv.h
+++ /dev/null
@@ -1,954 +0,0 @@
-
-/* pngpriv.h - private declarations for use inside libpng
- *
- * libpng version 1.4.4 - September 23, 2010
- * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-/* The symbols declared in this file (including the functions declared
- * as PNG_EXTERN) are PRIVATE.  They are not part of the libpng public
- * interface, and are not recommended for use by regular applications.
- * Some of them may become public in the future; others may stay private,
- * change in an incompatible way, or even disappear.
- * Although the libpng users are not forbidden to include this header,
- * they should be well aware of the issues that may arise from doing so.
- */
-
-#ifndef PNGPRIV_H
-#define PNGPRIV_H
-
-#ifndef PNG_VERSION_INFO_ONLY
-
-#include <stdlib.h>
-
-#ifndef PNG_EXTERN
-/* The functions exported by PNG_EXTERN are internal functions, which
- * aren't usually used outside the library (as far as I know), so it is
- * debatable if they should be exported at all.  In the future, when it
- * is possible to have run-time registry of chunk-handling functions,
- * some of these will be made available again.
-#  define PNG_EXTERN extern
- */
-#  define PNG_EXTERN
-#endif
-
-/* Other defines specific to compilers can go here.  Try to keep
- * them inside an appropriate ifdef/endif pair for portability.
- */
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-#  ifdef MACOS
-     /* We need to check that <math.h> hasn't already been included earlier
-      * as it seems it doesn't agree with <fp.h>, yet we should really use
-      * <fp.h> if possible.
-      */
-#    if !defined(__MATH_H__) && !defined(__MATH_H) && !defined(__cmath__)
-#      include <fp.h>
-#    endif
-#  else
-#    include <math.h>
-#  endif
-#  if defined(_AMIGA) && defined(__SASC) && defined(_M68881)
-     /* Amiga SAS/C: We must include builtin FPU functions when compiling using
-      * MATH=68881
-      */
-#    include <m68881.h>
-#  endif
-#endif
-
-/* Codewarrior on NT has linking problems without this. */
-#if (defined(__MWERKS__) && defined(WIN32)) || defined(__STDC__)
-#  define PNG_ALWAYS_EXTERN
-#endif
-
-/* This provides the non-ANSI (far) memory allocation routines. */
-#if defined(__TURBOC__) && defined(__MSDOS__)
-#  include <mem.h>
-#  include <alloc.h>
-#endif
-
-#if defined(WIN32) || defined(_Windows) || defined(_WINDOWS) || \
-    defined(_WIN32) || defined(__WIN32__)
-#  include <windows.h>  /* defines _WINDOWS_ macro */
-#endif
-
-/* Various modes of operation.  Note that after an init, mode is set to
- * zero automatically when the structure is created.
- */
-#define PNG_HAVE_IHDR               0x01
-#define PNG_HAVE_PLTE               0x02
-#define PNG_HAVE_IDAT               0x04
-#define PNG_AFTER_IDAT              0x08 /* Have complete zlib datastream */
-#define PNG_HAVE_IEND               0x10
-#define PNG_HAVE_gAMA               0x20
-#define PNG_HAVE_cHRM               0x40
-#define PNG_HAVE_sRGB               0x80
-#define PNG_HAVE_CHUNK_HEADER      0x100
-#define PNG_WROTE_tIME             0x200
-#define PNG_WROTE_INFO_BEFORE_PLTE 0x400
-#define PNG_BACKGROUND_IS_GRAY     0x800
-#define PNG_HAVE_PNG_SIGNATURE    0x1000
-#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
-
-/* Flags for the transformations the PNG library does on the image data */
-#define PNG_BGR                 0x0001
-#define PNG_INTERLACE           0x0002
-#define PNG_PACK                0x0004
-#define PNG_SHIFT               0x0008
-#define PNG_SWAP_BYTES          0x0010
-#define PNG_INVERT_MONO         0x0020
-#define PNG_QUANTIZE            0x0040 /* formerly PNG_DITHER */
-#define PNG_BACKGROUND          0x0080
-#define PNG_BACKGROUND_EXPAND   0x0100
-                          /*    0x0200 unused */
-#define PNG_16_TO_8             0x0400
-#define PNG_RGBA                0x0800
-#define PNG_EXPAND              0x1000
-#define PNG_GAMMA               0x2000
-#define PNG_GRAY_TO_RGB         0x4000
-#define PNG_FILLER              0x8000L
-#define PNG_PACKSWAP           0x10000L
-#define PNG_SWAP_ALPHA         0x20000L
-#define PNG_STRIP_ALPHA        0x40000L
-#define PNG_INVERT_ALPHA       0x80000L
-#define PNG_USER_TRANSFORM    0x100000L
-#define PNG_RGB_TO_GRAY_ERR   0x200000L
-#define PNG_RGB_TO_GRAY_WARN  0x400000L
-#define PNG_RGB_TO_GRAY       0x600000L  /* two bits, RGB_TO_GRAY_ERR|WARN */
-                       /*     0x800000L     Unused */
-#define PNG_ADD_ALPHA         0x1000000L  /* Added to libpng-1.2.7 */
-#define PNG_EXPAND_tRNS       0x2000000L  /* Added to libpng-1.2.9 */
-                       /*   0x4000000L  unused */
-                       /*   0x8000000L  unused */
-                       /*  0x10000000L  unused */
-                       /*  0x20000000L  unused */
-                       /*  0x40000000L  unused */
-
-/* Flags for png_create_struct */
-#define PNG_STRUCT_PNG   0x0001
-#define PNG_STRUCT_INFO  0x0002
-
-/* Scaling factor for filter heuristic weighting calculations */
-#define PNG_WEIGHT_SHIFT 8
-#define PNG_WEIGHT_FACTOR (1<<(PNG_WEIGHT_SHIFT))
-#define PNG_COST_SHIFT 3
-#define PNG_COST_FACTOR (1<<(PNG_COST_SHIFT))
-
-/* Flags for the png_ptr->flags rather than declaring a byte for each one */
-#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001
-#define PNG_FLAG_ZLIB_CUSTOM_LEVEL        0x0002
-#define PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL    0x0004
-#define PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS  0x0008
-#define PNG_FLAG_ZLIB_CUSTOM_METHOD       0x0010
-#define PNG_FLAG_ZLIB_FINISHED            0x0020
-#define PNG_FLAG_ROW_INIT                 0x0040
-#define PNG_FLAG_FILLER_AFTER             0x0080
-#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100
-#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200
-#define PNG_FLAG_CRC_CRITICAL_USE         0x0400
-#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800
-                                /*        0x1000  unused */
-                                /*        0x2000  unused */
-                                /*        0x4000  unused */
-#define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000L
-#define PNG_FLAG_KEEP_UNSAFE_CHUNKS       0x10000L
-#define PNG_FLAG_LIBRARY_MISMATCH         0x20000L
-#define PNG_FLAG_STRIP_ERROR_NUMBERS      0x40000L
-#define PNG_FLAG_STRIP_ERROR_TEXT         0x80000L
-#define PNG_FLAG_MALLOC_NULL_MEM_OK       0x100000L
-#define PNG_FLAG_ADD_ALPHA                0x200000L  /* Added to libpng-1.2.8 */
-#define PNG_FLAG_STRIP_ALPHA              0x400000L  /* Added to libpng-1.2.8 */
-#define PNG_FLAG_BENIGN_ERRORS_WARN       0x800000L  /* Added to libpng-1.4.0 */
-                                  /*     0x1000000L  unused */
-                                  /*     0x2000000L  unused */
-                                  /*     0x4000000L  unused */
-                                  /*     0x8000000L  unused */
-                                  /*    0x10000000L  unused */
-                                  /*    0x20000000L  unused */
-                                  /*    0x40000000L  unused */
-
-#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
-                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
-
-#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
-                                     PNG_FLAG_CRC_CRITICAL_IGNORE)
-
-#define PNG_FLAG_CRC_MASK           (PNG_FLAG_CRC_ANCILLARY_MASK | \
-                                     PNG_FLAG_CRC_CRITICAL_MASK)
-
-/* Save typing and make code easier to understand */
-
-#define PNG_COLOR_DIST(c1, c2) (abs((int)((c1).red) - (int)((c2).red)) + \
-   abs((int)((c1).green) - (int)((c2).green)) + \
-   abs((int)((c1).blue) - (int)((c2).blue)))
-
-/* Added to libpng-1.2.6 JB */
-#define PNG_ROWBYTES(pixel_bits, width) \
-    ((pixel_bits) >= 8 ? \
-    ((png_size_t)(width) * (((png_size_t)(pixel_bits)) >> 3)) : \
-    (( ((png_size_t)(width) * ((png_size_t)(pixel_bits))) + 7) >> 3) )
-
-/* PNG_OUT_OF_RANGE returns true if value is outside the range
- * ideal-delta..ideal+delta.  Each argument is evaluated twice.
- * "ideal" and "delta" should be constants, normally simple
- * integers, "value" a variable. Added to libpng-1.2.6 JB
- */
-#define PNG_OUT_OF_RANGE(value, ideal, delta) \
-        ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
-
-/* Constant strings for known chunk types.  If you need to add a chunk,
- * define the name here, and add an invocation of the macro wherever it's
- * needed.
- */
-#define PNG_IHDR PNG_CONST png_byte png_IHDR[5] = { 73,  72,  68,  82, '\0'}
-#define PNG_IDAT PNG_CONST png_byte png_IDAT[5] = { 73,  68,  65,  84, '\0'}
-#define PNG_IEND PNG_CONST png_byte png_IEND[5] = { 73,  69,  78,  68, '\0'}
-#define PNG_PLTE PNG_CONST png_byte png_PLTE[5] = { 80,  76,  84,  69, '\0'}
-#define PNG_bKGD PNG_CONST png_byte png_bKGD[5] = { 98,  75,  71,  68, '\0'}
-#define PNG_cHRM PNG_CONST png_byte png_cHRM[5] = { 99,  72,  82,  77, '\0'}
-#define PNG_gAMA PNG_CONST png_byte png_gAMA[5] = {103,  65,  77,  65, '\0'}
-#define PNG_hIST PNG_CONST png_byte png_hIST[5] = {104,  73,  83,  84, '\0'}
-#define PNG_iCCP PNG_CONST png_byte png_iCCP[5] = {105,  67,  67,  80, '\0'}
-#define PNG_iTXt PNG_CONST png_byte png_iTXt[5] = {105,  84,  88, 116, '\0'}
-#define PNG_oFFs PNG_CONST png_byte png_oFFs[5] = {111,  70,  70, 115, '\0'}
-#define PNG_pCAL PNG_CONST png_byte png_pCAL[5] = {112,  67,  65,  76, '\0'}
-#define PNG_sCAL PNG_CONST png_byte png_sCAL[5] = {115,  67,  65,  76, '\0'}
-#define PNG_pHYs PNG_CONST png_byte png_pHYs[5] = {112,  72,  89, 115, '\0'}
-#define PNG_sBIT PNG_CONST png_byte png_sBIT[5] = {115,  66,  73,  84, '\0'}
-#define PNG_sPLT PNG_CONST png_byte png_sPLT[5] = {115,  80,  76,  84, '\0'}
-#define PNG_sRGB PNG_CONST png_byte png_sRGB[5] = {115,  82,  71,  66, '\0'}
-#define PNG_sTER PNG_CONST png_byte png_sTER[5] = {115,  84,  69,  82, '\0'}
-#define PNG_tEXt PNG_CONST png_byte png_tEXt[5] = {116,  69,  88, 116, '\0'}
-#define PNG_tIME PNG_CONST png_byte png_tIME[5] = {116,  73,  77,  69, '\0'}
-#define PNG_tRNS PNG_CONST png_byte png_tRNS[5] = {116,  82,  78,  83, '\0'}
-#define PNG_zTXt PNG_CONST png_byte png_zTXt[5] = {122,  84,  88, 116, '\0'}
-
-
-/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* These functions are used internally in the code.  They generally
- * shouldn't be used unless you are writing code to add or replace some
- * functionality in libpng.  More information about most functions can
- * be found in the files where the functions are located.
- */
-
-/* Allocate memory for an internal libpng struct */
-PNG_EXTERN png_voidp png_create_struct PNGARG((int type));
-
-/* Free memory from internal libpng struct */
-PNG_EXTERN void png_destroy_struct PNGARG((png_voidp struct_ptr));
-
-PNG_EXTERN png_voidp png_create_struct_2 PNGARG((int type, png_malloc_ptr
-  malloc_fn, png_voidp mem_ptr));
-PNG_EXTERN void png_destroy_struct_2 PNGARG((png_voidp struct_ptr,
-   png_free_ptr free_fn, png_voidp mem_ptr));
-
-/* Free any memory that info_ptr points to and reset struct. */
-PNG_EXTERN void png_info_destroy PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-
-/* Function to allocate memory for zlib.  PNGAPI is disallowed. */
-PNG_EXTERN voidpf png_zalloc PNGARG((voidpf png_ptr, uInt items, uInt size));
-
-/* Function to free memory for zlib.  PNGAPI is disallowed. */
-PNG_EXTERN void png_zfree PNGARG((voidpf png_ptr, voidpf ptr));
-
-/* Next four functions are used internally as callbacks.  PNGAPI is required
- * but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3. */
-
-PNG_EXTERN void PNGAPI png_default_read_data PNGARG((png_structp png_ptr,
-   png_bytep data, png_size_t length));
-
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-PNG_EXTERN void PNGAPI png_push_fill_buffer PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t length));
-#endif
-
-PNG_EXTERN void PNGAPI png_default_write_data PNGARG((png_structp png_ptr,
-   png_bytep data, png_size_t length));
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-#ifdef PNG_STDIO_SUPPORTED
-PNG_EXTERN void PNGAPI png_default_flush PNGARG((png_structp png_ptr));
-#endif
-#endif
-
-/* Reset the CRC variable */
-PNG_EXTERN void png_reset_crc PNGARG((png_structp png_ptr));
-
-/* Write the "data" buffer to whatever output you are using */
-PNG_EXTERN void png_write_data PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
-
-/* Read the chunk header (length + type name) */
-PNG_EXTERN png_uint_32 png_read_chunk_header PNGARG((png_structp png_ptr));
-
-/* Read data from whatever input you are using into the "data" buffer */
-PNG_EXTERN void png_read_data PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
-
-/* Read bytes into buf, and update png_ptr->crc */
-PNG_EXTERN void png_crc_read PNGARG((png_structp png_ptr, png_bytep buf,
-   png_size_t length));
-
-/* Decompress data in a chunk that uses compression */
-#if defined(PNG_zTXt_SUPPORTED) || defined(PNG_iTXt_SUPPORTED) || \
-    defined(PNG_iCCP_SUPPORTED) || defined(PNG_sPLT_SUPPORTED)
-PNG_EXTERN void png_decompress_chunk PNGARG((png_structp png_ptr,
-   int comp_type, png_size_t chunklength, png_size_t prefix_length,
-   png_size_t *data_length));
-#endif
-
-/* Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc */
-PNG_EXTERN int png_crc_finish PNGARG((png_structp png_ptr, png_uint_32 skip));
-
-/* Read the CRC from the file and compare it to the libpng calculated CRC */
-PNG_EXTERN int png_crc_error PNGARG((png_structp png_ptr));
-
-/* Calculate the CRC over a section of data.  Note that we are only
- * passing a maximum of 64K on systems that have this as a memory limit,
- * since this is the maximum buffer size we can specify.
- */
-PNG_EXTERN void png_calculate_crc PNGARG((png_structp png_ptr, png_bytep ptr,
-   png_size_t length));
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-PNG_EXTERN void png_flush PNGARG((png_structp png_ptr));
-#endif
-
-/* Write various chunks */
-
-/* Write the IHDR chunk, and update the png_struct with the necessary
- * information.
- */
-PNG_EXTERN void png_write_IHDR PNGARG((png_structp png_ptr, png_uint_32 width,
-   png_uint_32 height,
-   int bit_depth, int color_type, int compression_method, int filter_method,
-   int interlace_method));
-
-PNG_EXTERN void png_write_PLTE PNGARG((png_structp png_ptr, png_colorp palette,
-   png_uint_32 num_pal));
-
-PNG_EXTERN void png_write_IDAT PNGARG((png_structp png_ptr, png_bytep data,
-   png_size_t length));
-
-PNG_EXTERN void png_write_IEND PNGARG((png_structp png_ptr));
-
-#ifdef PNG_WRITE_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXTERN void png_write_gAMA PNGARG((png_structp png_ptr, double file_gamma));
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXTERN void png_write_gAMA_fixed PNGARG((png_structp png_ptr,
-    png_fixed_point file_gamma));
-#endif
-#endif
-
-#ifdef PNG_WRITE_sBIT_SUPPORTED
-PNG_EXTERN void png_write_sBIT PNGARG((png_structp png_ptr, png_color_8p sbit,
-   int color_type));
-#endif
-
-#ifdef PNG_WRITE_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_EXTERN void png_write_cHRM PNGARG((png_structp png_ptr,
-   double white_x, double white_y,
-   double red_x, double red_y, double green_x, double green_y,
-   double blue_x, double blue_y));
-#endif
-PNG_EXTERN void png_write_cHRM_fixed PNGARG((png_structp png_ptr,
-   png_fixed_point int_white_x, png_fixed_point int_white_y,
-   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
-   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
-   png_fixed_point int_blue_y));
-#endif
-
-#ifdef PNG_WRITE_sRGB_SUPPORTED
-PNG_EXTERN void png_write_sRGB PNGARG((png_structp png_ptr,
-   int intent));
-#endif
-
-#ifdef PNG_WRITE_iCCP_SUPPORTED
-PNG_EXTERN void png_write_iCCP PNGARG((png_structp png_ptr,
-   png_charp name, int compression_type,
-   png_charp profile, int proflen));
-   /* Note to maintainer: profile should be png_bytep */
-#endif
-
-#ifdef PNG_WRITE_sPLT_SUPPORTED
-PNG_EXTERN void png_write_sPLT PNGARG((png_structp png_ptr,
-   png_sPLT_tp palette));
-#endif
-
-#ifdef PNG_WRITE_tRNS_SUPPORTED
-PNG_EXTERN void png_write_tRNS PNGARG((png_structp png_ptr, png_bytep trans,
-   png_color_16p values, int number, int color_type));
-#endif
-
-#ifdef PNG_WRITE_bKGD_SUPPORTED
-PNG_EXTERN void png_write_bKGD PNGARG((png_structp png_ptr,
-   png_color_16p values, int color_type));
-#endif
-
-#ifdef PNG_WRITE_hIST_SUPPORTED
-PNG_EXTERN void png_write_hIST PNGARG((png_structp png_ptr, png_uint_16p hist,
-   int num_hist));
-#endif
-
-#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
-    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
-PNG_EXTERN png_size_t png_check_keyword PNGARG((png_structp png_ptr,
-   png_charp key, png_charpp new_key));
-#endif
-
-#ifdef PNG_WRITE_tEXt_SUPPORTED
-PNG_EXTERN void png_write_tEXt PNGARG((png_structp png_ptr, png_charp key,
-   png_charp text, png_size_t text_len));
-#endif
-
-#ifdef PNG_WRITE_zTXt_SUPPORTED
-PNG_EXTERN void png_write_zTXt PNGARG((png_structp png_ptr, png_charp key,
-   png_charp text, png_size_t text_len, int compression));
-#endif
-
-#ifdef PNG_WRITE_iTXt_SUPPORTED
-PNG_EXTERN void png_write_iTXt PNGARG((png_structp png_ptr,
-   int compression, png_charp key, png_charp lang, png_charp lang_key,
-   png_charp text));
-#endif
-
-#ifdef PNG_TEXT_SUPPORTED  /* Added at version 1.0.14 and 1.2.4 */
-PNG_EXTERN int png_set_text_2 PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_textp text_ptr, int num_text));
-#endif
-
-#ifdef PNG_WRITE_oFFs_SUPPORTED
-PNG_EXTERN void png_write_oFFs PNGARG((png_structp png_ptr,
-   png_int_32 x_offset, png_int_32 y_offset, int unit_type));
-#endif
-
-#ifdef PNG_WRITE_pCAL_SUPPORTED
-PNG_EXTERN void png_write_pCAL PNGARG((png_structp png_ptr, png_charp purpose,
-   png_int_32 X0, png_int_32 X1, int type, int nparams,
-   png_charp units, png_charpp params));
-#endif
-
-#ifdef PNG_WRITE_pHYs_SUPPORTED
-PNG_EXTERN void png_write_pHYs PNGARG((png_structp png_ptr,
-   png_uint_32 x_pixels_per_unit, png_uint_32 y_pixels_per_unit,
-   int unit_type));
-#endif
-
-#ifdef PNG_WRITE_tIME_SUPPORTED
-PNG_EXTERN void png_write_tIME PNGARG((png_structp png_ptr,
-   png_timep mod_time));
-#endif
-
-#ifdef PNG_WRITE_sCAL_SUPPORTED
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
-PNG_EXTERN void png_write_sCAL PNGARG((png_structp png_ptr,
-   int unit, double width, double height));
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-PNG_EXTERN void png_write_sCAL_s PNGARG((png_structp png_ptr,
-   int unit, png_charp width, png_charp height));
-#endif
-#endif
-#endif
-
-/* Called when finished processing a row of data */
-PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr));
-
-/* Internal use only.   Called before first row of data */
-PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr));
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr,
-   png_byte bit_depth));
-#endif
-
-/* Combine a row of data, dealing with alpha, etc. if requested */
-PNG_EXTERN void png_combine_row PNGARG((png_structp png_ptr, png_bytep row,
-   int mask));
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-/* Expand an interlaced row */
-/* OLD pre-1.0.9 interface:
-PNG_EXTERN void png_do_read_interlace PNGARG((png_row_infop row_info,
-   png_bytep row, int pass, png_uint_32 transformations));
- */
-PNG_EXTERN void png_do_read_interlace PNGARG((png_structp png_ptr));
-#endif
-
-/* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-/* Grab pixels out of a row for an interlaced pass */
-PNG_EXTERN void png_do_write_interlace PNGARG((png_row_infop row_info,
-   png_bytep row, int pass));
-#endif
-
-/* Unfilter a row */
-PNG_EXTERN void png_read_filter_row PNGARG((png_structp png_ptr,
-   png_row_infop row_info, png_bytep row, png_bytep prev_row, int filter));
-
-/* Choose the best filter to use and filter the row data */
-PNG_EXTERN void png_write_find_filter PNGARG((png_structp png_ptr,
-   png_row_infop row_info));
-
-/* Write out the filtered row. */
-PNG_EXTERN void png_write_filtered_row PNGARG((png_structp png_ptr,
-   png_bytep filtered_row));
-/* Finish a row while reading, dealing with interlacing passes, etc. */
-PNG_EXTERN void png_read_finish_row PNGARG((png_structp png_ptr));
-
-/* Initialize the row buffers, etc. */
-PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr));
-/* Optional call to update the users info structure */
-PNG_EXTERN void png_read_transform_info PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-
-/* These are the functions that do the transformations */
-#ifdef PNG_READ_FILLER_SUPPORTED
-PNG_EXTERN void png_do_read_filler PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 filler, png_uint_32 flags));
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-PNG_EXTERN void png_do_read_swap_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-PNG_EXTERN void png_do_write_swap_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-PNG_EXTERN void png_do_read_invert_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-PNG_EXTERN void png_do_write_invert_alpha PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
-    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-PNG_EXTERN void png_do_strip_filler PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 flags));
-#endif
-
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-PNG_EXTERN void png_do_swap PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
-    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-PNG_EXTERN void png_do_packswap PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-PNG_EXTERN int png_do_rgb_to_gray PNGARG((png_structp png_ptr, png_row_infop
-   row_info, png_bytep row));
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-PNG_EXTERN void png_do_gray_to_rgb PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-#ifdef PNG_READ_PACK_SUPPORTED
-PNG_EXTERN void png_do_unpack PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-PNG_EXTERN void png_do_unshift PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_8p sig_bits));
-#endif
-
-#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
-PNG_EXTERN void png_do_invert PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-PNG_EXTERN void png_do_chop PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-PNG_EXTERN void png_do_quantize PNGARG((png_row_infop row_info,
-   png_bytep row, png_bytep palette_lookup, png_bytep quantize_lookup));
-
-#  ifdef PNG_CORRECT_PALETTE_SUPPORTED
-PNG_EXTERN void png_correct_palette PNGARG((png_structp png_ptr,
-   png_colorp palette, int num_palette));
-#  endif
-#endif
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-PNG_EXTERN void png_do_bgr PNGARG((png_row_infop row_info, png_bytep row));
-#endif
-
-#ifdef PNG_WRITE_PACK_SUPPORTED
-PNG_EXTERN void png_do_pack PNGARG((png_row_infop row_info,
-   png_bytep row, png_uint_32 bit_depth));
-#endif
-
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-PNG_EXTERN void png_do_shift PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_8p bit_depth));
-#endif
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-#ifdef PNG_READ_GAMMA_SUPPORTED
-PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_16p trans_color, png_color_16p background,
-   png_color_16p background_1,
-   png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
-   png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
-   png_uint_16pp gamma_16_to_1, int gamma_shift));
-#else
-PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info, png_bytep row,
-   png_color_16p trans_color, png_color_16p background));
-#endif
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-PNG_EXTERN void png_do_gamma PNGARG((png_row_infop row_info, png_bytep row,
-   png_bytep gamma_table, png_uint_16pp gamma_16_table,
-   int gamma_shift));
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-PNG_EXTERN void png_do_expand_palette PNGARG((png_row_infop row_info,
-   png_bytep row, png_colorp palette, png_bytep trans, int num_trans));
-PNG_EXTERN void png_do_expand PNGARG((png_row_infop row_info,
-   png_bytep row, png_color_16p trans_value));
-#endif
-
-/* The following decodes the appropriate chunks, and does error correction,
- * then calls the appropriate callback for the chunk if it is valid.
- */
-
-/* Decode the IHDR chunk */
-PNG_EXTERN void png_handle_IHDR PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_handle_PLTE PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_handle_IEND PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-
-#ifdef PNG_READ_bKGD_SUPPORTED
-PNG_EXTERN void png_handle_bKGD PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_cHRM_SUPPORTED
-PNG_EXTERN void png_handle_cHRM PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_gAMA_SUPPORTED
-PNG_EXTERN void png_handle_gAMA PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_hIST_SUPPORTED
-PNG_EXTERN void png_handle_hIST PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_iCCP_SUPPORTED
-PNG_EXTERN void png_handle_iCCP PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif /* PNG_READ_iCCP_SUPPORTED */
-
-#ifdef PNG_READ_iTXt_SUPPORTED
-PNG_EXTERN void png_handle_iTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_oFFs_SUPPORTED
-PNG_EXTERN void png_handle_oFFs PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_pCAL_SUPPORTED
-PNG_EXTERN void png_handle_pCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_pHYs_SUPPORTED
-PNG_EXTERN void png_handle_pHYs PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_sBIT_SUPPORTED
-PNG_EXTERN void png_handle_sBIT PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_sCAL_SUPPORTED
-PNG_EXTERN void png_handle_sCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_sPLT_SUPPORTED
-PNG_EXTERN void png_handle_sPLT PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif /* PNG_READ_sPLT_SUPPORTED */
-
-#ifdef PNG_READ_sRGB_SUPPORTED
-PNG_EXTERN void png_handle_sRGB PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_tEXt_SUPPORTED
-PNG_EXTERN void png_handle_tEXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_tIME_SUPPORTED
-PNG_EXTERN void png_handle_tIME PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_tRNS_SUPPORTED
-PNG_EXTERN void png_handle_tRNS PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-#ifdef PNG_READ_zTXt_SUPPORTED
-PNG_EXTERN void png_handle_zTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-#endif
-
-PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
-
-PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
-   png_bytep chunk_name));
-
-/* Handle the transformations for reading and writing */
-PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_do_write_transformations PNGARG((png_structp png_ptr));
-
-PNG_EXTERN void png_init_read_transformations PNGARG((png_structp png_ptr));
-
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-PNG_EXTERN void png_push_read_chunk PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_read_sig PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_check_crc PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_push_crc_skip PNGARG((png_structp png_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_push_crc_finish PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_push_save_buffer PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_push_restore_buffer PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t buffer_length));
-PNG_EXTERN void png_push_read_IDAT PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_process_IDAT_data PNGARG((png_structp png_ptr,
-   png_bytep buffer, png_size_t buffer_length));
-PNG_EXTERN void png_push_process_row PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_push_handle_unknown PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
-PNG_EXTERN void png_push_have_info PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_have_end PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_push_have_row PNGARG((png_structp png_ptr, png_bytep row));
-PNG_EXTERN void png_push_read_end PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_process_some_data PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_read_push_finish_row PNGARG((png_structp png_ptr));
-#ifdef PNG_READ_tEXt_SUPPORTED
-PNG_EXTERN void png_push_handle_tEXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
-PNG_EXTERN void png_push_read_tEXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-PNG_EXTERN void png_push_handle_zTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
-PNG_EXTERN void png_push_read_zTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-PNG_EXTERN void png_push_handle_iTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 length));
-PNG_EXTERN void png_push_read_iTXt PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
-   png_bytep row));
-PNG_EXTERN void png_do_write_intrapixel PNGARG((png_row_infop row_info,
-   png_bytep row));
-#endif
-
-/* Added at libpng version 1.4.0 */
-#ifdef PNG_cHRM_SUPPORTED
-PNG_EXTERN int png_check_cHRM_fixed PNGARG((png_structp png_ptr,
-   png_fixed_point int_white_x, png_fixed_point int_white_y,
-   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
-   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
-   png_fixed_point int_blue_y));
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-/* Added at libpng version 1.2.34 and 1.4.0 */
-PNG_EXTERN void png_64bit_product PNGARG((long v1, long v2,
-   unsigned long *hi_product, unsigned long *lo_product));
-#endif
-#endif
-
-/* Added at libpng version 1.4.0 */
-PNG_EXTERN void png_check_IHDR PNGARG((png_structp png_ptr,
-   png_uint_32 width, png_uint_32 height, int bit_depth,
-   int color_type, int interlace_type, int compression_type,
-   int filter_type));
-
-/* Free all memory used by the read (old method - NOT DLL EXPORTED) */
-PNG_EXTERN void png_read_destroy PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_infop end_info_ptr));
-
-/* Free any memory used in png_ptr struct (old method - NOT DLL EXPORTED) */
-PNG_EXTERN void png_write_destroy PNGARG((png_structp png_ptr));
-
-#ifdef USE_FAR_KEYWORD  /* memory model conversion function */
-PNG_EXTERN void *png_far_to_near PNGARG((png_structp png_ptr,png_voidp ptr,
-   int check));
-#endif /* USE_FAR_KEYWORD */
-
-/* Define PNG_DEBUG at compile time for debugging information.  Higher
- * numbers for PNG_DEBUG mean more debugging information.  This has
- * only been added since version 0.95 so it is not implemented throughout
- * libpng yet, but more support will be added as needed.
- */
-#ifdef PNG_DEBUG
-#if (PNG_DEBUG > 0)
-#if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
-#include <crtdbg.h>
-#if (PNG_DEBUG > 1)
-#ifndef _DEBUG
-#  define _DEBUG
-#endif
-#ifndef png_debug
-#define png_debug(l,m)  _RPT0(_CRT_WARN,m PNG_STRING_NEWLINE)
-#endif
-#ifndef png_debug1
-#define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m PNG_STRING_NEWLINE,p1)
-#endif
-#ifndef png_debug2
-#define png_debug2(l,m,p1,p2) _RPT2(_CRT_WARN,m PNG_STRING_NEWLINE,p1,p2)
-#endif
-#endif
-#else /* PNG_DEBUG_FILE || !_MSC_VER */
-#ifndef PNG_DEBUG_FILE
-#define PNG_DEBUG_FILE stderr
-#endif /* PNG_DEBUG_FILE */
-
-#if (PNG_DEBUG > 1)
-/* Note: ["%s"m PNG_STRING_NEWLINE] probably does not work on
- * non-ISO compilers
- */
-#  ifdef __STDC__
-#    ifndef png_debug
-#      define png_debug(l,m) \
-       { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
-       }
-#    endif
-#    ifndef png_debug1
-#      define png_debug1(l,m,p1) \
-       { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
-       }
-#    endif
-#    ifndef png_debug2
-#      define png_debug2(l,m,p1,p2) \
-       { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
-       }
-#    endif
-#  else /* __STDC __ */
-#    ifndef png_debug
-#      define png_debug(l,m) \
-       { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format); \
-       }
-#    endif
-#    ifndef png_debug1
-#      define png_debug1(l,m,p1) \
-       { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format,p1); \
-       }
-#    endif
-#    ifndef png_debug2
-#      define png_debug2(l,m,p1,p2) \
-       { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format,p1,p2); \
-       }
-#    endif
-#  endif /* __STDC __ */
-#endif /* (PNG_DEBUG > 1) */
-
-#endif /* _MSC_VER */
-#endif /* (PNG_DEBUG > 0) */
-#endif /* PNG_DEBUG */
-#ifndef png_debug
-#define png_debug(l, m)
-#endif
-#ifndef png_debug1
-#define png_debug1(l, m, p1)
-#endif
-#ifndef png_debug2
-#define png_debug2(l, m, p1, p2)
-#endif
-
-/* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PNG_VERSION_INFO_ONLY */
-#endif /* PNGPRIV_H */
diff --git a/thirdparty/libpng/pngread.c b/thirdparty/libpng/pngread.c
deleted file mode 100644
index 92060d2..0000000
--- a/thirdparty/libpng/pngread.c
+++ /dev/null
@@ -1,1361 +0,0 @@
-
-/* pngread.c - read a PNG file
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file contains routines that an application calls directly to
- * read a PNG file or stream.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_READ_SUPPORTED
-#include "pngpriv.h"
-
-
-/* Create a PNG structure for reading, and allocate any memory needed. */
-png_structp PNGAPI
-png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn)
-{
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
-      warn_fn, NULL, NULL, NULL));
-}
-
-/* Alternate create PNG structure for reading, and allocate any memory
- * needed.
- */
-png_structp PNGAPI
-png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-
-#ifdef PNG_SETJMP_SUPPORTED
-   volatile
-#endif
-   png_structp png_ptr;
-   volatile int png_cleanup_needed = 0;
-
-#ifdef PNG_SETJMP_SUPPORTED
-#ifdef USE_FAR_KEYWORD
-   jmp_buf jmpbuf;
-#endif
-#endif
-
-   int i;
-
-   png_debug(1, "in png_create_read_struct");
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
-      malloc_fn, mem_ptr);
-#else
-   png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
-#endif
-   if (png_ptr == NULL)
-      return (NULL);
-
-   /* Added at libpng-1.2.6 */
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
-#  ifdef PNG_USER_CHUNK_CACHE_MAX
-   /* Added at libpng-1.2.43 and 1.4.0 */
-   png_ptr->user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
-#  endif
-#  ifdef PNG_SET_USER_CHUNK_MALLOC_MAX
-   /* Added at libpng-1.2.43 and 1.4.1 */
-   png_ptr->user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
-#  endif
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-/* Applications that neglect to set up their own setjmp() and then
-   encounter a png_error() will longjmp here.  Since the jmpbuf is
-   then meaningless we abort instead of returning. */
-#ifdef USE_FAR_KEYWORD
-   if (setjmp(jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(png_ptr))) /* Sets longjmp to match setjmp */
-#endif
-      PNG_ABORT();
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(png_ptr), jmpbuf, png_sizeof(jmp_buf));
-#endif
-#endif /* PNG_SETJMP_SUPPORTED */
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
-#endif
-
-   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
-
-   if (user_png_ver)
-   {
-      i = 0;
-      do
-      {
-         if (user_png_ver[i] != png_libpng_ver[i])
-            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-      } while (png_libpng_ver[i++]);
-    }
-    else
-         png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-
-
-    if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-    {
-       /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-       * we must recompile any applications that use any older library version.
-       * For versions after libpng 1.0, we will be compatible, so we need
-       * only check the first digit.
-       */
-      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-      {
-#ifdef PNG_STDIO_SUPPORTED
-         char msg[80];
-         if (user_png_ver)
-         {
-           png_snprintf(msg, 80,
-              "Application was compiled with png.h from libpng-%.20s",
-              user_png_ver);
-           png_warning(png_ptr, msg);
-         }
-         png_snprintf(msg, 80,
-             "Application  is  running with png.c from libpng-%.20s",
-             png_libpng_ver);
-         png_warning(png_ptr, msg);
-#endif
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-         png_ptr->flags = 0;
-#endif
-         png_warning(png_ptr,
-            "Incompatible libpng version in application and library");
-
-         png_cleanup_needed = 1;
-      }
-   }
-
-   if (!png_cleanup_needed)
-   {
-   /* Initialize zbuf - compression buffer */
-   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
-   png_ptr->zbuf = (png_bytep)png_malloc_warn(png_ptr,
-     png_ptr->zbuf_size);
-   if (png_ptr->zbuf == NULL)
-        png_cleanup_needed = 1;
-   }
-   png_ptr->zstream.zalloc = png_zalloc;
-   png_ptr->zstream.zfree = png_zfree;
-   png_ptr->zstream.opaque = (voidpf)png_ptr;
-
-   if (!png_cleanup_needed)
-   {
-      switch (inflateInit(&png_ptr->zstream))
-      {
-         case Z_OK: /* Do nothing */ break;
-         case Z_MEM_ERROR:
-         case Z_STREAM_ERROR: png_warning(png_ptr, "zlib memory error");
-            png_cleanup_needed = 1; break;
-         case Z_VERSION_ERROR: png_warning(png_ptr, "zlib version error");
-            png_cleanup_needed = 1; break;
-         default: png_warning(png_ptr, "Unknown zlib error");
-            png_cleanup_needed = 1;
-      }
-   }
-
-   if (png_cleanup_needed)
-   {
-      /* Clean up PNG structure and deallocate any memory. */
-      png_free(png_ptr, png_ptr->zbuf);
-      png_ptr->zbuf = NULL;
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)png_ptr,
-         (png_free_ptr)free_fn, (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)png_ptr);
-#endif
-      return (NULL);
-   }
-
-   png_ptr->zstream.next_out = png_ptr->zbuf;
-   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-
-   png_set_read_fn(png_ptr, NULL, NULL);
-
-
-   return (png_ptr);
-}
-
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the information before the actual image data.  This has been
- * changed in v0.90 to allow reading a file that already has the magic
- * bytes read from the stream.  You can tell libpng how many bytes have
- * been read from the beginning of the stream (up to the maximum of 8)
- * via png_set_sig_bytes(), and we will only check the remaining bytes
- * here.  The application can then have access to the signature bytes we
- * read if it is determined that this isn't a valid PNG file.
- */
-void PNGAPI
-png_read_info(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_read_info");
- 
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
- 
-   /* If we haven't checked all of the PNG signature bytes, do so now. */
-   if (png_ptr->sig_bytes < 8)
-   {
-      png_size_t num_checked = png_ptr->sig_bytes,
-                 num_to_check = 8 - num_checked;
-
-#ifdef PNG_IO_STATE_SUPPORTED
-      png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;
-#endif
-
-      png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);
-      png_ptr->sig_bytes = 8;
-
-      if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
-      {
-         if (num_checked < 4 &&
-             png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
-            png_error(png_ptr, "Not a PNG file");
-         else
-            png_error(png_ptr, "PNG file corrupted by ASCII conversion");
-      }
-      if (num_checked < 3)
-         png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
-   }
-
-   for (;;)
-   {
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
-      png_uint_32 length = png_read_chunk_header(png_ptr);
-      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
-
-      /* This should be a binary subdivision search or a hash for
-       * matching the chunk name rather than a linear search.
-       */
-      if (!png_memcmp(chunk_name, png_IDAT, 4))
-        if (png_ptr->mode & PNG_AFTER_IDAT)
-          png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
-
-      if (!png_memcmp(chunk_name, png_IHDR, 4))
-         png_handle_IHDR(png_ptr, info_ptr, length);
-      else if (!png_memcmp(chunk_name, png_IEND, 4))
-         png_handle_IEND(png_ptr, info_ptr, length);
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, chunk_name))
-      {
-         if (!png_memcmp(chunk_name, png_IDAT, 4))
-            png_ptr->mode |= PNG_HAVE_IDAT;
-         png_handle_unknown(png_ptr, info_ptr, length);
-         if (!png_memcmp(chunk_name, png_PLTE, 4))
-            png_ptr->mode |= PNG_HAVE_PLTE;
-         else if (!png_memcmp(chunk_name, png_IDAT, 4))
-         {
-            if (!(png_ptr->mode & PNG_HAVE_IHDR))
-               png_error(png_ptr, "Missing IHDR before IDAT");
-            else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-                     !(png_ptr->mode & PNG_HAVE_PLTE))
-               png_error(png_ptr, "Missing PLTE before IDAT");
-            break;
-         }
-      }
-#endif
-      else if (!png_memcmp(chunk_name, png_PLTE, 4))
-         png_handle_PLTE(png_ptr, info_ptr, length);
-      else if (!png_memcmp(chunk_name, png_IDAT, 4))
-      {
-         if (!(png_ptr->mode & PNG_HAVE_IHDR))
-            png_error(png_ptr, "Missing IHDR before IDAT");
-         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-                  !(png_ptr->mode & PNG_HAVE_PLTE))
-            png_error(png_ptr, "Missing PLTE before IDAT");
-
-         png_ptr->idat_size = length;
-         png_ptr->mode |= PNG_HAVE_IDAT;
-         break;
-      }
-#ifdef PNG_READ_bKGD_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_bKGD, 4))
-         png_handle_bKGD(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_cHRM, 4))
-         png_handle_cHRM(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_gAMA, 4))
-         png_handle_gAMA(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_hIST, 4))
-         png_handle_hIST(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_oFFs, 4))
-         png_handle_oFFs(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pCAL, 4))
-         png_handle_pCAL(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sCAL, 4))
-         png_handle_sCAL(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pHYs, 4))
-         png_handle_pHYs(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sBIT, 4))
-         png_handle_sBIT(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sRGB, 4))
-         png_handle_sRGB(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iCCP, 4))
-         png_handle_iCCP(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sPLT, 4))
-         png_handle_sPLT(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tEXt, 4))
-         png_handle_tEXt(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tIME, 4))
-         png_handle_tIME(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tRNS, 4))
-         png_handle_tRNS(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_zTXt, 4))
-         png_handle_zTXt(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iTXt, 4))
-         png_handle_iTXt(png_ptr, info_ptr, length);
-#endif
-      else
-         png_handle_unknown(png_ptr, info_ptr, length);
-   }
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-/* Optional call to update the users info_ptr structure */
-void PNGAPI
-png_read_update_info(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_read_update_info");
- 
-   if (png_ptr == NULL)
-      return;
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      png_read_start_row(png_ptr);
-   else
-      png_warning(png_ptr,
-      "Ignoring extra png_read_update_info() call; row buffer not reallocated");
-
-   png_read_transform_info(png_ptr, info_ptr);
-}
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Initialize palette, background, etc, after transformations
- * are set, but before any reading takes place.  This allows
- * the user to obtain a gamma-corrected palette, for example.
- * If the user doesn't call this, we will do it ourselves.
- */
-void PNGAPI
-png_start_read_image(png_structp png_ptr)
-{
-   png_debug(1, "in png_start_read_image");
- 
-   if (png_ptr == NULL)
-      return;
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      png_read_start_row(png_ptr);
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-void PNGAPI
-png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
-{
-   PNG_IDAT;
-   PNG_CONST int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,
-      0xff};
-   PNG_CONST int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
-   int ret;
- 
-   if (png_ptr == NULL)
-      return;
- 
-   png_debug2(1, "in png_read_row (row %lu, pass %d)",
-      (unsigned long) png_ptr->row_number, png_ptr->pass);
-
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      png_read_start_row(png_ptr);
-   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
-   {
-   /* Check for transforms that have been set but were defined out */
-#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)
-   if (png_ptr->transformations & PNG_FILLER)
-      png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
-    !defined(PNG_READ_PACKSWAP_SUPPORTED)
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)
-   if (png_ptr->transformations & PNG_PACK)
-      png_warning(png_ptr, "PNG_READ_PACK_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_warning(png_ptr, "PNG_READ_SHIFT_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)
-   if (png_ptr->transformations & PNG_BGR)
-      png_warning(png_ptr, "PNG_READ_BGR_SUPPORTED is not defined");
-#endif
-#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_warning(png_ptr, "PNG_READ_SWAP_SUPPORTED is not defined");
-#endif
-   }
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* If interlaced and we do not need a new row, combine row and return */
-   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
-   {
-      switch (png_ptr->pass)
-      {
-         case 0:
-            if (png_ptr->row_number & 0x07)
-            {
-               if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 1:
-            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
-            {
-               if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 2:
-            if ((png_ptr->row_number & 0x07) != 4)
-            {
-               if (dsp_row != NULL && (png_ptr->row_number & 4))
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 3:
-            if ((png_ptr->row_number & 3) || png_ptr->width < 3)
-            {
-               if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 4:
-            if ((png_ptr->row_number & 3) != 2)
-            {
-               if (dsp_row != NULL && (png_ptr->row_number & 2))
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 5:
-            if ((png_ptr->row_number & 1) || png_ptr->width < 2)
-            {
-               if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 6:
-            if (!(png_ptr->row_number & 1))
-            {
-               png_read_finish_row(png_ptr);
-               return;
-            }
-            break;
-      }
-   }
-#endif
-
-   if (!(png_ptr->mode & PNG_HAVE_IDAT))
-      png_error(png_ptr, "Invalid attempt to read row data");
-
-   png_ptr->zstream.next_out = png_ptr->row_buf;
-   png_ptr->zstream.avail_out =
-       (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
-       png_ptr->iwidth) + 1);
-   do
-   {
-      if (!(png_ptr->zstream.avail_in))
-      {
-         while (!png_ptr->idat_size)
-         {
-            png_crc_finish(png_ptr, 0);
-
-            png_ptr->idat_size = png_read_chunk_header(png_ptr);
-            if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-               png_error(png_ptr, "Not enough image data");
-         }
-         png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
-         png_ptr->zstream.next_in = png_ptr->zbuf;
-         if (png_ptr->zbuf_size > png_ptr->idat_size)
-            png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
-         png_crc_read(png_ptr, png_ptr->zbuf,
-            (png_size_t)png_ptr->zstream.avail_in);
-         png_ptr->idat_size -= png_ptr->zstream.avail_in;
-      }
-      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-      if (ret == Z_STREAM_END)
-      {
-         if (png_ptr->zstream.avail_out || png_ptr->zstream.avail_in ||
-            png_ptr->idat_size)
-            png_benign_error(png_ptr, "Extra compressed data");
-         png_ptr->mode |= PNG_AFTER_IDAT;
-         png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-         break;
-      }
-      if (ret != Z_OK)
-         png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
-                   "Decompression error");
-
-   } while (png_ptr->zstream.avail_out);
-
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->iwidth;
-   png_ptr->row_info.channels = png_ptr->channels;
-   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
-   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-       png_ptr->row_info.width);
-
-   if (png_ptr->row_buf[0])
-   png_read_filter_row(png_ptr, &(png_ptr->row_info),
-      png_ptr->row_buf + 1, png_ptr->prev_row + 1,
-      (int)(png_ptr->row_buf[0]));
-
-   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-      (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
-   {
-      /* Intrapixel differencing */
-      png_do_read_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
-   }
-#endif
-
-
-   if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
-      png_do_read_transformations(png_ptr);
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* Blow up interlaced rows to full size */
-   if (png_ptr->interlaced &&
-      (png_ptr->transformations & PNG_INTERLACE))
-   {
-      if (png_ptr->pass < 6)
-         /* Old interface (pre-1.0.9):
-          * png_do_read_interlace(&(png_ptr->row_info),
-          *    png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
-          */
-         png_do_read_interlace(png_ptr);
-
-      if (dsp_row != NULL)
-         png_combine_row(png_ptr, dsp_row,
-            png_pass_dsp_mask[png_ptr->pass]);
-      if (row != NULL)
-         png_combine_row(png_ptr, row,
-            png_pass_mask[png_ptr->pass]);
-   }
-   else
-#endif
-   {
-      if (row != NULL)
-         png_combine_row(png_ptr, row, 0xff);
-      if (dsp_row != NULL)
-         png_combine_row(png_ptr, dsp_row, 0xff);
-   }
-   png_read_finish_row(png_ptr);
-
-   if (png_ptr->read_row_fn != NULL)
-      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read one or more rows of image data.  If the image is interlaced,
- * and png_set_interlace_handling() has been called, the rows need to
- * contain the contents of the rows from the previous pass.  If the
- * image has alpha or transparency, and png_handle_alpha()[*] has been
- * called, the rows contents must be initialized to the contents of the
- * screen.
- *
- * "row" holds the actual image, and pixels are placed in it
- * as they arrive.  If the image is displayed after each pass, it will
- * appear to "sparkle" in.  "display_row" can be used to display a
- * "chunky" progressive image, with finer detail added as it becomes
- * available.  If you do not want this "chunky" display, you may pass
- * NULL for display_row.  If you do not want the sparkle display, and
- * you have not called png_handle_alpha(), you may pass NULL for rows.
- * If you have called png_handle_alpha(), and the image has either an
- * alpha channel or a transparency chunk, you must provide a buffer for
- * rows.  In this case, you do not have to provide a display_row buffer
- * also, but you may.  If the image is not interlaced, or if you have
- * not called png_set_interlace_handling(), the display_row buffer will
- * be ignored, so pass NULL to it.
- *
- * [*] png_handle_alpha() does not exist yet, as of this version of libpng
- */
-
-void PNGAPI
-png_read_rows(png_structp png_ptr, png_bytepp row,
-   png_bytepp display_row, png_uint_32 num_rows)
-{
-   png_uint_32 i;
-   png_bytepp rp;
-   png_bytepp dp;
-
-   png_debug(1, "in png_read_rows");
- 
-   if (png_ptr == NULL)
-      return;
-   rp = row;
-   dp = display_row;
-   if (rp != NULL && dp != NULL)
-      for (i = 0; i < num_rows; i++)
-      {
-         png_bytep rptr = *rp++;
-         png_bytep dptr = *dp++;
-
-         png_read_row(png_ptr, rptr, dptr);
-      }
-   else if (rp != NULL)
-      for (i = 0; i < num_rows; i++)
-      {
-         png_bytep rptr = *rp;
-         png_read_row(png_ptr, rptr, NULL);
-         rp++;
-      }
-   else if (dp != NULL)
-      for (i = 0; i < num_rows; i++)
-      {
-         png_bytep dptr = *dp;
-         png_read_row(png_ptr, NULL, dptr);
-         dp++;
-      }
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the entire image.  If the image has an alpha channel or a tRNS
- * chunk, and you have called png_handle_alpha()[*], you will need to
- * initialize the image to the current image that PNG will be overlaying.
- * We set the num_rows again here, in case it was incorrectly set in
- * png_read_start_row() by a call to png_read_update_info() or
- * png_start_read_image() if png_set_interlace_handling() wasn't called
- * prior to either of these functions like it should have been.  You can
- * only call this function once.  If you desire to have an image for
- * each pass of a interlaced image, use png_read_rows() instead.
- *
- * [*] png_handle_alpha() does not exist yet, as of this version of libpng
- */
-void PNGAPI
-png_read_image(png_structp png_ptr, png_bytepp image)
-{
-   png_uint_32 i, image_height;
-   int pass, j;
-   png_bytepp rp;
-
-   png_debug(1, "in png_read_image");
- 
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   pass = png_set_interlace_handling(png_ptr);
-#else
-   if (png_ptr->interlaced)
-      png_error(png_ptr,
-        "Cannot read interlaced image -- interlace handler disabled");
-   pass = 1;
-#endif
-
-
-   image_height=png_ptr->height;
-   png_ptr->num_rows = image_height; /* Make sure this is set correctly */
-
-   for (j = 0; j < pass; j++)
-   {
-      rp = image;
-      for (i = 0; i < image_height; i++)
-      {
-         png_read_row(png_ptr, *rp, NULL);
-         rp++;
-      }
-   }
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-/* Read the end of the PNG file.  Will not read past the end of the
- * file, will verify the end is accurate, and will read any comments
- * or time information at the end of the file, if info is not NULL.
- */
-void PNGAPI
-png_read_end(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_read_end");
- 
-   if (png_ptr == NULL)
-      return;
-   png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
-
-   do
-   {
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
-      png_uint_32 length = png_read_chunk_header(png_ptr);
-      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
-
-      if (!png_memcmp(chunk_name, png_IHDR, 4))
-         png_handle_IHDR(png_ptr, info_ptr, length);
-      else if (!png_memcmp(chunk_name, png_IEND, 4))
-         png_handle_IEND(png_ptr, info_ptr, length);
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, chunk_name))
-      {
-         if (!png_memcmp(chunk_name, png_IDAT, 4))
-         {
-            if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
-               png_benign_error(png_ptr, "Too many IDATs found");
-         }
-         png_handle_unknown(png_ptr, info_ptr, length);
-         if (!png_memcmp(chunk_name, png_PLTE, 4))
-            png_ptr->mode |= PNG_HAVE_PLTE;
-      }
-#endif
-      else if (!png_memcmp(chunk_name, png_IDAT, 4))
-      {
-         /* Zero length IDATs are legal after the last IDAT has been
-          * read, but not after other chunks have been read.
-          */
-         if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
-            png_benign_error(png_ptr, "Too many IDATs found");
-         png_crc_finish(png_ptr, length);
-      }
-      else if (!png_memcmp(chunk_name, png_PLTE, 4))
-         png_handle_PLTE(png_ptr, info_ptr, length);
-#ifdef PNG_READ_bKGD_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_bKGD, 4))
-         png_handle_bKGD(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_cHRM, 4))
-         png_handle_cHRM(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_gAMA, 4))
-         png_handle_gAMA(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_hIST, 4))
-         png_handle_hIST(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_oFFs, 4))
-         png_handle_oFFs(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pCAL, 4))
-         png_handle_pCAL(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sCAL, 4))
-         png_handle_sCAL(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pHYs, 4))
-         png_handle_pHYs(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sBIT, 4))
-         png_handle_sBIT(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sRGB, 4))
-         png_handle_sRGB(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iCCP, 4))
-         png_handle_iCCP(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sPLT, 4))
-         png_handle_sPLT(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tEXt, 4))
-         png_handle_tEXt(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tIME, 4))
-         png_handle_tIME(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tRNS, 4))
-         png_handle_tRNS(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_zTXt, 4))
-         png_handle_zTXt(png_ptr, info_ptr, length);
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iTXt, 4))
-         png_handle_iTXt(png_ptr, info_ptr, length);
-#endif
-      else
-         png_handle_unknown(png_ptr, info_ptr, length);
-   } while (!(png_ptr->mode & PNG_HAVE_IEND));
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-/* Free all memory used by the read */
-void PNGAPI
-png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
-   png_infopp end_info_ptr_ptr)
-{
-   png_structp png_ptr = NULL;
-   png_infop info_ptr = NULL, end_info_ptr = NULL;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_free_ptr free_fn = NULL;
-   png_voidp mem_ptr = NULL;
-#endif
-
-   png_debug(1, "in png_destroy_read_struct");
- 
-   if (png_ptr_ptr != NULL)
-      png_ptr = *png_ptr_ptr;
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   free_fn = png_ptr->free_fn;
-   mem_ptr = png_ptr->mem_ptr;
-#endif
-
-   if (info_ptr_ptr != NULL)
-      info_ptr = *info_ptr_ptr;
-
-   if (end_info_ptr_ptr != NULL)
-      end_info_ptr = *end_info_ptr_ptr;
-
-   png_read_destroy(png_ptr, info_ptr, end_info_ptr);
-
-   if (info_ptr != NULL)
-   {
-#ifdef PNG_TEXT_SUPPORTED
-      png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, -1);
-#endif
-
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)info_ptr, (png_free_ptr)free_fn,
-          (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)info_ptr);
-#endif
-      *info_ptr_ptr = NULL;
-   }
-
-   if (end_info_ptr != NULL)
-   {
-#ifdef PNG_READ_TEXT_SUPPORTED
-      png_free_data(png_ptr, end_info_ptr, PNG_FREE_TEXT, -1);
-#endif
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)end_info_ptr, (png_free_ptr)free_fn,
-         (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)end_info_ptr);
-#endif
-      *end_info_ptr_ptr = NULL;
-   }
-
-   if (png_ptr != NULL)
-   {
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)png_ptr, (png_free_ptr)free_fn,
-          (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)png_ptr);
-#endif
-      *png_ptr_ptr = NULL;
-   }
-}
-
-/* Free all memory used by the read (old method) */
-void /* PRIVATE */
-png_read_destroy(png_structp png_ptr, png_infop info_ptr,
-    png_infop end_info_ptr)
-{
-#ifdef PNG_SETJMP_SUPPORTED
-   jmp_buf tmp_jmp;
-#endif
-   png_error_ptr error_fn;
-   png_error_ptr warning_fn;
-   png_voidp error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_free_ptr free_fn;
-#endif
-
-   png_debug(1, "in png_read_destroy");
- 
-   if (info_ptr != NULL)
-      png_info_destroy(png_ptr, info_ptr);
-
-   if (end_info_ptr != NULL)
-      png_info_destroy(png_ptr, end_info_ptr);
-
-   png_free(png_ptr, png_ptr->zbuf);
-   png_free(png_ptr, png_ptr->big_row_buf);
-   png_free(png_ptr, png_ptr->prev_row);
-   png_free(png_ptr, png_ptr->chunkdata);
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   png_free(png_ptr, png_ptr->palette_lookup);
-   png_free(png_ptr, png_ptr->quantize_index);
-#endif
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   png_free(png_ptr, png_ptr->gamma_table);
-#endif
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   png_free(png_ptr, png_ptr->gamma_from_1);
-   png_free(png_ptr, png_ptr->gamma_to_1);
-#endif
-   if (png_ptr->free_me & PNG_FREE_PLTE)
-      png_zfree(png_ptr, png_ptr->palette);
-   png_ptr->free_me &= ~PNG_FREE_PLTE;
-#if defined(PNG_tRNS_SUPPORTED) || \
-    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-   if (png_ptr->free_me & PNG_FREE_TRNS)
-      png_free(png_ptr, png_ptr->trans_alpha);
-   png_ptr->free_me &= ~PNG_FREE_TRNS;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-   if (png_ptr->free_me & PNG_FREE_HIST)
-      png_free(png_ptr, png_ptr->hist);
-   png_ptr->free_me &= ~PNG_FREE_HIST;
-#endif
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   if (png_ptr->gamma_16_table != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_table[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_table);
-   }
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if (png_ptr->gamma_16_from_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_from_1);
-   }
-   if (png_ptr->gamma_16_to_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_to_1);
-   }
-#endif
-#endif
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_free(png_ptr, png_ptr->time_buffer);
-#endif
-
-   inflateEnd(&png_ptr->zstream);
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-   png_free(png_ptr, png_ptr->save_buffer);
-#endif
-
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-#ifdef PNG_TEXT_SUPPORTED
-   png_free(png_ptr, png_ptr->current_text);
-#endif /* PNG_TEXT_SUPPORTED */
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
-   /* Save the important info out of the png_struct, in case it is
-    * being used again.
-    */
-#ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
-#endif
-
-   error_fn = png_ptr->error_fn;
-   warning_fn = png_ptr->warning_fn;
-   error_ptr = png_ptr->error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   free_fn = png_ptr->free_fn;
-#endif
-
-   png_memset(png_ptr, 0, png_sizeof(png_struct));
-
-   png_ptr->error_fn = error_fn;
-   png_ptr->warning_fn = warning_fn;
-   png_ptr->error_ptr = error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_ptr->free_fn = free_fn;
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
-#endif
-
-}
-
-void PNGAPI
-png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
-{
-   if (png_ptr == NULL)
-      return;
-   png_ptr->read_row_fn = read_row_fn;
-}
-
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-void PNGAPI
-png_read_png(png_structp png_ptr, png_infop info_ptr,
-                           int transforms,
-                           voidp params)
-{
-   int row;
-
-   if (png_ptr == NULL)
-      return;
-
-   /* png_read_info() gives us all of the information from the
-    * PNG file before the first IDAT (image data chunk).
-    */
-   png_read_info(png_ptr, info_ptr);
-   if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep))
-      png_error(png_ptr, "Image is too high to process with png_read_png()");
-
-   /* -------------- image transformations start here ------------------- */
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-   /* Tell libpng to strip 16 bit/color files down to 8 bits per color.
-    */
-   if (transforms & PNG_TRANSFORM_STRIP_16)
-      png_set_strip_16(png_ptr);
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   /* Strip alpha bytes from the input data without combining with
-    * the background (not recommended).
-    */
-   if (transforms & PNG_TRANSFORM_STRIP_ALPHA)
-      png_set_strip_alpha(png_ptr);
-#endif
-
-#if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)
-   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
-    * byte into separate bytes (useful for paletted and grayscale images).
-    */
-   if (transforms & PNG_TRANSFORM_PACKING)
-      png_set_packing(png_ptr);
-#endif
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-   /* Change the order of packed pixels to least significant bit first
-    * (not useful if you are using png_set_packing).
-    */
-   if (transforms & PNG_TRANSFORM_PACKSWAP)
-      png_set_packswap(png_ptr);
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   /* Expand paletted colors into true RGB triplets
-    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
-    * Expand paletted or RGB images with transparency to full alpha
-    * channels so the data will be available as RGBA quartets.
-    */
-   if (transforms & PNG_TRANSFORM_EXPAND)
-      if ((png_ptr->bit_depth < 8) ||
-          (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||
-          (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))
-         png_set_expand(png_ptr);
-#endif
-
-   /* We don't handle background color or gamma transformation or quantizing.
-    */
-
-#ifdef PNG_READ_INVERT_SUPPORTED
-   /* Invert monochrome files to have 0 as white and 1 as black
-    */
-   if (transforms & PNG_TRANSFORM_INVERT_MONO)
-      png_set_invert_mono(png_ptr);
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-   /* If you want to shift the pixel values from the range [0,255] or
-    * [0,65535] to the original [0,7] or [0,31], or whatever range the
-    * colors were originally in:
-    */
-   if ((transforms & PNG_TRANSFORM_SHIFT)
-       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
-   {
-      png_color_8p sig_bit;
-
-      png_get_sBIT(png_ptr, info_ptr, &sig_bit);
-      png_set_shift(png_ptr, sig_bit);
-   }
-#endif
-
-#ifdef PNG_READ_BGR_SUPPORTED
-   /* Flip the RGB pixels to BGR (or RGBA to BGRA)
-    */
-   if (transforms & PNG_TRANSFORM_BGR)
-      png_set_bgr(png_ptr);
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR)
-    */
-   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
-       png_set_swap_alpha(png_ptr);
-#endif
-
-#ifdef PNG_READ_SWAP_SUPPORTED
-   /* Swap bytes of 16 bit files to least significant byte first
-    */
-   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
-      png_set_swap(png_ptr);
-#endif
-
-/* Added at libpng-1.2.41 */
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-   /* Invert the alpha channel from opacity to transparency
-    */
-   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
-       png_set_invert_alpha(png_ptr);
-#endif
-
-/* Added at libpng-1.2.41 */
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* Expand grayscale image to RGB
-    */
-   if (transforms & PNG_TRANSFORM_GRAY_TO_RGB)
-       png_set_gray_to_rgb(png_ptr);
-#endif
-
-   /* We don't handle adding filler bytes */
-
-   /* Optional call to gamma correct and add the background to the palette
-    * and update info structure.  REQUIRED if you are expecting libpng to
-    * update the palette for you (i.e., you selected such a transform above).
-    */
-   png_read_update_info(png_ptr, info_ptr);
-
-   /* -------------- image transformations end here ------------------- */
-
-   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
-   if (info_ptr->row_pointers == NULL)
-   {
-    png_uint_32 iptr;
-
-      info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,
-         info_ptr->height * png_sizeof(png_bytep));
-      for (iptr=0; iptr<info_ptr->height; iptr++)
-         info_ptr->row_pointers[iptr] = NULL;
-
-      info_ptr->free_me |= PNG_FREE_ROWS;
-
-      for (row = 0; row < (int)info_ptr->height; row++)
-         info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,
-            png_get_rowbytes(png_ptr, info_ptr));
-   }
-
-   png_read_image(png_ptr, info_ptr->row_pointers);
-   info_ptr->valid |= PNG_INFO_IDAT;
-
-   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
-   png_read_end(png_ptr, info_ptr);
-
-   transforms = transforms; /* Quiet compiler warnings */
-   params = params;
-
-}
-#endif /* PNG_INFO_IMAGE_SUPPORTED */
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED */
diff --git a/thirdparty/libpng/pngrio.c b/thirdparty/libpng/pngrio.c
deleted file mode 100644
index 59059ca..0000000
--- a/thirdparty/libpng/pngrio.c
+++ /dev/null
@@ -1,163 +0,0 @@
-
-/* pngrio.c - functions for data input
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all input.  Users who need
- * special handling are expected to write a function that has the same
- * arguments as this and performs a similar function, but that possibly
- * has a different input method.  Note that you shouldn't change this
- * function, but rather write a replacement function and then make
- * libpng use it at run time with png_set_read_fn(...).
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_READ_SUPPORTED
-#include "pngpriv.h"
-
-/* Read the data from whatever input you are using.  The default routine
- * reads from a file pointer.  Note that this routine sometimes gets called
- * with very small lengths, so you should implement some kind of simple
- * buffering if you are using unbuffered reads.  This should never be asked
- * to read more then 64K on a 16 bit machine.
- */
-void /* PRIVATE */
-png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_debug1(4, "reading %d bytes", (int)length);
- 
-   if (png_ptr->read_data_fn != NULL)
-      (*(png_ptr->read_data_fn))(png_ptr, data, length);
-   else
-      png_error(png_ptr, "Call to NULL read function");
-}
-
-#ifdef PNG_STDIO_SUPPORTED
-/* This is the function that does the actual reading of data.  If you are
- * not reading from a standard C stream, you should create a replacement
- * read_data function and use it at run time with png_set_read_fn(), rather
- * than changing the library.
- */
-#ifndef USE_FAR_KEYWORD
-void PNGAPI
-png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-
-   if (png_ptr == NULL)
-      return;
-   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
-    * instead of an int, which is what fread() actually returns.
-    */
-   check = fread(data, 1, length, (png_FILE_p)png_ptr->io_ptr);
-
-   if (check != length)
-      png_error(png_ptr, "Read Error");
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void PNGAPI
-png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *n_data;
-   png_FILE_p io_ptr;
-
-   if (png_ptr == NULL)
-      return;
-   /* Check if data really is near. If so, use usual code. */
-   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
-   if ((png_bytep)n_data == data)
-   {
-      check = fread(n_data, 1, length, io_ptr);
-   }
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t read, remaining, err;
-      check = 0;
-      remaining = length;
-      do
-      {
-         read = MIN(NEAR_BUF_SIZE, remaining);
-         err = fread(buf, 1, read, io_ptr);
-         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
-         if (err != read)
-            break;
-         else
-            check += err;
-         data += read;
-         remaining -= read;
-      }
-      while (remaining != 0);
-   }
-   if ((png_uint_32)check != (png_uint_32)length)
-      png_error(png_ptr, "read Error");
-}
-#endif
-#endif
-
-/* This function allows the application to supply a new input function
- * for libpng if standard C streams aren't being used.
- *
- * This function takes as its arguments:
- * png_ptr      - pointer to a png input data structure
- * io_ptr       - pointer to user supplied structure containing info about
- *                the input functions.  May be NULL.
- * read_data_fn - pointer to a new input function that takes as its
- *                arguments a pointer to a png_struct, a pointer to
- *                a location where input data can be stored, and a 32-bit
- *                unsigned int that is the number of bytes to be read.
- *                To exit and output any fatal error messages the new write
- *                function should call png_error(png_ptr, "Error msg").
- *                May be NULL, in which case libpng's default function will
- *                be used.
- */
-void PNGAPI
-png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
-   png_rw_ptr read_data_fn)
-{
-   if (png_ptr == NULL)
-      return;
-   png_ptr->io_ptr = io_ptr;
-
-#ifdef PNG_STDIO_SUPPORTED
-   if (read_data_fn != NULL)
-      png_ptr->read_data_fn = read_data_fn;
-   else
-      png_ptr->read_data_fn = png_default_read_data;
-#else
-   png_ptr->read_data_fn = read_data_fn;
-#endif
-
-   /* It is an error to write to a read device */
-   if (png_ptr->write_data_fn != NULL)
-   {
-      png_ptr->write_data_fn = NULL;
-      png_warning(png_ptr,
-         "It's an error to set both read_data_fn and write_data_fn in the ");
-      png_warning(png_ptr,
-         "same structure.  Resetting write_data_fn to NULL");
-   }
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-   png_ptr->output_flush_fn = NULL;
-#endif
-}
-#endif /* PNG_READ_SUPPORTED */
diff --git a/thirdparty/libpng/pngrtran.c b/thirdparty/libpng/pngrtran.c
deleted file mode 100644
index b5e8f1a..0000000
--- a/thirdparty/libpng/pngrtran.c
+++ /dev/null
@@ -1,4203 +0,0 @@
-
-/* pngrtran.c - transforms the data in a row for PNG readers
- *
- * Last changed in libpng 1.4.2 [May 6, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file contains functions optionally called by an application
- * in order to tell libpng how to handle data when reading a PNG.
- * Transformations that are used in both reading and writing are
- * in pngtrans.c.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_READ_SUPPORTED
-#include "pngpriv.h"
-
-/* Set the action on getting a CRC error for an ancillary or critical chunk. */
-void PNGAPI
-png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
-{
-   png_debug(1, "in png_set_crc_action");
- 
-   if (png_ptr == NULL)
-      return;
-
-   /* Tell libpng how we react to CRC errors in critical chunks */
-   switch (crit_action)
-   {
-      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
-         break;
-
-      case PNG_CRC_WARN_USE:                               /* Warn/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
-         break;
-
-      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
-                           PNG_FLAG_CRC_CRITICAL_IGNORE;
-         break;
-
-      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
-         png_warning(png_ptr,
-            "Can't discard critical data on CRC error");
-      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
-
-      case PNG_CRC_DEFAULT:
-      default:
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         break;
-   }
-
-   /* Tell libpng how we react to CRC errors in ancillary chunks */
-   switch (ancil_action)
-   {
-      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
-         break;
-
-      case PNG_CRC_WARN_USE:                              /* Warn/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
-         break;
-
-      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
-                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
-         break;
-
-      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
-         break;
-
-      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */
-
-      case PNG_CRC_DEFAULT:
-      default:
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         break;
-   }
-}
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
-    defined(PNG_FLOATING_POINT_SUPPORTED)
-/* Handle alpha and tRNS via a background color */
-void PNGAPI
-png_set_background(png_structp png_ptr,
-   png_color_16p background_color, int background_gamma_code,
-   int need_expand, double background_gamma)
-{
-   png_debug(1, "in png_set_background");
- 
-   if (png_ptr == NULL)
-      return;
-   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
-   {
-      png_warning(png_ptr, "Application must supply a known background gamma");
-      return;
-   }
-
-   png_ptr->transformations |= PNG_BACKGROUND;
-   png_memcpy(&(png_ptr->background), background_color,
-      png_sizeof(png_color_16));
-   png_ptr->background_gamma = (float)background_gamma;
-   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
-   png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);
-}
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-/* Strip 16 bit depth files to 8 bit depth */
-void PNGAPI
-png_set_strip_16(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_strip_16");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_16_TO_8;
-}
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-void PNGAPI
-png_set_strip_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_strip_alpha");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
-}
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-/* Quantize file to 8 bit.  Supply a palette, the current number
- * of elements in the palette, the maximum number of elements
- * allowed, and a histogram if possible.  If the current number
- * of colors is greater then the maximum number, the palette will be
- * modified to fit in the maximum number.  "full_quantize" indicates
- * whether we need a quantizeing cube set up for RGB images, or if we
- * simply are reducing the number of colors in a paletted image.
- */
-
-typedef struct png_dsort_struct
-{
-   struct png_dsort_struct FAR * next;
-   png_byte left;
-   png_byte right;
-} png_dsort;
-typedef png_dsort FAR *       png_dsortp;
-typedef png_dsort FAR * FAR * png_dsortpp;
-
-void PNGAPI
-png_set_quantize(png_structp png_ptr, png_colorp palette,
-   int num_palette, int maximum_colors, png_uint_16p histogram,
-   int full_quantize)
-{
-   png_debug(1, "in png_set_quantize");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_QUANTIZE;
-
-   if (!full_quantize)
-   {
-      int i;
-
-      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
-         (png_uint_32)(num_palette * png_sizeof(png_byte)));
-      for (i = 0; i < num_palette; i++)
-         png_ptr->quantize_index[i] = (png_byte)i;
-   }
-
-   if (num_palette > maximum_colors)
-   {
-      if (histogram != NULL)
-      {
-         /* This is easy enough, just throw out the least used colors.
-          * Perhaps not the best solution, but good enough.
-          */
-
-         int i;
-
-         /* Initialize an array to sort colors */
-         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof(png_byte)));
-
-         /* Initialize the quantize_sort array */
-         for (i = 0; i < num_palette; i++)
-            png_ptr->quantize_sort[i] = (png_byte)i;
-
-         /* Find the least used palette entries by starting a
-          * bubble sort, and running it until we have sorted
-          * out enough colors.  Note that we don't care about
-          * sorting all the colors, just finding which are
-          * least used.
-          */
-
-         for (i = num_palette - 1; i >= maximum_colors; i--)
-         {
-            int done; /* To stop early if the list is pre-sorted */
-            int j;
-
-            done = 1;
-            for (j = 0; j < i; j++)
-            {
-               if (histogram[png_ptr->quantize_sort[j]]
-                   < histogram[png_ptr->quantize_sort[j + 1]])
-               {
-                  png_byte t;
-
-                  t = png_ptr->quantize_sort[j];
-                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];
-                  png_ptr->quantize_sort[j + 1] = t;
-                  done = 0;
-               }
-            }
-            if (done)
-               break;
-         }
-
-         /* Swap the palette around, and set up a table, if necessary */
-         if (full_quantize)
-         {
-            int j = num_palette;
-
-            /* Put all the useful colors within the max, but don't
-             * move the others.
-             */
-            for (i = 0; i < maximum_colors; i++)
-            {
-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
-               {
-                  do
-                     j--;
-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
-                  palette[i] = palette[j];
-               }
-            }
-         }
-         else
-         {
-            int j = num_palette;
-
-            /* Move all the used colors inside the max limit, and
-             * develop a translation table.
-             */
-            for (i = 0; i < maximum_colors; i++)
-            {
-               /* Only move the colors we need to */
-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
-               {
-                  png_color tmp_color;
-
-                  do
-                     j--;
-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
-
-                  tmp_color = palette[j];
-                  palette[j] = palette[i];
-                  palette[i] = tmp_color;
-                  /* Indicate where the color went */
-                  png_ptr->quantize_index[j] = (png_byte)i;
-                  png_ptr->quantize_index[i] = (png_byte)j;
-               }
-            }
-
-            /* Find closest color for those colors we are not using */
-            for (i = 0; i < num_palette; i++)
-            {
-               if ((int)png_ptr->quantize_index[i] >= maximum_colors)
-               {
-                  int min_d, k, min_k, d_index;
-
-                  /* Find the closest color to one we threw out */
-                  d_index = png_ptr->quantize_index[i];
-                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
-                  for (k = 1, min_k = 0; k < maximum_colors; k++)
-                  {
-                     int d;
-
-                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);
-
-                     if (d < min_d)
-                     {
-                        min_d = d;
-                        min_k = k;
-                     }
-                  }
-                  /* Point to closest color */
-                  png_ptr->quantize_index[i] = (png_byte)min_k;
-               }
-            }
-         }
-         png_free(png_ptr, png_ptr->quantize_sort);
-         png_ptr->quantize_sort = NULL;
-      }
-      else
-      {
-         /* This is much harder to do simply (and quickly).  Perhaps
-          * we need to go through a median cut routine, but those
-          * don't always behave themselves with only a few colors
-          * as input.  So we will just find the closest two colors,
-          * and throw out one of them (chosen somewhat randomly).
-          * [We don't understand this at all, so if someone wants to
-          *  work on improving it, be our guest - AED, GRP]
-          */
-         int i;
-         int max_d;
-         int num_new_palette;
-         png_dsortp t;
-         png_dsortpp hash;
-
-         t = NULL;
-
-         /* Initialize palette index arrays */
-         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof(png_byte)));
-         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(num_palette * png_sizeof(png_byte)));
-
-         /* Initialize the sort array */
-         for (i = 0; i < num_palette; i++)
-         {
-            png_ptr->index_to_palette[i] = (png_byte)i;
-            png_ptr->palette_to_index[i] = (png_byte)i;
-         }
-
-         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
-            png_sizeof(png_dsortp)));
-
-         num_new_palette = num_palette;
-
-         /* Initial wild guess at how far apart the farthest pixel
-          * pair we will be eliminating will be.  Larger
-          * numbers mean more areas will be allocated, Smaller
-          * numbers run the risk of not saving enough data, and
-          * having to do this all over again.
-          *
-          * I have not done extensive checking on this number.
-          */
-         max_d = 96;
-
-         while (num_new_palette > maximum_colors)
-         {
-            for (i = 0; i < num_new_palette - 1; i++)
-            {
-               int j;
-
-               for (j = i + 1; j < num_new_palette; j++)
-               {
-                  int d;
-
-                  d = PNG_COLOR_DIST(palette[i], palette[j]);
-
-                  if (d <= max_d)
-                  {
-
-                     t = (png_dsortp)png_malloc_warn(png_ptr,
-                         (png_uint_32)(png_sizeof(png_dsort)));
-                     if (t == NULL)
-                         break;
-                     t->next = hash[d];
-                     t->left = (png_byte)i;
-                     t->right = (png_byte)j;
-                     hash[d] = t;
-                  }
-               }
-               if (t == NULL)
-                  break;
-            }
-
-            if (t != NULL)
-            for (i = 0; i <= max_d; i++)
-            {
-               if (hash[i] != NULL)
-               {
-                  png_dsortp p;
-
-                  for (p = hash[i]; p; p = p->next)
-                  {
-                     if ((int)png_ptr->index_to_palette[p->left]
-                        < num_new_palette &&
-                        (int)png_ptr->index_to_palette[p->right]
-                        < num_new_palette)
-                     {
-                        int j, next_j;
-
-                        if (num_new_palette & 0x01)
-                        {
-                           j = p->left;
-                           next_j = p->right;
-                        }
-                        else
-                        {
-                           j = p->right;
-                           next_j = p->left;
-                        }
-
-                        num_new_palette--;
-                        palette[png_ptr->index_to_palette[j]]
-                          = palette[num_new_palette];
-                        if (!full_quantize)
-                        {
-                           int k;
-
-                           for (k = 0; k < num_palette; k++)
-                           {
-                              if (png_ptr->quantize_index[k] ==
-                                 png_ptr->index_to_palette[j])
-                                 png_ptr->quantize_index[k] =
-                                    png_ptr->index_to_palette[next_j];
-                              if ((int)png_ptr->quantize_index[k] ==
-                                 num_new_palette)
-                                 png_ptr->quantize_index[k] =
-                                    png_ptr->index_to_palette[j];
-                           }
-                        }
-
-                        png_ptr->index_to_palette[png_ptr->palette_to_index
-                           [num_new_palette]] = png_ptr->index_to_palette[j];
-                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
-                           = png_ptr->palette_to_index[num_new_palette];
-
-                        png_ptr->index_to_palette[j] =
-                            (png_byte)num_new_palette;
-                        png_ptr->palette_to_index[num_new_palette] =
-                            (png_byte)j;
-                     }
-                     if (num_new_palette <= maximum_colors)
-                        break;
-                  }
-                  if (num_new_palette <= maximum_colors)
-                     break;
-               }
-            }
-
-            for (i = 0; i < 769; i++)
-            {
-               if (hash[i] != NULL)
-               {
-                  png_dsortp p = hash[i];
-                  while (p)
-                  {
-                     t = p->next;
-                     png_free(png_ptr, p);
-                     p = t;
-                  }
-               }
-               hash[i] = 0;
-            }
-            max_d += 96;
-         }
-         png_free(png_ptr, hash);
-         png_free(png_ptr, png_ptr->palette_to_index);
-         png_free(png_ptr, png_ptr->index_to_palette);
-         png_ptr->palette_to_index = NULL;
-         png_ptr->index_to_palette = NULL;
-      }
-      num_palette = maximum_colors;
-   }
-   if (png_ptr->palette == NULL)
-   {
-      png_ptr->palette = palette;
-   }
-   png_ptr->num_palette = (png_uint_16)num_palette;
-
-   if (full_quantize)
-   {
-      int i;
-      png_bytep distance;
-      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +
-         PNG_QUANTIZE_BLUE_BITS;
-      int num_red = (1 << PNG_QUANTIZE_RED_BITS);
-      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);
-      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);
-      png_size_t num_entries = ((png_size_t)1 << total_bits);
-
-      png_ptr->palette_lookup = (png_bytep )png_calloc(png_ptr,
-         (png_uint_32)(num_entries * png_sizeof(png_byte)));
-
-      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
-         png_sizeof(png_byte)));
-      png_memset(distance, 0xff, num_entries * png_sizeof(png_byte));
-
-      for (i = 0; i < num_palette; i++)
-      {
-         int ir, ig, ib;
-         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));
-         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));
-         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));
-
-         for (ir = 0; ir < num_red; ir++)
-         {
-            /* int dr = abs(ir - r); */
-            int dr = ((ir > r) ? ir - r : r - ir);
-            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
-                PNG_QUANTIZE_GREEN_BITS));
-
-            for (ig = 0; ig < num_green; ig++)
-            {
-               /* int dg = abs(ig - g); */
-               int dg = ((ig > g) ? ig - g : g - ig);
-               int dt = dr + dg;
-               int dm = ((dr > dg) ? dr : dg);
-               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
-
-               for (ib = 0; ib < num_blue; ib++)
-               {
-                  int d_index = index_g | ib;
-                  /* int db = abs(ib - b); */
-                  int db = ((ib > b) ? ib - b : b - ib);
-                  int dmax = ((dm > db) ? dm : db);
-                  int d = dmax + dt + db;
-
-                  if (d < (int)distance[d_index])
-                  {
-                     distance[d_index] = (png_byte)d;
-                     png_ptr->palette_lookup[d_index] = (png_byte)i;
-                  }
-               }
-            }
-         }
-      }
-
-      png_free(png_ptr, distance);
-   }
-}
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
-/* Transform the image from the file_gamma to the screen_gamma.  We
- * only do transformations on images where the file_gamma and screen_gamma
- * are not close reciprocals, otherwise it slows things down slightly, and
- * also needlessly introduces small errors.
- *
- * We will turn off gamma transformation later if no semitransparent entries
- * are present in the tRNS array for palette images.  We can't do it here
- * because we don't necessarily have the tRNS chunk yet.
- */
-void PNGAPI
-png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
-{
-   png_debug(1, "in png_set_gamma");
-
-   if (png_ptr == NULL)
-      return;
-
-   if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||
-       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
-     png_ptr->transformations |= PNG_GAMMA;
-   png_ptr->gamma = (float)file_gamma;
-   png_ptr->screen_gamma = (float)scrn_gamma;
-}
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-/* Expand paletted images to RGB, expand grayscale images of
- * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
- * to alpha channels.
- */
-void PNGAPI
-png_set_expand(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_expand");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-/* GRR 19990627:  the following three functions currently are identical
- *  to png_set_expand().  However, it is entirely reasonable that someone
- *  might wish to expand an indexed image to RGB but *not* expand a single,
- *  fully transparent palette entry to a full alpha channel--perhaps instead
- *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
- *  the transparent color with a particular RGB value, or drop tRNS entirely.
- *  IOW, a future version of the library may make the transformations flag
- *  a bit more fine-grained, with separate bits for each of these three
- *  functions.
- *
- *  More to the point, these functions make it obvious what libpng will be
- *  doing, whereas "expand" can (and does) mean any number of things.
- *
- *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
- *  to expand only the sample depth but not to expand the tRNS to alpha
- *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
- */
-
-/* Expand paletted images to RGB. */
-void PNGAPI
-png_set_palette_to_rgb(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_palette_to_rgb");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-/* Expand grayscale images of less than 8-bit depth to 8 bits. */
-void PNGAPI
-png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_EXPAND;
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-
-
-/* Expand tRNS chunks to alpha channels. */
-void PNGAPI
-png_set_tRNS_to_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_tRNS_to_alpha");
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-void PNGAPI
-png_set_gray_to_rgb(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_gray_to_rgb");
-
-   png_ptr->transformations |= PNG_GRAY_TO_RGB;
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-/* Convert a RGB image to a grayscale of the same width.  This allows us,
- * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
- */
-
-void PNGAPI
-png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
-   double green)
-{
-   int red_fixed = (int)((float)red*100000.0 + 0.5);
-   int green_fixed = (int)((float)green*100000.0 + 0.5);
-   if (png_ptr == NULL)
-      return;
-   png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
-}
-#endif
-
-void PNGAPI
-png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
-   png_fixed_point red, png_fixed_point green)
-{
-   png_debug(1, "in png_set_rgb_to_gray");
-
-   if (png_ptr == NULL)
-      return;
-
-   switch(error_action)
-   {
-      case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
-              break;
-
-      case 2: png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
-              break;
-
-      case 3: png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
-   }
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-#ifdef PNG_READ_EXPAND_SUPPORTED
-      png_ptr->transformations |= PNG_EXPAND;
-#else
-   {
-      png_warning(png_ptr,
-        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED");
-      png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
-   }
-#endif
-   {
-      png_uint_16 red_int, green_int;
-      if (red < 0 || green < 0)
-      {
-         red_int   =  6968; /* .212671 * 32768 + .5 */
-         green_int = 23434; /* .715160 * 32768 + .5 */
-      }
-      else if (red + green < 100000L)
-      {
-         red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
-         green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
-      }
-      else
-      {
-         png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
-         red_int   =  6968;
-         green_int = 23434;
-      }
-      png_ptr->rgb_to_gray_red_coeff   = red_int;
-      png_ptr->rgb_to_gray_green_coeff = green_int;
-      png_ptr->rgb_to_gray_blue_coeff  =
-         (png_uint_16)(32768 - red_int - green_int);
-   }
-}
-#endif
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-void PNGAPI
-png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
-   read_user_transform_fn)
-{
-   png_debug(1, "in png_set_read_user_transform_fn");
-
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   png_ptr->transformations |= PNG_USER_TRANSFORM;
-   png_ptr->read_user_transform_fn = read_user_transform_fn;
-#endif
-}
-#endif
-
-/* Initialize everything needed for the read.  This includes modifying
- * the palette.
- */
-void /* PRIVATE */
-png_init_read_transformations(png_structp png_ptr)
-{
-   png_debug(1, "in png_init_read_transformations");
-
-  {
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-    defined(PNG_READ_SHIFT_SUPPORTED) || \
-    defined(PNG_READ_GAMMA_SUPPORTED)
-   int color_type = png_ptr->color_type;
-#endif
-
-#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* Detect gray background and attempt to enable optimization
-    * for gray --> RGB case
-    *
-    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
-    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
-    * background color might actually be gray yet not be flagged as such.
-    * This is not a problem for the current code, which uses
-    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
-    * png_do_gray_to_rgb() transformation.
-    */
-   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       !(color_type & PNG_COLOR_MASK_COLOR))
-   {
-          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-   } else if ((png_ptr->transformations & PNG_BACKGROUND) &&
-              !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-              (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-              png_ptr->background.red == png_ptr->background.green &&
-              png_ptr->background.red == png_ptr->background.blue)
-   {
-          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-          png_ptr->background.gray = png_ptr->background.red;
-   }
-#endif
-
-   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       (png_ptr->transformations & PNG_EXPAND))
-   {
-      if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
-      {
-         /* Expand background and tRNS chunks */
-         switch (png_ptr->bit_depth)
-         {
-            case 1:
-               png_ptr->background.gray *= (png_uint_16)0xff;
-               png_ptr->background.red = png_ptr->background.green
-                 =  png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                 png_ptr->trans_color.gray *= (png_uint_16)0xff;
-                 png_ptr->trans_color.red = png_ptr->trans_color.green
-                   = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
-               break;
-
-            case 2:
-               png_ptr->background.gray *= (png_uint_16)0x55;
-               png_ptr->background.red = png_ptr->background.green
-                 = png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                 png_ptr->trans_color.gray *= (png_uint_16)0x55;
-                 png_ptr->trans_color.red = png_ptr->trans_color.green
-                   = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
-               break;
-
-            case 4:
-               png_ptr->background.gray *= (png_uint_16)0x11;
-               png_ptr->background.red = png_ptr->background.green
-                 = png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                 png_ptr->trans_color.gray *= (png_uint_16)0x11;
-                 png_ptr->trans_color.red = png_ptr->trans_color.green
-                   = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
-               break;
-
-            case 8:
-
-            case 16:
-               png_ptr->background.red = png_ptr->background.green
-                 = png_ptr->background.blue = png_ptr->background.gray;
-               break;
-         }
-      }
-      else if (color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         png_ptr->background.red   =
-            png_ptr->palette[png_ptr->background.index].red;
-         png_ptr->background.green =
-            png_ptr->palette[png_ptr->background.index].green;
-         png_ptr->background.blue  =
-            png_ptr->palette[png_ptr->background.index].blue;
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-        if (png_ptr->transformations & PNG_INVERT_ALPHA)
-        {
-#ifdef PNG_READ_EXPAND_SUPPORTED
-           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-#endif
-           {
-           /* Invert the alpha channel (in tRNS) unless the pixels are
-            * going to be expanded, in which case leave it for later
-            */
-              int i, istop;
-              istop=(int)png_ptr->num_trans;
-              for (i=0; i<istop; i++)
-                 png_ptr->trans_alpha[i] = (png_byte)(255 - png_ptr->trans_alpha[i]);
-           }
-        }
-#endif
-
-      }
-   }
-#endif
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
-   png_ptr->background_1 = png_ptr->background;
-#endif
-#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
-
-   if ((color_type == PNG_COLOR_TYPE_PALETTE && png_ptr->num_trans != 0)
-       && (fabs(png_ptr->screen_gamma * png_ptr->gamma - 1.0)
-         < PNG_GAMMA_THRESHOLD))
-   {
-    int i, k;
-    k=0;
-    for (i=0; i<png_ptr->num_trans; i++)
-    {
-      if (png_ptr->trans_alpha[i] != 0 && png_ptr->trans_alpha[i] != 0xff)
-        k=1; /* Partial transparency is present */
-    }
-    if (k == 0)
-      png_ptr->transformations &= ~PNG_GAMMA;
-   }
-
-   if ((png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY)) &&
-        png_ptr->gamma != 0.0)
-   {
-      png_build_gamma_table(png_ptr, png_ptr->bit_depth);
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-      if (png_ptr->transformations & PNG_BACKGROUND)
-      {
-         if (color_type == PNG_COLOR_TYPE_PALETTE)
-         {
-           /* Could skip if no transparency */
-            png_color back, back_1;
-            png_colorp palette = png_ptr->palette;
-            int num_palette = png_ptr->num_palette;
-            int i;
-            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
-            {
-               back.red = png_ptr->gamma_table[png_ptr->background.red];
-               back.green = png_ptr->gamma_table[png_ptr->background.green];
-               back.blue = png_ptr->gamma_table[png_ptr->background.blue];
-
-               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
-               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
-               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
-            }
-            else
-            {
-               double g, gs;
-
-               switch (png_ptr->background_gamma_type)
-               {
-                  case PNG_BACKGROUND_GAMMA_SCREEN:
-                     g = (png_ptr->screen_gamma);
-                     gs = 1.0;
-                     break;
-
-                  case PNG_BACKGROUND_GAMMA_FILE:
-                     g = 1.0 / (png_ptr->gamma);
-                     gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
-                     break;
-
-                  case PNG_BACKGROUND_GAMMA_UNIQUE:
-                     g = 1.0 / (png_ptr->background_gamma);
-                     gs = 1.0 / (png_ptr->background_gamma *
-                                 png_ptr->screen_gamma);
-                     break;
-                  default:
-                     g = 1.0;    /* back_1 */
-                     gs = 1.0;   /* back */
-               }
-
-               if ( fabs(gs - 1.0) < PNG_GAMMA_THRESHOLD)
-               {
-                  back.red   = (png_byte)png_ptr->background.red;
-                  back.green = (png_byte)png_ptr->background.green;
-                  back.blue  = (png_byte)png_ptr->background.blue;
-               }
-               else
-               {
-                  back.red = (png_byte)(pow(
-                     (double)png_ptr->background.red/255.0, gs) * 255.0 + .5);
-                  back.green = (png_byte)(pow(
-                     (double)png_ptr->background.green/255.0, gs) * 255.0
-                         + .5);
-                  back.blue = (png_byte)(pow(
-                     (double)png_ptr->background.blue/255.0, gs) * 255.0 + .5);
-               }
-
-               back_1.red = (png_byte)(pow(
-                  (double)png_ptr->background.red/255.0, g) * 255.0 + .5);
-               back_1.green = (png_byte)(pow(
-                  (double)png_ptr->background.green/255.0, g) * 255.0 + .5);
-               back_1.blue = (png_byte)(pow(
-                  (double)png_ptr->background.blue/255.0, g) * 255.0 + .5);
-            }
-            for (i = 0; i < num_palette; i++)
-            {
-               if (i < (int)png_ptr->num_trans && png_ptr->trans_alpha[i] != 0xff)
-               {
-                  if (png_ptr->trans_alpha[i] == 0)
-                  {
-                     palette[i] = back;
-                  }
-                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
-                  {
-                     png_byte v, w;
-
-                     v = png_ptr->gamma_to_1[palette[i].red];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
-                     palette[i].red = png_ptr->gamma_from_1[w];
-
-                     v = png_ptr->gamma_to_1[palette[i].green];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
-                     palette[i].green = png_ptr->gamma_from_1[w];
-
-                     v = png_ptr->gamma_to_1[palette[i].blue];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);
-                     palette[i].blue = png_ptr->gamma_from_1[w];
-                  }
-               }
-               else
-               {
-                  palette[i].red = png_ptr->gamma_table[palette[i].red];
-                  palette[i].green = png_ptr->gamma_table[palette[i].green];
-                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
-               }
-            }
-            /* Prevent the transformations being done again, and make sure
-             * that the now spurious alpha channel is stripped - the code
-             * has just reduced background composition and gamma correction
-             * to a simple alpha channel strip.
-             */
-            png_ptr->transformations &= ~PNG_BACKGROUND;
-            png_ptr->transformations &= ~PNG_GAMMA;
-            png_ptr->transformations |= PNG_STRIP_ALPHA;
-         }
-         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
-         else
-         /* color_type != PNG_COLOR_TYPE_PALETTE */
-         {
-            double m = (double)(((png_uint_32)1 << png_ptr->bit_depth) - 1);
-            double g = 1.0;
-            double gs = 1.0;
-
-            switch (png_ptr->background_gamma_type)
-            {
-               case PNG_BACKGROUND_GAMMA_SCREEN:
-                  g = (png_ptr->screen_gamma);
-                  gs = 1.0;
-                  break;
-
-               case PNG_BACKGROUND_GAMMA_FILE:
-                  g = 1.0 / (png_ptr->gamma);
-                  gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
-                  break;
-
-               case PNG_BACKGROUND_GAMMA_UNIQUE:
-                  g = 1.0 / (png_ptr->background_gamma);
-                  gs = 1.0 / (png_ptr->background_gamma *
-                     png_ptr->screen_gamma);
-                  break;
-            }
-
-            png_ptr->background_1.gray = (png_uint_16)(pow(
-               (double)png_ptr->background.gray / m, g) * m + .5);
-            png_ptr->background.gray = (png_uint_16)(pow(
-               (double)png_ptr->background.gray / m, gs) * m + .5);
-
-            if ((png_ptr->background.red != png_ptr->background.green) ||
-                (png_ptr->background.red != png_ptr->background.blue) ||
-                (png_ptr->background.red != png_ptr->background.gray))
-            {
-               /* RGB or RGBA with color background */
-               png_ptr->background_1.red = (png_uint_16)(pow(
-                  (double)png_ptr->background.red / m, g) * m + .5);
-               png_ptr->background_1.green = (png_uint_16)(pow(
-                  (double)png_ptr->background.green / m, g) * m + .5);
-               png_ptr->background_1.blue = (png_uint_16)(pow(
-                  (double)png_ptr->background.blue / m, g) * m + .5);
-               png_ptr->background.red = (png_uint_16)(pow(
-                  (double)png_ptr->background.red / m, gs) * m + .5);
-               png_ptr->background.green = (png_uint_16)(pow(
-                  (double)png_ptr->background.green / m, gs) * m + .5);
-               png_ptr->background.blue = (png_uint_16)(pow(
-                  (double)png_ptr->background.blue / m, gs) * m + .5);
-            }
-            else
-            {
-               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
-               png_ptr->background_1.red = png_ptr->background_1.green
-                 = png_ptr->background_1.blue = png_ptr->background_1.gray;
-               png_ptr->background.red = png_ptr->background.green
-                 = png_ptr->background.blue = png_ptr->background.gray;
-            }
-         }
-      }
-      else
-      /* Transformation does not include PNG_BACKGROUND */
-#endif /* PNG_READ_BACKGROUND_SUPPORTED */
-      if (color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         png_colorp palette = png_ptr->palette;
-         int num_palette = png_ptr->num_palette;
-         int i;
-
-         for (i = 0; i < num_palette; i++)
-         {
-            palette[i].red = png_ptr->gamma_table[palette[i].red];
-            palette[i].green = png_ptr->gamma_table[palette[i].green];
-            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
-         }
-
-         /* Done the gamma correction. */
-         png_ptr->transformations &= ~PNG_GAMMA;
-      }
-   }
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   else
-#endif
-#endif /* PNG_READ_GAMMA_SUPPORTED && PNG_FLOATING_POINT_SUPPORTED */
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   /* No GAMMA transformation */
-   if ((png_ptr->transformations & PNG_BACKGROUND) &&
-       (color_type == PNG_COLOR_TYPE_PALETTE))
-   {
-      int i;
-      int istop = (int)png_ptr->num_trans;
-      png_color back;
-      png_colorp palette = png_ptr->palette;
-
-      back.red   = (png_byte)png_ptr->background.red;
-      back.green = (png_byte)png_ptr->background.green;
-      back.blue  = (png_byte)png_ptr->background.blue;
-
-      for (i = 0; i < istop; i++)
-      {
-         if (png_ptr->trans_alpha[i] == 0)
-         {
-            palette[i] = back;
-         }
-         else if (png_ptr->trans_alpha[i] != 0xff)
-         {
-            /* The png_composite() macro is defined in png.h */
-            png_composite(palette[i].red, palette[i].red,
-               png_ptr->trans_alpha[i], back.red);
-            png_composite(palette[i].green, palette[i].green,
-               png_ptr->trans_alpha[i], back.green);
-            png_composite(palette[i].blue, palette[i].blue,
-               png_ptr->trans_alpha[i], back.blue);
-         }
-      }
-
-      /* Handled alpha, still need to strip the channel. */
-      png_ptr->transformations &= ~PNG_BACKGROUND;
-      png_ptr->transformations |= PNG_STRIP_ALPHA;
-   }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED */
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-   if ((png_ptr->transformations & PNG_SHIFT) &&
-      (color_type == PNG_COLOR_TYPE_PALETTE))
-   {
-      png_uint_16 i;
-      png_uint_16 istop = png_ptr->num_palette;
-      int sr = 8 - png_ptr->sig_bit.red;
-      int sg = 8 - png_ptr->sig_bit.green;
-      int sb = 8 - png_ptr->sig_bit.blue;
-
-      if (sr < 0 || sr > 8)
-         sr = 0;
-      if (sg < 0 || sg > 8)
-         sg = 0;
-      if (sb < 0 || sb > 8)
-         sb = 0;
-      for (i = 0; i < istop; i++)
-      {
-         png_ptr->palette[i].red >>= sr;
-         png_ptr->palette[i].green >>= sg;
-         png_ptr->palette[i].blue >>= sb;
-      }
-   }
-#endif  /* PNG_READ_SHIFT_SUPPORTED */
- }
-#if !defined(PNG_READ_GAMMA_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) \
- && !defined(PNG_READ_BACKGROUND_SUPPORTED)
-   if (png_ptr)
-      return;
-#endif
-}
-
-/* Modify the info structure to reflect the transformations.  The
- * info should be updated so a PNG file could be written with it,
- * assuming the transformations result in valid PNG data.
- */
-void /* PRIVATE */
-png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_read_transform_info");
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND)
-   {
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         if (png_ptr->num_trans &&
-              (png_ptr->transformations & PNG_EXPAND_tRNS))
-            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         else
-            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
-         info_ptr->bit_depth = 8;
-         info_ptr->num_trans = 0;
-      }
-      else
-      {
-         if (png_ptr->num_trans)
-         {
-            if (png_ptr->transformations & PNG_EXPAND_tRNS)
-              info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
-         }
-         if (info_ptr->bit_depth < 8)
-            info_ptr->bit_depth = 8;
-         info_ptr->num_trans = 0;
-      }
-   }
-#endif
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if (png_ptr->transformations & PNG_BACKGROUND)
-   {
-      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
-      info_ptr->num_trans = 0;
-      info_ptr->background = png_ptr->background;
-   }
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   if (png_ptr->transformations & PNG_GAMMA)
-   {
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-      info_ptr->gamma = png_ptr->gamma;
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-      info_ptr->int_gamma = png_ptr->int_gamma;
-#endif
-   }
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-   if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))
-      info_ptr->bit_depth = 8;
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
-      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   if (png_ptr->transformations & PNG_QUANTIZE)
-   {
-      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
-          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
-          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
-      {
-         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
-      }
-   }
-#endif
-
-#ifdef PNG_READ_PACK_SUPPORTED
-   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
-      info_ptr->bit_depth = 8;
-#endif
-
-   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      info_ptr->channels = 1;
-   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
-      info_ptr->channels = 3;
-   else
-      info_ptr->channels = 1;
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
-      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
-#endif
-
-   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
-      info_ptr->channels++;
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
-   if ((png_ptr->transformations & PNG_FILLER) &&
-       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
-       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
-   {
-      info_ptr->channels++;
-      /* If adding a true alpha channel not just filler */
-      if (png_ptr->transformations & PNG_ADD_ALPHA)
-        info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
-   }
-#endif
-
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
-defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-     {
-       if (info_ptr->bit_depth < png_ptr->user_transform_depth)
-         info_ptr->bit_depth = png_ptr->user_transform_depth;
-       if (info_ptr->channels < png_ptr->user_transform_channels)
-         info_ptr->channels = png_ptr->user_transform_channels;
-     }
-#endif
-
-   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
-      info_ptr->bit_depth);
-
-   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
-
-#ifndef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr)
-      return;
-#endif
-}
-
-/* Transform the row.  The order of transformations is significant,
- * and is very touchy.  If you add a transformation, take care to
- * decide how it fits in with the other transformations here.
- */
-void /* PRIVATE */
-png_do_read_transformations(png_structp png_ptr)
-{
-   png_debug(1, "in png_do_read_transformations");
-
-   if (png_ptr->row_buf == NULL)
-   {
-#ifdef PNG_STDIO_SUPPORTED
-      char msg[50];
-
-      png_snprintf2(msg, 50,
-         "NULL row buffer for row %ld, pass %d", (long)png_ptr->row_number,
-         png_ptr->pass);
-      png_error(png_ptr, msg);
-#else
-      png_error(png_ptr, "NULL row buffer");
-#endif
-   }
-#ifdef PNG_WARN_UNINITIALIZED_ROW
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      /* Application has failed to call either png_read_start_image()
-       * or png_read_update_info() after setting transforms that expand
-       * pixels.  This check added to libpng-1.2.19
-       */
-#if (PNG_WARN_UNINITIALIZED_ROW==1)
-      png_error(png_ptr, "Uninitialized row");
-#else
-      png_warning(png_ptr, "Uninitialized row");
-#endif
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND)
-   {
-      if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
-            png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
-      }
-      else
-      {
-         if (png_ptr->num_trans &&
-             (png_ptr->transformations & PNG_EXPAND_tRNS))
-            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
-               &(png_ptr->trans_color));
-         else
-            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
-               NULL);
-      }
-   }
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
-      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         PNG_FLAG_FILLER_AFTER | (png_ptr->flags & PNG_FLAG_STRIP_ALPHA));
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-   {
-      int rgb_error =
-         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info),
-             png_ptr->row_buf + 1);
-      if (rgb_error)
-      {
-         png_ptr->rgb_to_gray_status=1;
-         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
-             PNG_RGB_TO_GRAY_WARN)
-            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
-         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
-             PNG_RGB_TO_GRAY_ERR)
-            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
-      }
-   }
-#endif
-
-/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
- *
- *   In most cases, the "simple transparency" should be done prior to doing
- *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
- *   pixel is transparent.  You would also need to make sure that the
- *   transparency information is upgraded to RGB.
- *
- *   To summarize, the current flow is:
- *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
- *                                   with background "in place" if transparent,
- *                                   convert to RGB if necessary
- *   - Gray + alpha -> composite with gray background and remove alpha bytes,
- *                                   convert to RGB if necessary
- *
- *   To support RGB backgrounds for gray images we need:
- *   - Gray + simple transparency -> convert to RGB + simple transparency,
- *                                   compare 3 or 6 bytes and composite with
- *                                   background "in place" if transparent
- *                                   (3x compare/pixel compared to doing
- *                                   composite with gray bkgrnd)
- *   - Gray + alpha -> convert to RGB + alpha, composite with background and
- *                                   remove alpha bytes (3x float
- *                                   operations/pixel compared with composite
- *                                   on gray background)
- *
- *  Greg's change will do this.  The reason it wasn't done before is for
- *  performance, as this increases the per-pixel operations.  If we would check
- *  in advance if the background was gray or RGB, and position the gray-to-RGB
- *  transform appropriately, then it would save a lot of work/time.
- */
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* If gray -> RGB, do so now only if background is non-gray; else do later
-    * for performance reasons
-    */
-   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if ((png_ptr->transformations & PNG_BACKGROUND) &&
-      ((png_ptr->num_trans != 0 ) ||
-      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
-      png_do_background(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         &(png_ptr->trans_color), &(png_ptr->background)
-#ifdef PNG_READ_GAMMA_SUPPORTED
-         , &(png_ptr->background_1),
-         png_ptr->gamma_table, png_ptr->gamma_from_1,
-         png_ptr->gamma_to_1, png_ptr->gamma_16_table,
-         png_ptr->gamma_16_from_1, png_ptr->gamma_16_to_1,
-         png_ptr->gamma_shift
-#endif
-);
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   if ((png_ptr->transformations & PNG_GAMMA) &&
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-       !((png_ptr->transformations & PNG_BACKGROUND) &&
-       ((png_ptr->num_trans != 0) ||
-       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
-#endif
-       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
-      png_do_gamma(&(png_ptr->row_info), png_ptr->row_buf + 1,
-          png_ptr->gamma_table, png_ptr->gamma_16_table,
-          png_ptr->gamma_shift);
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-   if (png_ptr->transformations & PNG_16_TO_8)
-      png_do_chop(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   if (png_ptr->transformations & PNG_QUANTIZE)
-   {
-      png_do_quantize((png_row_infop)&(png_ptr->row_info), png_ptr->row_buf + 1,
-         png_ptr->palette_lookup, png_ptr->quantize_index);
-      if (png_ptr->row_info.rowbytes == (png_uint_32)0)
-         png_error(png_ptr, "png_do_quantize returned rowbytes=0");
-   }
-#endif
-
-#ifdef PNG_READ_INVERT_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_do_unshift(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         &(png_ptr->shift));
-#endif
-
-#ifdef PNG_READ_PACK_SUPPORTED
-   if (png_ptr->transformations & PNG_PACK)
-      png_do_unpack(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_BGR_SUPPORTED
-   if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* If gray -> RGB, do so now only if we did not do so above */
-   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-   if (png_ptr->transformations & PNG_FILLER)
-      png_do_read_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         (png_uint_32)png_ptr->filler, png_ptr->flags);
-#endif
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_read_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_SWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-    {
-      if (png_ptr->read_user_transform_fn != NULL)
-         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
-            (png_ptr,                    /* png_ptr */
-               &(png_ptr->row_info),     /* row_info: */
-               /*  png_uint_32 width;       width of row */
-               /*  png_uint_32 rowbytes;    number of bytes in row */
-               /*  png_byte color_type;     color type of pixels */
-               /*  png_byte bit_depth;      bit depth of samples */
-               /*  png_byte channels;       number of channels (1-4) */
-               /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
-               png_ptr->row_buf + 1);    /* start of pixel data for row */
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-      if (png_ptr->user_transform_depth)
-         png_ptr->row_info.bit_depth = png_ptr->user_transform_depth;
-      if (png_ptr->user_transform_channels)
-         png_ptr->row_info.channels = png_ptr->user_transform_channels;
-#endif
-      png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
-         png_ptr->row_info.channels);
-      png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-         png_ptr->row_info.width);
-   }
-#endif
-
-}
-
-#ifdef PNG_READ_PACK_SUPPORTED
-/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
- * without changing the actual values.  Thus, if you had a row with
- * a bit depth of 1, you would end up with bytes that only contained
- * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
- * png_do_shift() after this.
- */
-void /* PRIVATE */
-png_do_unpack(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_unpack");
-
-   if (row_info->bit_depth < 8)
-   {
-      png_uint_32 i;
-      png_uint_32 row_width=row_info->width;
-
-      switch (row_info->bit_depth)
-      {
-         case 1:
-         {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x01);
-               if (shift == 7)
-               {
-                  shift = 0;
-                  sp--;
-               }
-               else
-                  shift++;
-
-               dp--;
-            }
-            break;
-         }
-
-         case 2:
-         {
-
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x03);
-               if (shift == 6)
-               {
-                  shift = 0;
-                  sp--;
-               }
-               else
-                  shift += 2;
-
-               dp--;
-            }
-            break;
-         }
-
-         case 4:
-         {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x0f);
-               if (shift == 4)
-               {
-                  shift = 0;
-                  sp--;
-               }
-               else
-                  shift = 4;
-
-               dp--;
-            }
-            break;
-         }
-      }
-      row_info->bit_depth = 8;
-      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
-      row_info->rowbytes = row_width * row_info->channels;
-   }
-}
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-/* Reverse the effects of png_do_shift.  This routine merely shifts the
- * pixels back to their significant bits values.  Thus, if you have
- * a row of bit depth 8, but only 5 are significant, this will shift
- * the values back to 0 through 31.
- */
-void /* PRIVATE */
-png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)
-{
-   png_debug(1, "in png_do_unshift");
-
-   if (
-       row_info->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      int shift[4];
-      int channels = 0;
-      int c;
-      png_uint_16 value = 0;
-      png_uint_32 row_width = row_info->width;
-
-      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
-      {
-         shift[channels++] = row_info->bit_depth - sig_bits->red;
-         shift[channels++] = row_info->bit_depth - sig_bits->green;
-         shift[channels++] = row_info->bit_depth - sig_bits->blue;
-      }
-      else
-      {
-         shift[channels++] = row_info->bit_depth - sig_bits->gray;
-      }
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         shift[channels++] = row_info->bit_depth - sig_bits->alpha;
-      }
-
-      for (c = 0; c < channels; c++)
-      {
-         if (shift[c] <= 0)
-            shift[c] = 0;
-         else
-            value = 1;
-      }
-
-      if (!value)
-         return;
-
-      switch (row_info->bit_depth)
-      {
-         case 2:
-         {
-            png_bytep bp;
-            png_uint_32 i;
-            png_uint_32 istop = row_info->rowbytes;
-
-            for (bp = row, i = 0; i < istop; i++)
-            {
-               *bp >>= 1;
-               *bp++ &= 0x55;
-            }
-            break;
-         }
-
-         case 4:
-         {
-            png_bytep bp = row;
-            png_uint_32 i;
-            png_uint_32 istop = row_info->rowbytes;
-            png_byte mask = (png_byte)((((int)0xf0 >> shift[0]) & (int)0xf0) |
-               (png_byte)((int)0xf >> shift[0]));
-
-            for (i = 0; i < istop; i++)
-            {
-               *bp >>= shift[0];
-               *bp++ &= mask;
-            }
-            break;
-         }
-
-         case 8:
-         {
-            png_bytep bp = row;
-            png_uint_32 i;
-            png_uint_32 istop = row_width * channels;
-
-            for (i = 0; i < istop; i++)
-            {
-               *bp++ >>= shift[i%channels];
-            }
-            break;
-         }
-
-         case 16:
-         {
-            png_bytep bp = row;
-            png_uint_32 i;
-            png_uint_32 istop = channels * row_width;
-
-            for (i = 0; i < istop; i++)
-            {
-               value = (png_uint_16)((*bp << 8) + *(bp + 1));
-               value >>= shift[i%channels];
-               *bp++ = (png_byte)(value >> 8);
-               *bp++ = (png_byte)(value & 0xff);
-            }
-            break;
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-/* Chop rows of bit depth 16 down to 8 */
-void /* PRIVATE */
-png_do_chop(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_chop");
-
-   if (row_info->bit_depth == 16)
-   {
-      png_bytep sp = row;
-      png_bytep dp = row;
-      png_uint_32 i;
-      png_uint_32 istop = row_info->width * row_info->channels;
-
-      for (i = 0; i<istop; i++, sp += 2, dp++)
-      {
-#ifdef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-      /* This does a more accurate scaling of the 16-bit color
-       * value, rather than a simple low-byte truncation.
-       *
-       * What the ideal calculation should be:
-       *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *          (png_uint_32)(*(sp + 1))) * 255 + 127)
-       *          / (png_uint_32)65535L;
-       *
-       * GRR: no, I think this is what it really should be:
-       *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *           (png_uint_32)(*(sp + 1))) + 128L)
-       *           / (png_uint_32)257L;
-       *
-       * GRR: here's the exact calculation with shifts:
-       *   temp = (((png_uint_32)(*sp) << 8) |
-       *           (png_uint_32)(*(sp + 1))) + 128L;
-       *   *dp = (temp - (temp >> 8)) >> 8;
-       *
-       * Approximate calculation with shift/add instead of multiply/divide:
-       *   *dp = ((((png_uint_32)(*sp) << 8) |
-       *          (png_uint_32)((int)(*(sp + 1)) - *sp)) + 128) >> 8;
-       *
-       * What we actually do to avoid extra shifting and conversion:
-       */
-
-         *dp = *sp + ((((int)(*(sp + 1)) - *sp) > 128) ? 1 : 0);
-#else
-       /* Simply discard the low order byte */
-         *dp = *sp;
-#endif
-      }
-      row_info->bit_depth = 8;
-      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
-      row_info->rowbytes = row_info->width * row_info->channels;
-   }
-}
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_read_swap_alpha");
-
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This converts from RGBA to ARGB */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
-         /* This converts from RRGGBBAA to AARRGGBB */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This converts from GA to AG */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
-         /* This converts from GGAA to AAGG */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_read_invert_alpha");
-
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This inverts the alpha channel in RGBA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = (png_byte)(255 - *(--sp));
-
-/*             This does nothing:
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               We can replace it with:
-*/
-               sp-=3;
-               dp=sp;
-            }
-         }
-         /* This inverts the alpha channel in RRGGBBAA */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = (png_byte)(255 - *(--sp));
-               *(--dp) = (png_byte)(255 - *(--sp));
-
-/*             This does nothing:
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               We can replace it with:
-*/
-               sp-=6;
-               dp=sp;
-            }
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This inverts the alpha channel in GA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = (png_byte)(255 - *(--sp));
-               *(--dp) = *(--sp);
-            }
-         }
-         /* This inverts the alpha channel in GGAA */
-         else
-         {
-            png_bytep sp  = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = (png_byte)(255 - *(--sp));
-               *(--dp) = (png_byte)(255 - *(--sp));
-/*
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-*/
-               sp-=2;
-               dp=sp;
-            }
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-/* Add filler channel if we have RGB color */
-void /* PRIVATE */
-png_do_read_filler(png_row_infop row_info, png_bytep row,
-   png_uint_32 filler, png_uint_32 flags)
-{
-   png_uint_32 i;
-   png_uint_32 row_width = row_info->width;
-
-   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
-   png_byte lo_filler = (png_byte)(filler & 0xff);
-
-   png_debug(1, "in png_do_read_filler");
-
-   if (
-       row_info->color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         /* This changes the data from G to GX */
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp =  sp + (png_size_t)row_width;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = lo_filler;
-            row_info->channels = 2;
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
-         }
-      /* This changes the data from G to XG */
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp = sp  + (png_size_t)row_width;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 2;
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         /* This changes the data from GG to GGXX */
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = hi_filler;
-            *(--dp) = lo_filler;
-            row_info->channels = 2;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-         /* This changes the data from GG to XXGG */
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 2;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-      }
-   } /* COLOR_TYPE == GRAY */
-   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         /* This changes the data from RGB to RGBX */
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp  + (png_size_t)row_width;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = lo_filler;
-            row_info->channels = 4;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-      /* This changes the data from RGB to XRGB */
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp + (png_size_t)row_width;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 4;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         /* This changes the data from RRGGBB to RRGGBBXX */
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = hi_filler;
-            *(--dp) = lo_filler;
-            row_info->channels = 4;
-            row_info->pixel_depth = 64;
-            row_info->rowbytes = row_width * 8;
-         }
-         /* This changes the data from RRGGBB to XXRRGGBB */
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 4;
-            row_info->pixel_depth = 64;
-            row_info->rowbytes = row_width * 8;
-         }
-      }
-   } /* COLOR_TYPE == RGB */
-}
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-/* Expand grayscale files to RGB, with or without alpha */
-void /* PRIVATE */
-png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
-{
-   png_uint_32 i;
-   png_uint_32 row_width = row_info->width;
-
-   png_debug(1, "in png_do_gray_to_rgb");
-
-   if (row_info->bit_depth >= 8 &&
-      !(row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + (png_size_t)row_width - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *sp;
-               *(dp--) = *sp;
-               *(dp--) = *(sp--);
-            }
-         }
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-            }
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *(sp--);
-               *(dp--) = *sp;
-               *(dp--) = *sp;
-               *(dp--) = *(sp--);
-            }
-         }
-         else
-         {
-            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-            }
-         }
-      }
-      row_info->channels += (png_byte)2;
-      row_info->color_type |= PNG_COLOR_MASK_COLOR;
-      row_info->pixel_depth = (png_byte)(row_info->channels *
-         row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-   }
-}
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-/* Reduce RGB files to grayscale, with or without alpha
- * using the equation given in Poynton's ColorFAQ at
- * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008)
- * New link:
- * <http://www.poynton.com/notes/colour_and_gamma/>
- * Charles Poynton poynton at poynton.com
- *
- *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
- *
- *  We approximate this with
- *
- *     Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B
- *
- *  which can be expressed with integers as
- *
- *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
- *
- *  The calculation is to be done in a linear colorspace.
- *
- *  Other integer coefficents can be used via png_set_rgb_to_gray().
- */
-int /* PRIVATE */
-png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
-
-{
-   png_uint_32 i;
-
-   png_uint_32 row_width = row_info->width;
-   int rgb_error = 0;
-
-   png_debug(1, "in png_do_rgb_to_gray");
-
-   if (
-      (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
-      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
-      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;
-
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-      {
-         if (row_info->bit_depth == 8)
-         {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
-                  if (red != green || red != blue)
-                  {
-                     rgb_error |= 1;
-                     *(dp++) = png_ptr->gamma_from_1[
-                       (rc*red + gc*green + bc*blue)>>15];
-                  }
-                  else
-                     *(dp++) = *(sp - 1);
-               }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = *(sp++);
-                  png_byte green = *(sp++);
-                  png_byte blue  = *(sp++);
-                  if (red != green || red != blue)
-                  {
-                     rgb_error |= 1;
-                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
-                  }
-                  else
-                     *(dp++) = *(sp - 1);
-               }
-            }
-         }
-
-         else /* RGB bit_depth == 16 */
-         {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_16_to_1 != NULL &&
-                png_ptr->gamma_16_from_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, w;
-
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-
-                  if (red == green && red == blue)
-                     w = red;
-                  else
-                  {
-                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
-                                  png_ptr->gamma_shift][red>>8];
-                     png_uint_16 green_1 =
-                         png_ptr->gamma_16_to_1[(green&0xff) >>
-                                  png_ptr->gamma_shift][green>>8];
-                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
-                                  png_ptr->gamma_shift][blue>>8];
-                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
-                                  + bc*blue_1)>>15);
-                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
-                         png_ptr->gamma_shift][gray16 >> 8];
-                     rgb_error |= 1;
-                  }
-
-                  *(dp++) = (png_byte)((w>>8) & 0xff);
-                  *(dp++) = (png_byte)(w & 0xff);
-               }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, gray16;
-
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
-                  *(dp++) = (png_byte)(gray16 & 0xff);
-               }
-            }
-         }
-      }
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-                  *(dp++) =  png_ptr->gamma_from_1
-                             [(rc*red + gc*green + bc*blue)>>15];
-                  *(dp++) = *(sp++);  /* alpha */
-               }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = *(sp++);
-                  png_byte green = *(sp++);
-                  png_byte blue  = *(sp++);
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = *(sp++);  /* alpha */
-               }
-            }
-         }
-         else /* RGBA bit_depth == 16 */
-         {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_16_to_1 != NULL &&
-                png_ptr->gamma_16_from_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, w;
-
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
-
-                  if (red == green && red == blue)
-                     w = red;
-                  else
-                  {
-                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
-                         png_ptr->gamma_shift][red>>8];
-                     png_uint_16 green_1 =
-                         png_ptr->gamma_16_to_1[(green&0xff) >>
-                         png_ptr->gamma_shift][green>>8];
-                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
-                         png_ptr->gamma_shift][blue>>8];
-                     png_uint_16 gray16  = (png_uint_16)((rc * red_1
-                         + gc * green_1 + bc * blue_1)>>15);
-                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
-                         png_ptr->gamma_shift][gray16 >> 8];
-                     rgb_error |= 1;
-                  }
-
-                  *(dp++) = (png_byte)((w>>8) & 0xff);
-                  *(dp++) = (png_byte)(w & 0xff);
-                  *(dp++) = *(sp++);  /* alpha */
-                  *(dp++) = *(sp++);
-               }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, gray16;
-                  red   = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
-                  green = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
-                  blue  = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
-                  *(dp++) = (png_byte)(gray16 & 0xff);
-                  *(dp++) = *(sp++);  /* alpha */
-                  *(dp++) = *(sp++);
-               }
-            }
-         }
-      }
-   row_info->channels -= (png_byte)2;
-      row_info->color_type &= ~PNG_COLOR_MASK_COLOR;
-      row_info->pixel_depth = (png_byte)(row_info->channels *
-         row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-   }
-   return rgb_error;
-}
-#endif
-
-/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
- * large of png_color.  This lets grayscale images be treated as
- * paletted.  Most useful for gamma correction and simplification
- * of code.
- */
-void PNGAPI
-png_build_grayscale_palette(int bit_depth, png_colorp palette)
-{
-   int num_palette;
-   int color_inc;
-   int i;
-   int v;
-
-   png_debug(1, "in png_do_build_grayscale_palette");
-
-   if (palette == NULL)
-      return;
-
-   switch (bit_depth)
-   {
-      case 1:
-         num_palette = 2;
-         color_inc = 0xff;
-         break;
-
-      case 2:
-         num_palette = 4;
-         color_inc = 0x55;
-         break;
-
-      case 4:
-         num_palette = 16;
-         color_inc = 0x11;
-         break;
-
-      case 8:
-         num_palette = 256;
-         color_inc = 1;
-         break;
-
-      default:
-         num_palette = 0;
-         color_inc = 0;
-         break;
-   }
-
-   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
-   {
-      palette[i].red = (png_byte)v;
-      palette[i].green = (png_byte)v;
-      palette[i].blue = (png_byte)v;
-   }
-}
-
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-/* Replace any alpha or transparency with the supplied background color.
- * "background" is already in the screen gamma, while "background_1" is
- * at a gamma of 1.0.  Paletted files have already been taken care of.
- */
-void /* PRIVATE */
-png_do_background(png_row_infop row_info, png_bytep row,
-   png_color_16p trans_color, png_color_16p background
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   , png_color_16p background_1,
-   png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
-   png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
-   png_uint_16pp gamma_16_to_1, int gamma_shift
-#endif
-   )
-{
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-   int shift;
-
-   png_debug(1, "in png_do_background");
-
-   if (background != NULL &&
-      (!(row_info->color_type & PNG_COLOR_MASK_ALPHA) ||
-      (row_info->color_type != PNG_COLOR_TYPE_PALETTE && trans_color)))
-   {
-      switch (row_info->color_type)
-      {
-         case PNG_COLOR_TYPE_GRAY:
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  sp = row;
-                  shift = 7;
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((png_uint_16)((*sp >> shift) & 0x01)
-                        == trans_color->gray)
-                     {
-                        *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
-                        *sp |= (png_byte)(background->gray << shift);
-                     }
-                     if (!shift)
-                     {
-                        shift = 7;
-                        sp++;
-                     }
-                     else
-                        shift--;
-                  }
-                  break;
-               }
-
-               case 2:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == trans_color->gray)
-                        {
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
-                        }
-                        else
-                        {
-                           png_byte p = (png_byte)((*sp >> shift) & 0x03);
-                           png_byte g = (png_byte)((gamma_table [p | (p << 2) |
-                               (p << 4) | (p << 6)] >> 6) & 0x03);
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(g << shift);
-                        }
-                        if (!shift)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
-                        else
-                           shift -= 2;
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == trans_color->gray)
-                        {
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
-                        }
-                        if (!shift)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
-                        else
-                           shift -= 2;
-                     }
-                  }
-                  break;
-               }
-
-               case 4:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == trans_color->gray)
-                        {
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
-                        }
-                        else
-                        {
-                           png_byte p = (png_byte)((*sp >> shift) & 0x0f);
-                           png_byte g = (png_byte)((gamma_table[p |
-                             (p << 4)] >> 4) & 0x0f);
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(g << shift);
-                        }
-                        if (!shift)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
-                        else
-                           shift -= 4;
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == trans_color->gray)
-                        {
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
-                        }
-                        if (!shift)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
-                        else
-                           shift -= 4;
-                     }
-                  }
-                  break;
-               }
-
-               case 8:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == trans_color->gray)
-                        {
-                           *sp = (png_byte)background->gray;
-                        }
-                        else
-                        {
-                           *sp = gamma_table[*sp];
-                        }
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == trans_color->gray)
-                        {
-                           *sp = (png_byte)background->gray;
-                        }
-                     }
-                  }
-                  break;
-               }
-
-               case 16:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_16 != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
-
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        if (v == trans_color->gray)
-                        {
-                           /* Background is already in screen gamma */
-                           *sp = (png_byte)((background->gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(background->gray & 0xff);
-                        }
-                        else
-                        {
-                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                           *sp = (png_byte)((v >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(v & 0xff);
-                        }
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
-
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        if (v == trans_color->gray)
-                        {
-                           *sp = (png_byte)((background->gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(background->gray & 0xff);
-                        }
-                     }
-                  }
-                  break;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == trans_color->red &&
-                        *(sp + 1) == trans_color->green &&
-                        *(sp + 2) == trans_color->blue)
-                     {
-                        *sp = (png_byte)background->red;
-                        *(sp + 1) = (png_byte)background->green;
-                        *(sp + 2) = (png_byte)background->blue;
-                     }
-                     else
-                     {
-                        *sp = gamma_table[*sp];
-                        *(sp + 1) = gamma_table[*(sp + 1)];
-                        *(sp + 2) = gamma_table[*(sp + 2)];
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == trans_color->red &&
-                        *(sp + 1) == trans_color->green &&
-                        *(sp + 2) == trans_color->blue)
-                     {
-                        *sp = (png_byte)background->red;
-                        *(sp + 1) = (png_byte)background->green;
-                        *(sp + 2) = (png_byte)background->blue;
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
-                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));
-                     if (r == trans_color->red && g == trans_color->green &&
-                        b == trans_color->blue)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((background->red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(background->red & 0xff);
-                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(background->green & 0xff);
-                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(background->blue & 0xff);
-                     }
-                     else
-                     {
-                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp+1));
-                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
-                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));
-
-                     if (r == trans_color->red && g == trans_color->green &&
-                        b == trans_color->blue)
-                     {
-                        *sp = (png_byte)((background->red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(background->red & 0xff);
-                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(background->green & 0xff);
-                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(background->blue & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 2, dp++)
-                  {
-                     png_uint_16 a = *(sp + 1);
-
-                     if (a == 0xff)
-                     {
-                        *dp = gamma_table[*sp];
-                     }
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *dp = (png_byte)background->gray;
-                     }
-                     else
-                     {
-                        png_byte v, w;
-
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, background_1->gray);
-                        *dp = gamma_from_1[w];
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 2, dp++)
-                  {
-                     png_byte a = *(sp + 1);
-
-                     if (a == 0xff)
-                     {
-                        *dp = *sp;
-                     }
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else if (a == 0)
-                     {
-                        *dp = (png_byte)background->gray;
-                     }
-                     else
-                     {
-                        png_composite(*dp, *sp, a, background_1->gray);
-                     }
-#else
-                     *dp = (png_byte)background->gray;
-#endif
-                  }
-               }
-            }
-            else /* if (png_ptr->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
-
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
-
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
-                     }
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else if (a == 0)
-#else
-                     else
-#endif
-                     {
-                        /* Background is already in screen gamma */
-                        *dp = (png_byte)((background->gray >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->gray & 0xff);
-                     }
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else
-                     {
-                        png_uint_16 g, v, w;
-
-                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(v, g, a, background_1->gray);
-                        w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
-                        *dp = (png_byte)((w >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(w & 0xff);
-                     }
-#endif
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_memcpy(dp, sp, 2);
-                     }
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else if (a == 0)
-#else
-                     else
-#endif
-                     {
-                        *dp = (png_byte)((background->gray >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->gray & 0xff);
-                     }
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else
-                     {
-                        png_uint_16 g, v;
-
-                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_composite_16(v, g, a, background_1->gray);
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
-                     }
-#endif
-                  }
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
-                  {
-                     png_byte a = *(sp + 3);
-
-                     if (a == 0xff)
-                     {
-                        *dp = gamma_table[*sp];
-                        *(dp + 1) = gamma_table[*(sp + 1)];
-                        *(dp + 2) = gamma_table[*(sp + 2)];
-                     }
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *dp = (png_byte)background->red;
-                        *(dp + 1) = (png_byte)background->green;
-                        *(dp + 2) = (png_byte)background->blue;
-                     }
-                     else
-                     {
-                        png_byte v, w;
-
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, background_1->red);
-                        *dp = gamma_from_1[w];
-                        v = gamma_to_1[*(sp + 1)];
-                        png_composite(w, v, a, background_1->green);
-                        *(dp + 1) = gamma_from_1[w];
-                        v = gamma_to_1[*(sp + 2)];
-                        png_composite(w, v, a, background_1->blue);
-                        *(dp + 2) = gamma_from_1[w];
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
-                  {
-                     png_byte a = *(sp + 3);
-
-                     if (a == 0xff)
-                     {
-                        *dp = *sp;
-                        *(dp + 1) = *(sp + 1);
-                        *(dp + 2) = *(sp + 2);
-                     }
-                     else if (a == 0)
-                     {
-                        *dp = (png_byte)background->red;
-                        *(dp + 1) = (png_byte)background->green;
-                        *(dp + 2) = (png_byte)background->blue;
-                     }
-                     else
-                     {
-                        png_composite(*dp, *sp, a, background->red);
-                        png_composite(*(dp + 1), *(sp + 1), a,
-                           background->green);
-                        png_composite(*(dp + 2), *(sp + 2), a,
-                           background->blue);
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                         << 8) + (png_uint_16)(*(sp + 7)));
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
-
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(v & 0xff);
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(v & 0xff);
-                     }
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *dp = (png_byte)((background->red >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->red & 0xff);
-                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(background->green & 0xff);
-                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(background->blue & 0xff);
-                     }
-                     else
-                     {
-                        png_uint_16 v, w, x;
-
-                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(w, v, a, background_1->red);
-                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-                        *dp = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(x & 0xff);
-                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        png_composite_16(w, v, a, background_1->green);
-                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-                        *(dp + 2) = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(x & 0xff);
-                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        png_composite_16(w, v, a, background_1->blue);
-                        x = gamma_16_from_1[(w & 0xff) >> gamma_shift][w >> 8];
-                        *(dp + 4) = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(x & 0xff);
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                        << 8) + (png_uint_16)(*(sp + 7)));
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_memcpy(dp, sp, 6);
-                     }
-                     else if (a == 0)
-                     {
-                        *dp = (png_byte)((background->red >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->red & 0xff);
-                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(background->green & 0xff);
-                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(background->blue & 0xff);
-                     }
-                     else
-                     {
-                        png_uint_16 v;
-
-                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                            + *(sp + 3));
-                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                            + *(sp + 5));
-
-                        png_composite_16(v, r, a, background->red);
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
-                        png_composite_16(v, g, a, background->green);
-                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(v & 0xff);
-                        png_composite_16(v, b, a, background->blue);
-                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
-      }
-
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
-         row_info->channels--;
-         row_info->pixel_depth = (png_byte)(row_info->channels *
-            row_info->bit_depth);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-/* Gamma correct the image, avoiding the alpha channel.  Make sure
- * you do this after you deal with the transparency issue on grayscale
- * or RGB images. If your bit depth is 8, use gamma_table, if it
- * is 16, use gamma_16_table and gamma_shift.  Build these with
- * build_gamma_table().
- */
-void /* PRIVATE */
-png_do_gamma(png_row_infop row_info, png_bytep row,
-   png_bytep gamma_table, png_uint_16pp gamma_16_table,
-   int gamma_shift)
-{
-   png_bytep sp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_gamma");
-
-   if (
-       ((row_info->bit_depth <= 8 && gamma_table != NULL) ||
-        (row_info->bit_depth == 16 && gamma_16_table != NULL)))
-   {
-      switch (row_info->color_type)
-      {
-         case PNG_COLOR_TYPE_RGB:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  sp++;
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 4;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp += 2;
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 4;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY:
-         {
-            if (row_info->bit_depth == 2)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i += 4)
-               {
-                  int a = *sp & 0xc0;
-                  int b = *sp & 0x30;
-                  int c = *sp & 0x0c;
-                  int d = *sp & 0x03;
-
-                  *sp = (png_byte)(
-                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
-                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
-                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
-                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
-                  sp++;
-               }
-            }
-
-            if (row_info->bit_depth == 4)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i += 2)
-               {
-                  int msb = *sp & 0xf0;
-                  int lsb = *sp & 0x0f;
-
-                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
-                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
-                  sp++;
-               }
-            }
-
-            else if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-               }
-            }
-
-            else if (row_info->bit_depth == 16)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-               }
-            }
-            break;
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-/* Expands a palette row to an RGB or RGBA row depending
- * upon whether you supply trans and num_trans.
- */
-void /* PRIVATE */
-png_do_expand_palette(png_row_infop row_info, png_bytep row,
-   png_colorp palette, png_bytep trans_alpha, int num_trans)
-{
-   int shift, value;
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_expand_palette");
-
-   if (
-       row_info->color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (row_info->bit_depth < 8)
-      {
-         switch (row_info->bit_depth)
-         {
-            case 1:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 3);
-               dp = row + (png_size_t)row_width - 1;
-               shift = 7 - (int)((row_width + 7) & 0x07);
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((*sp >> shift) & 0x01)
-                     *dp = 1;
-                  else
-                     *dp = 0;
-                  if (shift == 7)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-                  else
-                     shift++;
-
-                  dp--;
-               }
-               break;
-            }
-
-            case 2:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 2);
-               dp = row + (png_size_t)row_width - 1;
-               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-               for (i = 0; i < row_width; i++)
-               {
-                  value = (*sp >> shift) & 0x03;
-                  *dp = (png_byte)value;
-                  if (shift == 6)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-                  else
-                     shift += 2;
-
-                  dp--;
-               }
-               break;
-            }
-
-            case 4:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 1);
-               dp = row + (png_size_t)row_width - 1;
-               shift = (int)((row_width & 0x01) << 2);
-               for (i = 0; i < row_width; i++)
-               {
-                  value = (*sp >> shift) & 0x0f;
-                  *dp = (png_byte)value;
-                  if (shift == 4)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-                  else
-                     shift += 4;
-
-                  dp--;
-               }
-               break;
-            }
-         }
-         row_info->bit_depth = 8;
-         row_info->pixel_depth = 8;
-         row_info->rowbytes = row_width;
-      }
-      switch (row_info->bit_depth)
-      {
-         case 8:
-         {
-            if (trans_alpha != NULL)
-            {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 2) - 1;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((int)(*sp) >= num_trans)
-                     *dp-- = 0xff;
-                  else
-                     *dp-- = trans_alpha[*sp];
-                  *dp-- = palette[*sp].blue;
-                  *dp-- = palette[*sp].green;
-                  *dp-- = palette[*sp].red;
-                  sp--;
-               }
-               row_info->bit_depth = 8;
-               row_info->pixel_depth = 32;
-               row_info->rowbytes = row_width * 4;
-               row_info->color_type = 6;
-               row_info->channels = 4;
-            }
-            else
-            {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width * 3) - 1;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  *dp-- = palette[*sp].blue;
-                  *dp-- = palette[*sp].green;
-                  *dp-- = palette[*sp].red;
-                  sp--;
-               }
-
-               row_info->bit_depth = 8;
-               row_info->pixel_depth = 24;
-               row_info->rowbytes = row_width * 3;
-               row_info->color_type = 2;
-               row_info->channels = 3;
-            }
-            break;
-         }
-      }
-   }
-}
-
-/* If the bit depth < 8, it is expanded to 8.  Also, if the already
- * expanded transparency value is supplied, an alpha channel is built.
- */
-void /* PRIVATE */
-png_do_expand(png_row_infop row_info, png_bytep row,
-   png_color_16p trans_value)
-{
-   int shift, value;
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_expand");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         png_uint_16 gray = (png_uint_16)(trans_value ? trans_value->gray : 0);
-
-         if (row_info->bit_depth < 8)
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  gray = (png_uint_16)((gray&0x01)*0xff);
-                  sp = row + (png_size_t)((row_width - 1) >> 3);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = 7 - (int)((row_width + 7) & 0x07);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((*sp >> shift) & 0x01)
-                        *dp = 0xff;
-                     else
-                        *dp = 0;
-                     if (shift == 7)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-                     else
-                        shift++;
-
-                     dp--;
-                  }
-                  break;
-               }
-
-               case 2:
-               {
-                  gray = (png_uint_16)((gray&0x03)*0x55);
-                  sp = row + (png_size_t)((row_width - 1) >> 2);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x03;
-                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
-                        (value << 6));
-                     if (shift == 6)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-                     else
-                        shift += 2;
-
-                     dp--;
-                  }
-                  break;
-               }
-
-               case 4:
-               {
-                  gray = (png_uint_16)((gray&0x0f)*0x11);
-                  sp = row + (png_size_t)((row_width - 1) >> 1);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x0f;
-                     *dp = (png_byte)(value | (value << 4));
-                     if (shift == 4)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-                     else
-                        shift = 4;
-
-                     dp--;
-                  }
-                  break;
-               }
-            }
-
-            row_info->bit_depth = 8;
-            row_info->pixel_depth = 8;
-            row_info->rowbytes = row_width;
-         }
-
-         if (trans_value != NULL)
-         {
-            if (row_info->bit_depth == 8)
-            {
-               gray = gray & 0xff;
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 1) - 1;
-               for (i = 0; i < row_width; i++)
-               {
-                  if (*sp == gray)
-                     *dp-- = 0;
-                  else
-                     *dp-- = 0xff;
-                  *dp-- = *sp--;
-               }
-            }
-
-            else if (row_info->bit_depth == 16)
-            {
-               png_byte gray_high = (gray >> 8) & 0xff;
-               png_byte gray_low = gray & 0xff;
-               sp = row + row_info->rowbytes - 1;
-               dp = row + (row_info->rowbytes << 1) - 1;
-               for (i = 0; i < row_width; i++)
-               {
-                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
-                  {
-                     *dp-- = 0;
-                     *dp-- = 0;
-                  }
-                  else
-                  {
-                     *dp-- = 0xff;
-                     *dp-- = 0xff;
-                  }
-                  *dp-- = *sp--;
-                  *dp-- = *sp--;
-               }
-            }
-
-            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-            row_info->channels = 2;
-            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
-            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-               row_width);
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_value)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            png_byte red = trans_value->red & 0xff;
-            png_byte green = trans_value->green & 0xff;
-            png_byte blue = trans_value->blue & 0xff;
-            sp = row + (png_size_t)row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 2) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
-                  *dp-- = 0;
-               else
-                  *dp-- = 0xff;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         else if (row_info->bit_depth == 16)
-         {
-            png_byte red_high = (trans_value->red >> 8) & 0xff;
-            png_byte green_high = (trans_value->green >> 8) & 0xff;
-            png_byte blue_high = (trans_value->blue >> 8) & 0xff;
-            png_byte red_low = trans_value->red & 0xff;
-            png_byte green_low = trans_value->green & 0xff;
-            png_byte blue_low = trans_value->blue & 0xff;
-            sp = row + row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 3) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 5) == red_high &&
-                  *(sp - 4) == red_low &&
-                  *(sp - 3) == green_high &&
-                  *(sp - 2) == green_low &&
-                  *(sp - 1) == blue_high &&
-                  *(sp    ) == blue_low)
-               {
-                  *dp-- = 0;
-                  *dp-- = 0;
-               }
-               else
-               {
-                  *dp-- = 0xff;
-                  *dp-- = 0xff;
-               }
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         row_info->channels = 4;
-         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-void /* PRIVATE */
-png_do_quantize(png_row_infop row_info, png_bytep row,
-    png_bytep palette_lookup, png_bytep quantize_lookup)
-{
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_quantize");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
-         palette_lookup && row_info->bit_depth == 8)
-      {
-         int r, g, b, p;
-         sp = row;
-         dp = row;
-         for (i = 0; i < row_width; i++)
-         {
-            r = *sp++;
-            g = *sp++;
-            b = *sp++;
-
-            /* This looks real messy, but the compiler will reduce
-             * it down to a reasonable formula.  For example, with
-             * 5 bits per color, we get:
-             * p = (((r >> 3) & 0x1f) << 10) |
-             *    (((g >> 3) & 0x1f) << 5) |
-             *    ((b >> 3) & 0x1f);
-             */
-            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
-               ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
-               (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
-               (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
-               ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
-               (PNG_QUANTIZE_BLUE_BITS)) |
-               ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
-               ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
-
-            *dp++ = palette_lookup[p];
-         }
-         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
-         row_info->channels = 1;
-         row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-         palette_lookup != NULL && row_info->bit_depth == 8)
-      {
-         int r, g, b, p;
-         sp = row;
-         dp = row;
-         for (i = 0; i < row_width; i++)
-         {
-            r = *sp++;
-            g = *sp++;
-            b = *sp++;
-            sp++;
-
-            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
-               ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
-               (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
-               (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
-               ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
-               (PNG_QUANTIZE_BLUE_BITS)) |
-               ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
-               ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
-
-            *dp++ = palette_lookup[p];
-         }
-         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
-         row_info->channels = 1;
-         row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
-         quantize_lookup && row_info->bit_depth == 8)
-      {
-         sp = row;
-         for (i = 0; i < row_width; i++, sp++)
-         {
-            *sp = quantize_lookup[*sp];
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-#ifdef PNG_READ_GAMMA_SUPPORTED
-static PNG_CONST int png_gamma_shift[] =
-   {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0, 0x00};
-
-/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
- * tables, we don't make a full table if we are reducing to 8-bit in
- * the future.  Note also how the gamma_16 tables are segmented so that
- * we don't need to allocate > 64K chunks for a full 16-bit table.
- *
- * See the PNG extensions document for an integer algorithm for creating
- * the gamma tables.  Maybe we will implement that here someday.
- *
- * We should only reach this point if
- *
- *      the file_gamma is known (i.e., the gAMA or sRGB chunk is present,
- *      or the application has provided a file_gamma)
- *
- *   AND
- *      {
- *         the screen_gamma is known
- *
- *      OR
- *
- *         RGB_to_gray transformation is being performed
- *      }
- *
- *   AND
- *      {
- *         the screen_gamma is different from the reciprocal of the
- *         file_gamma by more than the specified threshold
- *
- *      OR
- *
- *         a background color has been specified and the file_gamma
- *         and screen_gamma are not 1.0, within the specified threshold.
- *      }
- */
-
-void /* PRIVATE */
-png_build_gamma_table(png_structp png_ptr, png_byte bit_depth)
-{
-  png_debug(1, "in png_build_gamma_table");
-
-  if (bit_depth <= 8)
-  {
-     int i;
-     double g;
-
-     if (png_ptr->screen_gamma > .000001)
-        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
-
-     else
-        g = 1.0;
-
-     png_ptr->gamma_table = (png_bytep)png_malloc(png_ptr,
-        (png_uint_32)256);
-
-     for (i = 0; i < 256; i++)
-     {
-        png_ptr->gamma_table[i] = (png_byte)(pow((double)i / 255.0,
-           g) * 255.0 + .5);
-     }
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
-     {
-
-        g = 1.0 / (png_ptr->gamma);
-
-        png_ptr->gamma_to_1 = (png_bytep)png_malloc(png_ptr,
-           (png_uint_32)256);
-
-        for (i = 0; i < 256; i++)
-        {
-           png_ptr->gamma_to_1[i] = (png_byte)(pow((double)i / 255.0,
-              g) * 255.0 + .5);
-        }
-
-
-        png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
-           (png_uint_32)256);
-
-        if (png_ptr->screen_gamma > 0.000001)
-           g = 1.0 / png_ptr->screen_gamma;
-
-        else
-           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
-
-        for (i = 0; i < 256; i++)
-        {
-           png_ptr->gamma_from_1[i] = (png_byte)(pow((double)i / 255.0,
-              g) * 255.0 + .5);
-
-        }
-     }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
-  }
-  else
-  {
-     double g;
-     int i, j, shift, num;
-     int sig_bit;
-     png_uint_32 ig;
-
-     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
-     {
-        sig_bit = (int)png_ptr->sig_bit.red;
-
-        if ((int)png_ptr->sig_bit.green > sig_bit)
-           sig_bit = png_ptr->sig_bit.green;
-
-        if ((int)png_ptr->sig_bit.blue > sig_bit)
-           sig_bit = png_ptr->sig_bit.blue;
-     }
-     else
-     {
-        sig_bit = (int)png_ptr->sig_bit.gray;
-     }
-
-     if (sig_bit > 0)
-        shift = 16 - sig_bit;
-
-     else
-        shift = 0;
-
-     if (png_ptr->transformations & PNG_16_TO_8)
-     {
-        if (shift < (16 - PNG_MAX_GAMMA_8))
-           shift = (16 - PNG_MAX_GAMMA_8);
-     }
-
-     if (shift > 8)
-        shift = 8;
-
-     if (shift < 0)
-        shift = 0;
-
-     png_ptr->gamma_shift = (png_byte)shift;
-
-     num = (1 << (8 - shift));
-
-     if (png_ptr->screen_gamma > .000001)
-        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
-     else
-        g = 1.0;
-
-     png_ptr->gamma_16_table = (png_uint_16pp)png_calloc(png_ptr,
-        (png_uint_32)(num * png_sizeof(png_uint_16p)));
-
-     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
-     {
-        double fin, fout;
-        png_uint_32 last, max;
-
-        for (i = 0; i < num; i++)
-        {
-           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof(png_uint_16)));
-        }
-
-        g = 1.0 / g;
-        last = 0;
-        for (i = 0; i < 256; i++)
-        {
-           fout = ((double)i + 0.5) / 256.0;
-           fin = pow(fout, g);
-           max = (png_uint_32)(fin * (double)((png_uint_32)num << 8));
-           while (last <= max)
-           {
-              png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
-                 [(int)(last >> (8 - shift))] = (png_uint_16)(
-                 (png_uint_16)i | ((png_uint_16)i << 8));
-              last++;
-           }
-        }
-        while (last < ((png_uint_32)num << 8))
-        {
-           png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
-              [(int)(last >> (8 - shift))] = (png_uint_16)65535L;
-           last++;
-        }
-     }
-     else
-     {
-        for (i = 0; i < num; i++)
-        {
-           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof(png_uint_16)));
-
-           ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);
-
-           for (j = 0; j < 256; j++)
-           {
-              png_ptr->gamma_16_table[i][j] =
-                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
-                    65535.0, g) * 65535.0 + .5);
-           }
-        }
-     }
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
-     {
-
-        g = 1.0 / (png_ptr->gamma);
-
-        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_calloc(png_ptr,
-           (png_uint_32)(num * png_sizeof(png_uint_16p )));
-
-        for (i = 0; i < num; i++)
-        {
-           png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof(png_uint_16)));
-
-           ig = (((png_uint_32)i *
-              (png_uint_32)png_gamma_shift[shift]) >> 4);
-           for (j = 0; j < 256; j++)
-           {
-              png_ptr->gamma_16_to_1[i][j] =
-                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
-                    65535.0, g) * 65535.0 + .5);
-           }
-        }
-
-        if (png_ptr->screen_gamma > 0.000001)
-           g = 1.0 / png_ptr->screen_gamma;
-
-        else
-           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
-
-        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_calloc(png_ptr,
-           (png_uint_32)(num * png_sizeof(png_uint_16p)));
-
-        for (i = 0; i < num; i++)
-        {
-           png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
-              (png_uint_32)(256 * png_sizeof(png_uint_16)));
-
-           ig = (((png_uint_32)i *
-              (png_uint_32)png_gamma_shift[shift]) >> 4);
-
-           for (j = 0; j < 256; j++)
-           {
-              png_ptr->gamma_16_from_1[i][j] =
-                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
-                    65535.0, g) * 65535.0 + .5);
-           }
-        }
-     }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
-  }
-}
-#endif
-/* To do: install integer version of png_build_gamma_table here */
-#endif
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-/* Undoes intrapixel differencing  */
-void /* PRIVATE */
-png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_read_intrapixel");
-
-   if (
-       (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      int bytes_per_pixel;
-      png_uint_32 row_width = row_info->width;
-      if (row_info->bit_depth == 8)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 3;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 4;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            *(rp) = (png_byte)((256 + *rp + *(rp+1))&0xff);
-            *(rp+2) = (png_byte)((256 + *(rp+2) + *(rp+1))&0xff);
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 6;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 8;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
-            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
-            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
-            png_uint_32 red  = (png_uint_32)((s0 + s1 + 65536L) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2 + s1 + 65536L) & 0xffffL);
-            *(rp  ) = (png_byte)((red >> 8) & 0xff);
-            *(rp+1) = (png_byte)(red & 0xff);
-            *(rp+4) = (png_byte)((blue >> 8) & 0xff);
-            *(rp+5) = (png_byte)(blue & 0xff);
-         }
-      }
-   }
-}
-#endif /* PNG_MNG_FEATURES_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED */
diff --git a/thirdparty/libpng/pngrutil.c b/thirdparty/libpng/pngrutil.c
deleted file mode 100644
index 11e412b..0000000
--- a/thirdparty/libpng/pngrutil.c
+++ /dev/null
@@ -1,3379 +0,0 @@
-
-/* pngrutil.c - utilities to read a PNG file
- *
- * Last changed in libpng 1.4.4 [August 26, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file contains routines that are only called from within
- * libpng itself during the course of reading an image.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_READ_SUPPORTED
-#include "pngpriv.h"
-
-#    define png_strtod(p,a,b) strtod(a,b)
-png_uint_32 PNGAPI
-png_get_uint_31(png_structp png_ptr, png_bytep buf)
-{
-   png_uint_32 i = png_get_uint_32(buf);
-   if (i > PNG_UINT_31_MAX)
-     png_error(png_ptr, "PNG unsigned integer out of range");
-   return (i);
-}
-#ifndef PNG_USE_READ_MACROS
-/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
-png_uint_32 (PNGAPI
-png_get_uint_32)(png_bytep buf)
-{
-   png_uint_32 i =
-       ((png_uint_32)(*(buf    )) << 24) +
-       ((png_uint_32)(*(buf + 1)) << 16) +
-       ((png_uint_32)(*(buf + 2)) <<  8) +
-       ((png_uint_32)(*(buf + 3))      ) ;
-
-   return (i);
-}
-
-/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
- * data is stored in the PNG file in two's complement format and there
- * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore
- * the following code does a two's complement to native conversion.
- */
-png_int_32 (PNGAPI
-png_get_int_32)(png_bytep buf)
-{
-   png_uint_32 u = png_get_uint_32(buf);
-   if ((u & 0x80000000) == 0) /* non-negative */
-      return u;
-
-   u = (u ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
-   return -(png_int_32)u;
-}
-
-/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
-png_uint_16 (PNGAPI
-png_get_uint_16)(png_bytep buf)
-{
-   png_uint_16 i =
-       ((png_uint_32)(*buf) << 8) +
-       ((png_uint_32)(*(buf + 1)));
-
-   return (i);
-}
-#endif /* PNG_USE_READ_MACROS */
-
-/* Read the chunk header (length + type name).
- * Put the type name into png_ptr->chunk_name, and return the length.
- */
-png_uint_32 /* PRIVATE */
-png_read_chunk_header(png_structp png_ptr)
-{
-   png_byte buf[8];
-   png_uint_32 length;
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that the chunk header is being read.
-    * PNG_IO_CHUNK_HDR requires a single I/O call.
-    */
-   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
-#endif
-
-   /* Read the length and the chunk name */
-   png_read_data(png_ptr, buf, 8);
-   length = png_get_uint_31(png_ptr, buf);
-
-   /* Put the chunk name into png_ptr->chunk_name */
-   png_memcpy(png_ptr->chunk_name, buf + 4, 4);
-
-   png_debug2(0, "Reading %s chunk, length = %lu",
-      png_ptr->chunk_name, length);
-
-   /* Reset the crc and run it over the chunk name */
-   png_reset_crc(png_ptr);
-   png_calculate_crc(png_ptr, png_ptr->chunk_name, 4);
-
-   /* Check to see if chunk name is valid */
-   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that chunk data will (possibly) be read.
-    * PNG_IO_CHUNK_DATA does NOT require a specific number of I/O calls.
-    */
-   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
-#endif
-
-   return length;
-}
-
-/* Read data, and (optionally) run it through the CRC. */
-void /* PRIVATE */
-png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
-{
-   if (png_ptr == NULL)
-      return;
-   png_read_data(png_ptr, buf, length);
-   png_calculate_crc(png_ptr, buf, length);
-}
-
-/* Optionally skip data and then check the CRC.  Depending on whether we
- * are reading a ancillary or critical chunk, and how the program has set
- * things up, we may calculate the CRC on the data and print a message.
- * Returns '1' if there was a CRC error, '0' otherwise.
- */
-int /* PRIVATE */
-png_crc_finish(png_structp png_ptr, png_uint_32 skip)
-{
-   png_size_t i;
-   png_size_t istop = png_ptr->zbuf_size;
-
-   for (i = (png_size_t)skip; i > istop; i -= istop)
-   {
-      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
-   }
-   if (i)
-   {
-      png_crc_read(png_ptr, png_ptr->zbuf, i);
-   }
-
-   if (png_crc_error(png_ptr))
-   {
-      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
-          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
-          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
-          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
-      {
-         png_chunk_warning(png_ptr, "CRC error");
-      }
-      else
-      {
-         png_chunk_benign_error(png_ptr, "CRC error");
-         return (0);
-      }
-      return (1);
-   }
-
-   return (0);
-}
-
-/* Compare the CRC stored in the PNG file with that calculated by libpng from
- * the data it has read thus far.
- */
-int /* PRIVATE */
-png_crc_error(png_structp png_ptr)
-{
-   png_byte crc_bytes[4];
-   png_uint_32 crc;
-   int need_crc = 1;
-
-   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
-   {
-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
-          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
-         need_crc = 0;
-   }
-   else                                                    /* critical */
-   {
-      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
-         need_crc = 0;
-   }
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that the chunk CRC is being read */
-   /* PNG_IO_CHUNK_CRC requires the I/O to be done at once */
-   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
-#endif
-
-   png_read_data(png_ptr, crc_bytes, 4);
-
-   if (need_crc)
-   {
-      crc = png_get_uint_32(crc_bytes);
-      return ((int)(crc != png_ptr->crc));
-   }
-   else
-      return (0);
-}
-
-#if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
-    defined(PNG_READ_iCCP_SUPPORTED)
-static png_size_t
-png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
-        png_bytep output, png_size_t output_size)
-{
-   png_size_t count = 0;
-
-   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */
-   png_ptr->zstream.avail_in = size;
-
-   while (1)
-   {
-      int ret, avail;
-
-      /* Reset the output buffer each time round - we empty it
-       * after every inflate call.
-       */
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = png_ptr->zbuf_size;
-
-      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
-      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-
-      /* First copy/count any new output - but only if we didn't
-       * get an error code.
-       */
-      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
-      {
-         if (output != 0 && output_size > count)
-         {
-            int copy = output_size - count;
-            if (avail < copy) copy = avail;
-            png_memcpy(output + count, png_ptr->zbuf, copy);
-         }
-         count += avail;
-      }
-
-      if (ret == Z_OK)
-         continue;
-
-      /* Termination conditions - always reset the zstream, it
-       * must be left in inflateInit state.
-       */
-      png_ptr->zstream.avail_in = 0;
-      inflateReset(&png_ptr->zstream);
-
-      if (ret == Z_STREAM_END)
-         return count; /* NOTE: may be zero. */
-
-      /* Now handle the error codes - the API always returns 0
-       * and the error message is dumped into the uncompressed
-       * buffer if available.
-       */
-      {
-         PNG_CONST char *msg;
-         if (png_ptr->zstream.msg != 0)
-            msg = png_ptr->zstream.msg;
-         else
-         {
-#ifdef PNG_STDIO_SUPPORTED
-            char umsg[52];
-
-            switch (ret)
-            {
-               case Z_BUF_ERROR:
-                  msg = "Buffer error in compressed datastream in %s chunk";
-                  break;
-               case Z_DATA_ERROR:
-                  msg = "Data error in compressed datastream in %s chunk";
-                  break;
-               default:
-                  msg = "Incomplete compressed datastream in %s chunk";
-                  break;
-            }
-
-            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
-            msg = umsg;
-#else
-            msg = "Damaged compressed datastream in chunk other than IDAT";
-#endif
-         }
-
-         png_warning(png_ptr, msg);
-      }
-
-      /* 0 means an error - notice that this code simple ignores
-       * zero length compressed chunks as a result.
-       */
-      return 0;
-   }
-}
-
-/*
- * Decompress trailing data in a chunk.  The assumption is that chunkdata
- * points at an allocated area holding the contents of a chunk with a
- * trailing compressed part.  What we get back is an allocated area
- * holding the original prefix part and an uncompressed version of the
- * trailing part (the malloc area passed in is freed).
- */
-void /* PRIVATE */
-png_decompress_chunk(png_structp png_ptr, int comp_type,
-    png_size_t chunklength,
-    png_size_t prefix_size, png_size_t *newlength)
-{
-   /* The caller should guarantee this */
-   if (prefix_size > chunklength)
-   {
-      /* The recovery is to delete the chunk. */
-      png_warning(png_ptr, "invalid chunklength");
-      prefix_size = 0; /* To delete everything */
-   }
-
-   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)
-   {
-      png_size_t expanded_size = png_inflate(png_ptr,
-                (png_bytep)(png_ptr->chunkdata + prefix_size),
-                chunklength - prefix_size,
-                0/*output*/, 0/*output size*/);
-
-      /* Now check the limits on this chunk - if the limit fails the
-       * compressed data will be removed, the prefix will remain.
-       */
-#ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-      if (png_ptr->user_chunk_malloc_max &&
-          (prefix_size + expanded_size >= png_ptr->user_chunk_malloc_max - 1))
-#else
-#  ifdef PNG_USER_CHUNK_MALLOC_MAX
-      if ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
-          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
-#  endif
-#endif
-         png_warning(png_ptr, "Exceeded size limit while expanding chunk");
-
-      /* If the size is zero either there was an error and a message
-       * has already been output (warning) or the size really is zero
-       * and we have nothing to do - the code will exit through the
-       * error case below.
-       */
-#if defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED) || \
-    defined(PNG_USER_CHUNK_MALLOC_MAX)
-      else
-#endif
-      if (expanded_size > 0)
-      {
-         /* Success (maybe) - really uncompress the chunk. */
-         png_size_t new_size = 0;
-         png_charp text = png_malloc_warn(png_ptr,
-                        prefix_size + expanded_size + 1);
-
-         if (text != NULL)
-         {
-            png_memcpy(text, png_ptr->chunkdata, prefix_size);
-            new_size = png_inflate(png_ptr,
-                (png_bytep)(png_ptr->chunkdata + prefix_size),
-                chunklength - prefix_size,
-                (png_bytep)(text + prefix_size), expanded_size);
-            text[prefix_size + expanded_size] = 0; /* just in case */
-
-            if (new_size == expanded_size)
-            {
-               png_free(png_ptr, png_ptr->chunkdata);
-               png_ptr->chunkdata = text;
-               *newlength = prefix_size + expanded_size;
-               return; /* The success return! */
-            }
-
-            png_warning(png_ptr, "png_inflate logic error");
-            png_free(png_ptr, text);
-         }
-         else
-          png_warning(png_ptr, "Not enough memory to decompress chunk");
-      }
-   }
-
-   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
-   {
-#ifdef PNG_STDIO_SUPPORTED
-      char umsg[50];
-
-      png_snprintf(umsg, sizeof umsg, "Unknown zTXt compression type %d",
-          comp_type);
-      png_warning(png_ptr, umsg);
-#else
-      png_warning(png_ptr, "Unknown zTXt compression type");
-#endif
-
-      /* The recovery is to simply drop the data. */
-   }
-
-   /* Generic error return - leave the prefix, delete the compressed
-    * data, reallocate the chunkdata to remove the potentially large
-    * amount of compressed data.
-    */
-   {
-      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
-      if (text != NULL)
-      {
-         if (prefix_size > 0)
-            png_memcpy(text, png_ptr->chunkdata, prefix_size);
-         png_free(png_ptr, png_ptr->chunkdata);
-         png_ptr->chunkdata = text;
-
-         /* This is an extra zero in the 'uncompressed' part. */
-         *(png_ptr->chunkdata + prefix_size) = 0x00;
-      }
-      /* Ignore a malloc error here - it is safe. */
-   }
-
-   *newlength = prefix_size;
-}
-#endif
-
-/* Read and check the IDHR chunk */
-void /* PRIVATE */
-png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte buf[13];
-   png_uint_32 width, height;
-   int bit_depth, color_type, compression_type, filter_type;
-   int interlace_type;
-
-   png_debug(1, "in png_handle_IHDR");
-
-   if (png_ptr->mode & PNG_HAVE_IHDR)
-      png_error(png_ptr, "Out of place IHDR");
-
-   /* Check the length */
-   if (length != 13)
-      png_error(png_ptr, "Invalid IHDR chunk");
-
-   png_ptr->mode |= PNG_HAVE_IHDR;
-
-   png_crc_read(png_ptr, buf, 13);
-   png_crc_finish(png_ptr, 0);
-
-   width = png_get_uint_31(png_ptr, buf);
-   height = png_get_uint_31(png_ptr, buf + 4);
-   bit_depth = buf[8];
-   color_type = buf[9];
-   compression_type = buf[10];
-   filter_type = buf[11];
-   interlace_type = buf[12];
-
-   /* Set internal variables */
-   png_ptr->width = width;
-   png_ptr->height = height;
-   png_ptr->bit_depth = (png_byte)bit_depth;
-   png_ptr->interlaced = (png_byte)interlace_type;
-   png_ptr->color_type = (png_byte)color_type;
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   png_ptr->filter_type = (png_byte)filter_type;
-#endif
-   png_ptr->compression_type = (png_byte)compression_type;
-
-   /* Find number of channels */
-   switch (png_ptr->color_type)
-   {
-      case PNG_COLOR_TYPE_GRAY:
-      case PNG_COLOR_TYPE_PALETTE:
-         png_ptr->channels = 1;
-         break;
-
-      case PNG_COLOR_TYPE_RGB:
-         png_ptr->channels = 3;
-         break;
-
-      case PNG_COLOR_TYPE_GRAY_ALPHA:
-         png_ptr->channels = 2;
-         break;
-
-      case PNG_COLOR_TYPE_RGB_ALPHA:
-         png_ptr->channels = 4;
-         break;
-   }
-
-   /* Set up other useful info */
-   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
-   png_ptr->channels);
-   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
-   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
-   png_debug1(3, "channels = %d", png_ptr->channels);
-   png_debug1(3, "rowbytes = %lu", png_ptr->rowbytes);
-   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
-      color_type, interlace_type, compression_type, filter_type);
-}
-
-/* Read and check the palette */
-void /* PRIVATE */
-png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_color palette[PNG_MAX_PALETTE_LENGTH];
-   int num, i;
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   png_colorp pal_ptr;
-#endif
-
-   png_debug(1, "in png_handle_PLTE");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before PLTE");
-
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid PLTE after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-      png_error(png_ptr, "Duplicate PLTE chunk");
-
-   png_ptr->mode |= PNG_HAVE_PLTE;
-
-   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
-   {
-      png_warning(png_ptr,
-        "Ignoring PLTE chunk in grayscale PNG");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-#ifndef PNG_READ_OPT_PLTE_SUPPORTED
-   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-#endif
-
-   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
-   {
-      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-      {
-         png_warning(png_ptr, "Invalid palette chunk");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-
-      else
-      {
-         png_error(png_ptr, "Invalid palette chunk");
-      }
-   }
-
-   num = (int)length / 3;
-
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
-   {
-      png_byte buf[3];
-
-      png_crc_read(png_ptr, buf, 3);
-      pal_ptr->red = buf[0];
-      pal_ptr->green = buf[1];
-      pal_ptr->blue = buf[2];
-   }
-#else
-   for (i = 0; i < num; i++)
-   {
-      png_byte buf[3];
-
-      png_crc_read(png_ptr, buf, 3);
-      /* Don't depend upon png_color being any order */
-      palette[i].red = buf[0];
-      palette[i].green = buf[1];
-      palette[i].blue = buf[2];
-   }
-#endif
-
-   /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
-    * whatever the normal CRC configuration tells us.  However, if we
-    * have an RGB image, the PLTE can be considered ancillary, so
-    * we will act as though it is.
-    */
-#ifndef PNG_READ_OPT_PLTE_SUPPORTED
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-#endif
-   {
-      png_crc_finish(png_ptr, 0);
-   }
-#ifndef PNG_READ_OPT_PLTE_SUPPORTED
-   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
-   {
-      /* If we don't want to use the data from an ancillary chunk,
-         we have two options: an error abort, or a warning and we
-         ignore the data in this chunk (which should be OK, since
-         it's considered ancillary for a RGB or RGBA image). */
-      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
-      {
-         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
-         {
-            png_chunk_benign_error(png_ptr, "CRC error");
-         }
-         else
-         {
-            png_chunk_warning(png_ptr, "CRC error");
-            return;
-         }
-      }
-      /* Otherwise, we (optionally) emit a warning and use the chunk. */
-      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
-      {
-         png_chunk_warning(png_ptr, "CRC error");
-      }
-   }
-#endif
-
-   png_set_PLTE(png_ptr, info_ptr, palette, num);
-
-#ifdef PNG_READ_tRNS_SUPPORTED
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
-      {
-         if (png_ptr->num_trans > (png_uint_16)num)
-         {
-            png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
-            png_ptr->num_trans = (png_uint_16)num;
-         }
-         if (info_ptr->num_trans > (png_uint_16)num)
-         {
-            png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
-            info_ptr->num_trans = (png_uint_16)num;
-         }
-      }
-   }
-#endif
-
-}
-
-void /* PRIVATE */
-png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_debug(1, "in png_handle_IEND");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
-   {
-      png_error(png_ptr, "No image in file");
-   }
-
-   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
-
-   if (length != 0)
-   {
-      png_warning(png_ptr, "Incorrect IEND chunk length");
-   }
-   png_crc_finish(png_ptr, length);
-
-   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
-}
-
-#ifdef PNG_READ_gAMA_SUPPORTED
-void /* PRIVATE */
-png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_fixed_point igamma;
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float file_gamma;
-#endif
-   png_byte buf[4];
-
-   png_debug(1, "in png_handle_gAMA");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before gAMA");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid gAMA after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-      /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Out of place gAMA chunk");
-
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
-#ifdef PNG_READ_sRGB_SUPPORTED
-      && !(info_ptr->valid & PNG_INFO_sRGB)
-#endif
-      )
-   {
-      png_warning(png_ptr, "Duplicate gAMA chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (length != 4)
-   {
-      png_warning(png_ptr, "Incorrect gAMA chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 4);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   igamma = (png_fixed_point)png_get_uint_32(buf);
-   /* Check for zero gamma */
-   if (igamma == 0)
-      {
-         png_warning(png_ptr,
-           "Ignoring gAMA chunk with gamma=0");
-         return;
-      }
-
-#ifdef PNG_READ_sRGB_SUPPORTED
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
-      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
-      {
-         png_warning(png_ptr,
-           "Ignoring incorrect gAMA value when sRGB is also present");
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
-#endif
-         return;
-      }
-#endif /* PNG_READ_sRGB_SUPPORTED */
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   file_gamma = (float)igamma / (float)100000.0;
-#  ifdef PNG_READ_GAMMA_SUPPORTED
-     png_ptr->gamma = file_gamma;
-#  endif
-     png_set_gAMA(png_ptr, info_ptr, file_gamma);
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
-#endif
-}
-#endif
-
-#ifdef PNG_READ_sBIT_SUPPORTED
-void /* PRIVATE */
-png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_size_t truelen;
-   png_byte buf[4];
-
-   png_debug(1, "in png_handle_sBIT");
-
-   buf[0] = buf[1] = buf[2] = buf[3] = 0;
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before sBIT");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid sBIT after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-   {
-      /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Out of place sBIT chunk");
-   }
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
-   {
-      png_warning(png_ptr, "Duplicate sBIT chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      truelen = 3;
-   else
-      truelen = (png_size_t)png_ptr->channels;
-
-   if (length != truelen || length > 4)
-   {
-      png_warning(png_ptr, "Incorrect sBIT chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, truelen);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
-   {
-      png_ptr->sig_bit.red = buf[0];
-      png_ptr->sig_bit.green = buf[1];
-      png_ptr->sig_bit.blue = buf[2];
-      png_ptr->sig_bit.alpha = buf[3];
-   }
-   else
-   {
-      png_ptr->sig_bit.gray = buf[0];
-      png_ptr->sig_bit.red = buf[0];
-      png_ptr->sig_bit.green = buf[0];
-      png_ptr->sig_bit.blue = buf[0];
-      png_ptr->sig_bit.alpha = buf[1];
-   }
-   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
-}
-#endif
-
-#ifdef PNG_READ_cHRM_SUPPORTED
-void /* PRIVATE */
-png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte buf[32];
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
-#endif
-   png_fixed_point int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
-      int_y_green, int_x_blue, int_y_blue;
-
-   png_uint_32 uint_x, uint_y;
-
-   png_debug(1, "in png_handle_cHRM");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before cHRM");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid cHRM after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-      /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Missing PLTE before cHRM");
-
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
-#ifdef PNG_READ_sRGB_SUPPORTED
-      && !(info_ptr->valid & PNG_INFO_sRGB)
-#endif
-      )
-   {
-      png_warning(png_ptr, "Duplicate cHRM chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (length != 32)
-   {
-      png_warning(png_ptr, "Incorrect cHRM chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 32);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   uint_x = png_get_uint_32(buf);
-   uint_y = png_get_uint_32(buf + 4);
-   int_x_white = (png_fixed_point)uint_x;
-   int_y_white = (png_fixed_point)uint_y;
-
-   uint_x = png_get_uint_32(buf + 8);
-   uint_y = png_get_uint_32(buf + 12);
-   int_x_red = (png_fixed_point)uint_x;
-   int_y_red = (png_fixed_point)uint_y;
-
-   uint_x = png_get_uint_32(buf + 16);
-   uint_y = png_get_uint_32(buf + 20);
-   int_x_green = (png_fixed_point)uint_x;
-   int_y_green = (png_fixed_point)uint_y;
-
-   uint_x = png_get_uint_32(buf + 24);
-   uint_y = png_get_uint_32(buf + 28);
-   int_x_blue = (png_fixed_point)uint_x;
-   int_y_blue = (png_fixed_point)uint_y;
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   white_x = (float)int_x_white / (float)100000.0;
-   white_y = (float)int_y_white / (float)100000.0;
-   red_x   = (float)int_x_red   / (float)100000.0;
-   red_y   = (float)int_y_red   / (float)100000.0;
-   green_x = (float)int_x_green / (float)100000.0;
-   green_y = (float)int_y_green / (float)100000.0;
-   blue_x  = (float)int_x_blue  / (float)100000.0;
-   blue_y  = (float)int_y_blue  / (float)100000.0;
-#endif
-
-#ifdef PNG_READ_sRGB_SUPPORTED
-   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))
-      {
-      if (PNG_OUT_OF_RANGE(int_x_white, 31270,  1000) ||
-          PNG_OUT_OF_RANGE(int_y_white, 32900,  1000) ||
-          PNG_OUT_OF_RANGE(int_x_red,   64000L, 1000) ||
-          PNG_OUT_OF_RANGE(int_y_red,   33000,  1000) ||
-          PNG_OUT_OF_RANGE(int_x_green, 30000,  1000) ||
-          PNG_OUT_OF_RANGE(int_y_green, 60000L, 1000) ||
-          PNG_OUT_OF_RANGE(int_x_blue,  15000,  1000) ||
-          PNG_OUT_OF_RANGE(int_y_blue,   6000,  1000))
-         {
-            png_warning(png_ptr,
-              "Ignoring incorrect cHRM value when sRGB is also present");
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-            fprintf(stderr, "wx=%f, wy=%f, rx=%f, ry=%f\n",
-               white_x, white_y, red_x, red_y);
-            fprintf(stderr, "gx=%f, gy=%f, bx=%f, by=%f\n",
-               green_x, green_y, blue_x, blue_y);
-#else
-            fprintf(stderr, "wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
-               (long)int_x_white, (long)int_y_white,
-               (long)int_x_red, (long)int_y_red);
-            fprintf(stderr, "gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
-               (long)int_x_green, (long)int_y_green,
-               (long)int_x_blue, (long)int_y_blue);
-#endif
-#endif /* PNG_CONSOLE_IO_SUPPORTED */
-         }
-         return;
-      }
-#endif /* PNG_READ_sRGB_SUPPORTED */
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   png_set_cHRM(png_ptr, info_ptr,
-      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_set_cHRM_fixed(png_ptr, info_ptr,
-      int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
-      int_y_green, int_x_blue, int_y_blue);
-#endif
-}
-#endif
-
-#ifdef PNG_READ_sRGB_SUPPORTED
-void /* PRIVATE */
-png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   int intent;
-   png_byte buf[1];
-
-   png_debug(1, "in png_handle_sRGB");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before sRGB");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid sRGB after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-      /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Out of place sRGB chunk");
-
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
-   {
-      png_warning(png_ptr, "Duplicate sRGB chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (length != 1)
-   {
-      png_warning(png_ptr, "Incorrect sRGB chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 1);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   intent = buf[0];
-   /* Check for bad intent */
-   if (intent >= PNG_sRGB_INTENT_LAST)
-   {
-      png_warning(png_ptr, "Unknown sRGB intent");
-      return;
-   }
-
-#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))
-   {
-   png_fixed_point igamma;
-#ifdef PNG_FIXED_POINT_SUPPORTED
-      igamma=info_ptr->int_gamma;
-#else
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-      igamma=(png_fixed_point)(info_ptr->gamma * 100000.);
-#  endif
-#endif
-      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
-      {
-         png_warning(png_ptr,
-           "Ignoring incorrect gAMA value when sRGB is also present");
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#  ifdef PNG_FIXED_POINT_SUPPORTED
-         fprintf(stderr, "incorrect gamma=(%d/100000)\n",
-            (int)png_ptr->int_gamma);
-#  else
-#    ifdef PNG_FLOATING_POINT_SUPPORTED
-         fprintf(stderr, "incorrect gamma=%f\n", png_ptr->gamma);
-#    endif
-#  endif
-#endif
-      }
-   }
-#endif /* PNG_READ_gAMA_SUPPORTED */
-
-#ifdef PNG_READ_cHRM_SUPPORTED
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
-      if (PNG_OUT_OF_RANGE(info_ptr->int_x_white, 31270,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_y_white, 32900,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_x_red,   64000L, 1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_y_red,   33000,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_x_green, 30000,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_y_green, 60000L, 1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_x_blue,  15000,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->int_y_blue,   6000,  1000))
-         {
-            png_warning(png_ptr,
-              "Ignoring incorrect cHRM value when sRGB is also present");
-         }
-#endif /* PNG_FIXED_POINT_SUPPORTED */
-#endif /* PNG_READ_cHRM_SUPPORTED */
-
-   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
-}
-#endif /* PNG_READ_sRGB_SUPPORTED */
-
-#ifdef PNG_READ_iCCP_SUPPORTED
-void /* PRIVATE */
-png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-/* Note: this does not properly handle chunks that are > 64K under DOS */
-{
-   png_byte compression_type;
-   png_bytep pC;
-   png_charp profile;
-   png_uint_32 skip = 0;
-   png_uint_32 profile_size, profile_length;
-   png_size_t slength, prefix_length, data_length;
-
-   png_debug(1, "in png_handle_iCCP");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before iCCP");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid iCCP after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->mode & PNG_HAVE_PLTE)
-      /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Out of place iCCP chunk");
-
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
-   {
-      png_warning(png_ptr, "Duplicate iCCP chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "iCCP chunk too large to fit in memory");
-      skip = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-
-   if (png_crc_finish(png_ptr, skip))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00;
-
-   for (profile = png_ptr->chunkdata; *profile; profile++)
-      /* Empty loop to find end of name */ ;
-
-   ++profile;
-
-   /* There should be at least one zero (the compression type byte)
-    * following the separator, and we should be on it
-    */
-   if ( profile >= png_ptr->chunkdata + slength - 1)
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_warning(png_ptr, "Malformed iCCP chunk");
-      return;
-   }
-
-   /* Compression_type should always be zero */
-   compression_type = *profile++;
-   if (compression_type)
-   {
-      png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
-      compression_type = 0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
-                                 wrote nonzero) */
-   }
-
-   prefix_length = profile - png_ptr->chunkdata;
-   png_decompress_chunk(png_ptr, compression_type,
-     slength, prefix_length, &data_length);
-
-   profile_length = data_length - prefix_length;
-
-   if ( prefix_length > data_length || profile_length < 4)
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_warning(png_ptr, "Profile size field missing from iCCP chunk");
-      return;
-   }
-
-   /* Check the profile_size recorded in the first 32 bits of the ICC profile */
-   pC = (png_bytep)(png_ptr->chunkdata + prefix_length);
-   profile_size = ((*(pC    ))<<24) |
-                  ((*(pC + 1))<<16) |
-                  ((*(pC + 2))<< 8) |
-                  ((*(pC + 3))    );
-
-   if (profile_size < profile_length)
-      profile_length = profile_size;
-
-   if (profile_size > profile_length)
-   {
-#ifdef PNG_STDIO_SUPPORTED
-         char umsg[50];
-#endif
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_warning(png_ptr, "Ignoring truncated iCCP profile");
-#ifdef PNG_STDIO_SUPPORTED
-
-      png_snprintf(umsg, 50, "declared profile size = %lu",
-          (unsigned long)profile_size);
-      png_warning(png_ptr, umsg);
-      png_snprintf(umsg, 50, "actual profile length = %lu",
-          (unsigned long)profile_length);
-      png_warning(png_ptr, umsg);
-#endif
-      return;
-   }
-
-   png_set_iCCP(png_ptr, info_ptr, png_ptr->chunkdata,
-     compression_type, png_ptr->chunkdata + prefix_length, profile_length);
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-}
-#endif /* PNG_READ_iCCP_SUPPORTED */
-
-#ifdef PNG_READ_sPLT_SUPPORTED
-void /* PRIVATE */
-png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-/* Note: this does not properly handle chunks that are > 64K under DOS */
-{
-   png_bytep entry_start;
-   png_sPLT_t new_palette;
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   png_sPLT_entryp pp;
-#endif
-   int data_length, entry_size, i;
-   png_uint_32 skip = 0;
-   png_size_t slength;
-
-   png_debug(1, "in png_handle_sPLT");
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-
-   if (png_ptr->user_chunk_cache_max != 0)
-   {
-      if (png_ptr->user_chunk_cache_max == 1)
-      {
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (--png_ptr->user_chunk_cache_max == 1)
-      {
-         png_warning(png_ptr, "No space in chunk cache for sPLT");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-   }
-#endif
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before sPLT");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid sPLT after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "sPLT chunk too large to fit in memory");
-      skip = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-
-   if (png_crc_finish(png_ptr, skip))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00;
-
-   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start;
-       entry_start++)
-      /* Empty loop to find end of name */ ;
-   ++entry_start;
-
-   /* A sample depth should follow the separator, and we should be on it  */
-   if (entry_start > (png_bytep)png_ptr->chunkdata + slength - 2)
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_warning(png_ptr, "malformed sPLT chunk");
-      return;
-   }
-
-   new_palette.depth = *entry_start++;
-   entry_size = (new_palette.depth == 8 ? 6 : 10);
-   data_length = (slength - (entry_start - (png_bytep)png_ptr->chunkdata));
-
-   /* Integrity-check the data length */
-   if (data_length % entry_size)
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_warning(png_ptr, "sPLT chunk has bad length");
-      return;
-   }
-
-   new_palette.nentries = (png_int_32) ( data_length / entry_size);
-   if ((png_uint_32) new_palette.nentries >
-       (png_uint_32) (PNG_SIZE_MAX / png_sizeof(png_sPLT_entry)))
-   {
-       png_warning(png_ptr, "sPLT chunk too long");
-       return;
-   }
-   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
-       png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry));
-   if (new_palette.entries == NULL)
-   {
-       png_warning(png_ptr, "sPLT chunk requires too much memory");
-       return;
-   }
-
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   for (i = 0; i < new_palette.nentries; i++)
-   {
-      pp = new_palette.entries + i;
-
-      if (new_palette.depth == 8)
-      {
-          pp->red = *entry_start++;
-          pp->green = *entry_start++;
-          pp->blue = *entry_start++;
-          pp->alpha = *entry_start++;
-      }
-      else
-      {
-          pp->red   = png_get_uint_16(entry_start); entry_start += 2;
-          pp->green = png_get_uint_16(entry_start); entry_start += 2;
-          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
-          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
-      }
-      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
-   }
-#else
-   pp = new_palette.entries;
-   for (i = 0; i < new_palette.nentries; i++)
-   {
-
-      if (new_palette.depth == 8)
-      {
-          pp[i].red   = *entry_start++;
-          pp[i].green = *entry_start++;
-          pp[i].blue  = *entry_start++;
-          pp[i].alpha = *entry_start++;
-      }
-      else
-      {
-          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
-          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
-          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
-          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
-      }
-      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
-   }
-#endif
-
-   /* Discard all chunk data except the name and stash that */
-   new_palette.name = png_ptr->chunkdata;
-
-   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-   png_free(png_ptr, new_palette.entries);
-}
-#endif /* PNG_READ_sPLT_SUPPORTED */
-
-#ifdef PNG_READ_tRNS_SUPPORTED
-void /* PRIVATE */
-png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
-
-   png_debug(1, "in png_handle_tRNS");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before tRNS");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid tRNS after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
-   {
-      png_warning(png_ptr, "Duplicate tRNS chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      png_byte buf[2];
-
-      if (length != 2)
-      {
-         png_warning(png_ptr, "Incorrect tRNS chunk length");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-
-      png_crc_read(png_ptr, buf, 2);
-      png_ptr->num_trans = 1;
-      png_ptr->trans_color.gray = png_get_uint_16(buf);
-   }
-   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
-   {
-      png_byte buf[6];
-
-      if (length != 6)
-      {
-         png_warning(png_ptr, "Incorrect tRNS chunk length");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      png_crc_read(png_ptr, buf, (png_size_t)length);
-      png_ptr->num_trans = 1;
-      png_ptr->trans_color.red = png_get_uint_16(buf);
-      png_ptr->trans_color.green = png_get_uint_16(buf + 2);
-      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);
-   }
-   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (!(png_ptr->mode & PNG_HAVE_PLTE))
-      {
-         /* Should be an error, but we can cope with it. */
-         png_warning(png_ptr, "Missing PLTE before tRNS");
-      }
-      if (length > (png_uint_32)png_ptr->num_palette ||
-          length > PNG_MAX_PALETTE_LENGTH)
-      {
-         png_warning(png_ptr, "Incorrect tRNS chunk length");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (length == 0)
-      {
-         png_warning(png_ptr, "Zero length tRNS chunk");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      png_crc_read(png_ptr, readbuf, (png_size_t)length);
-      png_ptr->num_trans = (png_uint_16)length;
-   }
-   else
-   {
-      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (png_crc_finish(png_ptr, 0))
-   {
-      png_ptr->num_trans = 0;
-      return;
-   }
-
-   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
-      &(png_ptr->trans_color));
-}
-#endif
-
-#ifdef PNG_READ_bKGD_SUPPORTED
-void /* PRIVATE */
-png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_size_t truelen;
-   png_byte buf[6];
-
-   png_debug(1, "in png_handle_bKGD");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before bKGD");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid bKGD after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-            !(png_ptr->mode & PNG_HAVE_PLTE))
-   {
-      png_warning(png_ptr, "Missing PLTE before bKGD");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))
-   {
-      png_warning(png_ptr, "Duplicate bKGD chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      truelen = 1;
-   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
-      truelen = 6;
-   else
-      truelen = 2;
-
-   if (length != truelen)
-   {
-      png_warning(png_ptr, "Incorrect bKGD chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, truelen);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   /* We convert the index value into RGB components so that we can allow
-    * arbitrary RGB values for background when we have transparency, and
-    * so it is easy to determine the RGB values of the background color
-    * from the info_ptr struct. */
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      png_ptr->background.index = buf[0];
-      if (info_ptr && info_ptr->num_palette)
-      {
-          if (buf[0] >= info_ptr->num_palette)
-          {
-             png_warning(png_ptr, "Incorrect bKGD chunk index value");
-             return;
-          }
-          png_ptr->background.red =
-             (png_uint_16)png_ptr->palette[buf[0]].red;
-          png_ptr->background.green =
-             (png_uint_16)png_ptr->palette[buf[0]].green;
-          png_ptr->background.blue =
-             (png_uint_16)png_ptr->palette[buf[0]].blue;
-      }
-   }
-   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
-   {
-      png_ptr->background.red =
-      png_ptr->background.green =
-      png_ptr->background.blue =
-      png_ptr->background.gray = png_get_uint_16(buf);
-   }
-   else
-   {
-      png_ptr->background.red = png_get_uint_16(buf);
-      png_ptr->background.green = png_get_uint_16(buf + 2);
-      png_ptr->background.blue = png_get_uint_16(buf + 4);
-   }
-
-   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
-}
-#endif
-
-#ifdef PNG_READ_hIST_SUPPORTED
-void /* PRIVATE */
-png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   unsigned int num, i;
-   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
-
-   png_debug(1, "in png_handle_hIST");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before hIST");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid hIST after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (!(png_ptr->mode & PNG_HAVE_PLTE))
-   {
-      png_warning(png_ptr, "Missing PLTE before hIST");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))
-   {
-      png_warning(png_ptr, "Duplicate hIST chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   num = length / 2 ;
-   if (num != (unsigned int) png_ptr->num_palette || num >
-      (unsigned int) PNG_MAX_PALETTE_LENGTH)
-   {
-      png_warning(png_ptr, "Incorrect hIST chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   for (i = 0; i < num; i++)
-   {
-      png_byte buf[2];
-
-      png_crc_read(png_ptr, buf, 2);
-      readbuf[i] = png_get_uint_16(buf);
-   }
-
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   png_set_hIST(png_ptr, info_ptr, readbuf);
-}
-#endif
-
-#ifdef PNG_READ_pHYs_SUPPORTED
-void /* PRIVATE */
-png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte buf[9];
-   png_uint_32 res_x, res_y;
-   int unit_type;
-
-   png_debug(1, "in png_handle_pHYs");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before pHYs");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid pHYs after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
-   {
-      png_warning(png_ptr, "Duplicate pHYs chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (length != 9)
-   {
-      png_warning(png_ptr, "Incorrect pHYs chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 9);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   res_x = png_get_uint_32(buf);
-   res_y = png_get_uint_32(buf + 4);
-   unit_type = buf[8];
-   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
-}
-#endif
-
-#ifdef PNG_READ_oFFs_SUPPORTED
-void /* PRIVATE */
-png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte buf[9];
-   png_int_32 offset_x, offset_y;
-   int unit_type;
-
-   png_debug(1, "in png_handle_oFFs");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before oFFs");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid oFFs after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
-   {
-      png_warning(png_ptr, "Duplicate oFFs chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (length != 9)
-   {
-      png_warning(png_ptr, "Incorrect oFFs chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 9);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   offset_x = png_get_int_32(buf);
-   offset_y = png_get_int_32(buf + 4);
-   unit_type = buf[8];
-   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
-}
-#endif
-
-#ifdef PNG_READ_pCAL_SUPPORTED
-/* Read the pCAL chunk (described in the PNG Extensions document) */
-void /* PRIVATE */
-png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_int_32 X0, X1;
-   png_byte type, nparams;
-   png_charp buf, units, endptr;
-   png_charpp params;
-   png_size_t slength;
-   int i;
-
-   png_debug(1, "in png_handle_pCAL");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before pCAL");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid pCAL after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))
-   {
-      png_warning(png_ptr, "Duplicate pCAL chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)",
-      length + 1);
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (png_ptr->chunkdata == NULL)
-     {
-       png_warning(png_ptr, "No memory for pCAL purpose");
-       return;
-     }
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-
-   if (png_crc_finish(png_ptr, 0))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
-
-   png_debug(3, "Finding end of pCAL purpose string");
-   for (buf = png_ptr->chunkdata; *buf; buf++)
-      /* Empty loop */ ;
-
-   endptr = png_ptr->chunkdata + slength;
-
-   /* We need to have at least 12 bytes after the purpose string
-      in order to get the parameter information. */
-   if (endptr <= buf + 12)
-   {
-      png_warning(png_ptr, "Invalid pCAL data");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
-   X0 = png_get_int_32((png_bytep)buf+1);
-   X1 = png_get_int_32((png_bytep)buf+5);
-   type = buf[9];
-   nparams = buf[10];
-   units = buf + 11;
-
-   png_debug(3, "Checking pCAL equation type and number of parameters");
-   /* Check that we have the right number of parameters for known
-      equation types. */
-   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
-       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
-       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
-       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
-   {
-      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-   else if (type >= PNG_EQUATION_LAST)
-   {
-      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
-   }
-
-   for (buf = units; *buf; buf++)
-      /* Empty loop to move past the units string. */ ;
-
-   png_debug(3, "Allocating pCAL parameters array");
-   params = (png_charpp)png_malloc_warn(png_ptr,
-      (png_size_t)(nparams * png_sizeof(png_charp)));
-   if (params == NULL)
-     {
-       png_free(png_ptr, png_ptr->chunkdata);
-       png_ptr->chunkdata = NULL;
-       png_warning(png_ptr, "No memory for pCAL params");
-       return;
-     }
-
-   /* Get pointers to the start of each parameter string. */
-   for (i = 0; i < (int)nparams; i++)
-   {
-      buf++; /* Skip the null string terminator from previous parameter. */
-
-      png_debug1(3, "Reading pCAL parameter %d", i);
-      for (params[i] = buf; buf <= endptr && *buf != 0x00; buf++)
-         /* Empty loop to move past each parameter string */ ;
-
-      /* Make sure we haven't run out of data yet */
-      if (buf > endptr)
-      {
-         png_warning(png_ptr, "Invalid pCAL data");
-         png_free(png_ptr, png_ptr->chunkdata);
-         png_ptr->chunkdata = NULL;
-         png_free(png_ptr, params);
-         return;
-      }
-   }
-
-   png_set_pCAL(png_ptr, info_ptr, png_ptr->chunkdata, X0, X1, type, nparams,
-      units, params);
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-   png_free(png_ptr, params);
-}
-#endif
-
-#ifdef PNG_READ_sCAL_SUPPORTED
-/* Read the sCAL chunk */
-void /* PRIVATE */
-png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_charp ep;
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   double width, height;
-   png_charp vp;
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_charp swidth, sheight;
-#endif
-#endif
-   png_size_t slength;
-
-   png_debug(1, "in png_handle_sCAL");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before sCAL");
-   else if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      png_warning(png_ptr, "Invalid sCAL after IDAT");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))
-   {
-      png_warning(png_ptr, "Duplicate sCAL chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)",
-      length + 1);
-   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (png_ptr->chunkdata == NULL)
-   {
-      png_warning(png_ptr, "Out of memory while processing sCAL chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-
-   if (png_crc_finish(png_ptr, 0))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
-
-   ep = png_ptr->chunkdata + 1;        /* Skip unit byte */
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   width = png_strtod(png_ptr, ep, &vp);
-   if (*vp)
-   {
-      png_warning(png_ptr, "malformed width string in sCAL chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
-   if (swidth == NULL)
-   {
-      png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-   png_memcpy(swidth, ep, png_strlen(ep));
-#endif
-#endif
-
-   for (ep = png_ptr->chunkdata; *ep; ep++)
-      /* Empty loop */ ;
-   ep++;
-
-   if (png_ptr->chunkdata + slength < ep)
-   {
-      png_warning(png_ptr, "Truncated sCAL chunk");
-#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
-      png_free(png_ptr, swidth);
-#endif
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   height = png_strtod(png_ptr, ep, &vp);
-   if (*vp)
-   {
-      png_warning(png_ptr, "malformed height string in sCAL chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
-   if (sheight == NULL)
-   {
-      png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      png_free(png_ptr, swidth);
-      return;
-   }
-   png_memcpy(sheight, ep, png_strlen(ep));
-#endif
-#endif
-
-   if (png_ptr->chunkdata + slength < ep
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-      || width <= 0. || height <= 0.
-#endif
-      )
-   {
-      png_warning(png_ptr, "Invalid sCAL data");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
-      png_free(png_ptr, swidth);
-      png_free(png_ptr, sheight);
-#endif
-      return;
-   }
-
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   png_set_sCAL(png_ptr, info_ptr, png_ptr->chunkdata[0], width, height);
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0], swidth, sheight);
-#endif
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
-   png_free(png_ptr, swidth);
-   png_free(png_ptr, sheight);
-#endif
-}
-#endif
-
-#ifdef PNG_READ_tIME_SUPPORTED
-void /* PRIVATE */
-png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_byte buf[7];
-   png_time mod_time;
-
-   png_debug(1, "in png_handle_tIME");
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Out of place tIME chunk");
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))
-   {
-      png_warning(png_ptr, "Duplicate tIME chunk");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   if (png_ptr->mode & PNG_HAVE_IDAT)
-      png_ptr->mode |= PNG_AFTER_IDAT;
-
-   if (length != 7)
-   {
-      png_warning(png_ptr, "Incorrect tIME chunk length");
-      png_crc_finish(png_ptr, length);
-      return;
-   }
-
-   png_crc_read(png_ptr, buf, 7);
-   if (png_crc_finish(png_ptr, 0))
-      return;
-
-   mod_time.second = buf[6];
-   mod_time.minute = buf[5];
-   mod_time.hour = buf[4];
-   mod_time.day = buf[3];
-   mod_time.month = buf[2];
-   mod_time.year = png_get_uint_16(buf);
-
-   png_set_tIME(png_ptr, info_ptr, &mod_time);
-}
-#endif
-
-#ifdef PNG_READ_tEXt_SUPPORTED
-/* Note: this does not properly handle chunks that are > 64K under DOS */
-void /* PRIVATE */
-png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_textp text_ptr;
-   png_charp key;
-   png_charp text;
-   png_uint_32 skip = 0;
-   png_size_t slength;
-   int ret;
-
-   png_debug(1, "in png_handle_tEXt");
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   if (png_ptr->user_chunk_cache_max != 0)
-   {
-      if (png_ptr->user_chunk_cache_max == 1)
-      {
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (--png_ptr->user_chunk_cache_max == 1)
-      {
-         png_warning(png_ptr, "No space in chunk cache for tEXt");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-   }
-#endif
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before tEXt");
-
-   if (png_ptr->mode & PNG_HAVE_IDAT)
-      png_ptr->mode |= PNG_AFTER_IDAT;
-
-#ifdef PNG_MAX_MALLOC_64K
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
-      skip = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-
-   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (png_ptr->chunkdata == NULL)
-   {
-     png_warning(png_ptr, "No memory to process text chunk");
-     return;
-   }
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-
-   if (png_crc_finish(png_ptr, skip))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   key = png_ptr->chunkdata;
-
-   key[slength] = 0x00;
-
-   for (text = key; *text; text++)
-      /* Empty loop to find end of key */ ;
-
-   if (text != key + slength)
-      text++;
-
-   text_ptr = (png_textp)png_malloc_warn(png_ptr,
-      png_sizeof(png_text));
-   if (text_ptr == NULL)
-   {
-     png_warning(png_ptr, "Not enough memory to process text chunk");
-     png_free(png_ptr, png_ptr->chunkdata);
-     png_ptr->chunkdata = NULL;
-     return;
-   }
-   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
-   text_ptr->key = key;
-#ifdef PNG_iTXt_SUPPORTED
-   text_ptr->lang = NULL;
-   text_ptr->lang_key = NULL;
-   text_ptr->itxt_length = 0;
-#endif
-   text_ptr->text = text;
-   text_ptr->text_length = png_strlen(text);
-
-   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-   png_free(png_ptr, text_ptr);
-   if (ret)
-     png_warning(png_ptr, "Insufficient memory to process text chunk");
-}
-#endif
-
-#ifdef PNG_READ_zTXt_SUPPORTED
-/* Note: this does not correctly handle chunks that are > 64K under DOS */
-void /* PRIVATE */
-png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_textp text_ptr;
-   png_charp text;
-   int comp_type;
-   int ret;
-   png_size_t slength, prefix_len, data_len;
-
-   png_debug(1, "in png_handle_zTXt");
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   if (png_ptr->user_chunk_cache_max != 0)
-   {
-      if (png_ptr->user_chunk_cache_max == 1)
-      {
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (--png_ptr->user_chunk_cache_max == 1)
-      {
-         png_warning(png_ptr, "No space in chunk cache for zTXt");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-   }
-#endif
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before zTXt");
-
-   if (png_ptr->mode & PNG_HAVE_IDAT)
-      png_ptr->mode |= PNG_AFTER_IDAT;
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We will no doubt have problems with chunks even half this size, but
-      there is no hard and fast rule to tell us where to stop. */
-   if (length > (png_uint_32)65535L)
-   {
-     png_warning(png_ptr, "zTXt chunk too large to fit in memory");
-     png_crc_finish(png_ptr, length);
-     return;
-   }
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (png_ptr->chunkdata == NULL)
-   {
-     png_warning(png_ptr, "Out of memory processing zTXt chunk");
-     return;
-   }
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-   if (png_crc_finish(png_ptr, 0))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00;
-
-   for (text = png_ptr->chunkdata; *text; text++)
-      /* Empty loop */ ;
-
-   /* zTXt must have some text after the chunkdataword */
-   if (text >= png_ptr->chunkdata + slength - 2)
-   {
-      png_warning(png_ptr, "Truncated zTXt chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-   else
-   {
-       comp_type = *(++text);
-       if (comp_type != PNG_TEXT_COMPRESSION_zTXt)
-       {
-          png_warning(png_ptr, "Unknown compression type in zTXt chunk");
-          comp_type = PNG_TEXT_COMPRESSION_zTXt;
-       }
-       text++;        /* Skip the compression_method byte */
-   }
-   prefix_len = text - png_ptr->chunkdata;
-
-   png_decompress_chunk(png_ptr, comp_type,
-     (png_size_t)length, prefix_len, &data_len);
-
-   text_ptr = (png_textp)png_malloc_warn(png_ptr,
-      png_sizeof(png_text));
-   if (text_ptr == NULL)
-   {
-     png_warning(png_ptr, "Not enough memory to process zTXt chunk");
-     png_free(png_ptr, png_ptr->chunkdata);
-     png_ptr->chunkdata = NULL;
-     return;
-   }
-   text_ptr->compression = comp_type;
-   text_ptr->key = png_ptr->chunkdata;
-#ifdef PNG_iTXt_SUPPORTED
-   text_ptr->lang = NULL;
-   text_ptr->lang_key = NULL;
-   text_ptr->itxt_length = 0;
-#endif
-   text_ptr->text = png_ptr->chunkdata + prefix_len;
-   text_ptr->text_length = data_len;
-
-   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-   png_free(png_ptr, text_ptr);
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-   if (ret)
-     png_error(png_ptr, "Insufficient memory to store zTXt chunk");
-}
-#endif
-
-#ifdef PNG_READ_iTXt_SUPPORTED
-/* Note: this does not correctly handle chunks that are > 64K under DOS */
-void /* PRIVATE */
-png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_textp text_ptr;
-   png_charp key, lang, text, lang_key;
-   int comp_flag;
-   int comp_type = 0;
-   int ret;
-   png_size_t slength, prefix_len, data_len;
-
-   png_debug(1, "in png_handle_iTXt");
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   if (png_ptr->user_chunk_cache_max != 0)
-   {
-      if (png_ptr->user_chunk_cache_max == 1)
-      {
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (--png_ptr->user_chunk_cache_max == 1)
-      {
-         png_warning(png_ptr, "No space in chunk cache for iTXt");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-   }
-#endif
-
-   if (!(png_ptr->mode & PNG_HAVE_IHDR))
-      png_error(png_ptr, "Missing IHDR before iTXt");
-
-   if (png_ptr->mode & PNG_HAVE_IDAT)
-      png_ptr->mode |= PNG_AFTER_IDAT;
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We will no doubt have problems with chunks even half this size, but
-      there is no hard and fast rule to tell us where to stop. */
-   if (length > (png_uint_32)65535L)
-   {
-     png_warning(png_ptr, "iTXt chunk too large to fit in memory");
-     png_crc_finish(png_ptr, length);
-     return;
-   }
-#endif
-
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
-   if (png_ptr->chunkdata == NULL)
-   {
-     png_warning(png_ptr, "No memory to process iTXt chunk");
-     return;
-   }
-   slength = (png_size_t)length;
-   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
-   if (png_crc_finish(png_ptr, 0))
-   {
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   png_ptr->chunkdata[slength] = 0x00;
-
-   for (lang = png_ptr->chunkdata; *lang; lang++)
-      /* Empty loop */ ;
-   lang++;        /* Skip NUL separator */
-
-   /* iTXt must have a language tag (possibly empty), two compression bytes,
-    * translated keyword (possibly empty), and possibly some text after the
-    * keyword
-    */
-
-   if (lang >= png_ptr->chunkdata + slength - 3)
-   {
-      png_warning(png_ptr, "Truncated iTXt chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-   else
-   {
-       comp_flag = *lang++;
-       comp_type = *lang++;
-   }
-
-   for (lang_key = lang; *lang_key; lang_key++)
-      /* Empty loop */ ;
-   lang_key++;        /* Skip NUL separator */
-
-   if (lang_key >= png_ptr->chunkdata + slength)
-   {
-      png_warning(png_ptr, "Truncated iTXt chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   for (text = lang_key; *text; text++)
-      /* Empty loop */ ;
-   text++;        /* Skip NUL separator */
-   if (text >= png_ptr->chunkdata + slength)
-   {
-      png_warning(png_ptr, "Malformed iTXt chunk");
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = NULL;
-      return;
-   }
-
-   prefix_len = text - png_ptr->chunkdata;
-
-   key=png_ptr->chunkdata;
-   if (comp_flag)
-       png_decompress_chunk(png_ptr, comp_type,
-         (size_t)length, prefix_len, &data_len);
-   else
-       data_len = png_strlen(png_ptr->chunkdata + prefix_len);
-   text_ptr = (png_textp)png_malloc_warn(png_ptr,
-      png_sizeof(png_text));
-   if (text_ptr == NULL)
-   {
-     png_warning(png_ptr, "Not enough memory to process iTXt chunk");
-     png_free(png_ptr, png_ptr->chunkdata);
-     png_ptr->chunkdata = NULL;
-     return;
-   }
-   text_ptr->compression = (int)comp_flag + 1;
-   text_ptr->lang_key = png_ptr->chunkdata + (lang_key - key);
-   text_ptr->lang = png_ptr->chunkdata + (lang - key);
-   text_ptr->itxt_length = data_len;
-   text_ptr->text_length = 0;
-   text_ptr->key = png_ptr->chunkdata;
-   text_ptr->text = png_ptr->chunkdata + prefix_len;
-
-   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-   png_free(png_ptr, text_ptr);
-   png_free(png_ptr, png_ptr->chunkdata);
-   png_ptr->chunkdata = NULL;
-   if (ret)
-     png_error(png_ptr, "Insufficient memory to store iTXt chunk");
-}
-#endif
-
-/* This function is called when we haven't found a handler for a
-   chunk.  If there isn't a problem with the chunk itself (ie bad
-   chunk name, CRC, or a critical chunk), the chunk is silently ignored
-   -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
-   case it will be saved away to be written out later. */
-void /* PRIVATE */
-png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-   png_uint_32 skip = 0;
-
-   png_debug(1, "in png_handle_unknown");
-
-#ifdef PNG_USER_LIMITS_SUPPORTED
-   if (png_ptr->user_chunk_cache_max != 0)
-   {
-      if (png_ptr->user_chunk_cache_max == 1)
-      {
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-      if (--png_ptr->user_chunk_cache_max == 1)
-      {
-         png_warning(png_ptr, "No space in chunk cache for unknown chunk");
-         png_crc_finish(png_ptr, length);
-         return;
-      }
-   }
-#endif
-
-   if (png_ptr->mode & PNG_HAVE_IDAT)
-   {
-      PNG_IDAT;
-      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* Not an IDAT */
-         png_ptr->mode |= PNG_AFTER_IDAT;
-   }
-
-   if (!(png_ptr->chunk_name[0] & 0x20))
-   {
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-           PNG_HANDLE_CHUNK_ALWAYS
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-           && png_ptr->read_user_chunk_fn == NULL
-#endif
-        )
-#endif
-          png_chunk_error(png_ptr, "unknown critical chunk");
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-       || (png_ptr->read_user_chunk_fn != NULL)
-#endif
-        )
-   {
-#ifdef PNG_MAX_MALLOC_64K
-       if (length > (png_uint_32)65535L)
-       {
-           png_warning(png_ptr, "unknown chunk too large to fit in memory");
-           skip = length - (png_uint_32)65535L;
-           length = (png_uint_32)65535L;
-       }
-#endif
-       png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-                  (png_charp)png_ptr->chunk_name,
-                  png_sizeof(png_ptr->unknown_chunk.name));
-       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]
-           = '\0';
-       png_ptr->unknown_chunk.size = (png_size_t)length;
-       if (length == 0)
-         png_ptr->unknown_chunk.data = NULL;
-       else
-       {
-         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
-         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
-       }
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-       if (png_ptr->read_user_chunk_fn != NULL)
-       {
-          /* Callback to user unknown chunk handler */
-          int ret;
-          ret = (*(png_ptr->read_user_chunk_fn))
-            (png_ptr, &png_ptr->unknown_chunk);
-          if (ret < 0)
-             png_chunk_error(png_ptr, "error in user chunk");
-          if (ret == 0)
-          {
-             if (!(png_ptr->chunk_name[0] & 0x20))
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-                if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-                     PNG_HANDLE_CHUNK_ALWAYS)
-#endif
-                   png_chunk_error(png_ptr, "unknown critical chunk");
-             png_set_unknown_chunks(png_ptr, info_ptr,
-               &png_ptr->unknown_chunk, 1);
-          }
-       }
-       else
-#endif
-       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
-       png_free(png_ptr, png_ptr->unknown_chunk.data);
-       png_ptr->unknown_chunk.data = NULL;
-   }
-   else
-#endif
-      skip = length;
-
-   png_crc_finish(png_ptr, skip);
-
-#ifndef PNG_READ_USER_CHUNKS_SUPPORTED
-   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
-#endif
-}
-
-/* This function is called to verify that a chunk name is valid.
-   This function can't have the "critical chunk check" incorporated
-   into it, since in the future we will need to be able to call user
-   functions to handle unknown critical chunks after we check that
-   the chunk name itself is valid. */
-
-#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
-
-void /* PRIVATE */
-png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
-{
-   png_debug(1, "in png_check_chunk_name");
-   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
-       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
-   {
-      png_chunk_error(png_ptr, "invalid chunk type");
-   }
-}
-
-/* Combines the row recently read in with the existing pixels in the
-   row.  This routine takes care of alpha and transparency if requested.
-   This routine also handles the two methods of progressive display
-   of interlaced images, depending on the mask value.
-   The mask value describes which pixels are to be combined with
-   the row.  The pattern always repeats every 8 pixels, so just 8
-   bits are needed.  A one indicates the pixel is to be combined,
-   a zero indicates the pixel is to be skipped.  This is in addition
-   to any alpha or transparency value associated with the pixel.  If
-   you want all pixels to be combined, pass 0xff (255) in mask.  */
-
-void /* PRIVATE */
-png_combine_row(png_structp png_ptr, png_bytep row, int mask)
-{
-   png_debug(1, "in png_combine_row");
-   if (mask == 0xff)
-   {
-      png_memcpy(row, png_ptr->row_buf + 1,
-         PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));
-   }
-   else
-   {
-      switch (png_ptr->row_info.pixel_depth)
-      {
-         case 1:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_inc, s_start, s_end;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-                s_start = 0;
-                s_end = 7;
-                s_inc = 1;
-            }
-            else
-#endif
-            {
-                s_start = 7;
-                s_end = 0;
-                s_inc = -1;
-            }
-
-            shift = s_start;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  int value;
-
-                  value = (*sp >> shift) & 0x01;
-                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
-               }
-
-               if (shift == s_end)
-               {
-                  shift = s_start;
-                  sp++;
-                  dp++;
-               }
-               else
-                  shift += s_inc;
-
-               if (m == 1)
-                  m = 0x80;
-               else
-                  m >>= 1;
-            }
-            break;
-         }
-         case 2:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_start, s_end, s_inc;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            int value;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-               s_start = 0;
-               s_end = 6;
-               s_inc = 2;
-            }
-            else
-#endif
-            {
-               s_start = 6;
-               s_end = 0;
-               s_inc = -2;
-            }
-
-            shift = s_start;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  value = (*sp >> shift) & 0x03;
-                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
-               }
-
-               if (shift == s_end)
-               {
-                  shift = s_start;
-                  sp++;
-                  dp++;
-               }
-               else
-                  shift += s_inc;
-               if (m == 1)
-                  m = 0x80;
-               else
-                  m >>= 1;
-            }
-            break;
-         }
-         case 4:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_start, s_end, s_inc;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            int value;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-               s_start = 0;
-               s_end = 4;
-               s_inc = 4;
-            }
-            else
-#endif
-            {
-               s_start = 4;
-               s_end = 0;
-               s_inc = -4;
-            }
-            shift = s_start;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  value = (*sp >> shift) & 0xf;
-                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
-               }
-
-               if (shift == s_end)
-               {
-                  shift = s_start;
-                  sp++;
-                  dp++;
-               }
-               else
-                  shift += s_inc;
-               if (m == 1)
-                  m = 0x80;
-               else
-                  m >>= 1;
-            }
-            break;
-         }
-         default:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            png_byte m = 0x80;
-
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  png_memcpy(dp, sp, pixel_bytes);
-               }
-
-               sp += pixel_bytes;
-               dp += pixel_bytes;
-
-               if (m == 1)
-                  m = 0x80;
-               else
-                  m >>= 1;
-            }
-            break;
-         }
-      }
-   }
-}
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-/* OLD pre-1.0.9 interface:
-void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
-   png_uint_32 transformations)
- */
-void /* PRIVATE */
-png_do_read_interlace(png_structp png_ptr)
-{
-   png_row_infop row_info = &(png_ptr->row_info);
-   png_bytep row = png_ptr->row_buf + 1;
-   int pass = png_ptr->pass;
-   png_uint_32 transformations = png_ptr->transformations;
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-   /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   png_debug(1, "in png_do_read_interlace");
-   if (row != NULL && row_info != NULL)
-   {
-      png_uint_32 final_width;
-
-      final_width = row_info->width * png_pass_inc[pass];
-
-      switch (row_info->pixel_depth)
-      {
-         case 1:
-         {
-            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
-            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
-            int jstop = png_pass_inc[pass];
-            png_byte v;
-            png_uint_32 i;
-            int j;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (transformations & PNG_PACKSWAP)
-            {
-                sshift = (int)((row_info->width + 7) & 0x07);
-                dshift = (int)((final_width + 7) & 0x07);
-                s_start = 7;
-                s_end = 0;
-                s_inc = -1;
-            }
-            else
-#endif
-            {
-                sshift = 7 - (int)((row_info->width + 7) & 0x07);
-                dshift = 7 - (int)((final_width + 7) & 0x07);
-                s_start = 0;
-                s_end = 7;
-                s_inc = 1;
-            }
-
-            for (i = 0; i < row_info->width; i++)
-            {
-               v = (png_byte)((*sp >> sshift) & 0x01);
-               for (j = 0; j < jstop; j++)
-               {
-                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
-                  *dp |= (png_byte)(v << dshift);
-                  if (dshift == s_end)
-                  {
-                     dshift = s_start;
-                     dp--;
-                  }
-                  else
-                     dshift += s_inc;
-               }
-               if (sshift == s_end)
-               {
-                  sshift = s_start;
-                  sp--;
-               }
-               else
-                  sshift += s_inc;
-            }
-            break;
-         }
-         case 2:
-         {
-            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
-            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
-            int jstop = png_pass_inc[pass];
-            png_uint_32 i;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (transformations & PNG_PACKSWAP)
-            {
-               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
-               dshift = (int)(((final_width + 3) & 0x03) << 1);
-               s_start = 6;
-               s_end = 0;
-               s_inc = -2;
-            }
-            else
-#endif
-            {
-               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
-               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
-               s_start = 0;
-               s_end = 6;
-               s_inc = 2;
-            }
-
-            for (i = 0; i < row_info->width; i++)
-            {
-               png_byte v;
-               int j;
-
-               v = (png_byte)((*sp >> sshift) & 0x03);
-               for (j = 0; j < jstop; j++)
-               {
-                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
-                  *dp |= (png_byte)(v << dshift);
-                  if (dshift == s_end)
-                  {
-                     dshift = s_start;
-                     dp--;
-                  }
-                  else
-                     dshift += s_inc;
-               }
-               if (sshift == s_end)
-               {
-                  sshift = s_start;
-                  sp--;
-               }
-               else
-                  sshift += s_inc;
-            }
-            break;
-         }
-         case 4:
-         {
-            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
-            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
-            png_uint_32 i;
-            int jstop = png_pass_inc[pass];
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (transformations & PNG_PACKSWAP)
-            {
-               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
-               dshift = (int)(((final_width + 1) & 0x01) << 2);
-               s_start = 4;
-               s_end = 0;
-               s_inc = -4;
-            }
-            else
-#endif
-            {
-               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
-               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
-               s_start = 0;
-               s_end = 4;
-               s_inc = 4;
-            }
-
-            for (i = 0; i < row_info->width; i++)
-            {
-               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
-               int j;
-
-               for (j = 0; j < jstop; j++)
-               {
-                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
-                  *dp |= (png_byte)(v << dshift);
-                  if (dshift == s_end)
-                  {
-                     dshift = s_start;
-                     dp--;
-                  }
-                  else
-                     dshift += s_inc;
-               }
-               if (sshift == s_end)
-               {
-                  sshift = s_start;
-                  sp--;
-               }
-               else
-                  sshift += s_inc;
-            }
-            break;
-         }
-         default:
-         {
-            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
-            png_bytep sp = row + (png_size_t)(row_info->width - 1)
-                * pixel_bytes;
-            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
-
-            int jstop = png_pass_inc[pass];
-            png_uint_32 i;
-
-            for (i = 0; i < row_info->width; i++)
-            {
-               png_byte v[8];
-               int j;
-
-               png_memcpy(v, sp, pixel_bytes);
-               for (j = 0; j < jstop; j++)
-               {
-                  png_memcpy(dp, v, pixel_bytes);
-                  dp -= pixel_bytes;
-               }
-               sp -= pixel_bytes;
-            }
-            break;
-         }
-      }
-      row_info->width = final_width;
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
-   }
-#ifndef PNG_READ_PACKSWAP_SUPPORTED
-   transformations = transformations; /* Silence compiler warning */
-#endif
-}
-#endif /* PNG_READ_INTERLACING_SUPPORTED */
-
-void /* PRIVATE */
-png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
-   png_bytep prev_row, int filter)
-{
-   png_debug(1, "in png_read_filter_row");
-   png_debug2(2, "row = %lu, filter = %d", png_ptr->row_number, filter);
-   switch (filter)
-   {
-      case PNG_FILTER_VALUE_NONE:
-         break;
-      case PNG_FILTER_VALUE_SUB:
-      {
-         png_uint_32 i;
-         png_uint_32 istop = row_info->rowbytes;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_bytep rp = row + bpp;
-         png_bytep lp = row;
-
-         for (i = bpp; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_UP:
-      {
-         png_uint_32 i;
-         png_uint_32 istop = row_info->rowbytes;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
-
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_AVG:
-      {
-         png_uint_32 i;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
-         png_bytep lp = row;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_uint_32 istop = row_info->rowbytes - bpp;
-
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-               ((int)(*pp++) / 2 )) & 0xff);
-            rp++;
-         }
-
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-               (int)(*pp++ + *lp++) / 2 ) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_PAETH:
-      {
-         png_uint_32 i;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
-         png_bytep lp = row;
-         png_bytep cp = prev_row;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_uint_32 istop=row_info->rowbytes - bpp;
-
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
-
-         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
-         {
-            int a, b, c, pa, pb, pc, p;
-
-            a = *lp++;
-            b = *pp++;
-            c = *cp++;
-
-            p = b - c;
-            pc = a - c;
-
-#ifdef PNG_USE_ABS
-            pa = abs(p);
-            pb = abs(pc);
-            pc = abs(p + pc);
-#else
-            pa = p < 0 ? -p : p;
-            pb = pc < 0 ? -pc : pc;
-            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
-#endif
-
-            /*
-               if (pa <= pb && pa <= pc)
-                  p = a;
-               else if (pb <= pc)
-                  p = b;
-               else
-                  p = c;
-             */
-
-            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
-
-            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      default:
-         png_warning(png_ptr, "Ignoring bad adaptive filter type");
-         *row = 0;
-         break;
-   }
-}
-
-#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-void /* PRIVATE */
-png_read_finish_row(png_structp png_ptr)
-{
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   /* Start of interlace block in the y direction */
-   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
-
-   /* Offset to next interlace block in the y direction */
-   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-#endif /* PNG_READ_INTERLACING_SUPPORTED */
-
-   png_debug(1, "in png_read_finish_row");
-   png_ptr->row_number++;
-   if (png_ptr->row_number < png_ptr->num_rows)
-      return;
-
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   if (png_ptr->interlaced)
-   {
-      png_ptr->row_number = 0;
-      png_memset(png_ptr->prev_row, 0,
-         png_ptr->rowbytes + 1);
-      do
-      {
-         png_ptr->pass++;
-         if (png_ptr->pass >= 7)
-            break;
-         png_ptr->iwidth = (png_ptr->width +
-            png_pass_inc[png_ptr->pass] - 1 -
-            png_pass_start[png_ptr->pass]) /
-            png_pass_inc[png_ptr->pass];
-
-         if (!(png_ptr->transformations & PNG_INTERLACE))
-         {
-            png_ptr->num_rows = (png_ptr->height +
-               png_pass_yinc[png_ptr->pass] - 1 -
-               png_pass_ystart[png_ptr->pass]) /
-               png_pass_yinc[png_ptr->pass];
-            if (!(png_ptr->num_rows))
-               continue;
-         }
-         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
-            break;
-      } while (png_ptr->iwidth == 0);
-
-      if (png_ptr->pass < 7)
-         return;
-   }
-#endif /* PNG_READ_INTERLACING_SUPPORTED */
-
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
-   {
-      PNG_IDAT;
-      char extra;
-      int ret;
-
-      png_ptr->zstream.next_out = (Byte *)&extra;
-      png_ptr->zstream.avail_out = (uInt)1;
-      for (;;)
-      {
-         if (!(png_ptr->zstream.avail_in))
-         {
-            while (!png_ptr->idat_size)
-            {
-               png_byte chunk_length[4];
-
-               png_crc_finish(png_ptr, 0);
-
-               png_read_data(png_ptr, chunk_length, 4);
-               png_ptr->idat_size = png_get_uint_31(png_ptr, chunk_length);
-               png_reset_crc(png_ptr);
-               png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-                  png_error(png_ptr, "Not enough image data");
-
-            }
-            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
-            png_ptr->zstream.next_in = png_ptr->zbuf;
-            if (png_ptr->zbuf_size > png_ptr->idat_size)
-               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
-            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
-            png_ptr->idat_size -= png_ptr->zstream.avail_in;
-         }
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret == Z_STREAM_END)
-         {
-            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
-               png_ptr->idat_size)
-               png_warning(png_ptr, "Extra compressed data");
-            png_ptr->mode |= PNG_AFTER_IDAT;
-            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-            break;
-         }
-         if (ret != Z_OK)
-            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
-                      "Decompression Error");
-
-         if (!(png_ptr->zstream.avail_out))
-         {
-            png_warning(png_ptr, "Extra compressed data");
-            png_ptr->mode |= PNG_AFTER_IDAT;
-            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-            break;
-         }
-
-      }
-      png_ptr->zstream.avail_out = 0;
-   }
-
-   if (png_ptr->idat_size || png_ptr->zstream.avail_in)
-      png_warning(png_ptr, "Extra compression data");
-
-   inflateReset(&png_ptr->zstream);
-
-   png_ptr->mode |= PNG_AFTER_IDAT;
-}
-#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
-
-void /* PRIVATE */
-png_read_start_row(png_structp png_ptr)
-{
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   /* Start of interlace block in the y direction */
-   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
-
-   /* Offset to next interlace block in the y direction */
-   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-#endif
-
-   int max_pixel_depth;
-   png_size_t row_bytes;
-
-   png_debug(1, "in png_read_start_row");
-   png_ptr->zstream.avail_in = 0;
-   png_init_read_transformations(png_ptr);
-#ifdef PNG_READ_INTERLACING_SUPPORTED
-   if (png_ptr->interlaced)
-   {
-      if (!(png_ptr->transformations & PNG_INTERLACE))
-         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
-            png_pass_ystart[0]) / png_pass_yinc[0];
-      else
-         png_ptr->num_rows = png_ptr->height;
-
-      png_ptr->iwidth = (png_ptr->width +
-         png_pass_inc[png_ptr->pass] - 1 -
-         png_pass_start[png_ptr->pass]) /
-         png_pass_inc[png_ptr->pass];
-   }
-   else
-#endif /* PNG_READ_INTERLACING_SUPPORTED */
-   {
-      png_ptr->num_rows = png_ptr->height;
-      png_ptr->iwidth = png_ptr->width;
-   }
-   max_pixel_depth = png_ptr->pixel_depth;
-
-#ifdef PNG_READ_PACK_SUPPORTED
-   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
-      max_pixel_depth = 8;
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND)
-   {
-      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         if (png_ptr->num_trans)
-            max_pixel_depth = 32;
-         else
-            max_pixel_depth = 24;
-      }
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         if (max_pixel_depth < 8)
-            max_pixel_depth = 8;
-         if (png_ptr->num_trans)
-            max_pixel_depth *= 2;
-      }
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
-      {
-         if (png_ptr->num_trans)
-         {
-            max_pixel_depth *= 4;
-            max_pixel_depth /= 3;
-         }
-      }
-   }
-#endif
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-   if (png_ptr->transformations & (PNG_FILLER))
-   {
-      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-         max_pixel_depth = 32;
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         if (max_pixel_depth <= 8)
-            max_pixel_depth = 16;
-         else
-            max_pixel_depth = 32;
-      }
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
-      {
-         if (max_pixel_depth <= 32)
-            max_pixel_depth = 32;
-         else
-            max_pixel_depth = 64;
-      }
-   }
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
-   {
-      if (
-#ifdef PNG_READ_EXPAND_SUPPORTED
-        (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
-#endif
-#ifdef PNG_READ_FILLER_SUPPORTED
-        (png_ptr->transformations & (PNG_FILLER)) ||
-#endif
-        png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         if (max_pixel_depth <= 16)
-            max_pixel_depth = 32;
-         else
-            max_pixel_depth = 64;
-      }
-      else
-      {
-         if (max_pixel_depth <= 8)
-           {
-             if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-               max_pixel_depth = 32;
-             else
-               max_pixel_depth = 24;
-           }
-         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            max_pixel_depth = 64;
-         else
-            max_pixel_depth = 48;
-      }
-   }
-#endif
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
-defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-     {
-       int user_pixel_depth = png_ptr->user_transform_depth*
-         png_ptr->user_transform_channels;
-       if (user_pixel_depth > max_pixel_depth)
-         max_pixel_depth=user_pixel_depth;
-     }
-#endif
-
-   /* Align the width on the next larger 8 pixels.  Mainly used
-    * for interlacing
-    */
-   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
-   /* Calculate the maximum bytes needed, adding a byte and a pixel
-    * for safety's sake
-    */
-   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
-      1 + ((max_pixel_depth + 7) >> 3);
-#ifdef PNG_MAX_MALLOC_64K
-   if (row_bytes > (png_uint_32)65536L)
-      png_error(png_ptr, "This image requires a row greater than 64KB");
-#endif
-
-   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)
-   {
-     png_free(png_ptr, png_ptr->big_row_buf);
-     if (png_ptr->interlaced)
-        png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
-            row_bytes + 48);
-     else
-        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr,
-            row_bytes + 48);
-     png_ptr->old_big_row_buf_size = row_bytes + 48;
-
-#ifdef PNG_ALIGNED_MEMORY_SUPPORTED
-     /* Use 16-byte aligned memory for row_buf with at least 16 bytes
-      * of padding before and after row_buf.
-      */
-     png_ptr->row_buf = png_ptr->big_row_buf + 32
-         - (((png_alloc_size_t)&(png_ptr->big_row_buf[0]) + 15) % 16);
-     png_ptr->old_big_row_buf_size = row_bytes + 48;
-#else
-     /* Use 32 bytes of padding before and 16 bytes after row_buf. */
-     png_ptr->row_buf = png_ptr->big_row_buf + 32;
-#endif
-     png_ptr->old_big_row_buf_size = row_bytes + 48;
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
-      png_error(png_ptr, "This image requires a row greater than 64KB");
-#endif
-   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
-      png_error(png_ptr, "Row has too many bytes to allocate in memory");
-
-   if (png_ptr->rowbytes + 1 > png_ptr->old_prev_row_size)
-   {
-      png_free(png_ptr, png_ptr->prev_row);
-      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
-        png_ptr->rowbytes + 1));
-      png_ptr->old_prev_row_size = png_ptr->rowbytes + 1;
-   }
-
-   png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
-
-   png_debug1(3, "width = %lu,", png_ptr->width);
-   png_debug1(3, "height = %lu,", png_ptr->height);
-   png_debug1(3, "iwidth = %lu,", png_ptr->iwidth);
-   png_debug1(3, "num_rows = %lu,", png_ptr->num_rows);
-   png_debug1(3, "rowbytes = %lu,", png_ptr->rowbytes);
-   png_debug1(3, "irowbytes = %lu",
-       PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
-
-   png_ptr->flags |= PNG_FLAG_ROW_INIT;
-}
-#endif /* PNG_READ_SUPPORTED */
diff --git a/thirdparty/libpng/pngset.c b/thirdparty/libpng/pngset.c
deleted file mode 100644
index 1f972c4..0000000
--- a/thirdparty/libpng/pngset.c
+++ /dev/null
@@ -1,1167 +0,0 @@
-
-/* pngset.c - storage of image information into info struct
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * The functions here are used during reads to store data from the file
- * into the info struct, and during writes to store application data
- * into the info struct for writing into the file.  This abstracts the
- * info struct and allows us to change the structure in the future.
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#include "pngpriv.h"
-
-#ifdef PNG_bKGD_SUPPORTED
-void PNGAPI
-png_set_bKGD(png_structp png_ptr, png_infop info_ptr, png_color_16p background)
-{
-   png_debug1(1, "in %s storage function", "bKGD");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   png_memcpy(&(info_ptr->background), background, png_sizeof(png_color_16));
-   info_ptr->valid |= PNG_INFO_bKGD;
-}
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
-   double white_x, double white_y, double red_x, double red_y,
-   double green_x, double green_y, double blue_x, double blue_y)
-{
-   png_debug1(1, "in %s storage function", "cHRM");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->x_white = (float)white_x;
-   info_ptr->y_white = (float)white_y;
-   info_ptr->x_red   = (float)red_x;
-   info_ptr->y_red   = (float)red_y;
-   info_ptr->x_green = (float)green_x;
-   info_ptr->y_green = (float)green_y;
-   info_ptr->x_blue  = (float)blue_x;
-   info_ptr->y_blue  = (float)blue_y;
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   info_ptr->int_x_white = (png_fixed_point)(white_x*100000.+0.5);
-   info_ptr->int_y_white = (png_fixed_point)(white_y*100000.+0.5);
-   info_ptr->int_x_red   = (png_fixed_point)(  red_x*100000.+0.5);
-   info_ptr->int_y_red   = (png_fixed_point)(  red_y*100000.+0.5);
-   info_ptr->int_x_green = (png_fixed_point)(green_x*100000.+0.5);
-   info_ptr->int_y_green = (png_fixed_point)(green_y*100000.+0.5);
-   info_ptr->int_x_blue  = (png_fixed_point)( blue_x*100000.+0.5);
-   info_ptr->int_y_blue  = (png_fixed_point)( blue_y*100000.+0.5);
-#endif
-   info_ptr->valid |= PNG_INFO_cHRM;
-}
-#endif /* PNG_FLOATING_POINT_SUPPORTED */
-
-#ifdef PNG_FIXED_POINT_SUPPORTED
-void PNGAPI
-png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
-   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
-   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
-   png_fixed_point blue_x, png_fixed_point blue_y)
-{
-   png_debug1(1, "in %s storage function", "cHRM fixed");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-   if (png_check_cHRM_fixed(png_ptr,
-      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y))
-#endif
-   {
-      info_ptr->int_x_white = white_x;
-      info_ptr->int_y_white = white_y;
-      info_ptr->int_x_red   = red_x;
-      info_ptr->int_y_red   = red_y;
-      info_ptr->int_x_green = green_x;
-      info_ptr->int_y_green = green_y;
-      info_ptr->int_x_blue  = blue_x;
-      info_ptr->int_y_blue  = blue_y;
-#ifdef  PNG_FLOATING_POINT_SUPPORTED
-      info_ptr->x_white = (float)(white_x/100000.);
-      info_ptr->y_white = (float)(white_y/100000.);
-      info_ptr->x_red   = (float)(  red_x/100000.);
-      info_ptr->y_red   = (float)(  red_y/100000.);
-      info_ptr->x_green = (float)(green_x/100000.);
-      info_ptr->y_green = (float)(green_y/100000.);
-      info_ptr->x_blue  = (float)( blue_x/100000.);
-      info_ptr->y_blue  = (float)( blue_y/100000.);
-#endif
-      info_ptr->valid |= PNG_INFO_cHRM;
-   }
-}
-#endif /* PNG_FIXED_POINT_SUPPORTED */
-#endif /* PNG_cHRM_SUPPORTED */
-
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_gAMA(png_structp png_ptr, png_infop info_ptr, double file_gamma)
-{
-   double png_gamma;
-
-   png_debug1(1, "in %s storage function", "gAMA");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   /* Check for overflow */
-   if (file_gamma > 21474.83)
-   {
-      png_warning(png_ptr, "Limiting gamma to 21474.83");
-      png_gamma=21474.83;
-   }
-   else
-      png_gamma = file_gamma;
-   info_ptr->gamma = (float)png_gamma;
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   info_ptr->int_gamma = (int)(png_gamma*100000.+.5);
-#endif
-   info_ptr->valid |= PNG_INFO_gAMA;
-   if (png_gamma == 0.0)
-      png_warning(png_ptr, "Setting gamma=0");
-}
-#endif
-void PNGAPI
-png_set_gAMA_fixed(png_structp png_ptr, png_infop info_ptr, png_fixed_point
-   int_gamma)
-{
-   png_fixed_point png_gamma;
-
-   png_debug1(1, "in %s storage function", "gAMA");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (int_gamma > (png_fixed_point)PNG_UINT_31_MAX)
-   {
-      png_warning(png_ptr, "Limiting gamma to 21474.83");
-      png_gamma=PNG_UINT_31_MAX;
-   }
-   else
-   {
-      if (int_gamma < 0)
-      {
-         png_warning(png_ptr, "Setting negative gamma to zero");
-         png_gamma = 0;
-      }
-      else
-         png_gamma = int_gamma;
-   }
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   info_ptr->gamma = (float)(png_gamma/100000.);
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   info_ptr->int_gamma = png_gamma;
-#endif
-   info_ptr->valid |= PNG_INFO_gAMA;
-   if (png_gamma == 0)
-      png_warning(png_ptr, "Setting gamma=0");
-}
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-void PNGAPI
-png_set_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p hist)
-{
-   int i;
-
-   png_debug1(1, "in %s storage function", "hIST");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (info_ptr->num_palette == 0 || info_ptr->num_palette
-       > PNG_MAX_PALETTE_LENGTH)
-   {
-      png_warning(png_ptr,
-         "Invalid palette size, hIST allocation skipped");
-      return;
-   }
-
-   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
-   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
-    * version 1.2.1
-    */
-   png_ptr->hist = (png_uint_16p)png_malloc_warn(png_ptr,
-      PNG_MAX_PALETTE_LENGTH * png_sizeof(png_uint_16));
-   if (png_ptr->hist == NULL)
-   {
-      png_warning(png_ptr, "Insufficient memory for hIST chunk data");
-      return;
-   }
-
-   for (i = 0; i < info_ptr->num_palette; i++)
-      png_ptr->hist[i] = hist[i];
-   info_ptr->hist = png_ptr->hist;
-   info_ptr->valid |= PNG_INFO_hIST;
-
-   info_ptr->free_me |= PNG_FREE_HIST;
-}
-#endif
-
-void PNGAPI
-png_set_IHDR(png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 width, png_uint_32 height, int bit_depth,
-   int color_type, int interlace_type, int compression_type,
-   int filter_type)
-{
-   png_debug1(1, "in %s storage function", "IHDR");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->width = width;
-   info_ptr->height = height;
-   info_ptr->bit_depth = (png_byte)bit_depth;
-   info_ptr->color_type = (png_byte)color_type;
-   info_ptr->compression_type = (png_byte)compression_type;
-   info_ptr->filter_type = (png_byte)filter_type;
-   info_ptr->interlace_type = (png_byte)interlace_type;
-
-   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
-       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
-       info_ptr->compression_type, info_ptr->filter_type);
-
-   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      info_ptr->channels = 1;
-   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
-      info_ptr->channels = 3;
-   else
-      info_ptr->channels = 1;
-   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
-      info_ptr->channels++;
-   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
-
-   /* Check for potential overflow */
-   if (width > (PNG_UINT_32_MAX
-                 >> 3)      /* 8-byte RGBA pixels */
-                 - 64       /* bigrowbuf hack */
-                 - 1        /* filter byte */
-                 - 7*8      /* rounding of width to multiple of 8 pixels */
-                 - 8)       /* extra max_pixel_depth pad */
-      info_ptr->rowbytes = 0;
-   else
-      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
-}
-
-#ifdef PNG_oFFs_SUPPORTED
-void PNGAPI
-png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
-   png_int_32 offset_x, png_int_32 offset_y, int unit_type)
-{
-   png_debug1(1, "in %s storage function", "oFFs");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->x_offset = offset_x;
-   info_ptr->y_offset = offset_y;
-   info_ptr->offset_unit_type = (png_byte)unit_type;
-   info_ptr->valid |= PNG_INFO_oFFs;
-}
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-void PNGAPI
-png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
-   png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams,
-   png_charp units, png_charpp params)
-{
-   png_size_t length;
-   int i;
-
-   png_debug1(1, "in %s storage function", "pCAL");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   length = png_strlen(purpose) + 1;
-   png_debug1(3, "allocating purpose for info (%lu bytes)",
-     (unsigned long)length);
-   info_ptr->pcal_purpose = (png_charp)png_malloc_warn(png_ptr, length);
-   if (info_ptr->pcal_purpose == NULL)
-   {
-      png_warning(png_ptr, "Insufficient memory for pCAL purpose");
-      return;
-   }
-   png_memcpy(info_ptr->pcal_purpose, purpose, length);
-
-   png_debug(3, "storing X0, X1, type, and nparams in info");
-   info_ptr->pcal_X0 = X0;
-   info_ptr->pcal_X1 = X1;
-   info_ptr->pcal_type = (png_byte)type;
-   info_ptr->pcal_nparams = (png_byte)nparams;
-
-   length = png_strlen(units) + 1;
-   png_debug1(3, "allocating units for info (%lu bytes)",
-     (unsigned long)length);
-   info_ptr->pcal_units = (png_charp)png_malloc_warn(png_ptr, length);
-   if (info_ptr->pcal_units == NULL)
-   {
-      png_warning(png_ptr, "Insufficient memory for pCAL units");
-      return;
-   }
-   png_memcpy(info_ptr->pcal_units, units, length);
-
-   info_ptr->pcal_params = (png_charpp)png_malloc_warn(png_ptr,
-      (png_size_t)((nparams + 1) * png_sizeof(png_charp)));
-   if (info_ptr->pcal_params == NULL)
-   {
-      png_warning(png_ptr, "Insufficient memory for pCAL params");
-      return;
-   }
-
-   png_memset(info_ptr->pcal_params, 0, (nparams + 1) * png_sizeof(png_charp));
-
-   for (i = 0; i < nparams; i++)
-   {
-      length = png_strlen(params[i]) + 1;
-      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
-        (unsigned long)length);
-      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);
-      if (info_ptr->pcal_params[i] == NULL)
-      {
-         png_warning(png_ptr, "Insufficient memory for pCAL parameter");
-         return;
-      }
-      png_memcpy(info_ptr->pcal_params[i], params[i], length);
-   }
-
-   info_ptr->valid |= PNG_INFO_pCAL;
-   info_ptr->free_me |= PNG_FREE_PCAL;
-}
-#endif
-
-#if defined(PNG_READ_sCAL_SUPPORTED) || defined(PNG_WRITE_sCAL_SUPPORTED)
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_sCAL(png_structp png_ptr, png_infop info_ptr,
-             int unit, double width, double height)
-{
-   png_debug1(1, "in %s storage function", "sCAL");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->scal_unit = (png_byte)unit;
-   info_ptr->scal_pixel_width = width;
-   info_ptr->scal_pixel_height = height;
-
-   info_ptr->valid |= PNG_INFO_sCAL;
-}
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-void PNGAPI
-png_set_sCAL_s(png_structp png_ptr, png_infop info_ptr,
-             int unit, png_charp swidth, png_charp sheight)
-{
-   png_size_t length;
-
-   png_debug1(1, "in %s storage function", "sCAL");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->scal_unit = (png_byte)unit;
-
-   length = png_strlen(swidth) + 1;
-   png_debug1(3, "allocating unit for info (%u bytes)",
-      (unsigned int)length);
-   info_ptr->scal_s_width = (png_charp)png_malloc_warn(png_ptr, length);
-   if (info_ptr->scal_s_width == NULL)
-   {
-      png_warning(png_ptr,
-         "Memory allocation failed while processing sCAL");
-      return;
-   }
-   png_memcpy(info_ptr->scal_s_width, swidth, length);
-
-   length = png_strlen(sheight) + 1;
-   png_debug1(3, "allocating unit for info (%u bytes)",
-      (unsigned int)length);
-   info_ptr->scal_s_height = (png_charp)png_malloc_warn(png_ptr, length);
-   if (info_ptr->scal_s_height == NULL)
-   {
-      png_free (png_ptr, info_ptr->scal_s_width);
-      info_ptr->scal_s_width = NULL;
-      png_warning(png_ptr,
-         "Memory allocation failed while processing sCAL");
-      return;
-   }
-   png_memcpy(info_ptr->scal_s_height, sheight, length);
-   info_ptr->valid |= PNG_INFO_sCAL;
-   info_ptr->free_me |= PNG_FREE_SCAL;
-}
-#endif
-#endif
-#endif
-
-#ifdef PNG_pHYs_SUPPORTED
-void PNGAPI
-png_set_pHYs(png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 res_x, png_uint_32 res_y, int unit_type)
-{
-   png_debug1(1, "in %s storage function", "pHYs");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->x_pixels_per_unit = res_x;
-   info_ptr->y_pixels_per_unit = res_y;
-   info_ptr->phys_unit_type = (png_byte)unit_type;
-   info_ptr->valid |= PNG_INFO_pHYs;
-}
-#endif
-
-void PNGAPI
-png_set_PLTE(png_structp png_ptr, png_infop info_ptr,
-   png_colorp palette, int num_palette)
-{
-
-   png_debug1(1, "in %s storage function", "PLTE");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)
-   {
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-         png_error(png_ptr, "Invalid palette length");
-      else
-      {
-         png_warning(png_ptr, "Invalid palette length");
-         return;
-      }
-   }
-
-   /* It may not actually be necessary to set png_ptr->palette here;
-    * we do it for backward compatibility with the way the png_handle_tRNS
-    * function used to do the allocation.
-    */
-   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);
-
-   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
-    * of num_palette entries, in case of an invalid PNG file that has
-    * too-large sample values.
-    */
-   png_ptr->palette = (png_colorp)png_calloc(png_ptr,
-      PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));
-   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));
-   info_ptr->palette = png_ptr->palette;
-   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;
-
-   info_ptr->free_me |= PNG_FREE_PLTE;
-
-   info_ptr->valid |= PNG_INFO_PLTE;
-}
-
-#ifdef PNG_sBIT_SUPPORTED
-void PNGAPI
-png_set_sBIT(png_structp png_ptr, png_infop info_ptr,
-   png_color_8p sig_bit)
-{
-   png_debug1(1, "in %s storage function", "sBIT");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof(png_color_8));
-   info_ptr->valid |= PNG_INFO_sBIT;
-}
-#endif
-
-#ifdef PNG_sRGB_SUPPORTED
-void PNGAPI
-png_set_sRGB(png_structp png_ptr, png_infop info_ptr, int intent)
-{
-   png_debug1(1, "in %s storage function", "sRGB");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   info_ptr->srgb_intent = (png_byte)intent;
-   info_ptr->valid |= PNG_INFO_sRGB;
-}
-
-void PNGAPI
-png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
-   int intent)
-{
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float file_gamma;
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_fixed_point int_file_gamma;
-#endif
-#endif
-#ifdef PNG_cHRM_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
-#endif
-   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
-      int_green_y, int_blue_x, int_blue_y;
-#endif
-   png_debug1(1, "in %s storage function", "sRGB_gAMA_and_cHRM");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   png_set_sRGB(png_ptr, info_ptr, intent);
-
-#ifdef PNG_gAMA_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   file_gamma = (float).45455;
-   png_set_gAMA(png_ptr, info_ptr, file_gamma);
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   int_file_gamma = 45455L;
-   png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
-#endif
-#endif
-
-#ifdef PNG_cHRM_SUPPORTED
-   int_white_x = 31270L;
-   int_white_y = 32900L;
-   int_red_x   = 64000L;
-   int_red_y   = 33000L;
-   int_green_x = 30000L;
-   int_green_y = 60000L;
-   int_blue_x  = 15000L;
-   int_blue_y  =  6000L;
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   white_x = (float).3127;
-   white_y = (float).3290;
-   red_x   = (float).64;
-   red_y   = (float).33;
-   green_x = (float).30;
-   green_y = (float).60;
-   blue_x  = (float).15;
-   blue_y  = (float).06;
-#endif
-
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   png_set_cHRM_fixed(png_ptr, info_ptr,
-       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
-       int_green_y, int_blue_x, int_blue_y);
-#endif
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   png_set_cHRM(png_ptr, info_ptr,
-       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
-#endif
-#endif /* cHRM */
-}
-#endif /* sRGB */
-
-
-#ifdef PNG_iCCP_SUPPORTED
-void PNGAPI
-png_set_iCCP(png_structp png_ptr, png_infop info_ptr,
-             png_charp name, int compression_type,
-             png_charp profile, png_uint_32 proflen)
-{
-   png_charp new_iccp_name;
-   png_charp new_iccp_profile;
-   png_uint_32 length;
-
-   png_debug1(1, "in %s storage function", "iCCP");
-
-   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)
-      return;
-
-   length = png_strlen(name)+1;
-   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, length);
-   if (new_iccp_name == NULL)
-   {
-        png_warning(png_ptr, "Insufficient memory to process iCCP chunk");
-      return;
-   }
-   png_memcpy(new_iccp_name, name, length);
-   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);
-   if (new_iccp_profile == NULL)
-   {
-      png_free (png_ptr, new_iccp_name);
-      png_warning(png_ptr,
-          "Insufficient memory to process iCCP profile");
-      return;
-   }
-   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);
-
-   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);
-
-   info_ptr->iccp_proflen = proflen;
-   info_ptr->iccp_name = new_iccp_name;
-   info_ptr->iccp_profile = new_iccp_profile;
-   /* Compression is always zero but is here so the API and info structure
-    * does not have to change if we introduce multiple compression types
-    */
-   info_ptr->iccp_compression = (png_byte)compression_type;
-   info_ptr->free_me |= PNG_FREE_ICCP;
-   info_ptr->valid |= PNG_INFO_iCCP;
-}
-#endif
-
-#ifdef PNG_TEXT_SUPPORTED
-void PNGAPI
-png_set_text(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
-             int num_text)
-{
-   int ret;
-   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
-   if (ret)
-      png_error(png_ptr, "Insufficient memory to store text");
-}
-
-int /* PRIVATE */
-png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
-               int num_text)
-{
-   int i;
-
-   png_debug1(1, "in %s storage function", ((png_ptr == NULL ||
-      png_ptr->chunk_name[0] == '\0') ?
-      "text" : (png_const_charp)png_ptr->chunk_name));
-
-   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
-      return(0);
-
-   /* Make sure we have enough space in the "text" array in info_struct
-    * to hold all of the incoming text_ptr objects.
-    */
-   if (info_ptr->num_text + num_text > info_ptr->max_text)
-   {
-      if (info_ptr->text != NULL)
-      {
-         png_textp old_text;
-         int old_max;
-
-         old_max = info_ptr->max_text;
-         info_ptr->max_text = info_ptr->num_text + num_text + 8;
-         old_text = info_ptr->text;
-         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
-            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
-         if (info_ptr->text == NULL)
-         {
-            png_free(png_ptr, old_text);
-            return(1);
-         }
-         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
-            png_sizeof(png_text)));
-         png_free(png_ptr, old_text);
-      }
-      else
-      {
-         info_ptr->max_text = num_text + 8;
-         info_ptr->num_text = 0;
-         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
-            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
-         if (info_ptr->text == NULL)
-            return(1);
-         info_ptr->free_me |= PNG_FREE_TEXT;
-      }
-      png_debug1(3, "allocated %d entries for info_ptr->text",
-         info_ptr->max_text);
-   }
-   for (i = 0; i < num_text; i++)
-   {
-      png_size_t text_length, key_len;
-      png_size_t lang_len, lang_key_len;
-      png_textp textp = &(info_ptr->text[info_ptr->num_text]);
-
-      if (text_ptr[i].key == NULL)
-          continue;
-
-      key_len = png_strlen(text_ptr[i].key);
-
-      if (text_ptr[i].compression <= 0)
-      {
-         lang_len = 0;
-         lang_key_len = 0;
-      }
-
-      else
-#ifdef PNG_iTXt_SUPPORTED
-      {
-         /* Set iTXt data */
-
-         if (text_ptr[i].lang != NULL)
-            lang_len = png_strlen(text_ptr[i].lang);
-         else
-            lang_len = 0;
-         if (text_ptr[i].lang_key != NULL)
-            lang_key_len = png_strlen(text_ptr[i].lang_key);
-         else
-            lang_key_len = 0;
-      }
-#else /* PNG_iTXt_SUPPORTED */
-      {
-         png_warning(png_ptr, "iTXt chunk not supported");
-         continue;
-      }
-#endif
-
-      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
-      {
-         text_length = 0;
-#ifdef PNG_iTXt_SUPPORTED
-         if (text_ptr[i].compression > 0)
-            textp->compression = PNG_ITXT_COMPRESSION_NONE;
-         else
-#endif
-            textp->compression = PNG_TEXT_COMPRESSION_NONE;
-      }
-
-      else
-      {
-         text_length = png_strlen(text_ptr[i].text);
-         textp->compression = text_ptr[i].compression;
-      }
-
-      textp->key = (png_charp)png_malloc_warn(png_ptr,
-         (png_size_t)
-         (key_len + text_length + lang_len + lang_key_len + 4));
-      if (textp->key == NULL)
-         return(1);
-      png_debug2(2, "Allocated %lu bytes at %x in png_set_text",
-                 (unsigned long)(png_uint_32)
-                 (key_len + lang_len + lang_key_len + text_length + 4),
-                 (int)textp->key);
-
-      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
-      *(textp->key + key_len) = '\0';
-#ifdef PNG_iTXt_SUPPORTED
-      if (text_ptr[i].compression > 0)
-      {
-         textp->lang = textp->key + key_len + 1;
-         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
-         *(textp->lang + lang_len) = '\0';
-         textp->lang_key = textp->lang + lang_len + 1;
-         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
-         *(textp->lang_key + lang_key_len) = '\0';
-         textp->text = textp->lang_key + lang_key_len + 1;
-      }
-      else
-#endif
-      {
-#ifdef PNG_iTXt_SUPPORTED
-         textp->lang=NULL;
-         textp->lang_key=NULL;
-#endif
-         textp->text = textp->key + key_len + 1;
-      }
-      if (text_length)
-         png_memcpy(textp->text, text_ptr[i].text,
-            (png_size_t)(text_length));
-      *(textp->text + text_length) = '\0';
-
-#ifdef PNG_iTXt_SUPPORTED
-      if (textp->compression > 0)
-      {
-         textp->text_length = 0;
-         textp->itxt_length = text_length;
-      }
-      else
-#endif
-
-      {
-         textp->text_length = text_length;
-#ifdef PNG_iTXt_SUPPORTED
-         textp->itxt_length = 0;
-#endif
-      }
-      info_ptr->num_text++;
-      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
-   }
-   return(0);
-}
-#endif
-
-#ifdef PNG_tIME_SUPPORTED
-void PNGAPI
-png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
-{
-   png_debug1(1, "in %s storage function", "tIME");
-
-   if (png_ptr == NULL || info_ptr == NULL ||
-       (png_ptr->mode & PNG_WROTE_tIME))
-      return;
-
-   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
-   info_ptr->valid |= PNG_INFO_tIME;
-}
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-void PNGAPI
-png_set_tRNS(png_structp png_ptr, png_infop info_ptr,
-   png_bytep trans_alpha, int num_trans, png_color_16p trans_color)
-{
-   png_debug1(1, "in %s storage function", "tRNS");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (trans_alpha != NULL)
-   {
-       /* It may not actually be necessary to set png_ptr->trans_alpha here;
-        * we do it for backward compatibility with the way the png_handle_tRNS
-        * function used to do the allocation.
-        */
-
-       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
-
-       /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
-       png_ptr->trans_alpha = info_ptr->trans_alpha = (png_bytep)png_malloc(png_ptr,
-           (png_size_t)PNG_MAX_PALETTE_LENGTH);
-       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
-          png_memcpy(info_ptr->trans_alpha, trans_alpha, (png_size_t)num_trans);
-   }
-
-   if (trans_color != NULL)
-   {
-      int sample_max = (1 << info_ptr->bit_depth);
-      if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
-          (int)trans_color->gray > sample_max) ||
-          (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
-          ((int)trans_color->red > sample_max ||
-          (int)trans_color->green > sample_max ||
-          (int)trans_color->blue > sample_max)))
-         png_warning(png_ptr,
-            "tRNS chunk has out-of-range samples for bit_depth");
-      png_memcpy(&(info_ptr->trans_color), trans_color,
-         png_sizeof(png_color_16));
-      if (num_trans == 0)
-         num_trans = 1;
-   }
-
-   info_ptr->num_trans = (png_uint_16)num_trans;
-   if (num_trans != 0)
-   {
-      info_ptr->valid |= PNG_INFO_tRNS;
-      info_ptr->free_me |= PNG_FREE_TRNS;
-   }
-}
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-void PNGAPI
-png_set_sPLT(png_structp png_ptr,
-             png_infop info_ptr, png_sPLT_tp entries, int nentries)
-/*
- *  entries        - array of png_sPLT_t structures
- *                   to be added to the list of palettes
- *                   in the info structure.
- *  nentries       - number of palette structures to be
- *                   added.
- */
-{
-   png_sPLT_tp np;
-   int i;
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   np = (png_sPLT_tp)png_malloc_warn(png_ptr,
-       (info_ptr->splt_palettes_num + nentries) *
-        (png_size_t)png_sizeof(png_sPLT_t));
-   if (np == NULL)
-   {
-      png_warning(png_ptr, "No memory for sPLT palettes");
-      return;
-   }
-
-   png_memcpy(np, info_ptr->splt_palettes,
-       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
-   png_free(png_ptr, info_ptr->splt_palettes);
-   info_ptr->splt_palettes=NULL;
-
-   for (i = 0; i < nentries; i++)
-   {
-      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
-      png_sPLT_tp from = entries + i;
-      png_uint_32 length;
-
-      length = png_strlen(from->name) + 1;
-      to->name = (png_charp)png_malloc_warn(png_ptr, (png_size_t)length);
-      if (to->name == NULL)
-      {
-         png_warning(png_ptr,
-           "Out of memory while processing sPLT chunk");
-         continue;
-      }
-      png_memcpy(to->name, from->name, length);
-      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
-          (png_size_t)(from->nentries * png_sizeof(png_sPLT_entry)));
-      if (to->entries == NULL)
-      {
-         png_warning(png_ptr,
-           "Out of memory while processing sPLT chunk");
-         png_free(png_ptr, to->name);
-         to->name = NULL;
-         continue;
-      }
-      png_memcpy(to->entries, from->entries,
-          from->nentries * png_sizeof(png_sPLT_entry));
-      to->nentries = from->nentries;
-      to->depth = from->depth;
-   }
-
-   info_ptr->splt_palettes = np;
-   info_ptr->splt_palettes_num += nentries;
-   info_ptr->valid |= PNG_INFO_sPLT;
-   info_ptr->free_me |= PNG_FREE_SPLT;
-}
-#endif /* PNG_sPLT_SUPPORTED */
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-void PNGAPI
-png_set_unknown_chunks(png_structp png_ptr,
-   png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns)
-{
-   png_unknown_chunkp np;
-   int i;
-
-   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
-      return;
-
-   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
-       (png_size_t)((info_ptr->unknown_chunks_num + num_unknowns) *
-       png_sizeof(png_unknown_chunk)));
-   if (np == NULL)
-   {
-      png_warning(png_ptr,
-          "Out of memory while processing unknown chunk");
-      return;
-   }
-
-   png_memcpy(np, info_ptr->unknown_chunks,
-       info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
-   png_free(png_ptr, info_ptr->unknown_chunks);
-   info_ptr->unknown_chunks = NULL;
-
-   for (i = 0; i < num_unknowns; i++)
-   {
-      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
-      png_unknown_chunkp from = unknowns + i;
-
-      png_memcpy((png_charp)to->name, (png_charp)from->name,
-          png_sizeof(from->name));
-      to->name[png_sizeof(to->name)-1] = '\0';
-      to->size = from->size;
-      /* Note our location in the read or write sequence */
-      to->location = (png_byte)(png_ptr->mode & 0xff);
-
-      if (from->size == 0)
-         to->data=NULL;
-      else
-      {
-         to->data = (png_bytep)png_malloc_warn(png_ptr,
-           (png_size_t)from->size);
-         if (to->data == NULL)
-         {
-            png_warning(png_ptr,
-             "Out of memory while processing unknown chunk");
-            to->size = 0;
-         }
-         else
-            png_memcpy(to->data, from->data, from->size);
-      }
-   }
-
-   info_ptr->unknown_chunks = np;
-   info_ptr->unknown_chunks_num += num_unknowns;
-   info_ptr->free_me |= PNG_FREE_UNKN;
-}
-void PNGAPI
-png_set_unknown_chunk_location(png_structp png_ptr, png_infop info_ptr,
-   int chunk, int location)
-{
-   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
-       (int)info_ptr->unknown_chunks_num)
-      info_ptr->unknown_chunks[chunk].location = (png_byte)location;
-}
-#endif
-
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-png_uint_32 PNGAPI
-png_permit_mng_features (png_structp png_ptr, png_uint_32 mng_features)
-{
-   png_debug(1, "in png_permit_mng_features");
-
-   if (png_ptr == NULL)
-      return (png_uint_32)0;
-   png_ptr->mng_features_permitted =
-     (png_byte)(mng_features & PNG_ALL_MNG_FEATURES);
-   return (png_uint_32)png_ptr->mng_features_permitted;
-}
-#endif
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-void PNGAPI
-png_set_keep_unknown_chunks(png_structp png_ptr, int keep, png_bytep
-   chunk_list, int num_chunks)
-{
-   png_bytep new_list, p;
-   int i, old_num_chunks;
-   if (png_ptr == NULL)
-      return;
-   if (num_chunks == 0)
-   {
-      if (keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
-         png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
-      else
-         png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
-
-      if (keep == PNG_HANDLE_CHUNK_ALWAYS)
-         png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
-      else
-         png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
-      return;
-   }
-   if (chunk_list == NULL)
-      return;
-   old_num_chunks = png_ptr->num_chunk_list;
-   new_list=(png_bytep)png_malloc(png_ptr,
-      (png_size_t)
-       (5*(num_chunks + old_num_chunks)));
-   if (png_ptr->chunk_list != NULL)
-   {
-      png_memcpy(new_list, png_ptr->chunk_list,
-          (png_size_t)(5*old_num_chunks));
-      png_free(png_ptr, png_ptr->chunk_list);
-      png_ptr->chunk_list=NULL;
-   }
-   png_memcpy(new_list + 5*old_num_chunks, chunk_list,
-       (png_size_t)(5*num_chunks));
-   for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
-      *p=(png_byte)keep;
-   png_ptr->num_chunk_list = old_num_chunks + num_chunks;
-   png_ptr->chunk_list = new_list;
-   png_ptr->free_me |= PNG_FREE_LIST;
-}
-#endif
-
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-void PNGAPI
-png_set_read_user_chunk_fn(png_structp png_ptr, png_voidp user_chunk_ptr,
-   png_user_chunk_ptr read_user_chunk_fn)
-{
-   png_debug(1, "in png_set_read_user_chunk_fn");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->read_user_chunk_fn = read_user_chunk_fn;
-   png_ptr->user_chunk_ptr = user_chunk_ptr;
-}
-#endif
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-void PNGAPI
-png_set_rows(png_structp png_ptr, png_infop info_ptr, png_bytepp row_pointers)
-{
-   png_debug1(1, "in %s storage function", "rows");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
-      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
-   info_ptr->row_pointers = row_pointers;
-   if (row_pointers)
-      info_ptr->valid |= PNG_INFO_IDAT;
-}
-#endif
-
-void PNGAPI
-png_set_compression_buffer_size(png_structp png_ptr,
-    png_size_t size)
-{
-    if (png_ptr == NULL)
-       return;
-    png_free(png_ptr, png_ptr->zbuf);
-    png_ptr->zbuf_size = size;
-    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr, size);
-    png_ptr->zstream.next_out = png_ptr->zbuf;
-    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-}
-
-void PNGAPI
-png_set_invalid(png_structp png_ptr, png_infop info_ptr, int mask)
-{
-   if (png_ptr && info_ptr)
-      info_ptr->valid &= ~mask;
-}
-
-
-
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-/* This function was added to libpng 1.2.6 */
-void PNGAPI
-png_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max,
-    png_uint_32 user_height_max)
-{
-   /* Images with dimensions larger than these limits will be
-    * rejected by png_set_IHDR().  To accept any PNG datastream
-    * regardless of dimensions, set both limits to 0x7ffffffL.
-    */
-   if (png_ptr == NULL)
-      return;
-   png_ptr->user_width_max = user_width_max;
-   png_ptr->user_height_max = user_height_max;
-}
-
-/* This function was added to libpng 1.4.0 */
-void PNGAPI
-png_set_chunk_cache_max (png_structp png_ptr,
-   png_uint_32 user_chunk_cache_max)
-{
-    if (png_ptr)
-       png_ptr->user_chunk_cache_max = user_chunk_cache_max;
-}
-
-/* This function was added to libpng 1.4.1 */
-void PNGAPI
-png_set_chunk_malloc_max (png_structp png_ptr,
-   png_alloc_size_t user_chunk_malloc_max)
-{
-    if (png_ptr)
-       png_ptr->user_chunk_malloc_max =
-          (png_size_t)user_chunk_malloc_max;
-}
-#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */
-
-
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-void PNGAPI
-png_set_benign_errors(png_structp png_ptr, int allowed)
-{
-   png_debug(1, "in png_set_benign_errors");
-
-   if (allowed)
-      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
-   else
-      png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
-}
-#endif /* PNG_BENIGN_ERRORS_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngtest.c b/thirdparty/libpng/pngtest.c
deleted file mode 100644
index 6317751..0000000
--- a/thirdparty/libpng/pngtest.c
+++ /dev/null
@@ -1,1632 +0,0 @@
-
-/* pngtest.c - a simple test program to test libpng
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This program reads in a PNG image, writes it out again, and then
- * compares the two files.  If the files are identical, this shows that
- * the basic chunk handling, filtering, and (de)compression code is working
- * properly.  It does not currently test all of the transforms, although
- * it probably should.
- *
- * The program will report "FAIL" in certain legitimate cases:
- * 1) when the compression level or filter selection method is changed.
- * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
- * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
- *    exist in the input file.
- * 4) others not listed here...
- * In these cases, it is best to check with another tool such as "pngcheck"
- * to see what the differences between the two files are.
- *
- * If a filename is given on the command-line, then this file is used
- * for the input, rather than the default "pngtest.png".  This allows
- * testing a wide variety of files easily.  You can also test a number
- * of files at once by typing "pngtest -m file1.png file2.png ..."
- */
-
-#include "png.h"
-#include "pngpriv.h"
-
-#  include <stdio.h>
-#  include <stdlib.h>
-#  define FCLOSE(file) fclose(file)
-
-#ifndef PNG_STDIO_SUPPORTED
-     typedef FILE                * png_FILE_p;
-#endif
-
-/* Makes pngtest verbose so we can find problems (needs to be before png.h) */
-#ifndef PNG_DEBUG
-#  define PNG_DEBUG 0
-#endif
-
-#if !PNG_DEBUG
-#  define SINGLE_ROWBUF_ALLOC  /* Makes buffer overruns easier to nail */
-#endif
-
-/* Turn on CPU timing
-#define PNGTEST_TIMING
-*/
-
-#ifndef PNG_FLOATING_POINT_SUPPORTED
-#undef PNGTEST_TIMING
-#endif
-
-#ifdef PNGTEST_TIMING
-static float t_start, t_stop, t_decode, t_encode, t_misc;
-#include <time.h>
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-#define PNG_tIME_STRING_LENGTH 29
-static int tIME_chunk_present = 0;
-static char tIME_string[PNG_tIME_STRING_LENGTH] = "tIME chunk is not present";
-#endif
-
-static int verbose = 0;
-
-int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
-
-#ifdef __TURBOC__
-#include <mem.h>
-#endif
-
-/* Defined so I can write to a file on gui/windowing platforms */
-/*  #define STDERR stderr  */
-#define STDERR stdout   /* For DOS */
-
-/* In case a system header (e.g., on AIX) defined jmpbuf */
-#ifdef jmpbuf
-#  undef jmpbuf
-#endif
-
-/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
-#ifndef png_jmpbuf
-#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
-#endif
-
-/* Example of using row callbacks to make a simple progress meter */
-static int status_pass = 1;
-static int status_dots_requested = 0;
-static int status_dots = 1;
-
-void
-read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
-void
-read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
-{
-   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX)
-      return;
-   if (status_pass != pass)
-   {
-      fprintf(stdout, "\n Pass %d: ", pass);
-      status_pass = pass;
-      status_dots = 31;
-   }
-   status_dots--;
-   if (status_dots == 0)
-   {
-      fprintf(stdout, "\n         ");
-      status_dots=30;
-   }
-   fprintf(stdout, "r");
-}
-
-void
-write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
-void
-write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
-{
-   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7)
-      return;
-   fprintf(stdout, "w");
-}
-
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-/* Example of using user transform callback (we don't transform anything,
- * but merely examine the row filters.  We set this to 256 rather than
- * 5 in case illegal filter values are present.)
- */
-static png_uint_32 filters_used[256];
-void
-count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data);
-void
-count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-{
-   if (png_ptr != NULL && row_info != NULL)
-      ++filters_used[*(data - 1)];
-}
-#endif
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-/* Example of using user transform callback (we don't transform anything,
- * but merely count the zero samples)
- */
-
-static png_uint_32 zero_samples;
-
-void
-count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data);
-void
-count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-{
-   png_bytep dp = data;
-   if (png_ptr == NULL)return;
-
-   /* Contents of row_info:
-    *  png_uint_32 width      width of row
-    *  png_uint_32 rowbytes   number of bytes in row
-    *  png_byte color_type    color type of pixels
-    *  png_byte bit_depth     bit depth of samples
-    *  png_byte channels      number of channels (1-4)
-    *  png_byte pixel_depth   bits per pixel (depth*channels)
-    */
-
-    /* Counts the number of zero samples (or zero pixels if color_type is 3 */
-
-    if (row_info->color_type == 0 || row_info->color_type == 3)
-    {
-       int pos = 0;
-       png_uint_32 n, nstop;
-       for (n = 0, nstop=row_info->width; n<nstop; n++)
-       {
-          if (row_info->bit_depth == 1)
-          {
-             if (((*dp << pos++ ) & 0x80) == 0)
-                zero_samples++;
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-          if (row_info->bit_depth == 2)
-          {
-             if (((*dp << (pos+=2)) & 0xc0) == 0)
-                zero_samples++;
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-          if (row_info->bit_depth == 4)
-          {
-             if (((*dp << (pos+=4)) & 0xf0) == 0)
-                zero_samples++;
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-          if (row_info->bit_depth == 8)
-             if (*dp++ == 0)
-                zero_samples++;
-          if (row_info->bit_depth == 16)
-          {
-             if ((*dp | *(dp+1)) == 0)
-                zero_samples++;
-             dp+=2;
-          }
-       }
-    }
-    else /* Other color types */
-    {
-       png_uint_32 n, nstop;
-       int channel;
-       int color_channels = row_info->channels;
-       if (row_info->color_type > 3)color_channels--;
-
-       for (n = 0, nstop=row_info->width; n<nstop; n++)
-       {
-          for (channel = 0; channel < color_channels; channel++)
-          {
-             if (row_info->bit_depth == 8)
-                if (*dp++ == 0)
-                   zero_samples++;
-             if (row_info->bit_depth == 16)
-             {
-                if ((*dp | *(dp+1)) == 0)
-                   zero_samples++;
-                dp+=2;
-             }
-          }
-          if (row_info->color_type > 3)
-          {
-             dp++;
-             if (row_info->bit_depth == 16)
-                dp++;
-          }
-       }
-    }
-}
-#endif /* PNG_WRITE_USER_TRANSFORM_SUPPORTED */
-
-static int wrote_question = 0;
-
-#ifndef PNG_STDIO_SUPPORTED
-/* START of code to validate stdio-free compilation */
-/* These copies of the default read/write functions come from pngrio.c and
- * pngwio.c.  They allow "don't include stdio" testing of the library.
- * This is the function that does the actual reading of data.  If you are
- * not reading from a standard C stream, you should create a replacement
- * read_data function and use it at run time with png_set_read_fn(), rather
- * than changing the library.
- */
-
-#ifndef USE_FAR_KEYWORD
-static void
-pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check = 0;
-   png_voidp io_ptr;
-
-   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
-    * instead of an int, which is what fread() actually returns.
-    */
-   io_ptr = png_get_io_ptr(png_ptr);
-   if (io_ptr != NULL)
-   {
-      check = fread(data, 1, length, (png_FILE_p)io_ptr);
-   }
-
-   if (check != length)
-   {
-      png_error(png_ptr, "Read Error!");
-   }
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void
-pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *n_data;
-   png_FILE_p io_ptr;
-
-   /* Check if data really is near. If so, use usual code. */
-   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));
-   if ((png_bytep)n_data == data)
-   {
-      check = fread(n_data, 1, length, io_ptr);
-   }
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t read, remaining, err;
-      check = 0;
-      remaining = length;
-      do
-      {
-         read = MIN(NEAR_BUF_SIZE, remaining);
-         err = fread(buf, 1, 1, io_ptr);
-         png_memcpy(data, buf, read); /* Copy far buffer to near buffer */
-         if (err != read)
-            break;
-         else
-            check += err;
-         data += read;
-         remaining -= read;
-      }
-      while (remaining != 0);
-   }
-   if (check != length)
-      png_error(png_ptr, "read Error");
-}
-#endif /* USE_FAR_KEYWORD */
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-static void
-pngtest_flush(png_structp png_ptr)
-{
-   /* Do nothing; fflush() is said to be just a waste of energy. */
-   png_ptr = png_ptr;  /* Stifle compiler warning */
-}
-#endif
-
-/* This is the function that does the actual writing of data.  If you are
- * not writing to a standard C stream, you should create a replacement
- * write_data function and use it at run time with png_set_write_fn(), rather
- * than changing the library.
- */
-#ifndef USE_FAR_KEYWORD
-static void
-pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_FILE_p io_ptr;
-   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));
-
-   check = fwrite(data, 1, length, io_ptr);
-   if (check != length)
-   {
-      png_error(png_ptr, "Write Error");
-   }
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void
-pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
-   png_FILE_p io_ptr;
-
-   /* Check if data really is near. If so, use usual code. */
-   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
-   if ((png_bytep)near_data == data)
-   {
-      check = fwrite(near_data, 1, length, io_ptr);
-   }
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t written, remaining, err;
-      check = 0;
-      remaining = length;
-      do
-      {
-         written = MIN(NEAR_BUF_SIZE, remaining);
-         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
-         err = fwrite(buf, 1, written, io_ptr);
-         if (err != written)
-            break;
-         else
-            check += err;
-         data += written;
-         remaining -= written;
-      }
-      while (remaining != 0);
-   }
-   if (check != length)
-   {
-      png_error(png_ptr, "Write Error");
-   }
-}
-#endif /* USE_FAR_KEYWORD */
-
-/* This function is called when there is a warning, but the library thinks
- * it can continue anyway.  Replacement functions don't have to do anything
- * here if you don't want to.  In the default configuration, png_ptr is
- * not used, but it is passed in case it may be useful.
- */
-static void
-pngtest_warning(png_structp png_ptr, png_const_charp message)
-{
-   PNG_CONST char *name = "UNKNOWN (ERROR!)";
-   char *test;
-   test = png_get_error_ptr(png_ptr);
-   if (test == NULL)
-     fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
-   else
-     fprintf(STDERR, "%s: libpng warning: %s\n", test, message);
-}
-
-/* This is the default error handling function.  Note that replacements for
- * this function MUST NOT RETURN, or the program will likely crash.  This
- * function is used by default, or if the program supplies NULL for the
- * error function pointer in png_set_error_fn().
- */
-static void
-pngtest_error(png_structp png_ptr, png_const_charp message)
-{
-   pngtest_warning(png_ptr, message);
-   /* We can return because png_error calls the default handler, which is
-    * actually OK in this case.
-    */
-}
-#endif /* !PNG_STDIO_SUPPORTED */
-/* END of code to validate stdio-free compilation */
-
-/* START of code to validate memory allocation and deallocation */
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information.  zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- *
- * This piece of code can be compiled to validate max 64K allocations
- * by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K.
- */
-typedef struct memory_information
-{
-   png_alloc_size_t          size;
-   png_voidp                 pointer;
-   struct memory_information FAR *next;
-} memory_information;
-typedef memory_information FAR *memory_infop;
-
-static memory_infop pinformation = NULL;
-static int current_allocation = 0;
-static int maximum_allocation = 0;
-static int total_allocation = 0;
-static int num_allocations = 0;
-
-png_voidp png_debug_malloc
-   PNGARG((png_structp png_ptr, png_alloc_size_t size));
-void png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));
-
-png_voidp
-png_debug_malloc(png_structp png_ptr, png_alloc_size_t size)
-{
-
-   /* png_malloc has already tested for NULL; png_create_struct calls
-    * png_debug_malloc directly, with png_ptr == NULL which is OK
-    */
-
-   if (size == 0)
-      return (NULL);
-
-   /* This calls the library allocator twice, once to get the requested
-      buffer and once to get a new free list entry. */
-   {
-      /* Disable malloc_fn and free_fn */
-      memory_infop pinfo;
-      png_set_mem_fn(png_ptr, NULL, NULL, NULL);
-      pinfo = (memory_infop)png_malloc(png_ptr,
-         png_sizeof(*pinfo));
-      pinfo->size = size;
-      current_allocation += size;
-      total_allocation += size;
-      num_allocations ++;
-      if (current_allocation > maximum_allocation)
-         maximum_allocation = current_allocation;
-      pinfo->pointer = png_malloc(png_ptr, size);
-      /* Restore malloc_fn and free_fn */
-      png_set_mem_fn(png_ptr,
-          NULL, png_debug_malloc, png_debug_free);
-      if (size != 0 && pinfo->pointer == NULL)
-      {
-         current_allocation -= size;
-         total_allocation -= size;
-         png_error(png_ptr,
-           "out of memory in pngtest->png_debug_malloc");
-      }
-      pinfo->next = pinformation;
-      pinformation = pinfo;
-      /* Make sure the caller isn't assuming zeroed memory. */
-      png_memset(pinfo->pointer, 0xdd, pinfo->size);
-      if (verbose)
-         printf("png_malloc %lu bytes at %x\n", (unsigned long)size,
-            pinfo->pointer);
-      return (png_voidp)(pinfo->pointer);
-   }
-}
-
-/* Free a pointer.  It is removed from the list at the same time. */
-void
-png_debug_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL)
-      fprintf(STDERR, "NULL pointer to png_debug_free.\n");
-   if (ptr == 0)
-   {
-#if 0 /* This happens all the time. */
-      fprintf(STDERR, "WARNING: freeing NULL pointer\n");
-#endif
-      return;
-   }
-
-   /* Unlink the element from the list. */
-   {
-      memory_infop FAR *ppinfo = &pinformation;
-      for (;;)
-      {
-         memory_infop pinfo = *ppinfo;
-         if (pinfo->pointer == ptr)
-         {
-            *ppinfo = pinfo->next;
-            current_allocation -= pinfo->size;
-            if (current_allocation < 0)
-               fprintf(STDERR, "Duplicate free of memory\n");
-            /* We must free the list element too, but first kill
-               the memory that is to be freed. */
-            png_memset(ptr, 0x55, pinfo->size);
-            png_free_default(png_ptr, pinfo);
-            pinfo = NULL;
-            break;
-         }
-         if (pinfo->next == NULL)
-         {
-            fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr);
-            break;
-         }
-         ppinfo = &pinfo->next;
-      }
-   }
-
-   /* Finally free the data. */
-   if (verbose)
-      printf("Freeing %x\n", ptr);
-   png_free_default(png_ptr, ptr);
-   ptr = NULL;
-}
-#endif /* PNG_USER_MEM_SUPPORTED && PNG_DEBUG */
-/* END of code to test memory allocation/deallocation */
-
-
-/* Demonstration of user chunk support of the sTER and vpAg chunks */
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-
-/* (sTER is a public chunk not yet known by libpng.  vpAg is a private
-chunk used in ImageMagick to store "virtual page" size).  */
-
-static png_uint_32 user_chunk_data[4];
-
-    /* 0: sTER mode + 1
-     * 1: vpAg width
-     * 2: vpAg height
-     * 3: vpAg units
-     */
-
-static int read_user_chunk_callback(png_struct *png_ptr,
-   png_unknown_chunkp chunk)
-{
-   png_uint_32
-     *my_user_chunk_data;
-
-   /* Return one of the following:
-    *    return (-n);  chunk had an error
-    *    return (0);  did not recognize
-    *    return (n);  success
-    *
-    * The unknown chunk structure contains the chunk data:
-    * png_byte name[5];
-    * png_byte *data;
-    * png_size_t size;
-    *
-    * Note that libpng has already taken care of the CRC handling.
-    */
-
-   if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&     /* s  T */
-       chunk->name[2] ==  69 && chunk->name[3] ==  82)       /* E  R */
-      {
-         /* Found sTER chunk */
-         if (chunk->size != 1)
-            return (-1); /* Error return */
-         if (chunk->data[0] != 0 && chunk->data[0] != 1)
-            return (-1);  /* Invalid mode */
-         my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);
-         my_user_chunk_data[0]=chunk->data[0]+1;
-         return (1);
-      }
-
-   if (chunk->name[0] != 118 || chunk->name[1] != 112 ||    /* v  p */
-       chunk->name[2] !=  65 || chunk->name[3] != 103)      /* A  g */
-      return (0); /* Did not recognize */
-
-   /* Found ImageMagick vpAg chunk */
-
-   if (chunk->size != 9)
-      return (-1); /* Error return */
-
-   my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);
-
-   my_user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data);
-   my_user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4);
-   my_user_chunk_data[3]=(png_uint_32)chunk->data[8];
-
-   return (1);
-
-}
-#endif
-/* END of code to demonstrate user chunk support */
-
-/* Test one file */
-int
-test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
-{
-   static png_FILE_p fpin;
-   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
-   png_structp read_ptr;
-   png_infop read_info_ptr, end_info_ptr;
-#ifdef PNG_WRITE_SUPPORTED
-   png_structp write_ptr;
-   png_infop write_info_ptr;
-   png_infop write_end_info_ptr;
-#else
-   png_structp write_ptr = NULL;
-   png_infop write_info_ptr = NULL;
-   png_infop write_end_info_ptr = NULL;
-#endif
-   png_bytep row_buf;
-   png_uint_32 y;
-   png_uint_32 width, height;
-   int num_pass, pass;
-   int bit_depth, color_type;
-#ifdef PNG_SETJMP_SUPPORTED
-#ifdef USE_FAR_KEYWORD
-   jmp_buf jmpbuf;
-#endif
-#endif
-
-   char inbuf[256], outbuf[256];
-
-   row_buf = NULL;
-
-   if ((fpin = fopen(inname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find input file %s\n", inname);
-      return (1);
-   }
-
-   if ((fpout = fopen(outname, "wb")) == NULL)
-   {
-      fprintf(STDERR, "Could not open output file %s\n", outname);
-      FCLOSE(fpin);
-      return (1);
-   }
-
-   png_debug(0, "Allocating read and write structures");
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-   read_ptr =
-      png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL,
-      NULL, NULL, NULL,
-      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);
-#else
-   read_ptr =
-      png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-#endif
-#ifndef PNG_STDIO_SUPPORTED
-   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,
-       pngtest_warning);
-#endif
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   user_chunk_data[0] = 0;
-   user_chunk_data[1] = 0;
-   user_chunk_data[2] = 0;
-   user_chunk_data[3] = 0;
-   png_set_read_user_chunk_fn(read_ptr, user_chunk_data,
-     read_user_chunk_callback);
-
-#endif
-#ifdef PNG_WRITE_SUPPORTED
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-   write_ptr =
-      png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL,
-      NULL, NULL, NULL, png_debug_malloc, png_debug_free);
-#else
-   write_ptr =
-      png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-#endif
-#ifndef PNG_STDIO_SUPPORTED
-   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,
-       pngtest_warning);
-#endif
-#endif
-   png_debug(0, "Allocating read_info, write_info and end_info structures");
-   read_info_ptr = png_create_info_struct(read_ptr);
-   end_info_ptr = png_create_info_struct(read_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-   write_info_ptr = png_create_info_struct(write_ptr);
-   write_end_info_ptr = png_create_info_struct(write_ptr);
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   png_debug(0, "Setting jmpbuf for read struct");
-#ifdef USE_FAR_KEYWORD
-   if (setjmp(jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(read_ptr)))
-#endif
-   {
-      fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
-      png_free(read_ptr, row_buf);
-      row_buf = NULL;
-      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-      png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-      FCLOSE(fpin);
-      FCLOSE(fpout);
-      return (1);
-   }
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(read_ptr), jmpbuf, png_sizeof(jmp_buf));
-#endif
-
-#ifdef PNG_WRITE_SUPPORTED
-   png_debug(0, "Setting jmpbuf for write struct");
-#ifdef USE_FAR_KEYWORD
-   if (setjmp(jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(write_ptr)))
-#endif
-   {
-      fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
-      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-      png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-      FCLOSE(fpin);
-      FCLOSE(fpout);
-      return (1);
-   }
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(write_ptr), jmpbuf, png_sizeof(jmp_buf));
-#endif
-#endif
-#endif
-
-   png_debug(0, "Initializing input and output streams");
-#ifdef PNG_STDIO_SUPPORTED
-   png_init_io(read_ptr, fpin);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_init_io(write_ptr, fpout);
-#  endif
-#else
-   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
-#    ifdef PNG_WRITE_FLUSH_SUPPORTED
-      pngtest_flush);
-#    else
-      NULL);
-#    endif
-#  endif
-#endif
-   if (status_dots_requested == 1)
-   {
-#ifdef PNG_WRITE_SUPPORTED
-      png_set_write_status_fn(write_ptr, write_row_callback);
-#endif
-      png_set_read_status_fn(read_ptr, read_row_callback);
-   }
-   else
-   {
-#ifdef PNG_WRITE_SUPPORTED
-      png_set_write_status_fn(write_ptr, NULL);
-#endif
-      png_set_read_status_fn(read_ptr, NULL);
-   }
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   {
-      int i;
-      for (i = 0; i<256; i++)
-         filters_used[i] = 0;
-      png_set_read_user_transform_fn(read_ptr, count_filters);
-   }
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-   zero_samples = 0;
-   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
-#endif
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_HANDLE_CHUNK_ALWAYS
-#    define PNG_HANDLE_CHUNK_ALWAYS       3
-#  endif
-   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,
-      NULL, 0);
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_HANDLE_CHUNK_IF_SAFE
-#    define PNG_HANDLE_CHUNK_IF_SAFE      2
-#  endif
-   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE,
-      NULL, 0);
-#endif
-
-   png_debug(0, "Reading info struct");
-   png_read_info(read_ptr, read_info_ptr);
-
-   png_debug(0, "Transferring info struct");
-   {
-      int interlace_type, compression_type, filter_type;
-
-      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,
-          &color_type, &interlace_type, &compression_type, &filter_type))
-      {
-         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-            color_type, interlace_type, compression_type, filter_type);
-#else
-            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);
-#endif
-      }
-   }
-#ifdef PNG_FIXED_POINT_SUPPORTED
-#ifdef PNG_cHRM_SUPPORTED
-   {
-      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
-         blue_y;
-      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,
-         &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y))
-      {
-         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
-            red_y, green_x, green_y, blue_x, blue_y);
-      }
-   }
-#endif
-#ifdef PNG_gAMA_SUPPORTED
-   {
-      png_fixed_point gamma;
-
-      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))
-         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
-   }
-#endif
-#else /* Use floating point versions */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-#ifdef PNG_cHRM_SUPPORTED
-   {
-      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
-         blue_y;
-      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
-         &red_y, &green_x, &green_y, &blue_x, &blue_y))
-      {
-         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
-            red_y, green_x, green_y, blue_x, blue_y);
-      }
-   }
-#endif
-#ifdef PNG_gAMA_SUPPORTED
-   {
-      double gamma;
-
-      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))
-         png_set_gAMA(write_ptr, write_info_ptr, gamma);
-   }
-#endif
-#endif /* Floating point */
-#endif /* Fixed point */
-#ifdef PNG_iCCP_SUPPORTED
-   {
-      png_charp name;
-      png_charp profile;
-      png_uint_32 proflen;
-      int compression_type;
-
-      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
-                      &profile, &proflen))
-      {
-         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
-                      profile, proflen);
-      }
-   }
-#endif
-#ifdef PNG_sRGB_SUPPORTED
-   {
-      int intent;
-
-      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))
-         png_set_sRGB(write_ptr, write_info_ptr, intent);
-   }
-#endif
-   {
-      png_colorp palette;
-      int num_palette;
-
-      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
-         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
-   }
-#ifdef PNG_bKGD_SUPPORTED
-   {
-      png_color_16p background;
-
-      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
-      {
-         png_set_bKGD(write_ptr, write_info_ptr, background);
-      }
-   }
-#endif
-#ifdef PNG_hIST_SUPPORTED
-   {
-      png_uint_16p hist;
-
-      if (png_get_hIST(read_ptr, read_info_ptr, &hist))
-         png_set_hIST(write_ptr, write_info_ptr, hist);
-   }
-#endif
-#ifdef PNG_oFFs_SUPPORTED
-   {
-      png_int_32 offset_x, offset_y;
-      int unit_type;
-
-      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,
-          &unit_type))
-      {
-         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
-      }
-   }
-#endif
-#ifdef PNG_pCAL_SUPPORTED
-   {
-      png_charp purpose, units;
-      png_charpp params;
-      png_int_32 X0, X1;
-      int type, nparams;
-
-      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,
-         &nparams, &units, &params))
-      {
-         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,
-            nparams, units, params);
-      }
-   }
-#endif
-#ifdef PNG_pHYs_SUPPORTED
-   {
-      png_uint_32 res_x, res_y;
-      int unit_type;
-
-      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))
-         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
-   }
-#endif
-#ifdef PNG_sBIT_SUPPORTED
-   {
-      png_color_8p sig_bit;
-
-      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
-         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
-   }
-#endif
-#ifdef PNG_sCAL_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   {
-      int unit;
-      double scal_width, scal_height;
-
-      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
-         &scal_height))
-      {
-         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
-      }
-   }
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   {
-      int unit;
-      png_charp scal_width, scal_height;
-
-      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
-          &scal_height))
-      {
-         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width,
-             scal_height);
-      }
-   }
-#endif
-#endif
-#endif
-#ifdef PNG_TEXT_SUPPORTED
-   {
-      png_textp text_ptr;
-      int num_text;
-
-      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
-      {
-         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks", num_text);
-         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
-      }
-   }
-#endif
-#ifdef PNG_tIME_SUPPORTED
-   {
-      png_timep mod_time;
-
-      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
-      {
-         png_set_tIME(write_ptr, write_info_ptr, mod_time);
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         /* We have to use png_memcpy instead of "=" because the string
-          * pointed to by png_convert_to_rfc1123() gets free'ed before
-          * we use it.
-          */
-         png_memcpy(tIME_string,
-                    png_convert_to_rfc1123(read_ptr, mod_time),
-                    png_sizeof(tIME_string));
-         tIME_string[png_sizeof(tIME_string) - 1] = '\0';
-         tIME_chunk_present++;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-      }
-   }
-#endif
-#ifdef PNG_tRNS_SUPPORTED
-   {
-      png_bytep trans_alpha;
-      int num_trans;
-      png_color_16p trans_color;
-
-      if (png_get_tRNS(read_ptr, read_info_ptr, &trans_alpha, &num_trans,
-         &trans_color))
-      {
-         int sample_max = (1 << bit_depth);
-         /* libpng doesn't reject a tRNS chunk with out-of-range samples */
-         if (!((color_type == PNG_COLOR_TYPE_GRAY &&
-             (int)trans_color->gray > sample_max) ||
-             (color_type == PNG_COLOR_TYPE_RGB &&
-             ((int)trans_color->red > sample_max ||
-             (int)trans_color->green > sample_max ||
-             (int)trans_color->blue > sample_max))))
-            png_set_tRNS(write_ptr, write_info_ptr, trans_alpha, num_trans,
-               trans_color);
-      }
-   }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   {
-      png_unknown_chunkp unknowns;
-      int num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr,
-         &unknowns);
-      if (num_unknowns)
-      {
-         png_size_t i;
-         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
-           num_unknowns);
-         /* Copy the locations from the read_info_ptr.  The automatically
-          * generated locations in write_info_ptr are wrong because we
-          * haven't written anything yet.
-          */
-         for (i = 0; i < (png_size_t)num_unknowns; i++)
-           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
-             unknowns[i].location);
-      }
-   }
-#endif
-
-#ifdef PNG_WRITE_SUPPORTED
-   png_debug(0, "Writing info struct");
-
-/* If we wanted, we could write info in two steps:
- * png_write_info_before_PLTE(write_ptr, write_info_ptr);
- */
-   png_write_info(write_ptr, write_info_ptr);
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   if (user_chunk_data[0] != 0)
-   {
-      png_byte png_sTER[5] = {115,  84,  69,  82, '\0'};
-
-      unsigned char
-        ster_chunk_data[1];
-
-      if (verbose)
-         fprintf(STDERR, "\n stereo mode = %lu\n",
-           (unsigned long)(user_chunk_data[0] - 1));
-      ster_chunk_data[0]=(unsigned char)(user_chunk_data[0] - 1);
-      png_write_chunk(write_ptr, png_sTER, ster_chunk_data, 1);
-   }
-   if (user_chunk_data[1] != 0 || user_chunk_data[2] != 0)
-   {
-      png_byte png_vpAg[5] = {118, 112,  65, 103, '\0'};
-
-      unsigned char
-        vpag_chunk_data[9];
-
-      if (verbose)
-         fprintf(STDERR, " vpAg = %lu x %lu, units = %lu\n",
-           (unsigned long)user_chunk_data[1],
-           (unsigned long)user_chunk_data[2],
-           (unsigned long)user_chunk_data[3]);
-      png_save_uint_32(vpag_chunk_data, user_chunk_data[1]);
-      png_save_uint_32(vpag_chunk_data + 4, user_chunk_data[2]);
-      vpag_chunk_data[8] = (unsigned char)(user_chunk_data[3] & 0xff);
-      png_write_chunk(write_ptr, png_vpAg, vpag_chunk_data, 9);
-   }
-
-#endif
-#endif
-
-#ifdef SINGLE_ROWBUF_ALLOC
-   png_debug(0, "Allocating row buffer...");
-   row_buf = (png_bytep)png_malloc(read_ptr,
-      png_get_rowbytes(read_ptr, read_info_ptr));
-   png_debug1(0, "0x%08lx", (unsigned long)row_buf);
-#endif /* SINGLE_ROWBUF_ALLOC */
-   png_debug(0, "Writing row data");
-
-#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
-  defined(PNG_WRITE_INTERLACING_SUPPORTED)
-   num_pass = png_set_interlace_handling(read_ptr);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_set_interlace_handling(write_ptr);
-#  endif
-#else
-   num_pass = 1;
-#endif
-
-#ifdef PNGTEST_TIMING
-   t_stop = (float)clock();
-   t_misc += (t_stop - t_start);
-   t_start = t_stop;
-#endif
-   for (pass = 0; pass < num_pass; pass++)
-   {
-      png_debug1(0, "Writing row data for pass %d", pass);
-      for (y = 0; y < height; y++)
-      {
-#ifndef SINGLE_ROWBUF_ALLOC
-         png_debug2(0, "Allocating row buffer (pass %d, y = %ld)...", pass, y);
-         row_buf = (png_bytep)png_malloc(read_ptr,
-            png_get_rowbytes(read_ptr, read_info_ptr));
-         png_debug2(0, "0x%08lx (%ld bytes)", (unsigned long)row_buf,
-            png_get_rowbytes(read_ptr, read_info_ptr));
-#endif /* !SINGLE_ROWBUF_ALLOC */
-         png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);
-
-#ifdef PNG_WRITE_SUPPORTED
-#ifdef PNGTEST_TIMING
-         t_stop = (float)clock();
-         t_decode += (t_stop - t_start);
-         t_start = t_stop;
-#endif
-         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
-#ifdef PNGTEST_TIMING
-         t_stop = (float)clock();
-         t_encode += (t_stop - t_start);
-         t_start = t_stop;
-#endif
-#endif /* PNG_WRITE_SUPPORTED */
-
-#ifndef SINGLE_ROWBUF_ALLOC
-         png_debug2(0, "Freeing row buffer (pass %d, y = %ld)", pass, y);
-         png_free(read_ptr, row_buf);
-         row_buf = NULL;
-#endif /* !SINGLE_ROWBUF_ALLOC */
-      }
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
-#endif
-
-   png_debug(0, "Reading and writing end_info data");
-
-   png_read_end(read_ptr, end_info_ptr);
-#ifdef PNG_TEXT_SUPPORTED
-   {
-      png_textp text_ptr;
-      int num_text;
-
-      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
-      {
-         png_debug1(0, "Handling %d iTXt/tEXt/zTXt chunks", num_text);
-         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
-      }
-   }
-#endif
-#ifdef PNG_tIME_SUPPORTED
-   {
-      png_timep mod_time;
-
-      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
-      {
-         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         /* We have to use png_memcpy instead of "=" because the string
-            pointed to by png_convert_to_rfc1123() gets free'ed before
-            we use it */
-         png_memcpy(tIME_string,
-                    png_convert_to_rfc1123(read_ptr, mod_time),
-                    png_sizeof(tIME_string));
-         tIME_string[png_sizeof(tIME_string) - 1] = '\0';
-         tIME_chunk_present++;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-      }
-   }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   {
-      png_unknown_chunkp unknowns;
-      int num_unknowns;
-      num_unknowns = (int)png_get_unknown_chunks(read_ptr, end_info_ptr,
-         &unknowns);
-      if (num_unknowns)
-      {
-         png_size_t i;
-         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
-           num_unknowns);
-         /* Copy the locations from the read_info_ptr.  The automatically
-          * generated locations in write_end_info_ptr are wrong because we
-          * haven't written the end_info yet.
-          */
-         for (i = 0; i < (png_size_t)num_unknowns; i++)
-           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
-             unknowns[i].location);
-      }
-   }
-#endif
-#ifdef PNG_WRITE_SUPPORTED
-   png_write_end(write_ptr, write_end_info_ptr);
-#endif
-
-#ifdef PNG_EASY_ACCESS_SUPPORTED
-   if (verbose)
-   {
-      png_uint_32 iwidth, iheight;
-      iwidth = png_get_image_width(write_ptr, write_info_ptr);
-      iheight = png_get_image_height(write_ptr, write_info_ptr);
-      fprintf(STDERR, "\n Image width = %lu, height = %lu\n",
-         (unsigned long)iwidth, (unsigned long)iheight);
-   }
-#endif
-
-   png_debug(0, "Destroying data structs");
-#ifdef SINGLE_ROWBUF_ALLOC
-   png_debug(1, "destroying row_buf for read_ptr");
-   png_free(read_ptr, row_buf);
-   row_buf = NULL;
-#endif /* SINGLE_ROWBUF_ALLOC */
-   png_debug(1, "destroying read_ptr, read_info_ptr, end_info_ptr");
-   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-   png_debug(1, "destroying write_end_info_ptr");
-   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-   png_debug(1, "destroying write_ptr, write_info_ptr");
-   png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-   png_debug(0, "Destruction complete.");
-
-   FCLOSE(fpin);
-   FCLOSE(fpout);
-
-   png_debug(0, "Opening files for comparison");
-   if ((fpin = fopen(inname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find file %s\n", inname);
-      return (1);
-   }
-
-   if ((fpout = fopen(outname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find file %s\n", outname);
-      FCLOSE(fpin);
-      return (1);
-   }
-
-   for (;;)
-   {
-      png_size_t num_in, num_out;
-
-         num_in = fread(inbuf, 1, 1, fpin);
-         num_out = fread(outbuf, 1, 1, fpout);
-
-      if (num_in != num_out)
-      {
-         fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
-                 inname, outname);
-         if (wrote_question == 0)
-         {
-            fprintf(STDERR,
-         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
-              inname, PNG_ZBUF_SIZE);
-            fprintf(STDERR,
-              "\n   filtering heuristic (libpng default), compression");
-            fprintf(STDERR,
-              " level (zlib default),\n   and zlib version (%s)?\n\n",
-              ZLIB_VERSION);
-            wrote_question = 1;
-         }
-         FCLOSE(fpin);
-         FCLOSE(fpout);
-         return (0);
-      }
-
-      if (!num_in)
-         break;
-
-      if (png_memcmp(inbuf, outbuf, num_in))
-      {
-         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
-         if (wrote_question == 0)
-         {
-            fprintf(STDERR,
-         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
-                 inname, PNG_ZBUF_SIZE);
-            fprintf(STDERR,
-              "\n   filtering heuristic (libpng default), compression");
-            fprintf(STDERR,
-              " level (zlib default),\n   and zlib version (%s)?\n\n",
-              ZLIB_VERSION);
-            wrote_question = 1;
-         }
-         FCLOSE(fpin);
-         FCLOSE(fpout);
-         return (0);
-      }
-   }
-
-   FCLOSE(fpin);
-   FCLOSE(fpout);
-
-   return (0);
-}
-
-/* Input and output filenames */
-#ifdef RISCOS
-static PNG_CONST char *inname = "pngtest/png";
-static PNG_CONST char *outname = "pngout/png";
-#else
-static PNG_CONST char *inname = "pngtest.png";
-static PNG_CONST char *outname = "pngout.png";
-#endif
-
-int
-main(int argc, char *argv[])
-{
-   int multiple = 0;
-   int ierror = 0;
-
-   fprintf(STDERR, "\n Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
-   fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
-   fprintf(STDERR, "%s", png_get_copyright(NULL));
-   /* Show the version of libpng used in building the library */
-   fprintf(STDERR, " library (%lu):%s",
-      (unsigned long)png_access_version_number(),
-      png_get_header_version(NULL));
-   /* Show the version of libpng used in building the application */
-   fprintf(STDERR, " pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
-      PNG_HEADER_VERSION_STRING);
-   fprintf(STDERR, " sizeof(png_struct)=%ld, sizeof(png_info)=%ld\n",
-                    (long)png_sizeof(png_struct), (long)png_sizeof(png_info));
-
-   /* Do some consistency checking on the memory allocation settings, I'm
-    * not sure this matters, but it is nice to know, the first of these
-    * tests should be impossible because of the way the macros are set
-    * in pngconf.h
-    */
-#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
-      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
-#endif
-   /* I think the following can happen. */
-#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
-      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
-#endif
-
-   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
-   {
-      fprintf(STDERR,
-         "Warning: versions are different between png.h and png.c\n");
-      fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
-      fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
-      ++ierror;
-   }
-
-   if (argc > 1)
-   {
-      if (strcmp(argv[1], "-m") == 0)
-      {
-         multiple = 1;
-         status_dots_requested = 0;
-      }
-      else if (strcmp(argv[1], "-mv") == 0 ||
-               strcmp(argv[1], "-vm") == 0 )
-      {
-         multiple = 1;
-         verbose = 1;
-         status_dots_requested = 1;
-      }
-      else if (strcmp(argv[1], "-v") == 0)
-      {
-         verbose = 1;
-         status_dots_requested = 1;
-         inname = argv[2];
-      }
-      else
-      {
-         inname = argv[1];
-         status_dots_requested = 0;
-      }
-   }
-
-   if (!multiple && argc == 3 + verbose)
-     outname = argv[2 + verbose];
-
-   if ((!multiple && argc > 3 + verbose) || (multiple && argc < 2))
-   {
-     fprintf(STDERR,
-       "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
-        argv[0], argv[0]);
-     fprintf(STDERR,
-       "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
-     fprintf(STDERR,
-       "  with -m %s is used as a temporary file\n", outname);
-     exit(1);
-   }
-
-   if (multiple)
-   {
-      int i;
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-      int allocation_now = current_allocation;
-#endif
-      for (i=2; i<argc; ++i)
-      {
-         int kerror;
-         fprintf(STDERR, "\n Testing %s:", argv[i]);
-         kerror = test_one_file(argv[i], outname);
-         if (kerror == 0)
-         {
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-            int k;
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-            fprintf(STDERR, "\n PASS (%lu zero samples)\n",
-               (unsigned long)zero_samples);
-#else
-            fprintf(STDERR, " PASS\n");
-#endif
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-            for (k = 0; k<256; k++)
-               if (filters_used[k])
-                  fprintf(STDERR, " Filter %d was used %lu times\n",
-                     k, (unsigned long)filters_used[k]);
-#endif
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         if (tIME_chunk_present != 0)
-            fprintf(STDERR, " tIME = %s\n", tIME_string);
-         tIME_chunk_present = 0;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-         }
-         else
-         {
-            fprintf(STDERR, " FAIL\n");
-            ierror += kerror;
-         }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         if (allocation_now != current_allocation)
-            fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
-               current_allocation - allocation_now);
-         if (current_allocation != 0)
-         {
-            memory_infop pinfo = pinformation;
-
-            fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
-               current_allocation);
-            while (pinfo != NULL)
-            {
-               fprintf(STDERR, " %lu bytes at %x\n",
-                 (unsigned long)pinfo->size,
-                 (unsigned int) pinfo->pointer);
-               pinfo = pinfo->next;
-            }
-         }
-#endif
-      }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
-            current_allocation);
-         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
-            maximum_allocation);
-         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
-            total_allocation);
-         fprintf(STDERR, "     Number of allocations: %10d\n",
-            num_allocations);
-#endif
-   }
-   else
-   {
-      int i;
-      for (i = 0; i<3; ++i)
-      {
-         int kerror;
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         int allocation_now = current_allocation;
-#endif
-         if (i == 1) status_dots_requested = 1;
-         else if (verbose == 0)status_dots_requested = 0;
-         if (i == 0 || verbose == 1 || ierror != 0)
-            fprintf(STDERR, "\n Testing %s:", inname);
-         kerror = test_one_file(inname, outname);
-         if (kerror == 0)
-         {
-            if (verbose == 1 || i == 2)
-            {
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-                int k;
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-                fprintf(STDERR, "\n PASS (%lu zero samples)\n",
-                   (unsigned long)zero_samples);
-#else
-                fprintf(STDERR, " PASS\n");
-#endif
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-                for (k = 0; k<256; k++)
-                   if (filters_used[k])
-                      fprintf(STDERR, " Filter %d was used %lu times\n",
-                         k, (unsigned long)filters_used[k]);
-#endif
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-             if (tIME_chunk_present != 0)
-                fprintf(STDERR, " tIME = %s\n", tIME_string);
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-            }
-         }
-         else
-         {
-            if (verbose == 0 && i != 2)
-               fprintf(STDERR, "\n Testing %s:", inname);
-            fprintf(STDERR, " FAIL\n");
-            ierror += kerror;
-         }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         if (allocation_now != current_allocation)
-             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
-               current_allocation - allocation_now);
-         if (current_allocation != 0)
-         {
-             memory_infop pinfo = pinformation;
-
-             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
-                current_allocation);
-             while (pinfo != NULL)
-             {
-                fprintf(STDERR, " %lu bytes at %x\n",
-                   (unsigned long)pinfo->size, (unsigned int)pinfo->pointer);
-                pinfo = pinfo->next;
-             }
-          }
-#endif
-       }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
-          current_allocation);
-       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
-          maximum_allocation);
-       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
-          total_allocation);
-       fprintf(STDERR, "     Number of allocations: %10d\n",
-            num_allocations);
-#endif
-   }
-
-#ifdef PNGTEST_TIMING
-   t_stop = (float)clock();
-   t_misc += (t_stop - t_start);
-   t_start = t_stop;
-   fprintf(STDERR, " CPU time used = %.3f seconds",
-      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, " (decoding %.3f,\n",
-      t_decode/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, "        encoding %.3f ,",
-      t_encode/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, " other %.3f seconds)\n\n",
-      t_misc/(float)CLOCKS_PER_SEC);
-#endif
-
-   if (ierror == 0)
-      fprintf(STDERR, " libpng passes test\n");
-   else
-      fprintf(STDERR, " libpng FAILS test\n");
-   return (int)(ierror != 0);
-}
-
-/* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_4_4 your_png_h_is_not_version_1_4_4;
diff --git a/thirdparty/libpng/pngtrans.c b/thirdparty/libpng/pngtrans.c
deleted file mode 100644
index 741daf4..0000000
--- a/thirdparty/libpng/pngtrans.c
+++ /dev/null
@@ -1,677 +0,0 @@
-
-/* pngtrans.c - transforms the data in a row (used by both readers and writers)
- *
- * Last changed in libpng 1.4.2 [April 29, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#include "pngpriv.h"
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* Turn on BGR-to-RGB mapping */
-void PNGAPI
-png_set_bgr(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_bgr");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_BGR;
-}
-#endif
-
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* Turn on 16 bit byte swapping */
-void PNGAPI
-png_set_swap(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_swap");
-
-   if (png_ptr == NULL)
-      return;
-   if (png_ptr->bit_depth == 16)
-      png_ptr->transformations |= PNG_SWAP_BYTES;
-}
-#endif
-
-#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
-/* Turn on pixel packing */
-void PNGAPI
-png_set_packing(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_packing");
-
-   if (png_ptr == NULL)
-      return;
-   if (png_ptr->bit_depth < 8)
-   {
-      png_ptr->transformations |= PNG_PACK;
-      png_ptr->usr_bit_depth = 8;
-   }
-}
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-/* Turn on packed pixel swapping */
-void PNGAPI
-png_set_packswap(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_packswap");
-
-   if (png_ptr == NULL)
-      return;
-   if (png_ptr->bit_depth < 8)
-      png_ptr->transformations |= PNG_PACKSWAP;
-}
-#endif
-
-#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-void PNGAPI
-png_set_shift(png_structp png_ptr, png_color_8p true_bits)
-{
-   png_debug(1, "in png_set_shift");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_SHIFT;
-   png_ptr->shift = *true_bits;
-}
-#endif
-
-#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
-    defined(PNG_WRITE_INTERLACING_SUPPORTED)
-int PNGAPI
-png_set_interlace_handling(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_interlace handling");
-
-   if (png_ptr && png_ptr->interlaced)
-   {
-      png_ptr->transformations |= PNG_INTERLACE;
-      return (7);
-   }
-
-   return (1);
-}
-#endif
-
-#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
-/* Add a filler byte on read, or remove a filler or alpha byte on write.
- * The filler type has changed in v0.95 to allow future 2-byte fillers
- * for 48-bit input data, as well as to avoid problems with some compilers
- * that don't like bytes as parameters.
- */
-void PNGAPI
-png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
-{
-   png_debug(1, "in png_set_filler");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_FILLER;
-   png_ptr->filler = (png_uint_16)filler;
-   if (filler_loc == PNG_FILLER_AFTER)
-      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
-   else
-      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
-
-   /* This should probably go in the "do_read_filler" routine.
-    * I attempted to do that in libpng-1.0.1a but that caused problems
-    * so I restored it in libpng-1.0.2a
-   */
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
-   {
-      png_ptr->usr_channels = 4;
-   }
-
-   /* Also I added this in libpng-1.0.2a (what happens when we expand
-    * a less-than-8-bit grayscale to GA? */
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)
-   {
-      png_ptr->usr_channels = 2;
-   }
-}
-
-/* Added to libpng-1.2.7 */
-void PNGAPI
-png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
-{
-   png_debug(1, "in png_set_add_alpha");
-
-   if (png_ptr == NULL)
-      return;
-   png_set_filler(png_ptr, filler, filler_loc);
-   png_ptr->transformations |= PNG_ADD_ALPHA;
-}
-
-#endif
-
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
-void PNGAPI
-png_set_swap_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_swap_alpha");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_SWAP_ALPHA;
-}
-#endif
-
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
-void PNGAPI
-png_set_invert_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_invert_alpha");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_INVERT_ALPHA;
-}
-#endif
-
-#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
-void PNGAPI
-png_set_invert_mono(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_invert_mono");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_INVERT_MONO;
-}
-
-/* Invert monochrome grayscale data */
-void /* PRIVATE */
-png_do_invert(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_invert");
-
-  /* This test removed from libpng version 1.0.13 and 1.2.0:
-   *   if (row_info->bit_depth == 1 &&
-   */
-   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      png_bytep rp = row;
-      png_uint_32 i;
-      png_uint_32 istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i++)
-      {
-         *rp = (png_byte)(~(*rp));
-         rp++;
-      }
-   }
-   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-      row_info->bit_depth == 8)
-   {
-      png_bytep rp = row;
-      png_uint_32 i;
-      png_uint_32 istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i+=2)
-      {
-         *rp = (png_byte)(~(*rp));
-         rp+=2;
-      }
-   }
-   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-      row_info->bit_depth == 16)
-   {
-      png_bytep rp = row;
-      png_uint_32 i;
-      png_uint_32 istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i+=4)
-      {
-         *rp = (png_byte)(~(*rp));
-         *(rp+1) = (png_byte)(~(*(rp+1)));
-         rp+=4;
-      }
-   }
-}
-#endif
-
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* Swaps byte order on 16 bit depth images */
-void /* PRIVATE */
-png_do_swap(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_swap");
-
-   if (
-       row_info->bit_depth == 16)
-   {
-      png_bytep rp = row;
-      png_uint_32 i;
-      png_uint_32 istop= row_info->width * row_info->channels;
-
-      for (i = 0; i < istop; i++, rp += 2)
-      {
-         png_byte t = *rp;
-         *rp = *(rp + 1);
-         *(rp + 1) = t;
-      }
-   }
-}
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-static PNG_CONST png_byte onebppswaptable[256] = {
-   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
-   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
-   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
-   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
-   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
-   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
-   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
-   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
-   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
-   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
-   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
-   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
-   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
-   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
-   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
-   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
-   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
-   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
-   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
-   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
-   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
-   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
-   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
-   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
-   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
-   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
-   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
-   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
-   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
-   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
-   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
-   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
-};
-
-static PNG_CONST png_byte twobppswaptable[256] = {
-   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
-   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
-   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
-   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
-   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
-   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
-   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
-   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
-   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
-   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
-   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
-   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
-   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
-   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
-   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
-   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
-   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
-   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
-   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
-   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
-   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
-   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
-   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
-   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
-   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
-   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
-   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
-   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
-   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
-   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
-   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
-   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
-};
-
-static PNG_CONST png_byte fourbppswaptable[256] = {
-   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
-   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
-   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
-   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
-   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
-   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
-   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
-   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
-   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
-   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
-   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
-   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
-   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
-   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
-   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
-   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
-   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
-   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
-   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
-   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
-   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
-   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
-   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
-   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
-   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
-   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
-   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
-   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
-   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
-   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
-   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
-};
-
-/* Swaps pixel packing order within bytes */
-void /* PRIVATE */
-png_do_packswap(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_packswap");
-
-   if (
-       row_info->bit_depth < 8)
-   {
-      png_bytep rp, end, table;
-
-      end = row + row_info->rowbytes;
-
-      if (row_info->bit_depth == 1)
-         table = (png_bytep)onebppswaptable;
-      else if (row_info->bit_depth == 2)
-         table = (png_bytep)twobppswaptable;
-      else if (row_info->bit_depth == 4)
-         table = (png_bytep)fourbppswaptable;
-      else
-         return;
-
-      for (rp = row; rp < end; rp++)
-         *rp = table[*rp];
-   }
-}
-#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */
-
-#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
-    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-/* Remove filler or alpha byte(s) */
-void /* PRIVATE */
-png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)
-{
-   png_debug(1, "in png_do_strip_filler");
-
-   {
-      png_bytep sp=row;
-      png_bytep dp=row;
-      png_uint_32 row_width=row_info->width;
-      png_uint_32 i;
-
-      if ((row_info->color_type == PNG_COLOR_TYPE_RGB ||
-          (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-          (flags & PNG_FLAG_STRIP_ALPHA))) &&
-          row_info->channels == 4)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This converts from RGBX or RGBA to RGB */
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               dp+=3; sp+=4;
-               for (i = 1; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp++;
-               }
-            }
-            /* This converts from XRGB or ARGB to RGB */
-            else
-            {
-               for (i = 0; i < row_width; i++)
-               {
-                  sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
-            row_info->pixel_depth = 24;
-            row_info->rowbytes = row_width * 3;
-         }
-         else /* if (row_info->bit_depth == 16) */
-         {
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */
-               sp += 8; dp += 6;
-               for (i = 1; i < row_width; i++)
-               {
-                  /* This could be (although png_memcpy is probably slower):
-                  png_memcpy(dp, sp, 6);
-                  sp += 8;
-                  dp += 6;
-                  */
-
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp += 2;
-               }
-            }
-            else
-            {
-               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */
-               for (i = 0; i < row_width; i++)
-               {
-                  /* This could be (although png_memcpy is probably slower):
-                  png_memcpy(dp, sp, 6);
-                  sp += 8;
-                  dp += 6;
-                  */
-
-                  sp+=2;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
-            row_info->pixel_depth = 48;
-            row_info->rowbytes = row_width * 6;
-         }
-         row_info->channels = 3;
-      }
-      else if ((row_info->color_type == PNG_COLOR_TYPE_GRAY ||
-         (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-         (flags & PNG_FLAG_STRIP_ALPHA))) &&
-          row_info->channels == 2)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This converts from GX or GA to G */
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               for (i = 0; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  sp++;
-               }
-            }
-            /* This converts from XG or AG to G */
-            else
-            {
-               for (i = 0; i < row_width; i++)
-               {
-                  sp++;
-                  *dp++ = *sp++;
-               }
-            }
-            row_info->pixel_depth = 8;
-            row_info->rowbytes = row_width;
-         }
-         else /* if (row_info->bit_depth == 16) */
-         {
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               /* This converts from GGXX or GGAA to GG */
-               sp += 4; dp += 2;
-               for (i = 1; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp += 2;
-               }
-            }
-            else
-            {
-               /* This converts from XXGG or AAGG to GG */
-               for (i = 0; i < row_width; i++)
-               {
-                  sp += 2;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
-         }
-         row_info->channels = 1;
-      }
-      if (flags & PNG_FLAG_STRIP_ALPHA)
-        row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
-   }
-}
-#endif
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* Swaps red and blue bytes within a pixel */
-void /* PRIVATE */
-png_do_bgr(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_bgr");
-
-   if (
-       (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->bit_depth == 8)
-      {
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 3)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 2);
-               *(rp + 2) = save;
-            }
-         }
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 4)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 2);
-               *(rp + 2) = save;
-            }
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 6)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 4);
-               *(rp + 4) = save;
-               save = *(rp + 1);
-               *(rp + 1) = *(rp + 5);
-               *(rp + 5) = save;
-            }
-         }
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 8)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 4);
-               *(rp + 4) = save;
-               save = *(rp + 1);
-               *(rp + 1) = *(rp + 5);
-               *(rp + 5) = save;
-            }
-         }
-      }
-   }
-}
-#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-void PNGAPI
-png_set_user_transform_info(png_structp png_ptr, png_voidp
-   user_transform_ptr, int user_transform_depth, int user_transform_channels)
-{
-   png_debug(1, "in png_set_user_transform_info");
-
-   if (png_ptr == NULL)
-      return;
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-   png_ptr->user_transform_ptr = user_transform_ptr;
-   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
-   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
-#else
-   if (user_transform_ptr || user_transform_depth || user_transform_channels)
-      png_warning(png_ptr,
-        "This version of libpng does not support user transform info");
-#endif
-}
-
-/* This function returns a pointer to the user_transform_ptr associated with
- * the user transform functions.  The application should free any memory
- * associated with this pointer before png_write_destroy and png_read_destroy
- * are called.
- */
-png_voidp PNGAPI
-png_get_user_transform_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-   return ((png_voidp)png_ptr->user_transform_ptr);
-#else
-   return (NULL);
-#endif
-}
-#endif /* PNG_READ_USER_TRANSFORM_SUPPORTED ||
-          PNG_WRITE_USER_TRANSFORM_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngwio.c b/thirdparty/libpng/pngwio.c
deleted file mode 100644
index 513a71a..0000000
--- a/thirdparty/libpng/pngwio.c
+++ /dev/null
@@ -1,241 +0,0 @@
-
-/* pngwio.c - functions for data output
- *
- * Last changed in libpng 1.4.0 [January 3, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all output.  Users who need
- * special handling are expected to write functions that have the same
- * arguments as these and perform similar functions, but that possibly
- * use different output methods.  Note that you shouldn't change these
- * functions, but rather write replacement functions and then change
- * them at run time with png_set_write_fn(...).
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_WRITE_SUPPORTED
-#include "pngpriv.h"
-
-/* Write the data to whatever output you are using.  The default routine
- * writes to a file pointer.  Note that this routine sometimes gets called
- * with very small lengths, so you should implement some kind of simple
- * buffering if you are using unbuffered writes.  This should never be asked
- * to write more than 64K on a 16 bit machine.
- */
-
-void /* PRIVATE */
-png_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   if (png_ptr->write_data_fn != NULL )
-      (*(png_ptr->write_data_fn))(png_ptr, data, length);
-   else
-      png_error(png_ptr, "Call to NULL write function");
-}
-
-#ifdef PNG_STDIO_SUPPORTED
-/* This is the function that does the actual writing of data.  If you are
- * not writing to a standard C stream, you should create a replacement
- * write_data function and use it at run time with png_set_write_fn(), rather
- * than changing the library.
- */
-#ifndef USE_FAR_KEYWORD
-void PNGAPI
-png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_uint_32 check;
-
-   if (png_ptr == NULL)
-      return;
-   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
-   if (check != length)
-      png_error(png_ptr, "Write Error");
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
- * can't handle far buffers in the medium and small models, we have to copy
- * the data.
- */
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-void PNGAPI
-png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_uint_32 check;
-   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
-   png_FILE_p io_ptr;
-
-   if (png_ptr == NULL)
-      return;
-   /* Check if data really is near. If so, use usual code. */
-   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
-   if ((png_bytep)near_data == data)
-   {
-      check = fwrite(near_data, 1, length, io_ptr);
-   }
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t written, remaining, err;
-      check = 0;
-      remaining = length;
-      do
-      {
-         written = MIN(NEAR_BUF_SIZE, remaining);
-         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
-         err = fwrite(buf, 1, written, io_ptr);
-         if (err != written)
-            break;
-
-         else
-            check += err;
-
-         data += written;
-         remaining -= written;
-      }
-      while (remaining != 0);
-   }
-   if (check != length)
-      png_error(png_ptr, "Write Error");
-}
-
-#endif
-#endif
-
-/* This function is called to output any data pending writing (normally
- * to disk).  After png_flush is called, there should be no data pending
- * writing in any buffers.
- */
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-void /* PRIVATE */
-png_flush(png_structp png_ptr)
-{
-   if (png_ptr->output_flush_fn != NULL)
-      (*(png_ptr->output_flush_fn))(png_ptr);
-}
-
-#ifdef PNG_STDIO_SUPPORTED
-void PNGAPI
-png_default_flush(png_structp png_ptr)
-{
-   png_FILE_p io_ptr;
-   if (png_ptr == NULL)
-      return;
-   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
-   fflush(io_ptr);
-}
-#endif
-#endif
-
-/* This function allows the application to supply new output functions for
- * libpng if standard C streams aren't being used.
- *
- * This function takes as its arguments:
- * png_ptr       - pointer to a png output data structure
- * io_ptr        - pointer to user supplied structure containing info about
- *                 the output functions.  May be NULL.
- * write_data_fn - pointer to a new output function that takes as its
- *                 arguments a pointer to a png_struct, a pointer to
- *                 data to be written, and a 32-bit unsigned int that is
- *                 the number of bytes to be written.  The new write
- *                 function should call png_error(png_ptr, "Error msg")
- *                 to exit and output any fatal error messages.  May be
- *                 NULL, in which case libpng's default function will
- *                 be used.
- * flush_data_fn - pointer to a new flush function that takes as its
- *                 arguments a pointer to a png_struct.  After a call to
- *                 the flush function, there should be no data in any buffers
- *                 or pending transmission.  If the output method doesn't do
- *                 any buffering of output, a function prototype must still be
- *                 supplied although it doesn't have to do anything.  If
- *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
- *                 time, output_flush_fn will be ignored, although it must be
- *                 supplied for compatibility.  May be NULL, in which case
- *                 libpng's default function will be used, if
- *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
- *                 a good idea if io_ptr does not point to a standard
- *                 *FILE structure.
- */
-void PNGAPI
-png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
-   png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->io_ptr = io_ptr;
-
-#ifdef PNG_STDIO_SUPPORTED
-   if (write_data_fn != NULL)
-      png_ptr->write_data_fn = write_data_fn;
-
-   else
-      png_ptr->write_data_fn = png_default_write_data;
-#else
-   png_ptr->write_data_fn = write_data_fn;
-#endif
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-#ifdef PNG_STDIO_SUPPORTED
-   if (output_flush_fn != NULL)
-      png_ptr->output_flush_fn = output_flush_fn;
-
-   else
-      png_ptr->output_flush_fn = png_default_flush;
-#else
-   png_ptr->output_flush_fn = output_flush_fn;
-#endif
-#endif /* PNG_WRITE_FLUSH_SUPPORTED */
-
-   /* It is an error to read while writing a png file */
-   if (png_ptr->read_data_fn != NULL)
-   {
-      png_ptr->read_data_fn = NULL;
-      png_warning(png_ptr,
-         "Attempted to set both read_data_fn and write_data_fn in");
-      png_warning(png_ptr,
-         "the same structure.  Resetting read_data_fn to NULL");
-   }
-}
-
-#ifdef USE_FAR_KEYWORD
-#ifdef _MSC_VER
-void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
-{
-   void *near_ptr;
-   void FAR *far_ptr;
-   FP_OFF(near_ptr) = FP_OFF(ptr);
-   far_ptr = (void FAR *)near_ptr;
-
-   if (check != 0)
-      if (FP_SEG(ptr) != FP_SEG(far_ptr))
-         png_error(png_ptr, "segment lost in conversion");
-
-   return(near_ptr);
-}
-#  else
-void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
-{
-   void *near_ptr;
-   void FAR *far_ptr;
-   near_ptr = (void FAR *)ptr;
-   far_ptr = (void FAR *)near_ptr;
-
-   if (check != 0)
-      if (far_ptr != ptr)
-         png_error(png_ptr, "segment lost in conversion");
-
-   return(near_ptr);
-}
-#   endif
-#   endif
-#endif /* PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngwrite.c b/thirdparty/libpng/pngwrite.c
deleted file mode 100644
index 0252051..0000000
--- a/thirdparty/libpng/pngwrite.c
+++ /dev/null
@@ -1,1457 +0,0 @@
-
-/* pngwrite.c - general routines to write a PNG file
- *
- * Last changed in libpng 1.4.0 [January 3, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-/* Get internal access to png.h */
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_WRITE_SUPPORTED
-#include "pngpriv.h"
-
-/* Writes all the PNG information.  This is the suggested way to use the
- * library.  If you have a new chunk to add, make a function to write it,
- * and put it in the correct location here.  If you want the chunk written
- * after the image data, put it in png_write_end().  I strongly encourage
- * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing
- * the chunk, as that will keep the code from breaking if you want to just
- * write a plain PNG file.  If you have long comments, I suggest writing
- * them in png_write_end(), and compressing them.
- */
-void PNGAPI
-png_write_info_before_PLTE(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_write_info_before_PLTE");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-   if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
-   {
-   /* Write PNG signature */
-   png_write_sig(png_ptr);
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   if ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) && \
-      (png_ptr->mng_features_permitted))
-   {
-      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
-      png_ptr->mng_features_permitted = 0;
-   }
-#endif
-   /* Write IHDR information. */
-   png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height,
-      info_ptr->bit_depth, info_ptr->color_type, info_ptr->compression_type,
-      info_ptr->filter_type,
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-      info_ptr->interlace_type);
-#else
-      0);
-#endif
-   /* The rest of these check to see if the valid field has the appropriate
-    * flag set, and if it does, writes the chunk.
-    */
-#ifdef PNG_WRITE_gAMA_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_gAMA)
-   {
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-      png_write_gAMA(png_ptr, info_ptr->gamma);
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-      png_write_gAMA_fixed(png_ptr, info_ptr->int_gamma);
-#  endif
-#endif
-   }
-#endif
-#ifdef PNG_WRITE_sRGB_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_sRGB)
-      png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
-#endif
-#ifdef PNG_WRITE_iCCP_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_iCCP)
-      png_write_iCCP(png_ptr, info_ptr->iccp_name, PNG_COMPRESSION_TYPE_BASE,
-                     info_ptr->iccp_profile, (int)info_ptr->iccp_proflen);
-#endif
-#ifdef PNG_WRITE_sBIT_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_sBIT)
-      png_write_sBIT(png_ptr, &(info_ptr->sig_bit), info_ptr->color_type);
-#endif
-#ifdef PNG_WRITE_cHRM_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_cHRM)
-   {
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-      png_write_cHRM(png_ptr,
-         info_ptr->x_white, info_ptr->y_white,
-         info_ptr->x_red, info_ptr->y_red,
-         info_ptr->x_green, info_ptr->y_green,
-         info_ptr->x_blue, info_ptr->y_blue);
-#else
-#  ifdef PNG_FIXED_POINT_SUPPORTED
-      png_write_cHRM_fixed(png_ptr,
-         info_ptr->int_x_white, info_ptr->int_y_white,
-         info_ptr->int_x_red, info_ptr->int_y_red,
-         info_ptr->int_x_green, info_ptr->int_y_green,
-         info_ptr->int_x_blue, info_ptr->int_y_blue);
-#  endif
-#endif
-   }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   if (info_ptr->unknown_chunks_num)
-   {
-      png_unknown_chunk *up;
-
-      png_debug(5, "writing extra chunks");
-
-      for (up = info_ptr->unknown_chunks;
-           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-           up++)
-      {
-         int keep = png_handle_as_unknown(png_ptr, up->name);
-         if (keep != PNG_HANDLE_CHUNK_NEVER &&
-            up->location && !(up->location & PNG_HAVE_PLTE) &&
-            !(up->location & PNG_HAVE_IDAT) &&
-            ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
-            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
-         {
-            if (up->size == 0)
-               png_warning(png_ptr, "Writing zero-length unknown chunk");
-            png_write_chunk(png_ptr, up->name, up->data, up->size);
-         }
-      }
-   }
-#endif
-      png_ptr->mode |= PNG_WROTE_INFO_BEFORE_PLTE;
-   }
-}
-
-void PNGAPI
-png_write_info(png_structp png_ptr, png_infop info_ptr)
-{
-#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
-   int i;
-#endif
-
-   png_debug(1, "in png_write_info");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   png_write_info_before_PLTE(png_ptr, info_ptr);
-
-   if (info_ptr->valid & PNG_INFO_PLTE)
-      png_write_PLTE(png_ptr, info_ptr->palette,
-         (png_uint_32)info_ptr->num_palette);
-   else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      png_error(png_ptr, "Valid palette required for paletted images");
-
-#ifdef PNG_WRITE_tRNS_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_tRNS)
-   {
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-      /* Invert the alpha channel (in tRNS) */
-      if ((png_ptr->transformations & PNG_INVERT_ALPHA) &&
-         info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         int j;
-         for (j = 0; j<(int)info_ptr->num_trans; j++)
-            info_ptr->trans_alpha[j] = (png_byte)(255 - info_ptr->trans_alpha[j]);
-      }
-#endif
-      png_write_tRNS(png_ptr, info_ptr->trans_alpha, &(info_ptr->trans_color),
-         info_ptr->num_trans, info_ptr->color_type);
-   }
-#endif
-#ifdef PNG_WRITE_bKGD_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_bKGD)
-      png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
-#endif
-#ifdef PNG_WRITE_hIST_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_hIST)
-      png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
-#endif
-#ifdef PNG_WRITE_oFFs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_oFFs)
-      png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
-         info_ptr->offset_unit_type);
-#endif
-#ifdef PNG_WRITE_pCAL_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_pCAL)
-      png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0,
-         info_ptr->pcal_X1, info_ptr->pcal_type, info_ptr->pcal_nparams,
-         info_ptr->pcal_units, info_ptr->pcal_params);
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_sCAL)
-#ifdef PNG_WRITE_sCAL_SUPPORTED
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
-      png_write_sCAL(png_ptr, (int)info_ptr->scal_unit,
-          info_ptr->scal_pixel_width, info_ptr->scal_pixel_height);
-#else /* !FLOATING_POINT */
-#ifdef PNG_FIXED_POINT_SUPPORTED
-      png_write_sCAL_s(png_ptr, (int)info_ptr->scal_unit,
-          info_ptr->scal_s_width, info_ptr->scal_s_height);
-#endif /* FIXED_POINT */
-#endif /* FLOATING_POINT */
-#else  /* !WRITE_sCAL */
-      png_warning(png_ptr,
-          "png_write_sCAL not supported; sCAL chunk not written");
-#endif /* WRITE_sCAL */
-#endif /* sCAL */
-
-#ifdef PNG_WRITE_pHYs_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_pHYs)
-      png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
-         info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
-#endif /* pHYs */
-
-#ifdef PNG_WRITE_tIME_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_tIME)
-   {
-      png_write_tIME(png_ptr, &(info_ptr->mod_time));
-      png_ptr->mode |= PNG_WROTE_tIME;
-   }
-#endif /* tIME */
-
-#ifdef PNG_WRITE_sPLT_SUPPORTED
-   if (info_ptr->valid & PNG_INFO_sPLT)
-     for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
-       png_write_sPLT(png_ptr, info_ptr->splt_palettes + i);
-#endif /* sPLT */
-
-#ifdef PNG_WRITE_TEXT_SUPPORTED
-   /* Check to see if we need to write text chunks */
-   for (i = 0; i < info_ptr->num_text; i++)
-   {
-      png_debug2(2, "Writing header text chunk %d, type %d", i,
-         info_ptr->text[i].compression);
-      /* An internationalized chunk? */
-      if (info_ptr->text[i].compression > 0)
-      {
-#ifdef PNG_WRITE_iTXt_SUPPORTED
-          /* Write international chunk */
-          png_write_iTXt(png_ptr,
-                         info_ptr->text[i].compression,
-                         info_ptr->text[i].key,
-                         info_ptr->text[i].lang,
-                         info_ptr->text[i].lang_key,
-                         info_ptr->text[i].text);
-#else
-          png_warning(png_ptr, "Unable to write international text");
-#endif
-          /* Mark this chunk as written */
-          info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
-      }
-      /* If we want a compressed text chunk */
-      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
-      {
-#ifdef PNG_WRITE_zTXt_SUPPORTED
-         /* Write compressed chunk */
-         png_write_zTXt(png_ptr, info_ptr->text[i].key,
-            info_ptr->text[i].text, 0,
-            info_ptr->text[i].compression);
-#else
-         png_warning(png_ptr, "Unable to write compressed text");
-#endif
-         /* Mark this chunk as written */
-         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
-      }
-      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
-      {
-#ifdef PNG_WRITE_tEXt_SUPPORTED
-         /* Write uncompressed chunk */
-         png_write_tEXt(png_ptr, info_ptr->text[i].key,
-                         info_ptr->text[i].text,
-                         0);
-         /* Mark this chunk as written */
-         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
-#else
-         /* Can't get here */
-         png_warning(png_ptr, "Unable to write uncompressed text");
-#endif
-      }
-   }
-#endif /* tEXt */
-
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   if (info_ptr->unknown_chunks_num)
-   {
-      png_unknown_chunk *up;
-
-      png_debug(5, "writing extra chunks");
-
-      for (up = info_ptr->unknown_chunks;
-           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-           up++)
-      {
-         int keep = png_handle_as_unknown(png_ptr, up->name);
-         if (keep != PNG_HANDLE_CHUNK_NEVER &&
-            up->location && (up->location & PNG_HAVE_PLTE) &&
-            !(up->location & PNG_HAVE_IDAT) &&
-            ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
-            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
-         {
-            png_write_chunk(png_ptr, up->name, up->data, up->size);
-         }
-      }
-   }
-#endif
-}
-
-/* Writes the end of the PNG file.  If you don't want to write comments or
- * time information, you can pass NULL for info.  If you already wrote these
- * in png_write_info(), do not write them again here.  If you have long
- * comments, I suggest writing them here, and compressing them.
- */
-void PNGAPI
-png_write_end(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_write_end");
-
-   if (png_ptr == NULL)
-      return;
-   if (!(png_ptr->mode & PNG_HAVE_IDAT))
-      png_error(png_ptr, "No IDATs written into file");
-
-   /* See if user wants us to write information chunks */
-   if (info_ptr != NULL)
-   {
-#ifdef PNG_WRITE_TEXT_SUPPORTED
-      int i; /* local index variable */
-#endif
-#ifdef PNG_WRITE_tIME_SUPPORTED
-      /* Check to see if user has supplied a time chunk */
-      if ((info_ptr->valid & PNG_INFO_tIME) &&
-         !(png_ptr->mode & PNG_WROTE_tIME))
-         png_write_tIME(png_ptr, &(info_ptr->mod_time));
-#endif
-#ifdef PNG_WRITE_TEXT_SUPPORTED
-      /* Loop through comment chunks */
-      for (i = 0; i < info_ptr->num_text; i++)
-      {
-         png_debug2(2, "Writing trailer text chunk %d, type %d", i,
-            info_ptr->text[i].compression);
-         /* An internationalized chunk? */
-         if (info_ptr->text[i].compression > 0)
-         {
-#ifdef PNG_WRITE_iTXt_SUPPORTED
-            /* Write international chunk */
-            png_write_iTXt(png_ptr,
-                        info_ptr->text[i].compression,
-                        info_ptr->text[i].key,
-                        info_ptr->text[i].lang,
-                        info_ptr->text[i].lang_key,
-                        info_ptr->text[i].text);
-#else
-            png_warning(png_ptr, "Unable to write international text");
-#endif
-            /* Mark this chunk as written */
-            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
-         }
-         else if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
-         {
-#ifdef PNG_WRITE_zTXt_SUPPORTED
-            /* Write compressed chunk */
-            png_write_zTXt(png_ptr, info_ptr->text[i].key,
-               info_ptr->text[i].text, 0,
-               info_ptr->text[i].compression);
-#else
-            png_warning(png_ptr, "Unable to write compressed text");
-#endif
-            /* Mark this chunk as written */
-            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
-         }
-         else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
-         {
-#ifdef PNG_WRITE_tEXt_SUPPORTED
-            /* Write uncompressed chunk */
-            png_write_tEXt(png_ptr, info_ptr->text[i].key,
-               info_ptr->text[i].text, 0);
-#else
-            png_warning(png_ptr, "Unable to write uncompressed text");
-#endif
-
-            /* Mark this chunk as written */
-            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
-         }
-      }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   if (info_ptr->unknown_chunks_num)
-   {
-      png_unknown_chunk *up;
-
-      png_debug(5, "writing extra chunks");
-
-      for (up = info_ptr->unknown_chunks;
-           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
-           up++)
-      {
-         int keep = png_handle_as_unknown(png_ptr, up->name);
-         if (keep != PNG_HANDLE_CHUNK_NEVER &&
-            up->location && (up->location & PNG_AFTER_IDAT) &&
-            ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
-            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
-         {
-            png_write_chunk(png_ptr, up->name, up->data, up->size);
-         }
-      }
-   }
-#endif
-   }
-
-   png_ptr->mode |= PNG_AFTER_IDAT;
-
-   /* Write end of PNG file */
-   png_write_IEND(png_ptr);
-   /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
-    * and restored again in libpng-1.2.30, may cause some applications that
-    * do not set png_ptr->output_flush_fn to crash.  If your application
-    * experiences a problem, please try building libpng with
-    * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to
-    * png-mng-implement at lists.sf.net .
-    */
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-#  ifdef PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
-   png_flush(png_ptr);
-#  endif
-#endif
-}
-
-#ifdef PNG_CONVERT_tIME_SUPPORTED
-/* "tm" structure is not supported on WindowsCE */
-void PNGAPI
-png_convert_from_struct_tm(png_timep ptime, struct tm FAR * ttime)
-{
-   png_debug(1, "in png_convert_from_struct_tm");
-
-   ptime->year = (png_uint_16)(1900 + ttime->tm_year);
-   ptime->month = (png_byte)(ttime->tm_mon + 1);
-   ptime->day = (png_byte)ttime->tm_mday;
-   ptime->hour = (png_byte)ttime->tm_hour;
-   ptime->minute = (png_byte)ttime->tm_min;
-   ptime->second = (png_byte)ttime->tm_sec;
-}
-
-void PNGAPI
-png_convert_from_time_t(png_timep ptime, time_t ttime)
-{
-   struct tm *tbuf;
-
-   png_debug(1, "in png_convert_from_time_t");
-
-   tbuf = gmtime(&ttime);
-   png_convert_from_struct_tm(ptime, tbuf);
-}
-#endif
-
-/* Initialize png_ptr structure, and allocate any memory needed */
-png_structp PNGAPI
-png_create_write_struct(png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn)
-{
-#ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_write_struct_2(user_png_ver, error_ptr, error_fn,
-      warn_fn, NULL, NULL, NULL));
-}
-
-/* Alternate initialize png_ptr structure, and allocate any memory needed */
-png_structp PNGAPI
-png_create_write_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
-   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
-   png_malloc_ptr malloc_fn, png_free_ptr free_fn)
-{
-#endif /* PNG_USER_MEM_SUPPORTED */
-   volatile int png_cleanup_needed = 0;
-#ifdef PNG_SETJMP_SUPPORTED
-   volatile
-#endif
-   png_structp png_ptr;
-#ifdef PNG_SETJMP_SUPPORTED
-#ifdef USE_FAR_KEYWORD
-   jmp_buf jmpbuf;
-#endif
-#endif
-   int i;
-
-   png_debug(1, "in png_create_write_struct");
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
-      (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);
-#else
-   png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
-#endif /* PNG_USER_MEM_SUPPORTED */
-   if (png_ptr == NULL)
-      return (NULL);
-
-   /* Added at libpng-1.2.6 */
-#ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
-   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-/* Applications that neglect to set up their own setjmp() and then
-   encounter a png_error() will longjmp here.  Since the jmpbuf is
-   then meaningless we abort instead of returning. */
-#ifdef USE_FAR_KEYWORD
-   if (setjmp(jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(png_ptr))) /* sets longjmp to match setjmp */
-#endif
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(png_ptr), jmpbuf, png_sizeof(jmp_buf));
-#endif
-      PNG_ABORT();
-#endif
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
-#endif /* PNG_USER_MEM_SUPPORTED */
-   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
-
-   if (user_png_ver)
-   {
-      i = 0;
-      do
-      {
-         if (user_png_ver[i] != png_libpng_ver[i])
-            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-      } while (png_libpng_ver[i++]);
-   }
-
-   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-   {
-     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-      * we must recompile any applications that use any older library version.
-      * For versions after libpng 1.0, we will be compatible, so we need
-      * only check the first digit.
-      */
-     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-     {
-#ifdef PNG_STDIO_SUPPORTED
-        char msg[80];
-        if (user_png_ver)
-        {
-           png_snprintf(msg, 80,
-              "Application was compiled with png.h from libpng-%.20s",
-              user_png_ver);
-           png_warning(png_ptr, msg);
-        }
-        png_snprintf(msg, 80,
-           "Application  is  running with png.c from libpng-%.20s",
-           png_libpng_ver);
-        png_warning(png_ptr, msg);
-#endif
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-        png_ptr->flags = 0;
-#endif
-        png_warning(png_ptr,
-           "Incompatible libpng version in application and library");
-        png_cleanup_needed = 1;
-     }
-   }
-
-   /* Initialize zbuf - compression buffer */
-   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
-   if (!png_cleanup_needed)
-   {
-      png_ptr->zbuf = (png_bytep)png_malloc_warn(png_ptr,
-         png_ptr->zbuf_size);
-      if (png_ptr->zbuf == NULL)
-         png_cleanup_needed = 1;
-   }
-   if (png_cleanup_needed)
-   {
-       /* Clean up PNG structure and deallocate any memory. */
-       png_free(png_ptr, png_ptr->zbuf);
-       png_ptr->zbuf = NULL;
-#ifdef PNG_USER_MEM_SUPPORTED
-       png_destroy_struct_2((png_voidp)png_ptr,
-          (png_free_ptr)free_fn, (png_voidp)mem_ptr);
-#else
-       png_destroy_struct((png_voidp)png_ptr);
-#endif
-       return (NULL);
-   }
-
-   png_set_write_fn(png_ptr, NULL, NULL, NULL);
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
-      1, NULL, NULL);
-#endif
-
-   return (png_ptr);
-}
-
-
-/* Write a few rows of image data.  If the image is interlaced,
- * either you will have to write the 7 sub images, or, if you
- * have called png_set_interlace_handling(), you will have to
- * "write" the image seven times.
- */
-void PNGAPI
-png_write_rows(png_structp png_ptr, png_bytepp row,
-   png_uint_32 num_rows)
-{
-   png_uint_32 i; /* row counter */
-   png_bytepp rp; /* row pointer */
-
-   png_debug(1, "in png_write_rows");
-
-   if (png_ptr == NULL)
-      return;
-
-   /* Loop through the rows */
-   for (i = 0, rp = row; i < num_rows; i++, rp++)
-   {
-      png_write_row(png_ptr, *rp);
-   }
-}
-
-/* Write the image.  You only need to call this function once, even
- * if you are writing an interlaced image.
- */
-void PNGAPI
-png_write_image(png_structp png_ptr, png_bytepp image)
-{
-   png_uint_32 i; /* row index */
-   int pass, num_pass; /* pass variables */
-   png_bytepp rp; /* points to current row */
-
-   if (png_ptr == NULL)
-      return;
-
-   png_debug(1, "in png_write_image");
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* Initialize interlace handling.  If image is not interlaced,
-    * this will set pass to 1
-    */
-   num_pass = png_set_interlace_handling(png_ptr);
-#else
-   num_pass = 1;
-#endif
-   /* Loop through passes */
-   for (pass = 0; pass < num_pass; pass++)
-   {
-      /* Loop through image */
-      for (i = 0, rp = image; i < png_ptr->height; i++, rp++)
-      {
-         png_write_row(png_ptr, *rp);
-      }
-   }
-}
-
-/* Called by user to write a row of image data */
-void PNGAPI
-png_write_row(png_structp png_ptr, png_bytep row)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_debug2(1, "in png_write_row (row %ld, pass %d)",
-      png_ptr->row_number, png_ptr->pass);
-
-   /* Initialize transformations and other stuff if first time */
-   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
-   {
-      /* Make sure we wrote the header info */
-      if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
-         png_error(png_ptr,
-            "png_write_info was never called before png_write_row");
-
-      /* Check for transforms that have been set but were defined out */
-#if !defined(PNG_WRITE_INVERT_SUPPORTED) && defined(PNG_READ_INVERT_SUPPORTED)
-      if (png_ptr->transformations & PNG_INVERT_MONO)
-         png_warning(png_ptr, "PNG_WRITE_INVERT_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_FILLER_SUPPORTED) && defined(PNG_READ_FILLER_SUPPORTED)
-      if (png_ptr->transformations & PNG_FILLER)
-         png_warning(png_ptr, "PNG_WRITE_FILLER_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
-    defined(PNG_READ_PACKSWAP_SUPPORTED)
-      if (png_ptr->transformations & PNG_PACKSWAP)
-         png_warning(png_ptr,
-             "PNG_WRITE_PACKSWAP_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_PACK_SUPPORTED) && defined(PNG_READ_PACK_SUPPORTED)
-      if (png_ptr->transformations & PNG_PACK)
-         png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_SHIFT_SUPPORTED) && defined(PNG_READ_SHIFT_SUPPORTED)
-      if (png_ptr->transformations & PNG_SHIFT)
-         png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_BGR_SUPPORTED) && defined(PNG_READ_BGR_SUPPORTED)
-      if (png_ptr->transformations & PNG_BGR)
-         png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined");
-#endif
-#if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
-      if (png_ptr->transformations & PNG_SWAP_BYTES)
-         png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined");
-#endif
-
-      png_write_start_row(png_ptr);
-   }
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* If interlaced and not interested in row, return */
-   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
-   {
-      switch (png_ptr->pass)
-      {
-         case 0:
-            if (png_ptr->row_number & 0x07)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 1:
-            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 2:
-            if ((png_ptr->row_number & 0x07) != 4)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 3:
-            if ((png_ptr->row_number & 0x03) || png_ptr->width < 3)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 4:
-            if ((png_ptr->row_number & 0x03) != 2)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 5:
-            if ((png_ptr->row_number & 0x01) || png_ptr->width < 2)
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-         case 6:
-            if (!(png_ptr->row_number & 0x01))
-            {
-               png_write_finish_row(png_ptr);
-               return;
-            }
-            break;
-      }
-   }
-#endif
-
-   /* Set up row info for transformations */
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->usr_width;
-   png_ptr->row_info.channels = png_ptr->usr_channels;
-   png_ptr->row_info.bit_depth = png_ptr->usr_bit_depth;
-   png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
-      png_ptr->row_info.channels);
-
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-      png_ptr->row_info.width);
-
-   png_debug1(3, "row_info->color_type = %d", png_ptr->row_info.color_type);
-   png_debug1(3, "row_info->width = %lu", png_ptr->row_info.width);
-   png_debug1(3, "row_info->channels = %d", png_ptr->row_info.channels);
-   png_debug1(3, "row_info->bit_depth = %d", png_ptr->row_info.bit_depth);
-   png_debug1(3, "row_info->pixel_depth = %d", png_ptr->row_info.pixel_depth);
-   png_debug1(3, "row_info->rowbytes = %lu", png_ptr->row_info.rowbytes);
-
-   /* Copy user's row into buffer, leaving room for filter byte. */
-   png_memcpy(png_ptr->row_buf + 1, row, png_ptr->row_info.rowbytes);
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* Handle interlacing */
-   if (png_ptr->interlaced && png_ptr->pass < 6 &&
-      (png_ptr->transformations & PNG_INTERLACE))
-   {
-      png_do_write_interlace(&(png_ptr->row_info),
-         png_ptr->row_buf + 1, png_ptr->pass);
-      /* This should always get caught above, but still ... */
-      if (!(png_ptr->row_info.width))
-      {
-         png_write_finish_row(png_ptr);
-         return;
-      }
-   }
-#endif
-
-   /* Handle other transformations */
-   if (png_ptr->transformations)
-      png_do_write_transformations(png_ptr);
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   /* Write filter_method 64 (intrapixel differencing) only if
-    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
-    * 2. Libpng did not write a PNG signature (this filter_method is only
-    *    used in PNG datastreams that are embedded in MNG datastreams) and
-    * 3. The application called png_permit_mng_features with a mask that
-    *    included PNG_FLAG_MNG_FILTER_64 and
-    * 4. The filter_method is 64 and
-    * 5. The color_type is RGB or RGBA
-    */
-   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-      (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
-   {
-      /* Intrapixel differencing */
-      png_do_write_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
-   }
-#endif
-
-   /* Find a filter if necessary, filter the row and write it out. */
-   png_write_find_filter(png_ptr, &(png_ptr->row_info));
-
-   if (png_ptr->write_row_fn != NULL)
-      (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
-}
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-/* Set the automatic flush interval or 0 to turn flushing off */
-void PNGAPI
-png_set_flush(png_structp png_ptr, int nrows)
-{
-   png_debug(1, "in png_set_flush");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);
-}
-
-/* Flush the current output buffers now */
-void PNGAPI
-png_write_flush(png_structp png_ptr)
-{
-   int wrote_IDAT;
-
-   png_debug(1, "in png_write_flush");
-
-   if (png_ptr == NULL)
-      return;
-   /* We have already written out all of the data */
-   if (png_ptr->row_number >= png_ptr->num_rows)
-      return;
-
-   do
-   {
-      int ret;
-
-      /* Compress the data */
-      ret = deflate(&png_ptr->zstream, Z_SYNC_FLUSH);
-      wrote_IDAT = 0;
-
-      /* Check for compression errors */
-      if (ret != Z_OK)
-      {
-         if (png_ptr->zstream.msg != NULL)
-            png_error(png_ptr, png_ptr->zstream.msg);
-         else
-            png_error(png_ptr, "zlib error");
-      }
-
-      if (!(png_ptr->zstream.avail_out))
-      {
-         /* Write the IDAT and reset the zlib output buffer */
-         png_write_IDAT(png_ptr, png_ptr->zbuf,
-                        png_ptr->zbuf_size);
-         png_ptr->zstream.next_out = png_ptr->zbuf;
-         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-         wrote_IDAT = 1;
-      }
-   } while(wrote_IDAT == 1);
-
-   /* If there is any data left to be output, write it into a new IDAT */
-   if (png_ptr->zbuf_size != png_ptr->zstream.avail_out)
-   {
-      /* Write the IDAT and reset the zlib output buffer */
-      png_write_IDAT(png_ptr, png_ptr->zbuf,
-                     png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-   }
-   png_ptr->flush_rows = 0;
-   png_flush(png_ptr);
-}
-#endif /* PNG_WRITE_FLUSH_SUPPORTED */
-
-/* Free all memory used by the write */
-void PNGAPI
-png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
-{
-   png_structp png_ptr = NULL;
-   png_infop info_ptr = NULL;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_free_ptr free_fn = NULL;
-   png_voidp mem_ptr = NULL;
-#endif
-
-   png_debug(1, "in png_destroy_write_struct");
-
-   if (png_ptr_ptr != NULL)
-   {
-      png_ptr = *png_ptr_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-      free_fn = png_ptr->free_fn;
-      mem_ptr = png_ptr->mem_ptr;
-#endif
-   }
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr != NULL)
-   {
-      free_fn = png_ptr->free_fn;
-      mem_ptr = png_ptr->mem_ptr;
-   }
-#endif
-
-   if (info_ptr_ptr != NULL)
-      info_ptr = *info_ptr_ptr;
-
-   if (info_ptr != NULL)
-   {
-      if (png_ptr != NULL)
-      {
-        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-        if (png_ptr->num_chunk_list)
-        {
-           png_free(png_ptr, png_ptr->chunk_list);
-           png_ptr->num_chunk_list = 0;
-        }
-#endif
-      }
-
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)info_ptr, (png_free_ptr)free_fn,
-         (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)info_ptr);
-#endif
-      *info_ptr_ptr = NULL;
-   }
-
-   if (png_ptr != NULL)
-   {
-      png_write_destroy(png_ptr);
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)png_ptr, (png_free_ptr)free_fn,
-         (png_voidp)mem_ptr);
-#else
-      png_destroy_struct((png_voidp)png_ptr);
-#endif
-      *png_ptr_ptr = NULL;
-   }
-}
-
-
-/* Free any memory used in png_ptr struct (old method) */
-void /* PRIVATE */
-png_write_destroy(png_structp png_ptr)
-{
-#ifdef PNG_SETJMP_SUPPORTED
-   jmp_buf tmp_jmp; /* Save jump buffer */
-#endif
-   png_error_ptr error_fn;
-   png_error_ptr warning_fn;
-   png_voidp error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_free_ptr free_fn;
-#endif
-
-   png_debug(1, "in png_write_destroy");
-
-   /* Free any memory zlib uses */
-   deflateEnd(&png_ptr->zstream);
-
-   /* Free our memory.  png_free checks NULL for us. */
-   png_free(png_ptr, png_ptr->zbuf);
-   png_free(png_ptr, png_ptr->row_buf);
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-   png_free(png_ptr, png_ptr->prev_row);
-   png_free(png_ptr, png_ptr->sub_row);
-   png_free(png_ptr, png_ptr->up_row);
-   png_free(png_ptr, png_ptr->avg_row);
-   png_free(png_ptr, png_ptr->paeth_row);
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_free(png_ptr, png_ptr->time_buffer);
-#endif
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   png_free(png_ptr, png_ptr->prev_filters);
-   png_free(png_ptr, png_ptr->filter_weights);
-   png_free(png_ptr, png_ptr->inv_filter_weights);
-   png_free(png_ptr, png_ptr->filter_costs);
-   png_free(png_ptr, png_ptr->inv_filter_costs);
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   /* Reset structure */
-   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
-#endif
-
-   error_fn = png_ptr->error_fn;
-   warning_fn = png_ptr->warning_fn;
-   error_ptr = png_ptr->error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   free_fn = png_ptr->free_fn;
-#endif
-
-   png_memset(png_ptr, 0, png_sizeof(png_struct));
-
-   png_ptr->error_fn = error_fn;
-   png_ptr->warning_fn = warning_fn;
-   png_ptr->error_ptr = error_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-   png_ptr->free_fn = free_fn;
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
-#endif
-}
-
-/* Allow the application to select one or more row filters to use. */
-void PNGAPI
-png_set_filter(png_structp png_ptr, int method, int filters)
-{
-   png_debug(1, "in png_set_filter");
-
-   if (png_ptr == NULL)
-      return;
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-      (method == PNG_INTRAPIXEL_DIFFERENCING))
-         method = PNG_FILTER_TYPE_BASE;
-#endif
-   if (method == PNG_FILTER_TYPE_BASE)
-   {
-      switch (filters & (PNG_ALL_FILTERS | 0x07))
-      {
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-         case 5:
-         case 6:
-         case 7: png_warning(png_ptr, "Unknown row filter for method 0");
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-         case PNG_FILTER_VALUE_NONE:
-              png_ptr->do_filter = PNG_FILTER_NONE; break;
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-         case PNG_FILTER_VALUE_SUB:
-              png_ptr->do_filter = PNG_FILTER_SUB; break;
-         case PNG_FILTER_VALUE_UP:
-              png_ptr->do_filter = PNG_FILTER_UP; break;
-         case PNG_FILTER_VALUE_AVG:
-              png_ptr->do_filter = PNG_FILTER_AVG; break;
-         case PNG_FILTER_VALUE_PAETH:
-              png_ptr->do_filter = PNG_FILTER_PAETH; break;
-         default: png_ptr->do_filter = (png_byte)filters; break;
-#else
-         default: png_warning(png_ptr, "Unknown row filter for method 0");
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-      }
-
-      /* If we have allocated the row_buf, this means we have already started
-       * with the image and we should have allocated all of the filter buffers
-       * that have been selected.  If prev_row isn't already allocated, then
-       * it is too late to start using the filters that need it, since we
-       * will be missing the data in the previous row.  If an application
-       * wants to start and stop using particular filters during compression,
-       * it should start out with all of the filters, and then add and
-       * remove them after the start of compression.
-       */
-      if (png_ptr->row_buf != NULL)
-      {
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-         if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)
-         {
-            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
-              (png_ptr->rowbytes + 1));
-            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
-         }
-
-         if ((png_ptr->do_filter & PNG_FILTER_UP) && png_ptr->up_row == NULL)
-         {
-            if (png_ptr->prev_row == NULL)
-            {
-               png_warning(png_ptr, "Can't add Up filter after starting");
-               png_ptr->do_filter &= ~PNG_FILTER_UP;
-            }
-            else
-            {
-               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
-                  (png_ptr->rowbytes + 1));
-               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
-            }
-         }
-
-         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->avg_row == NULL)
-         {
-            if (png_ptr->prev_row == NULL)
-            {
-               png_warning(png_ptr, "Can't add Average filter after starting");
-               png_ptr->do_filter &= ~PNG_FILTER_AVG;
-            }
-            else
-            {
-               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
-                  (png_ptr->rowbytes + 1));
-               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
-            }
-         }
-
-         if ((png_ptr->do_filter & PNG_FILTER_PAETH) &&
-             png_ptr->paeth_row == NULL)
-         {
-            if (png_ptr->prev_row == NULL)
-            {
-               png_warning(png_ptr, "Can't add Paeth filter after starting");
-               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);
-            }
-            else
-            {
-               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
-                  (png_ptr->rowbytes + 1));
-               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
-            }
-         }
-
-         if (png_ptr->do_filter == PNG_NO_FILTERS)
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-            png_ptr->do_filter = PNG_FILTER_NONE;
-      }
-   }
-   else
-      png_error(png_ptr, "Unknown custom filter method");
-}
-
-/* This allows us to influence the way in which libpng chooses the "best"
- * filter for the current scanline.  While the "minimum-sum-of-absolute-
- * differences metric is relatively fast and effective, there is some
- * question as to whether it can be improved upon by trying to keep the
- * filtered data going to zlib more consistent, hopefully resulting in
- * better compression.
- */
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED      /* GRR 970116 */
-void PNGAPI
-png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,
-   int num_weights, png_doublep filter_weights,
-   png_doublep filter_costs)
-{
-   int i;
-
-   png_debug(1, "in png_set_filter_heuristics");
-
-   if (png_ptr == NULL)
-      return;
-   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)
-   {
-      png_warning(png_ptr, "Unknown filter heuristic method");
-      return;
-   }
-
-   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)
-   {
-      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;
-   }
-
-   if (num_weights < 0 || filter_weights == NULL ||
-      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)
-   {
-      num_weights = 0;
-   }
-
-   png_ptr->num_prev_filters = (png_byte)num_weights;
-   png_ptr->heuristic_method = (png_byte)heuristic_method;
-
-   if (num_weights > 0)
-   {
-      if (png_ptr->prev_filters == NULL)
-      {
-         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_byte) * num_weights));
-
-         /* To make sure that the weighting starts out fairly */
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->prev_filters[i] = 255;
-         }
-      }
-
-      if (png_ptr->filter_weights == NULL)
-      {
-         png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-
-         png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,
-            (png_uint_32)(png_sizeof(png_uint_16) * num_weights));
-         for (i = 0; i < num_weights; i++)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-      }
-
-      for (i = 0; i < num_weights; i++)
-      {
-         if (filter_weights[i] < 0.0)
-         {
-            png_ptr->inv_filter_weights[i] =
-            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
-         }
-         else
-         {
-            png_ptr->inv_filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);
-            png_ptr->filter_weights[i] =
-               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);
-         }
-      }
-   }
-
-   /* If, in the future, there are other filter methods, this would
-    * need to be based on png_ptr->filter.
-    */
-   if (png_ptr->filter_costs == NULL)
-   {
-      png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,
-         (png_uint_32)(png_sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
-
-      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-   }
-
-   /* Here is where we set the relative costs of the different filters.  We
-    * should take the desired compression level into account when setting
-    * the costs, so that Paeth, for instance, has a high relative cost at low
-    * compression levels, while it has a lower relative cost at higher
-    * compression settings.  The filter types are in order of increasing
-    * relative cost, so it would be possible to do this with an algorithm.
-    */
-   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
-   {
-      if (filter_costs == NULL || filter_costs[i] < 0.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
-      }
-      else if (filter_costs[i] >= 1.0)
-      {
-         png_ptr->inv_filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);
-         png_ptr->filter_costs[i] =
-            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);
-      }
-   }
-}
-#endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
-
-void PNGAPI
-png_set_compression_level(png_structp png_ptr, int level)
-{
-   png_debug(1, "in png_set_compression_level");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_LEVEL;
-   png_ptr->zlib_level = level;
-}
-
-void PNGAPI
-png_set_compression_mem_level(png_structp png_ptr, int mem_level)
-{
-   png_debug(1, "in png_set_compression_mem_level");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL;
-   png_ptr->zlib_mem_level = mem_level;
-}
-
-void PNGAPI
-png_set_compression_strategy(png_structp png_ptr, int strategy)
-{
-   png_debug(1, "in png_set_compression_strategy");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
-   png_ptr->zlib_strategy = strategy;
-}
-
-void PNGAPI
-png_set_compression_window_bits(png_structp png_ptr, int window_bits)
-{
-   if (png_ptr == NULL)
-      return;
-   if (window_bits > 15)
-      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
-   else if (window_bits < 8)
-      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
-#ifndef WBITS_8_OK
-   /* Avoid libpng bug with 256-byte windows */
-   if (window_bits == 8)
-     {
-       png_warning(png_ptr, "Compression window is being reset to 512");
-       window_bits = 9;
-     }
-#endif
-   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS;
-   png_ptr->zlib_window_bits = window_bits;
-}
-
-void PNGAPI
-png_set_compression_method(png_structp png_ptr, int method)
-{
-   png_debug(1, "in png_set_compression_method");
-
-   if (png_ptr == NULL)
-      return;
-   if (method != 8)
-      png_warning(png_ptr, "Only compression method 8 is supported by PNG");
-   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_METHOD;
-   png_ptr->zlib_method = method;
-}
-
-void PNGAPI
-png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)
-{
-   if (png_ptr == NULL)
-      return;
-   png_ptr->write_row_fn = write_row_fn;
-}
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-void PNGAPI
-png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
-   write_user_transform_fn)
-{
-   png_debug(1, "in png_set_write_user_transform_fn");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->transformations |= PNG_USER_TRANSFORM;
-   png_ptr->write_user_transform_fn = write_user_transform_fn;
-}
-#endif
-
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-void PNGAPI
-png_write_png(png_structp png_ptr, png_infop info_ptr,
-              int transforms, voidp params)
-{
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   /* Write the file header information. */
-   png_write_info(png_ptr, info_ptr);
-
-   /* ------ these transformations don't touch the info structure ------- */
-
-#ifdef PNG_WRITE_INVERT_SUPPORTED
-   /* Invert monochrome pixels */
-   if (transforms & PNG_TRANSFORM_INVERT_MONO)
-      png_set_invert_mono(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-   /* Shift the pixels up to a legal bit depth and fill in
-    * as appropriate to correctly scale the image.
-    */
-   if ((transforms & PNG_TRANSFORM_SHIFT)
-               && (info_ptr->valid & PNG_INFO_sBIT))
-      png_set_shift(png_ptr, &info_ptr->sig_bit);
-#endif
-
-#ifdef PNG_WRITE_PACK_SUPPORTED
-   /* Pack pixels into bytes */
-   if (transforms & PNG_TRANSFORM_PACKING)
-       png_set_packing(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-   /* Swap location of alpha bytes from ARGB to RGBA */
-   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
-      png_set_swap_alpha(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_FILLER_SUPPORTED
-   /* Pack XRGB/RGBX/ARGB/RGBA into * RGB (4 channels -> 3 channels) */
-   if (transforms & PNG_TRANSFORM_STRIP_FILLER_AFTER)
-      png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
-   else if (transforms & PNG_TRANSFORM_STRIP_FILLER_BEFORE)
-      png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-#endif
-
-#ifdef PNG_WRITE_BGR_SUPPORTED
-   /* Flip BGR pixels to RGB */
-   if (transforms & PNG_TRANSFORM_BGR)
-      png_set_bgr(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_SWAP_SUPPORTED
-   /* Swap bytes of 16-bit files to most significant byte first */
-   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
-      png_set_swap(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
-   /* Swap bits of 1, 2, 4 bit packed pixel formats */
-   if (transforms & PNG_TRANSFORM_PACKSWAP)
-      png_set_packswap(png_ptr);
-#endif
-
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-   /* Invert the alpha channel from opacity to transparency */
-   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
-      png_set_invert_alpha(png_ptr);
-#endif
-
-   /* ----------------------- end of transformations ------------------- */
-
-   /* Write the bits */
-   if (info_ptr->valid & PNG_INFO_IDAT)
-       png_write_image(png_ptr, info_ptr->row_pointers);
-
-   /* It is REQUIRED to call this to finish writing the rest of the file */
-   png_write_end(png_ptr, info_ptr);
-
-   transforms = transforms; /* Quiet compiler warnings */
-   params = params;
-}
-#endif
-#endif /* PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngwtran.c b/thirdparty/libpng/pngwtran.c
deleted file mode 100644
index 070caa5..0000000
--- a/thirdparty/libpng/pngwtran.c
+++ /dev/null
@@ -1,566 +0,0 @@
-
-/* pngwtran.c - transforms the data in a row for PNG writers
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_WRITE_SUPPORTED
-#include "pngpriv.h"
-
-/* Transform the data according to the user's wishes.  The order of
- * transformations is significant.
- */
-void /* PRIVATE */
-png_do_write_transformations(png_structp png_ptr)
-{
-   png_debug(1, "in png_do_write_transformations");
-
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-      if (png_ptr->write_user_transform_fn != NULL)
-        (*(png_ptr->write_user_transform_fn)) /* User write transform
-                                                 function */
-          (png_ptr,                    /* png_ptr */
-           &(png_ptr->row_info),       /* row_info:     */
-             /*  png_uint_32 width;          width of row */
-             /*  png_uint_32 rowbytes;       number of bytes in row */
-             /*  png_byte color_type;        color type of pixels */
-             /*  png_byte bit_depth;         bit depth of samples */
-             /*  png_byte channels;          number of channels (1-4) */
-             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
-           png_ptr->row_buf + 1);      /* start of pixel data for row */
-#endif
-#ifdef PNG_WRITE_FILLER_SUPPORTED
-   if (png_ptr->transformations & PNG_FILLER)
-      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         png_ptr->flags);
-#endif
-#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-#ifdef PNG_WRITE_PACK_SUPPORTED
-   if (png_ptr->transformations & PNG_PACK)
-      png_do_pack(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         (png_uint_32)png_ptr->bit_depth);
-#endif
-#ifdef PNG_WRITE_SWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
-         &(png_ptr->shift));
-#endif
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_write_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-#ifdef PNG_WRITE_BGR_SUPPORTED
-   if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-#ifdef PNG_WRITE_INVERT_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-}
-
-#ifdef PNG_WRITE_PACK_SUPPORTED
-/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
- * row_info bit depth should be 8 (one pixel per byte).  The channels
- * should be 1 (this only happens on grayscale and paletted images).
- */
-void /* PRIVATE */
-png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
-{
-   png_debug(1, "in png_do_pack");
-
-   if (row_info->bit_depth == 8 &&
-      row_info->channels == 1)
-   {
-      switch ((int)bit_depth)
-      {
-         case 1:
-         {
-            png_bytep sp, dp;
-            int mask, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            mask = 0x80;
-            v = 0;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (*sp != 0)
-                  v |= mask;
-               sp++;
-               if (mask > 1)
-                  mask >>= 1;
-               else
-               {
-                  mask = 0x80;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-            }
-            if (mask != 0x80)
-               *dp = (png_byte)v;
-            break;
-         }
-         case 2:
-         {
-            png_bytep sp, dp;
-            int shift, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            shift = 6;
-            v = 0;
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte value;
-
-               value = (png_byte)(*sp & 0x03);
-               v |= (value << shift);
-               if (shift == 0)
-               {
-                  shift = 6;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-               else
-                  shift -= 2;
-               sp++;
-            }
-            if (shift != 6)
-               *dp = (png_byte)v;
-            break;
-         }
-         case 4:
-         {
-            png_bytep sp, dp;
-            int shift, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            shift = 4;
-            v = 0;
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte value;
-
-               value = (png_byte)(*sp & 0x0f);
-               v |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 4;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-               else
-                  shift -= 4;
-
-               sp++;
-            }
-            if (shift != 4)
-               *dp = (png_byte)v;
-            break;
-         }
-      }
-      row_info->bit_depth = (png_byte)bit_depth;
-      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-         row_info->width);
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-/* Shift pixel values to take advantage of whole range.  Pass the
- * true number of bits in bit_depth.  The row should be packed
- * according to row_info->bit_depth.  Thus, if you had a row of
- * bit depth 4, but the pixels only had values from 0 to 7, you
- * would pass 3 as bit_depth, and this routine would translate the
- * data to 0 to 15.
- */
-void /* PRIVATE */
-png_do_shift(png_row_infop row_info, png_bytep row, png_color_8p bit_depth)
-{
-   png_debug(1, "in png_do_shift");
-
-   if (
-      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      int shift_start[4], shift_dec[4];
-      int channels = 0;
-
-      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->red;
-         shift_dec[channels] = bit_depth->red;
-         channels++;
-         shift_start[channels] = row_info->bit_depth - bit_depth->green;
-         shift_dec[channels] = bit_depth->green;
-         channels++;
-         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
-         shift_dec[channels] = bit_depth->blue;
-         channels++;
-      }
-      else
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
-         shift_dec[channels] = bit_depth->gray;
-         channels++;
-      }
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
-         shift_dec[channels] = bit_depth->alpha;
-         channels++;
-      }
-
-      /* With low row depths, could only be grayscale, so one channel */
-      if (row_info->bit_depth < 8)
-      {
-         png_bytep bp = row;
-         png_uint_32 i;
-         png_byte mask;
-         png_uint_32 row_bytes = row_info->rowbytes;
-
-         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
-            mask = 0x55;
-         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
-            mask = 0x11;
-         else
-            mask = 0xff;
-
-         for (i = 0; i < row_bytes; i++, bp++)
-         {
-            png_uint_16 v;
-            int j;
-
-            v = *bp;
-            *bp = 0;
-            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
-            {
-               if (j > 0)
-                  *bp |= (png_byte)((v << j) & 0xff);
-               else
-                  *bp |= (png_byte)((v >> (-j)) & mask);
-            }
-         }
-      }
-      else if (row_info->bit_depth == 8)
-      {
-         png_bytep bp = row;
-         png_uint_32 i;
-         png_uint_32 istop = channels * row_info->width;
-
-         for (i = 0; i < istop; i++, bp++)
-         {
-
-            png_uint_16 v;
-            int j;
-            int c = (int)(i%channels);
-
-            v = *bp;
-            *bp = 0;
-            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
-            {
-               if (j > 0)
-                  *bp |= (png_byte)((v << j) & 0xff);
-               else
-                  *bp |= (png_byte)((v >> (-j)) & 0xff);
-            }
-         }
-      }
-      else
-      {
-         png_bytep bp;
-         png_uint_32 i;
-         png_uint_32 istop = channels * row_info->width;
-
-         for (bp = row, i = 0; i < istop; i++)
-         {
-            int c = (int)(i%channels);
-            png_uint_16 value, v;
-            int j;
-
-            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
-            value = 0;
-            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
-            {
-               if (j > 0)
-                  value |= (png_uint_16)((v << j) & (png_uint_16)0xffff);
-               else
-                  value |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
-            }
-            *bp++ = (png_byte)(value >> 8);
-            *bp++ = (png_byte)(value & 0xff);
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_swap_alpha");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This converts from ARGB to RGBA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save;
-            }
-         }
-         /* This converts from AARRGGBB to RRGGBBAA */
-         else
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save[2];
-               save[0] = *(sp++);
-               save[1] = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save[0];
-               *(dp++) = save[1];
-            }
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This converts from AG to GA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save;
-            }
-         }
-         /* This converts from AAGG to GGAA */
-         else
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save[2];
-               save[0] = *(sp++);
-               save[1] = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save[0];
-               *(dp++) = save[1];
-            }
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_invert_alpha");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This inverts the alpha channel in RGBA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=3; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-         /* This inverts the alpha channel in RRGGBBAA */
-         else
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=6; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This inverts the alpha channel in GA */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               *(dp++) = *(sp++);
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-         /* This inverts the alpha channel in GGAA */
-         else
-         {
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=2; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-/* Undoes intrapixel differencing  */
-void /* PRIVATE */
-png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_intrapixel");
-
-   if (
-       (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      int bytes_per_pixel;
-      png_uint_32 row_width = row_info->width;
-      if (row_info->bit_depth == 8)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 3;
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 4;
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            *(rp)   = (png_byte)((*rp     - *(rp+1))&0xff);
-            *(rp+2) = (png_byte)((*(rp+2) - *(rp+1))&0xff);
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 6;
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 8;
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            png_uint_32 s0   = (*(rp  ) << 8) | *(rp+1);
-            png_uint_32 s1   = (*(rp+2) << 8) | *(rp+3);
-            png_uint_32 s2   = (*(rp+4) << 8) | *(rp+5);
-            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
-            *(rp  ) = (png_byte)((red >> 8) & 0xff);
-            *(rp+1) = (png_byte)(red & 0xff);
-            *(rp+4) = (png_byte)((blue >> 8) & 0xff);
-            *(rp+5) = (png_byte)(blue & 0xff);
-         }
-      }
-   }
-}
-#endif /* PNG_MNG_FEATURES_SUPPORTED */
-#endif /* PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libpng/pngwutil.c b/thirdparty/libpng/pngwutil.c
deleted file mode 100644
index 19feb1d..0000000
--- a/thirdparty/libpng/pngwutil.c
+++ /dev/null
@@ -1,2786 +0,0 @@
-
-/* pngwutil.c - utilities to write a PNG file
- *
- * Last changed in libpng 1.4.1 [February 25, 2010]
- * Copyright (c) 1998-2010 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#define PNG_NO_PEDANTIC_WARNINGS
-#include "png.h"
-#ifdef PNG_WRITE_SUPPORTED
-#include "pngpriv.h"
-
-/* Place a 32-bit number into a buffer in PNG byte order.  We work
- * with unsigned numbers for convenience, although one supported
- * ancillary chunk uses signed (two's complement) numbers.
- */
-void PNGAPI
-png_save_uint_32(png_bytep buf, png_uint_32 i)
-{
-   buf[0] = (png_byte)((i >> 24) & 0xff);
-   buf[1] = (png_byte)((i >> 16) & 0xff);
-   buf[2] = (png_byte)((i >> 8) & 0xff);
-   buf[3] = (png_byte)(i & 0xff);
-}
-
-#ifdef PNG_SAVE_INT_32_SUPPORTED
-/* The png_save_int_32 function assumes integers are stored in two's
- * complement format.  If this isn't the case, then this routine needs to
- * be modified to write data in two's complement format.
- */
-void PNGAPI
-png_save_int_32(png_bytep buf, png_int_32 i)
-{
-   buf[0] = (png_byte)((i >> 24) & 0xff);
-   buf[1] = (png_byte)((i >> 16) & 0xff);
-   buf[2] = (png_byte)((i >> 8) & 0xff);
-   buf[3] = (png_byte)(i & 0xff);
-}
-#endif
-
-/* Place a 16-bit number into a buffer in PNG byte order.
- * The parameter is declared unsigned int, not png_uint_16,
- * just to avoid potential problems on pre-ANSI C compilers.
- */
-void PNGAPI
-png_save_uint_16(png_bytep buf, unsigned int i)
-{
-   buf[0] = (png_byte)((i >> 8) & 0xff);
-   buf[1] = (png_byte)(i & 0xff);
-}
-
-/* Simple function to write the signature.  If we have already written
- * the magic bytes of the signature, or more likely, the PNG stream is
- * being embedded into another stream and doesn't need its own signature,
- * we should call png_set_sig_bytes() to tell libpng how many of the
- * bytes have already been written.
- */
-void PNGAPI
-png_write_sig(png_structp png_ptr)
-{
-   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that the signature is being written */
-   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_SIGNATURE;
-#endif
-
-   /* Write the rest of the 8 byte signature */
-   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
-      (png_size_t)(8 - png_ptr->sig_bytes));
-   if (png_ptr->sig_bytes < 3)
-      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
-}
-
-/* Write a PNG chunk all at once.  The type is an array of ASCII characters
- * representing the chunk name.  The array must be at least 4 bytes in
- * length, and does not need to be null terminated.  To be safe, pass the
- * pre-defined chunk names here, and if you need a new one, define it
- * where the others are defined.  The length is the length of the data.
- * All the data must be present.  If that is not possible, use the
- * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
- * functions instead.
- */
-void PNGAPI
-png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
-   png_bytep data, png_size_t length)
-{
-   if (png_ptr == NULL)
-      return;
-   png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
-   png_write_chunk_data(png_ptr, data, (png_size_t)length);
-   png_write_chunk_end(png_ptr);
-}
-
-/* Write the start of a PNG chunk.  The type is the chunk type.
- * The total_length is the sum of the lengths of all the data you will be
- * passing in png_write_chunk_data().
- */
-void PNGAPI
-png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
-   png_uint_32 length)
-{
-   png_byte buf[8];
-
-   png_debug2(0, "Writing %s chunk, length = %lu", chunk_name,
-      (unsigned long)length);
-
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that the chunk header is being written.
-    * PNG_IO_CHUNK_HDR requires a single I/O call.
-    */
-   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_HDR;
-#endif
-
-   /* Write the length and the chunk name */
-   png_save_uint_32(buf, length);
-   png_memcpy(buf + 4, chunk_name, 4);
-   png_write_data(png_ptr, buf, (png_size_t)8);
-   /* Put the chunk name into png_ptr->chunk_name */
-   png_memcpy(png_ptr->chunk_name, chunk_name, 4);
-   /* Reset the crc and run it over the chunk name */
-   png_reset_crc(png_ptr);
-   png_calculate_crc(png_ptr, chunk_name, 4);
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that chunk data will (possibly) be written.
-    * PNG_IO_CHUNK_DATA does NOT require a specific number of I/O calls.
-    */
-   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_DATA;
-#endif
-}
-
-/* Write the data of a PNG chunk started with png_write_chunk_start().
- * Note that multiple calls to this function are allowed, and that the
- * sum of the lengths from these calls *must* add up to the total_length
- * given to png_write_chunk_start().
- */
-void PNGAPI
-png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   /* Write the data, and run the CRC over it */
-   if (png_ptr == NULL)
-      return;
-   if (data != NULL && length > 0)
-   {
-      png_write_data(png_ptr, data, length);
-      /* Update the CRC after writing the data,
-       * in case that the user I/O routine alters it.
-       */
-      png_calculate_crc(png_ptr, data, length);
-   }
-}
-
-/* Finish a chunk started with png_write_chunk_start(). */
-void PNGAPI
-png_write_chunk_end(png_structp png_ptr)
-{
-   png_byte buf[4];
-
-   if (png_ptr == NULL) return;
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   /* Inform the I/O callback that the chunk CRC is being written.
-    * PNG_IO_CHUNK_CRC requires a single I/O function call.
-    */
-   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_CRC;
-#endif
-
-   /* Write the crc in a single operation */
-   png_save_uint_32(buf, png_ptr->crc);
-
-   png_write_data(png_ptr, buf, (png_size_t)4);
-}
-
-#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
-/* This pair of functions encapsulates the operation of (a) compressing a
- * text string, and (b) issuing it later as a series of chunk data writes.
- * The compression_state structure is shared context for these functions
- * set up by the caller in order to make the whole mess thread-safe.
- */
-
-typedef struct
-{
-   char *input;   /* The uncompressed input data */
-   int input_len;   /* Its length */
-   int num_output_ptr; /* Number of output pointers used */
-   int max_output_ptr; /* Size of output_ptr */
-   png_charpp output_ptr; /* Array of pointers to output */
-} compression_state;
-
-/* Compress given text into storage in the png_ptr structure */
-static int /* PRIVATE */
-png_text_compress(png_structp png_ptr,
-        png_charp text, png_size_t text_len, int compression,
-        compression_state *comp)
-{
-   int ret;
-
-   comp->num_output_ptr = 0;
-   comp->max_output_ptr = 0;
-   comp->output_ptr = NULL;
-   comp->input = NULL;
-   comp->input_len = 0;
-
-   /* We may just want to pass the text right through */
-   if (compression == PNG_TEXT_COMPRESSION_NONE)
-   {
-       comp->input = text;
-       comp->input_len = text_len;
-       return((int)text_len);
-   }
-
-   if (compression >= PNG_TEXT_COMPRESSION_LAST)
-   {
-#ifdef PNG_STDIO_SUPPORTED
-      char msg[50];
-      png_snprintf(msg, 50, "Unknown compression type %d", compression);
-      png_warning(png_ptr, msg);
-#else
-      png_warning(png_ptr, "Unknown compression type");
-#endif
-   }
-
-   /* We can't write the chunk until we find out how much data we have,
-    * which means we need to run the compressor first and save the
-    * output.  This shouldn't be a problem, as the vast majority of
-    * comments should be reasonable, but we will set up an array of
-    * malloc'd pointers to be sure.
-    *
-    * If we knew the application was well behaved, we could simplify this
-    * greatly by assuming we can always malloc an output buffer large
-    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)
-    * and malloc this directly.  The only time this would be a bad idea is
-    * if we can't malloc more than 64K and we have 64K of random input
-    * data, or if the input string is incredibly large (although this
-    * wouldn't cause a failure, just a slowdown due to swapping).
-    */
-
-   /* Set up the compression buffers */
-   png_ptr->zstream.avail_in = (uInt)text_len;
-   png_ptr->zstream.next_in = (Bytef *)text;
-   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-   png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;
-
-   /* This is the same compression loop as in png_write_row() */
-   do
-   {
-      /* Compress the data */
-      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
-      if (ret != Z_OK)
-      {
-         /* Error */
-         if (png_ptr->zstream.msg != NULL)
-            png_error(png_ptr, png_ptr->zstream.msg);
-         else
-            png_error(png_ptr, "zlib error");
-      }
-      /* Check to see if we need more room */
-      if (!(png_ptr->zstream.avail_out))
-      {
-         /* Make sure the output array has room */
-         if (comp->num_output_ptr >= comp->max_output_ptr)
-         {
-            int old_max;
-
-            old_max = comp->max_output_ptr;
-            comp->max_output_ptr = comp->num_output_ptr + 4;
-            if (comp->output_ptr != NULL)
-            {
-               png_charpp old_ptr;
-
-               old_ptr = comp->output_ptr;
-               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                  (png_alloc_size_t)
-                  (comp->max_output_ptr * png_sizeof(png_charpp)));
-               png_memcpy(comp->output_ptr, old_ptr, old_max
-                  * png_sizeof(png_charp));
-               png_free(png_ptr, old_ptr);
-            }
-            else
-               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                  (png_alloc_size_t)
-                  (comp->max_output_ptr * png_sizeof(png_charp)));
-         }
-
-         /* Save the data */
-         comp->output_ptr[comp->num_output_ptr] =
-            (png_charp)png_malloc(png_ptr,
-            (png_alloc_size_t)png_ptr->zbuf_size);
-         png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
-            png_ptr->zbuf_size);
-         comp->num_output_ptr++;
-
-         /* and reset the buffer */
-         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-         png_ptr->zstream.next_out = png_ptr->zbuf;
-      }
-   /* Continue until we don't have any more to compress */
-   } while (png_ptr->zstream.avail_in);
-
-   /* Finish the compression */
-   do
-   {
-      /* Tell zlib we are finished */
-      ret = deflate(&png_ptr->zstream, Z_FINISH);
-
-      if (ret == Z_OK)
-      {
-         /* Check to see if we need more room */
-         if (!(png_ptr->zstream.avail_out))
-         {
-            /* Check to make sure our output array has room */
-            if (comp->num_output_ptr >= comp->max_output_ptr)
-            {
-               int old_max;
-
-               old_max = comp->max_output_ptr;
-               comp->max_output_ptr = comp->num_output_ptr + 4;
-               if (comp->output_ptr != NULL)
-               {
-                  png_charpp old_ptr;
-
-                  old_ptr = comp->output_ptr;
-                  /* This could be optimized to realloc() */
-                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                     (png_alloc_size_t)(comp->max_output_ptr *
-                     png_sizeof(png_charp)));
-                  png_memcpy(comp->output_ptr, old_ptr,
-                     old_max * png_sizeof(png_charp));
-                  png_free(png_ptr, old_ptr);
-               }
-               else
-                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
-                     (png_alloc_size_t)(comp->max_output_ptr *
-                     png_sizeof(png_charp)));
-            }
-
-            /* Save the data */
-            comp->output_ptr[comp->num_output_ptr] =
-               (png_charp)png_malloc(png_ptr,
-               (png_alloc_size_t)png_ptr->zbuf_size);
-            png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
-               png_ptr->zbuf_size);
-            comp->num_output_ptr++;
-
-            /* and reset the buffer pointers */
-            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            png_ptr->zstream.next_out = png_ptr->zbuf;
-         }
-      }
-      else if (ret != Z_STREAM_END)
-      {
-         /* We got an error */
-         if (png_ptr->zstream.msg != NULL)
-            png_error(png_ptr, png_ptr->zstream.msg);
-         else
-            png_error(png_ptr, "zlib error");
-      }
-   } while (ret != Z_STREAM_END);
-
-   /* Text length is number of buffers plus last buffer */
-   text_len = png_ptr->zbuf_size * comp->num_output_ptr;
-   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
-      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;
-
-   return((int)text_len);
-}
-
-/* Ship the compressed text out via chunk writes */
-static void /* PRIVATE */
-png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
-{
-   int i;
-
-   /* Handle the no-compression case */
-   if (comp->input)
-   {
-      png_write_chunk_data(png_ptr, (png_bytep)comp->input,
-                            (png_size_t)comp->input_len);
-      return;
-   }
-
-   /* Write saved output buffers, if any */
-   for (i = 0; i < comp->num_output_ptr; i++)
-   {
-      png_write_chunk_data(png_ptr, (png_bytep)comp->output_ptr[i],
-         (png_size_t)png_ptr->zbuf_size);
-      png_free(png_ptr, comp->output_ptr[i]);
-   }
-   if (comp->max_output_ptr != 0)
-      png_free(png_ptr, comp->output_ptr);
-   /* Write anything left in zbuf */
-   if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
-      png_write_chunk_data(png_ptr, png_ptr->zbuf,
-         (png_size_t)(png_ptr->zbuf_size - png_ptr->zstream.avail_out));
-
-   /* Reset zlib for another zTXt/iTXt or image data */
-   deflateReset(&png_ptr->zstream);
-   png_ptr->zstream.data_type = Z_BINARY;
-}
-#endif
-
-/* Write the IHDR chunk, and update the png_struct with the necessary
- * information.  Note that the rest of this code depends upon this
- * information being correct.
- */
-void /* PRIVATE */
-png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
-   int bit_depth, int color_type, int compression_type, int filter_type,
-   int interlace_type)
-{
-   PNG_IHDR;
-   int ret;
-
-   png_byte buf[13]; /* Buffer to store the IHDR info */
-
-   png_debug(1, "in png_write_IHDR");
-
-   /* Check that we have valid input data from the application info */
-   switch (color_type)
-   {
-      case PNG_COLOR_TYPE_GRAY:
-         switch (bit_depth)
-         {
-            case 1:
-            case 2:
-            case 4:
-            case 8:
-            case 16: png_ptr->channels = 1; break;
-            default: png_error(png_ptr,
-                         "Invalid bit depth for grayscale image");
-         }
-         break;
-      case PNG_COLOR_TYPE_RGB:
-         if (bit_depth != 8 && bit_depth != 16)
-            png_error(png_ptr, "Invalid bit depth for RGB image");
-         png_ptr->channels = 3;
-         break;
-      case PNG_COLOR_TYPE_PALETTE:
-         switch (bit_depth)
-         {
-            case 1:
-            case 2:
-            case 4:
-            case 8: png_ptr->channels = 1; break;
-            default: png_error(png_ptr, "Invalid bit depth for paletted image");
-         }
-         break;
-      case PNG_COLOR_TYPE_GRAY_ALPHA:
-         if (bit_depth != 8 && bit_depth != 16)
-            png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
-         png_ptr->channels = 2;
-         break;
-      case PNG_COLOR_TYPE_RGB_ALPHA:
-         if (bit_depth != 8 && bit_depth != 16)
-            png_error(png_ptr, "Invalid bit depth for RGBA image");
-         png_ptr->channels = 4;
-         break;
-      default:
-         png_error(png_ptr, "Invalid image color type specified");
-   }
-
-   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Invalid compression type specified");
-      compression_type = PNG_COMPRESSION_TYPE_BASE;
-   }
-
-   /* Write filter_method 64 (intrapixel differencing) only if
-    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
-    * 2. Libpng did not write a PNG signature (this filter_method is only
-    *    used in PNG datastreams that are embedded in MNG datastreams) and
-    * 3. The application called png_permit_mng_features with a mask that
-    *    included PNG_FLAG_MNG_FILTER_64 and
-    * 4. The filter_method is 64 and
-    * 5. The color_type is RGB or RGBA
-    */
-   if (
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-      !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-      ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
-      (color_type == PNG_COLOR_TYPE_RGB ||
-       color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
-      (filter_type == PNG_INTRAPIXEL_DIFFERENCING)) &&
-#endif
-      filter_type != PNG_FILTER_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Invalid filter type specified");
-      filter_type = PNG_FILTER_TYPE_BASE;
-   }
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   if (interlace_type != PNG_INTERLACE_NONE &&
-      interlace_type != PNG_INTERLACE_ADAM7)
-   {
-      png_warning(png_ptr, "Invalid interlace type specified");
-      interlace_type = PNG_INTERLACE_ADAM7;
-   }
-#else
-   interlace_type=PNG_INTERLACE_NONE;
-#endif
-
-   /* Save the relevent information */
-   png_ptr->bit_depth = (png_byte)bit_depth;
-   png_ptr->color_type = (png_byte)color_type;
-   png_ptr->interlaced = (png_byte)interlace_type;
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-   png_ptr->filter_type = (png_byte)filter_type;
-#endif
-   png_ptr->compression_type = (png_byte)compression_type;
-   png_ptr->width = width;
-   png_ptr->height = height;
-
-   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
-   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
-   /* Set the usr info, so any transformations can modify it */
-   png_ptr->usr_width = png_ptr->width;
-   png_ptr->usr_bit_depth = png_ptr->bit_depth;
-   png_ptr->usr_channels = png_ptr->channels;
-
-   /* Pack the header information into the buffer */
-   png_save_uint_32(buf, width);
-   png_save_uint_32(buf + 4, height);
-   buf[8] = (png_byte)bit_depth;
-   buf[9] = (png_byte)color_type;
-   buf[10] = (png_byte)compression_type;
-   buf[11] = (png_byte)filter_type;
-   buf[12] = (png_byte)interlace_type;
-
-   /* Write the chunk */
-   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
-
-   /* Initialize zlib with PNG info */
-   png_ptr->zstream.zalloc = png_zalloc;
-   png_ptr->zstream.zfree = png_zfree;
-   png_ptr->zstream.opaque = (voidpf)png_ptr;
-   if (!(png_ptr->do_filter))
-   {
-      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-         png_ptr->bit_depth < 8)
-         png_ptr->do_filter = PNG_FILTER_NONE;
-      else
-         png_ptr->do_filter = PNG_ALL_FILTERS;
-   }
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY))
-   {
-      if (png_ptr->do_filter != PNG_FILTER_NONE)
-         png_ptr->zlib_strategy = Z_FILTERED;
-      else
-         png_ptr->zlib_strategy = Z_DEFAULT_STRATEGY;
-   }
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_LEVEL))
-      png_ptr->zlib_level = Z_DEFAULT_COMPRESSION;
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL))
-      png_ptr->zlib_mem_level = 8;
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS))
-      png_ptr->zlib_window_bits = 15;
-   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
-      png_ptr->zlib_method = 8;
-   ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
-         png_ptr->zlib_method, png_ptr->zlib_window_bits,
-         png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
-   if (ret != Z_OK)
-   {
-      if (ret == Z_VERSION_ERROR) png_error(png_ptr,
-          "zlib failed to initialize compressor -- version error");
-      if (ret == Z_STREAM_ERROR) png_error(png_ptr,
-           "zlib failed to initialize compressor -- stream error");
-      if (ret == Z_MEM_ERROR) png_error(png_ptr,
-           "zlib failed to initialize compressor -- mem error");
-      png_error(png_ptr, "zlib failed to initialize compressor");
-   }
-   png_ptr->zstream.next_out = png_ptr->zbuf;
-   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-   /* libpng is not interested in zstream.data_type */
-   /* Set it to a predefined value, to avoid its evaluation inside zlib */
-   png_ptr->zstream.data_type = Z_BINARY;
-
-   png_ptr->mode = PNG_HAVE_IHDR;
-}
-
-/* Write the palette.  We are careful not to trust png_color to be in the
- * correct order for PNG, so people can redefine it to any convenient
- * structure.
- */
-void /* PRIVATE */
-png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)
-{
-   PNG_PLTE;
-   png_uint_32 i;
-   png_colorp pal_ptr;
-   png_byte buf[3];
-
-   png_debug(1, "in png_write_PLTE");
-
-   if ((
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-        !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&
-#endif
-        num_pal == 0) || num_pal > 256)
-   {
-     if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-     {
-        png_error(png_ptr, "Invalid number of colors in palette");
-     }
-     else
-     {
-        png_warning(png_ptr, "Invalid number of colors in palette");
-        return;
-     }
-   }
-
-   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
-   {
-      png_warning(png_ptr,
-        "Ignoring request to write a PLTE chunk in grayscale PNG");
-      return;
-   }
-
-   png_ptr->num_palette = (png_uint_16)num_pal;
-   png_debug1(3, "num_palette = %d", png_ptr->num_palette);
-
-   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE,
-     (png_uint_32)(num_pal * 3));
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
-   {
-      buf[0] = pal_ptr->red;
-      buf[1] = pal_ptr->green;
-      buf[2] = pal_ptr->blue;
-      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
-   }
-#else
-   /* This is a little slower but some buggy compilers need to do this
-    * instead
-    */
-   pal_ptr=palette;
-   for (i = 0; i < num_pal; i++)
-   {
-      buf[0] = pal_ptr[i].red;
-      buf[1] = pal_ptr[i].green;
-      buf[2] = pal_ptr[i].blue;
-      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
-   }
-#endif
-   png_write_chunk_end(png_ptr);
-   png_ptr->mode |= PNG_HAVE_PLTE;
-}
-
-/* Write an IDAT chunk */
-void /* PRIVATE */
-png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   PNG_IDAT;
-
-   png_debug(1, "in png_write_IDAT");
-
-   /* Optimize the CMF field in the zlib stream. */
-   /* This hack of the zlib stream is compliant to the stream specification. */
-   if (!(png_ptr->mode & PNG_HAVE_IDAT) &&
-       png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
-   {
-      unsigned int z_cmf = data[0];  /* zlib compression method and flags */
-      if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
-      {
-         /* Avoid memory underflows and multiplication overflows.
-          *
-          * The conditions below are practically always satisfied;
-          * however, they still must be checked.
-          */
-         if (length >= 2 &&
-             png_ptr->height < 16384 && png_ptr->width < 16384)
-         {
-            png_uint_32 uncompressed_idat_size = png_ptr->height *
-               ((png_ptr->width *
-               png_ptr->channels * png_ptr->bit_depth + 15) >> 3);
-            unsigned int z_cinfo = z_cmf >> 4;
-            unsigned int half_z_window_size = 1 << (z_cinfo + 7);
-            while (uncompressed_idat_size <= half_z_window_size &&
-                   half_z_window_size >= 256)
-            {
-               z_cinfo--;
-               half_z_window_size >>= 1;
-            }
-            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);
-            if (data[0] != (png_byte)z_cmf)
-            {
-               data[0] = (png_byte)z_cmf;
-               data[1] &= 0xe0;
-               data[1] += (png_byte)(0x1f - ((z_cmf << 8) + data[1]) % 0x1f);
-            }
-         }
-      }
-      else
-         png_error(png_ptr,
-            "Invalid zlib compression method or flags in IDAT");
-   }
-
-   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
-   png_ptr->mode |= PNG_HAVE_IDAT;
-}
-
-/* Write an IEND chunk */
-void /* PRIVATE */
-png_write_IEND(png_structp png_ptr)
-{
-   PNG_IEND;
-
-   png_debug(1, "in png_write_IEND");
-
-   png_write_chunk(png_ptr, (png_bytep)png_IEND, NULL,
-     (png_size_t)0);
-   png_ptr->mode |= PNG_HAVE_IEND;
-}
-
-#ifdef PNG_WRITE_gAMA_SUPPORTED
-/* Write a gAMA chunk */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-void /* PRIVATE */
-png_write_gAMA(png_structp png_ptr, double file_gamma)
-{
-   PNG_gAMA;
-   png_uint_32 igamma;
-   png_byte buf[4];
-
-   png_debug(1, "in png_write_gAMA");
-
-   /* file_gamma is saved in 1/100,000ths */
-   igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
-   png_save_uint_32(buf, igamma);
-   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
-}
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-void /* PRIVATE */
-png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
-{
-   PNG_gAMA;
-   png_byte buf[4];
-
-   png_debug(1, "in png_write_gAMA");
-
-   /* file_gamma is saved in 1/100,000ths */
-   png_save_uint_32(buf, (png_uint_32)file_gamma);
-   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
-}
-#endif
-#endif
-
-#ifdef PNG_WRITE_sRGB_SUPPORTED
-/* Write a sRGB chunk */
-void /* PRIVATE */
-png_write_sRGB(png_structp png_ptr, int srgb_intent)
-{
-   PNG_sRGB;
-   png_byte buf[1];
-
-   png_debug(1, "in png_write_sRGB");
-
-   if (srgb_intent >= PNG_sRGB_INTENT_LAST)
-         png_warning(png_ptr,
-            "Invalid sRGB rendering intent specified");
-   buf[0]=(png_byte)srgb_intent;
-   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
-}
-#endif
-
-#ifdef PNG_WRITE_iCCP_SUPPORTED
-/* Write an iCCP chunk */
-void /* PRIVATE */
-png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
-   png_charp profile, int profile_len)
-{
-   PNG_iCCP;
-   png_size_t name_len;
-   png_charp new_name;
-   compression_state comp;
-   int embedded_profile_len = 0;
-
-   png_debug(1, "in png_write_iCCP");
-
-   comp.num_output_ptr = 0;
-   comp.max_output_ptr = 0;
-   comp.output_ptr = NULL;
-   comp.input = NULL;
-   comp.input_len = 0;
-
-   if ((name_len = png_check_keyword(png_ptr, name,
-      &new_name)) == 0)
-      return;
-
-   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
-      png_warning(png_ptr, "Unknown compression type in iCCP chunk");
-
-   if (profile == NULL)
-      profile_len = 0;
-
-   if (profile_len > 3)
-      embedded_profile_len =
-          ((*( (png_bytep)profile    ))<<24) |
-          ((*( (png_bytep)profile + 1))<<16) |
-          ((*( (png_bytep)profile + 2))<< 8) |
-          ((*( (png_bytep)profile + 3))    );
-
-   if (embedded_profile_len < 0)
-   {
-      png_warning(png_ptr,
-        "Embedded profile length in iCCP chunk is negative");
-      png_free(png_ptr, new_name);
-      return;
-   }
-
-   if (profile_len < embedded_profile_len)
-   {
-      png_warning(png_ptr,
-        "Embedded profile length too large in iCCP chunk");
-      png_free(png_ptr, new_name);
-      return;
-   }
-
-   if (profile_len > embedded_profile_len)
-   {
-      png_warning(png_ptr,
-        "Truncating profile to actual length in iCCP chunk");
-      profile_len = embedded_profile_len;
-   }
-
-   if (profile_len)
-      profile_len = png_text_compress(png_ptr, profile,
-        (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);
-
-   /* Make sure we include the NULL after the name and the compression type */
-   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
-          (png_uint_32)(name_len + profile_len + 2));
-   new_name[name_len + 1] = 0x00;
-   png_write_chunk_data(png_ptr, (png_bytep)new_name,
-     (png_size_t)(name_len + 2));
-
-   if (profile_len)
-      png_write_compressed_data_out(png_ptr, &comp);
-
-   png_write_chunk_end(png_ptr);
-   png_free(png_ptr, new_name);
-}
-#endif
-
-#ifdef PNG_WRITE_sPLT_SUPPORTED
-/* Write a sPLT chunk */
-void /* PRIVATE */
-png_write_sPLT(png_structp png_ptr, png_sPLT_tp spalette)
-{
-   PNG_sPLT;
-   png_size_t name_len;
-   png_charp new_name;
-   png_byte entrybuf[10];
-   png_size_t entry_size = (spalette->depth == 8 ? 6 : 10);
-   png_size_t palette_size = entry_size * spalette->nentries;
-   png_sPLT_entryp ep;
-#ifndef PNG_POINTER_INDEXING_SUPPORTED
-   int i;
-#endif
-
-   png_debug(1, "in png_write_sPLT");
-
-   if ((name_len = png_check_keyword(png_ptr,spalette->name, &new_name))==0)
-      return;
-
-   /* Make sure we include the NULL after the name */
-   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
-     (png_uint_32)(name_len + 2 + palette_size));
-   png_write_chunk_data(png_ptr, (png_bytep)new_name,
-     (png_size_t)(name_len + 1));
-   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, (png_size_t)1);
-
-   /* Loop through each palette entry, writing appropriately */
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
-   for (ep = spalette->entries; ep<spalette->entries + spalette->nentries; ep++)
-   {
-      if (spalette->depth == 8)
-      {
-          entrybuf[0] = (png_byte)ep->red;
-          entrybuf[1] = (png_byte)ep->green;
-          entrybuf[2] = (png_byte)ep->blue;
-          entrybuf[3] = (png_byte)ep->alpha;
-          png_save_uint_16(entrybuf + 4, ep->frequency);
-      }
-      else
-      {
-          png_save_uint_16(entrybuf + 0, ep->red);
-          png_save_uint_16(entrybuf + 2, ep->green);
-          png_save_uint_16(entrybuf + 4, ep->blue);
-          png_save_uint_16(entrybuf + 6, ep->alpha);
-          png_save_uint_16(entrybuf + 8, ep->frequency);
-      }
-      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
-   }
-#else
-   ep=spalette->entries;
-   for (i=0; i>spalette->nentries; i++)
-   {
-      if (spalette->depth == 8)
-      {
-          entrybuf[0] = (png_byte)ep[i].red;
-          entrybuf[1] = (png_byte)ep[i].green;
-          entrybuf[2] = (png_byte)ep[i].blue;
-          entrybuf[3] = (png_byte)ep[i].alpha;
-          png_save_uint_16(entrybuf + 4, ep[i].frequency);
-      }
-      else
-      {
-          png_save_uint_16(entrybuf + 0, ep[i].red);
-          png_save_uint_16(entrybuf + 2, ep[i].green);
-          png_save_uint_16(entrybuf + 4, ep[i].blue);
-          png_save_uint_16(entrybuf + 6, ep[i].alpha);
-          png_save_uint_16(entrybuf + 8, ep[i].frequency);
-      }
-      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
-   }
-#endif
-
-   png_write_chunk_end(png_ptr);
-   png_free(png_ptr, new_name);
-}
-#endif
-
-#ifdef PNG_WRITE_sBIT_SUPPORTED
-/* Write the sBIT chunk */
-void /* PRIVATE */
-png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
-{
-   PNG_sBIT;
-   png_byte buf[4];
-   png_size_t size;
-
-   png_debug(1, "in png_write_sBIT");
-
-   /* Make sure we don't depend upon the order of PNG_COLOR_8 */
-   if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      png_byte maxbits;
-
-      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
-                png_ptr->usr_bit_depth);
-      if (sbit->red == 0 || sbit->red > maxbits ||
-          sbit->green == 0 || sbit->green > maxbits ||
-          sbit->blue == 0 || sbit->blue > maxbits)
-      {
-         png_warning(png_ptr, "Invalid sBIT depth specified");
-         return;
-      }
-      buf[0] = sbit->red;
-      buf[1] = sbit->green;
-      buf[2] = sbit->blue;
-      size = 3;
-   }
-   else
-   {
-      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
-      {
-         png_warning(png_ptr, "Invalid sBIT depth specified");
-         return;
-      }
-      buf[0] = sbit->gray;
-      size = 1;
-   }
-
-   if (color_type & PNG_COLOR_MASK_ALPHA)
-   {
-      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
-      {
-         png_warning(png_ptr, "Invalid sBIT depth specified");
-         return;
-      }
-      buf[size++] = sbit->alpha;
-   }
-
-   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
-}
-#endif
-
-#ifdef PNG_WRITE_cHRM_SUPPORTED
-/* Write the cHRM chunk */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-void /* PRIVATE */
-png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
-   double red_x, double red_y, double green_x, double green_y,
-   double blue_x, double blue_y)
-{
-   PNG_cHRM;
-   png_byte buf[32];
-
-   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y,
-      int_green_x, int_green_y, int_blue_x, int_blue_y;
-
-   png_debug(1, "in png_write_cHRM");
-
-   int_white_x = (png_uint_32)(white_x * 100000.0 + 0.5);
-   int_white_y = (png_uint_32)(white_y * 100000.0 + 0.5);
-   int_red_x   = (png_uint_32)(red_x   * 100000.0 + 0.5);
-   int_red_y   = (png_uint_32)(red_y   * 100000.0 + 0.5);
-   int_green_x = (png_uint_32)(green_x * 100000.0 + 0.5);
-   int_green_y = (png_uint_32)(green_y * 100000.0 + 0.5);
-   int_blue_x  = (png_uint_32)(blue_x  * 100000.0 + 0.5);
-   int_blue_y  = (png_uint_32)(blue_y  * 100000.0 + 0.5);
-
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-   if (png_check_cHRM_fixed(png_ptr, int_white_x, int_white_y,
-      int_red_x, int_red_y, int_green_x, int_green_y, int_blue_x, int_blue_y))
-#endif
-   {
-      /* Each value is saved in 1/100,000ths */
-
-      png_save_uint_32(buf, int_white_x);
-      png_save_uint_32(buf + 4, int_white_y);
-
-      png_save_uint_32(buf + 8, int_red_x);
-      png_save_uint_32(buf + 12, int_red_y);
-
-      png_save_uint_32(buf + 16, int_green_x);
-      png_save_uint_32(buf + 20, int_green_y);
-
-      png_save_uint_32(buf + 24, int_blue_x);
-      png_save_uint_32(buf + 28, int_blue_y);
-
-      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
-   }
-}
-#endif
-#ifdef PNG_FIXED_POINT_SUPPORTED
-void /* PRIVATE */
-png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
-   png_fixed_point white_y, png_fixed_point red_x, png_fixed_point red_y,
-   png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,
-   png_fixed_point blue_y)
-{
-   PNG_cHRM;
-   png_byte buf[32];
-
-   png_debug(1, "in png_write_cHRM");
-
-   /* Each value is saved in 1/100,000ths */
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-   if (png_check_cHRM_fixed(png_ptr, white_x, white_y, red_x, red_y,
-      green_x, green_y, blue_x, blue_y))
-#endif
-   {
-      png_save_uint_32(buf, (png_uint_32)white_x);
-      png_save_uint_32(buf + 4, (png_uint_32)white_y);
-
-      png_save_uint_32(buf + 8, (png_uint_32)red_x);
-      png_save_uint_32(buf + 12, (png_uint_32)red_y);
-
-      png_save_uint_32(buf + 16, (png_uint_32)green_x);
-      png_save_uint_32(buf + 20, (png_uint_32)green_y);
-
-      png_save_uint_32(buf + 24, (png_uint_32)blue_x);
-      png_save_uint_32(buf + 28, (png_uint_32)blue_y);
-
-      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
-   }
-}
-#endif
-#endif
-
-#ifdef PNG_WRITE_tRNS_SUPPORTED
-/* Write the tRNS chunk */
-void /* PRIVATE */
-png_write_tRNS(png_structp png_ptr, png_bytep trans_alpha, png_color_16p tran,
-   int num_trans, int color_type)
-{
-   PNG_tRNS;
-   png_byte buf[6];
-
-   png_debug(1, "in png_write_tRNS");
-
-   if (color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
-      {
-         png_warning(png_ptr, "Invalid number of transparent colors specified");
-         return;
-      }
-      /* Write the chunk out as it is */
-      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans_alpha,
-        (png_size_t)num_trans);
-   }
-   else if (color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      /* One 16 bit value */
-      if (tran->gray >= (1 << png_ptr->bit_depth))
-      {
-         png_warning(png_ptr,
-           "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
-         return;
-      }
-      png_save_uint_16(buf, tran->gray);
-      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
-   }
-   else if (color_type == PNG_COLOR_TYPE_RGB)
-   {
-      /* Three 16 bit values */
-      png_save_uint_16(buf, tran->red);
-      png_save_uint_16(buf + 2, tran->green);
-      png_save_uint_16(buf + 4, tran->blue);
-      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
-      {
-         png_warning(png_ptr,
-           "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
-         return;
-      }
-      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
-   }
-   else
-   {
-      png_warning(png_ptr, "Can't write tRNS with an alpha channel");
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_bKGD_SUPPORTED
-/* Write the background chunk */
-void /* PRIVATE */
-png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
-{
-   PNG_bKGD;
-   png_byte buf[6];
-
-   png_debug(1, "in png_write_bKGD");
-
-   if (color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-          (png_ptr->num_palette ||
-          (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&
-#endif
-         back->index >= png_ptr->num_palette)
-      {
-         png_warning(png_ptr, "Invalid background palette index");
-         return;
-      }
-      buf[0] = back->index;
-      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
-   }
-   else if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      png_save_uint_16(buf, back->red);
-      png_save_uint_16(buf + 2, back->green);
-      png_save_uint_16(buf + 4, back->blue);
-      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
-      {
-         png_warning(png_ptr,
-           "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
-         return;
-      }
-      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
-   }
-   else
-   {
-      if (back->gray >= (1 << png_ptr->bit_depth))
-      {
-         png_warning(png_ptr,
-           "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
-         return;
-      }
-      png_save_uint_16(buf, back->gray);
-      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_hIST_SUPPORTED
-/* Write the histogram */
-void /* PRIVATE */
-png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
-{
-   PNG_hIST;
-   int i;
-   png_byte buf[3];
-
-   png_debug(1, "in png_write_hIST");
-
-   if (num_hist > (int)png_ptr->num_palette)
-   {
-      png_debug2(3, "num_hist = %d, num_palette = %d", num_hist,
-         png_ptr->num_palette);
-      png_warning(png_ptr, "Invalid number of histogram entries specified");
-      return;
-   }
-
-   png_write_chunk_start(png_ptr, (png_bytep)png_hIST,
-     (png_uint_32)(num_hist * 2));
-   for (i = 0; i < num_hist; i++)
-   {
-      png_save_uint_16(buf, hist[i]);
-      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
-   }
-   png_write_chunk_end(png_ptr);
-}
-#endif
-
-#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
-    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
-/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
- * and if invalid, correct the keyword rather than discarding the entire
- * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
- * length, forbids leading or trailing whitespace, multiple internal spaces,
- * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
- *
- * The new_key is allocated to hold the corrected keyword and must be freed
- * by the calling routine.  This avoids problems with trying to write to
- * static keywords without having to have duplicate copies of the strings.
- */
-png_size_t /* PRIVATE */
-png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
-{
-   png_size_t key_len;
-   png_charp kp, dp;
-   int kflag;
-   int kwarn=0;
-
-   png_debug(1, "in png_check_keyword");
-
-   *new_key = NULL;
-
-   if (key == NULL || (key_len = png_strlen(key)) == 0)
-   {
-      png_warning(png_ptr, "zero length keyword");
-      return ((png_size_t)0);
-   }
-
-   png_debug1(2, "Keyword to be checked is '%s'", key);
-
-   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));
-   if (*new_key == NULL)
-   {
-      png_warning(png_ptr, "Out of memory while procesing keyword");
-      return ((png_size_t)0);
-   }
-
-   /* Replace non-printing characters with a blank and print a warning */
-   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
-   {
-      if ((png_byte)*kp < 0x20 ||
-         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
-      {
-#ifdef PNG_STDIO_SUPPORTED
-         char msg[40];
-
-         png_snprintf(msg, 40,
-           "invalid keyword character 0x%02X", (png_byte)*kp);
-         png_warning(png_ptr, msg);
-#else
-         png_warning(png_ptr, "invalid character in keyword");
-#endif
-         *dp = ' ';
-      }
-      else
-      {
-         *dp = *kp;
-      }
-   }
-   *dp = '\0';
-
-   /* Remove any trailing white space. */
-   kp = *new_key + key_len - 1;
-   if (*kp == ' ')
-   {
-      png_warning(png_ptr, "trailing spaces removed from keyword");
-
-      while (*kp == ' ')
-      {
-         *(kp--) = '\0';
-         key_len--;
-      }
-   }
-
-   /* Remove any leading white space. */
-   kp = *new_key;
-   if (*kp == ' ')
-   {
-      png_warning(png_ptr, "leading spaces removed from keyword");
-
-      while (*kp == ' ')
-      {
-         kp++;
-         key_len--;
-      }
-   }
-
-   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);
-
-   /* Remove multiple internal spaces. */
-   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
-   {
-      if (*kp == ' ' && kflag == 0)
-      {
-         *(dp++) = *kp;
-         kflag = 1;
-      }
-      else if (*kp == ' ')
-      {
-         key_len--;
-         kwarn=1;
-      }
-      else
-      {
-         *(dp++) = *kp;
-         kflag = 0;
-      }
-   }
-   *dp = '\0';
-   if (kwarn)
-      png_warning(png_ptr, "extra interior spaces removed from keyword");
-
-   if (key_len == 0)
-   {
-      png_free(png_ptr, *new_key);
-      png_warning(png_ptr, "Zero length keyword");
-   }
-
-   if (key_len > 79)
-   {
-      png_warning(png_ptr, "keyword length must be 1 - 79 characters");
-      (*new_key)[79] = '\0';
-      key_len = 79;
-   }
-
-   return (key_len);
-}
-#endif
-
-#ifdef PNG_WRITE_tEXt_SUPPORTED
-/* Write a tEXt chunk */
-void /* PRIVATE */
-png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
-   png_size_t text_len)
-{
-   PNG_tEXt;
-   png_size_t key_len;
-   png_charp new_key;
-
-   png_debug(1, "in png_write_tEXt");
-
-   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
-      return;
-
-   if (text == NULL || *text == '\0')
-      text_len = 0;
-   else
-      text_len = png_strlen(text);
-
-   /* Make sure we include the 0 after the key */
-   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt,
-      (png_uint_32)(key_len + text_len + 1));
-   /*
-    * We leave it to the application to meet PNG-1.0 requirements on the
-    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
-    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
-    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
-    */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key,
-     (png_size_t)(key_len + 1));
-   if (text_len)
-      png_write_chunk_data(png_ptr, (png_bytep)text, (png_size_t)text_len);
-
-   png_write_chunk_end(png_ptr);
-   png_free(png_ptr, new_key);
-}
-#endif
-
-#ifdef PNG_WRITE_zTXt_SUPPORTED
-/* Write a compressed text chunk */
-void /* PRIVATE */
-png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
-   png_size_t text_len, int compression)
-{
-   PNG_zTXt;
-   png_size_t key_len;
-   char buf[1];
-   png_charp new_key;
-   compression_state comp;
-
-   png_debug(1, "in png_write_zTXt");
-
-   comp.num_output_ptr = 0;
-   comp.max_output_ptr = 0;
-   comp.output_ptr = NULL;
-   comp.input = NULL;
-   comp.input_len = 0;
-
-   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
-   {
-      png_free(png_ptr, new_key);
-      return;
-   }
-
-   if (text == NULL || *text == '\0' || compression==PNG_TEXT_COMPRESSION_NONE)
-   {
-      png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
-      png_free(png_ptr, new_key);
-      return;
-   }
-
-   text_len = png_strlen(text);
-
-   /* Compute the compressed data; do it now for the length */
-   text_len = png_text_compress(png_ptr, text, text_len, compression,
-       &comp);
-
-   /* Write start of chunk */
-   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt,
-     (png_uint_32)(key_len+text_len + 2));
-   /* Write key */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key,
-     (png_size_t)(key_len + 1));
-   png_free(png_ptr, new_key);
-
-   buf[0] = (png_byte)compression;
-   /* Write compression */
-   png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);
-   /* Write the compressed data */
-   png_write_compressed_data_out(png_ptr, &comp);
-
-   /* Close the chunk */
-   png_write_chunk_end(png_ptr);
-}
-#endif
-
-#ifdef PNG_WRITE_iTXt_SUPPORTED
-/* Write an iTXt chunk */
-void /* PRIVATE */
-png_write_iTXt(png_structp png_ptr, int compression, png_charp key,
-    png_charp lang, png_charp lang_key, png_charp text)
-{
-   PNG_iTXt;
-   png_size_t lang_len, key_len, lang_key_len, text_len;
-   png_charp new_lang;
-   png_charp new_key = NULL;
-   png_byte cbuf[2];
-   compression_state comp;
-
-   png_debug(1, "in png_write_iTXt");
-
-   comp.num_output_ptr = 0;
-   comp.max_output_ptr = 0;
-   comp.output_ptr = NULL;
-   comp.input = NULL;
-
-   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
-      return;
-
-   if ((lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
-   {
-      png_warning(png_ptr, "Empty language field in iTXt chunk");
-      new_lang = NULL;
-      lang_len = 0;
-   }
-
-   if (lang_key == NULL)
-      lang_key_len = 0;
-   else
-      lang_key_len = png_strlen(lang_key);
-
-   if (text == NULL)
-      text_len = 0;
-   else
-      text_len = png_strlen(text);
-
-   /* Compute the compressed data; do it now for the length */
-   text_len = png_text_compress(png_ptr, text, text_len, compression-2,
-      &comp);
-
-
-   /* Make sure we include the compression flag, the compression byte,
-    * and the NULs after the key, lang, and lang_key parts */
-
-   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
-          (png_uint_32)(
-        5 /* comp byte, comp flag, terminators for key, lang and lang_key */
-        + key_len
-        + lang_len
-        + lang_key_len
-        + text_len));
-
-   /* We leave it to the application to meet PNG-1.0 requirements on the
-    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
-    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
-    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
-    */
-   png_write_chunk_data(png_ptr, (png_bytep)new_key,
-     (png_size_t)(key_len + 1));
-
-   /* Set the compression flag */
-   if (compression == PNG_ITXT_COMPRESSION_NONE || \
-       compression == PNG_TEXT_COMPRESSION_NONE)
-       cbuf[0] = 0;
-   else /* compression == PNG_ITXT_COMPRESSION_zTXt */
-       cbuf[0] = 1;
-   /* Set the compression method */
-   cbuf[1] = 0;
-   png_write_chunk_data(png_ptr, cbuf, (png_size_t)2);
-
-   cbuf[0] = 0;
-   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf),
-     (png_size_t)(lang_len + 1));
-   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf),
-     (png_size_t)(lang_key_len + 1));
-   png_write_compressed_data_out(png_ptr, &comp);
-
-   png_write_chunk_end(png_ptr);
-   png_free(png_ptr, new_key);
-   png_free(png_ptr, new_lang);
-}
-#endif
-
-#ifdef PNG_WRITE_oFFs_SUPPORTED
-/* Write the oFFs chunk */
-void /* PRIVATE */
-png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
-   int unit_type)
-{
-   PNG_oFFs;
-   png_byte buf[9];
-
-   png_debug(1, "in png_write_oFFs");
-
-   if (unit_type >= PNG_OFFSET_LAST)
-      png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");
-
-   png_save_int_32(buf, x_offset);
-   png_save_int_32(buf + 4, y_offset);
-   buf[8] = (png_byte)unit_type;
-
-   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
-}
-#endif
-#ifdef PNG_WRITE_pCAL_SUPPORTED
-/* Write the pCAL chunk (described in the PNG extensions document) */
-void /* PRIVATE */
-png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
-   png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
-{
-   PNG_pCAL;
-   png_size_t purpose_len, units_len, total_len;
-   png_uint_32p params_len;
-   png_byte buf[10];
-   png_charp new_purpose;
-   int i;
-
-   png_debug1(1, "in png_write_pCAL (%d parameters)", nparams);
-
-   if (type >= PNG_EQUATION_LAST)
-      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
-
-   purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
-   png_debug1(3, "pCAL purpose length = %d", (int)purpose_len);
-   units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
-   png_debug1(3, "pCAL units length = %d", (int)units_len);
-   total_len = purpose_len + units_len + 10;
-
-   params_len = (png_uint_32p)png_malloc(png_ptr,
-      (png_alloc_size_t)(nparams * png_sizeof(png_uint_32)));
-
-   /* Find the length of each parameter, making sure we don't count the
-      null terminator for the last parameter. */
-   for (i = 0; i < nparams; i++)
-   {
-      params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
-      png_debug2(3, "pCAL parameter %d length = %lu", i,
-        (unsigned long) params_len[i]);
-      total_len += (png_size_t)params_len[i];
-   }
-
-   png_debug1(3, "pCAL total length = %d", (int)total_len);
-   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
-   png_write_chunk_data(png_ptr, (png_bytep)new_purpose,
-     (png_size_t)purpose_len);
-   png_save_int_32(buf, X0);
-   png_save_int_32(buf + 4, X1);
-   buf[8] = (png_byte)type;
-   buf[9] = (png_byte)nparams;
-   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
-   png_write_chunk_data(png_ptr, (png_bytep)units, (png_size_t)units_len);
-
-   png_free(png_ptr, new_purpose);
-
-   for (i = 0; i < nparams; i++)
-   {
-      png_write_chunk_data(png_ptr, (png_bytep)params[i],
-         (png_size_t)params_len[i]);
-   }
-
-   png_free(png_ptr, params_len);
-   png_write_chunk_end(png_ptr);
-}
-#endif
-
-#ifdef PNG_WRITE_sCAL_SUPPORTED
-/* Write the sCAL chunk */
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
-void /* PRIVATE */
-png_write_sCAL(png_structp png_ptr, int unit, double width, double height)
-{
-   PNG_sCAL;
-   char buf[64];
-   png_size_t total_len;
-
-   png_debug(1, "in png_write_sCAL");
-
-   buf[0] = (char)unit;
-   png_snprintf(buf + 1, 63, "%12.12e", width);
-   total_len = 1 + png_strlen(buf + 1) + 1;
-   png_snprintf(buf + total_len, 64-total_len, "%12.12e", height);
-   total_len += png_strlen(buf + total_len);
-
-   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
-   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
-}
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-void /* PRIVATE */
-png_write_sCAL_s(png_structp png_ptr, int unit, png_charp width,
-   png_charp height)
-{
-   PNG_sCAL;
-   png_byte buf[64];
-   png_size_t wlen, hlen, total_len;
-
-   png_debug(1, "in png_write_sCAL_s");
-
-   wlen = png_strlen(width);
-   hlen = png_strlen(height);
-   total_len = wlen + hlen + 2;
-   if (total_len > 64)
-   {
-      png_warning(png_ptr, "Can't write sCAL (buffer too small)");
-      return;
-   }
-
-   buf[0] = (png_byte)unit;
-   png_memcpy(buf + 1, width, wlen + 1);      /* Append the '\0' here */
-   png_memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */
-
-   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
-   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
-}
-#endif
-#endif
-#endif
-
-#ifdef PNG_WRITE_pHYs_SUPPORTED
-/* Write the pHYs chunk */
-void /* PRIVATE */
-png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
-   png_uint_32 y_pixels_per_unit,
-   int unit_type)
-{
-   PNG_pHYs;
-   png_byte buf[9];
-
-   png_debug(1, "in png_write_pHYs");
-
-   if (unit_type >= PNG_RESOLUTION_LAST)
-      png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");
-
-   png_save_uint_32(buf, x_pixels_per_unit);
-   png_save_uint_32(buf + 4, y_pixels_per_unit);
-   buf[8] = (png_byte)unit_type;
-
-   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
-}
-#endif
-
-#ifdef PNG_WRITE_tIME_SUPPORTED
-/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
- * or png_convert_from_time_t(), or fill in the structure yourself.
- */
-void /* PRIVATE */
-png_write_tIME(png_structp png_ptr, png_timep mod_time)
-{
-   PNG_tIME;
-   png_byte buf[7];
-
-   png_debug(1, "in png_write_tIME");
-
-   if (mod_time->month  > 12 || mod_time->month  < 1 ||
-       mod_time->day    > 31 || mod_time->day    < 1 ||
-       mod_time->hour   > 23 || mod_time->second > 60)
-   {
-      png_warning(png_ptr, "Invalid time specified for tIME chunk");
-      return;
-   }
-
-   png_save_uint_16(buf, mod_time->year);
-   buf[2] = mod_time->month;
-   buf[3] = mod_time->day;
-   buf[4] = mod_time->hour;
-   buf[5] = mod_time->minute;
-   buf[6] = mod_time->second;
-
-   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
-}
-#endif
-
-/* Initializes the row writing capability of libpng */
-void /* PRIVATE */
-png_write_start_row(png_structp png_ptr)
-{
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   /* Start of interlace block in the y direction */
-   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
-
-   /* Offset to next interlace block in the y direction */
-   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-#endif
-
-   png_size_t buf_size;
-
-   png_debug(1, "in png_write_start_row");
-
-   buf_size = (png_size_t)(PNG_ROWBYTES(
-      png_ptr->usr_channels*png_ptr->usr_bit_depth, png_ptr->width) + 1);
-
-   /* Set up row buffer */
-   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr,
-     (png_alloc_size_t)buf_size);
-   png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;
-
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-   /* Set up filtering buffer, if using this filter */
-   if (png_ptr->do_filter & PNG_FILTER_SUB)
-   {
-      png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
-         (png_alloc_size_t)(png_ptr->rowbytes + 1));
-      png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
-   }
-
-   /* We only need to keep the previous row if we are using one of these. */
-   if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
-   {
-      /* Set up previous row buffer */
-      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr,
-         (png_alloc_size_t)buf_size);
-
-      if (png_ptr->do_filter & PNG_FILTER_UP)
-      {
-         png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
-            (png_size_t)(png_ptr->rowbytes + 1));
-         png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
-      }
-
-      if (png_ptr->do_filter & PNG_FILTER_AVG)
-      {
-         png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
-            (png_alloc_size_t)(png_ptr->rowbytes + 1));
-         png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
-      }
-
-      if (png_ptr->do_filter & PNG_FILTER_PAETH)
-      {
-         png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
-            (png_size_t)(png_ptr->rowbytes + 1));
-         png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
-      }
-   }
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* If interlaced, we need to set up width and height of pass */
-   if (png_ptr->interlaced)
-   {
-      if (!(png_ptr->transformations & PNG_INTERLACE))
-      {
-         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
-            png_pass_ystart[0]) / png_pass_yinc[0];
-         png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
-            png_pass_start[0]) / png_pass_inc[0];
-      }
-      else
-      {
-         png_ptr->num_rows = png_ptr->height;
-         png_ptr->usr_width = png_ptr->width;
-      }
-   }
-   else
-#endif
-   {
-      png_ptr->num_rows = png_ptr->height;
-      png_ptr->usr_width = png_ptr->width;
-   }
-   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-   png_ptr->zstream.next_out = png_ptr->zbuf;
-}
-
-/* Internal use only.  Called when finished processing a row of data. */
-void /* PRIVATE */
-png_write_finish_row(png_structp png_ptr)
-{
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   /* Start of interlace block in the y direction */
-   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
-
-   /* Offset to next interlace block in the y direction */
-   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-#endif
-
-   int ret;
-
-   png_debug(1, "in png_write_finish_row");
-
-   /* Next row */
-   png_ptr->row_number++;
-
-   /* See if we are done */
-   if (png_ptr->row_number < png_ptr->num_rows)
-      return;
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-   /* If interlaced, go to next pass */
-   if (png_ptr->interlaced)
-   {
-      png_ptr->row_number = 0;
-      if (png_ptr->transformations & PNG_INTERLACE)
-      {
-         png_ptr->pass++;
-      }
-      else
-      {
-         /* Loop until we find a non-zero width or height pass */
-         do
-         {
-            png_ptr->pass++;
-            if (png_ptr->pass >= 7)
-               break;
-            png_ptr->usr_width = (png_ptr->width +
-               png_pass_inc[png_ptr->pass] - 1 -
-               png_pass_start[png_ptr->pass]) /
-               png_pass_inc[png_ptr->pass];
-            png_ptr->num_rows = (png_ptr->height +
-               png_pass_yinc[png_ptr->pass] - 1 -
-               png_pass_ystart[png_ptr->pass]) /
-               png_pass_yinc[png_ptr->pass];
-            if (png_ptr->transformations & PNG_INTERLACE)
-               break;
-         } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);
-
-      }
-
-      /* Reset the row above the image for the next pass */
-      if (png_ptr->pass < 7)
-      {
-         if (png_ptr->prev_row != NULL)
-            png_memset(png_ptr->prev_row, 0,
-               (png_size_t)(PNG_ROWBYTES(png_ptr->usr_channels*
-               png_ptr->usr_bit_depth, png_ptr->width)) + 1);
-         return;
-      }
-   }
-#endif
-
-   /* If we get here, we've just written the last row, so we need
-      to flush the compressor */
-   do
-   {
-      /* Tell the compressor we are done */
-      ret = deflate(&png_ptr->zstream, Z_FINISH);
-      /* Check for an error */
-      if (ret == Z_OK)
-      {
-         /* Check to see if we need more room */
-         if (!(png_ptr->zstream.avail_out))
-         {
-            png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
-            png_ptr->zstream.next_out = png_ptr->zbuf;
-            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-         }
-      }
-      else if (ret != Z_STREAM_END)
-      {
-         if (png_ptr->zstream.msg != NULL)
-            png_error(png_ptr, png_ptr->zstream.msg);
-         else
-            png_error(png_ptr, "zlib error");
-      }
-   } while (ret != Z_STREAM_END);
-
-   /* Write any extra space */
-   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
-   {
-      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
-         png_ptr->zstream.avail_out);
-   }
-
-   deflateReset(&png_ptr->zstream);
-   png_ptr->zstream.data_type = Z_BINARY;
-}
-
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-/* Pick out the correct pixels for the interlace pass.
- * The basic idea here is to go through the row with a source
- * pointer and a destination pointer (sp and dp), and copy the
- * correct pixels for the pass.  As the row gets compacted,
- * sp will always be >= dp, so we should never overwrite anything.
- * See the default: case for the easiest code to understand.
- */
-void /* PRIVATE */
-png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
-{
-   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
-
-   /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
-
-   /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
-
-   png_debug(1, "in png_do_write_interlace");
-
-   /* We don't have to do anything on the last pass (6) */
-   if (pass < 6)
-   {
-      /* Each pixel depth is handled separately */
-      switch (row_info->pixel_depth)
-      {
-         case 1:
-         {
-            png_bytep sp;
-            png_bytep dp;
-            int shift;
-            int d;
-            int value;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            dp = row;
-            d = 0;
-            shift = 7;
-            for (i = png_pass_start[pass]; i < row_width;
-               i += png_pass_inc[pass])
-            {
-               sp = row + (png_size_t)(i >> 3);
-               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
-               d |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 7;
-                  *dp++ = (png_byte)d;
-                  d = 0;
-               }
-               else
-                  shift--;
-
-            }
-            if (shift != 7)
-               *dp = (png_byte)d;
-            break;
-         }
-         case 2:
-         {
-            png_bytep sp;
-            png_bytep dp;
-            int shift;
-            int d;
-            int value;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            dp = row;
-            shift = 6;
-            d = 0;
-            for (i = png_pass_start[pass]; i < row_width;
-               i += png_pass_inc[pass])
-            {
-               sp = row + (png_size_t)(i >> 2);
-               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
-               d |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 6;
-                  *dp++ = (png_byte)d;
-                  d = 0;
-               }
-               else
-                  shift -= 2;
-            }
-            if (shift != 6)
-                   *dp = (png_byte)d;
-            break;
-         }
-         case 4:
-         {
-            png_bytep sp;
-            png_bytep dp;
-            int shift;
-            int d;
-            int value;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            dp = row;
-            shift = 4;
-            d = 0;
-            for (i = png_pass_start[pass]; i < row_width;
-               i += png_pass_inc[pass])
-            {
-               sp = row + (png_size_t)(i >> 1);
-               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
-               d |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 4;
-                  *dp++ = (png_byte)d;
-                  d = 0;
-               }
-               else
-                  shift -= 4;
-            }
-            if (shift != 4)
-               *dp = (png_byte)d;
-            break;
-         }
-         default:
-         {
-            png_bytep sp;
-            png_bytep dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-            png_size_t pixel_bytes;
-
-            /* Start at the beginning */
-            dp = row;
-            /* Find out how many bytes each pixel takes up */
-            pixel_bytes = (row_info->pixel_depth >> 3);
-            /* Loop through the row, only looking at the pixels that
-               matter */
-            for (i = png_pass_start[pass]; i < row_width;
-               i += png_pass_inc[pass])
-            {
-               /* Find out where the original pixel is */
-               sp = row + (png_size_t)i * pixel_bytes;
-               /* Move the pixel */
-               if (dp != sp)
-                  png_memcpy(dp, sp, pixel_bytes);
-               /* Next pixel */
-               dp += pixel_bytes;
-            }
-            break;
-         }
-      }
-      /* Set new row width */
-      row_info->width = (row_info->width +
-         png_pass_inc[pass] - 1 -
-         png_pass_start[pass]) /
-         png_pass_inc[pass];
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-            row_info->width);
-   }
-}
-#endif
-
-/* This filters the row, chooses which filter to use, if it has not already
- * been specified by the application, and then writes the row out with the
- * chosen filter.
- */
-#define PNG_MAXSUM (((png_uint_32)(-1)) >> 1)
-#define PNG_HISHIFT 10
-#define PNG_LOMASK ((png_uint_32)0xffffL)
-#define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
-void /* PRIVATE */
-png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
-{
-   png_bytep best_row;
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-   png_bytep prev_row, row_buf;
-   png_uint_32 mins, bpp;
-   png_byte filter_to_do = png_ptr->do_filter;
-   png_uint_32 row_bytes = row_info->rowbytes;
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   int num_p_filters = (int)png_ptr->num_prev_filters;
-#endif
-
-   png_debug(1, "in png_write_find_filter");
-
-#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)
-  {
-      /* These will never be selected so we need not test them. */
-      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);
-  }
-#endif
-
-   /* Find out how many bytes offset each pixel is */
-   bpp = (row_info->pixel_depth + 7) >> 3;
-
-   prev_row = png_ptr->prev_row;
-#endif
-   best_row = png_ptr->row_buf;
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-   row_buf = best_row;
-   mins = PNG_MAXSUM;
-
-   /* The prediction method we use is to find which method provides the
-    * smallest value when summing the absolute values of the distances
-    * from zero, using anything >= 128 as negative numbers.  This is known
-    * as the "minimum sum of absolute differences" heuristic.  Other
-    * heuristics are the "weighted minimum sum of absolute differences"
-    * (experimental and can in theory improve compression), and the "zlib
-    * predictive" method (not implemented yet), which does test compressions
-    * of lines using different filter methods, and then chooses the
-    * (series of) filter(s) that give minimum compressed data size (VERY
-    * computationally expensive).
-    *
-    * GRR 980525:  consider also
-    *   (1) minimum sum of absolute differences from running average (i.e.,
-    *       keep running sum of non-absolute differences & count of bytes)
-    *       [track dispersion, too?  restart average if dispersion too large?]
-    *  (1b) minimum sum of absolute differences from sliding average, probably
-    *       with window size <= deflate window (usually 32K)
-    *   (2) minimum sum of squared differences from zero or running average
-    *       (i.e., ~ root-mean-square approach)
-    */
-
-
-   /* We don't need to test the 'no filter' case if this is the only filter
-    * that has been chosen, as it doesn't actually do anything to the data.
-    */
-   if ((filter_to_do & PNG_FILTER_NONE) &&
-       filter_to_do != PNG_FILTER_NONE)
-   {
-      png_bytep rp;
-      png_uint_32 sum = 0;
-      png_uint_32 i;
-      int v;
-
-      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
-      {
-         v = *rp;
-         sum += (v < 128) ? v : 256 - v;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         png_uint_32 sumhi, sumlo;
-         int j;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */
-
-         /* Reduce the sum if we match any of the previous rows */
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         /* Factor in the cost of this filter (this is here for completeness,
-          * but it makes no sense to have a "cost" for the NONE filter, as
-          * it has the minimum possible computational cost - none).
-          */
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-      mins = sum;
-   }
-
-   /* Sub filter */
-   if (filter_to_do == PNG_FILTER_SUB)
-   /* It's the only filter so no testing is needed */
-   {
-      png_bytep rp, lp, dp;
-      png_uint_32 i;
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
-           i++, rp++, dp++)
-      {
-         *dp = *rp;
-      }
-      for (lp = row_buf + 1; i < row_bytes;
-         i++, rp++, lp++, dp++)
-      {
-         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
-      }
-      best_row = png_ptr->sub_row;
-   }
-
-   else if (filter_to_do & PNG_FILTER_SUB)
-   {
-      png_bytep rp, dp, lp;
-      png_uint_32 sum = 0, lmins = mins;
-      png_uint_32 i;
-      int v;
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      /* We temporarily increase the "minimum sum" by the factor we
-       * would reduce the sum of this filter, so that we can do the
-       * early exit comparison without scaling the sum each time.
-       */
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
-           i++, rp++, dp++)
-      {
-         v = *dp = *rp;
-
-         sum += (v < 128) ? v : 256 - v;
-      }
-      for (lp = row_buf + 1; i < row_bytes;
-         i++, rp++, lp++, dp++)
-      {
-         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
-      if (sum < mins)
-      {
-         mins = sum;
-         best_row = png_ptr->sub_row;
-      }
-   }
-
-   /* Up filter */
-   if (filter_to_do == PNG_FILTER_UP)
-   {
-      png_bytep rp, dp, pp;
-      png_uint_32 i;
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
-           pp = prev_row + 1; i < row_bytes;
-           i++, rp++, pp++, dp++)
-      {
-         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
-      }
-      best_row = png_ptr->up_row;
-   }
-
-   else if (filter_to_do & PNG_FILTER_UP)
-   {
-      png_bytep rp, dp, pp;
-      png_uint_32 sum = 0, lmins = mins;
-      png_uint_32 i;
-      int v;
-
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
-           pp = prev_row + 1; i < row_bytes; i++)
-      {
-         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
-      if (sum < mins)
-      {
-         mins = sum;
-         best_row = png_ptr->up_row;
-      }
-   }
-
-   /* Avg filter */
-   if (filter_to_do == PNG_FILTER_AVG)
-   {
-      png_bytep rp, dp, pp, lp;
-      png_uint_32 i;
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
-           pp = prev_row + 1; i < bpp; i++)
-      {
-         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
-      }
-      for (lp = row_buf + 1; i < row_bytes; i++)
-      {
-         *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
-                 & 0xff);
-      }
-      best_row = png_ptr->avg_row;
-   }
-
-   else if (filter_to_do & PNG_FILTER_AVG)
-   {
-      png_bytep rp, dp, pp, lp;
-      png_uint_32 sum = 0, lmins = mins;
-      png_uint_32 i;
-      int v;
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
-           pp = prev_row + 1; i < bpp; i++)
-      {
-         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-      }
-      for (lp = row_buf + 1; i < row_bytes; i++)
-      {
-         v = *dp++ =
-          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
-      if (sum < mins)
-      {
-         mins = sum;
-         best_row = png_ptr->avg_row;
-      }
-   }
-
-   /* Paeth filter */
-   if (filter_to_do == PNG_FILTER_PAETH)
-   {
-      png_bytep rp, dp, pp, cp, lp;
-      png_uint_32 i;
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
-           pp = prev_row + 1; i < bpp; i++)
-      {
-         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
-      }
-
-      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
-      {
-         int a, b, c, pa, pb, pc, p;
-
-         b = *pp++;
-         c = *cp++;
-         a = *lp++;
-
-         p = b - c;
-         pc = a - c;
-
-#ifdef PNG_USE_ABS
-         pa = abs(p);
-         pb = abs(pc);
-         pc = abs(p + pc);
-#else
-         pa = p < 0 ? -p : p;
-         pb = pc < 0 ? -pc : pc;
-         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
-#endif
-
-         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
-
-         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
-      }
-      best_row = png_ptr->paeth_row;
-   }
-
-   else if (filter_to_do & PNG_FILTER_PAETH)
-   {
-      png_bytep rp, dp, pp, cp, lp;
-      png_uint_32 sum = 0, lmins = mins;
-      png_uint_32 i;
-      int v;
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
-           pp = prev_row + 1; i < bpp; i++)
-      {
-         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-      }
-
-      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
-      {
-         int a, b, c, pa, pb, pc, p;
-
-         b = *pp++;
-         c = *cp++;
-         a = *lp++;
-
-#ifndef PNG_SLOW_PAETH
-         p = b - c;
-         pc = a - c;
-#ifdef PNG_USE_ABS
-         pa = abs(p);
-         pb = abs(pc);
-         pc = abs(p + pc);
-#else
-         pa = p < 0 ? -p : p;
-         pb = pc < 0 ? -pc : pc;
-         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
-#endif
-         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
-#else /* PNG_SLOW_PAETH */
-         p = a + b - c;
-         pa = abs(p - a);
-         pb = abs(p - b);
-         pc = abs(p - c);
-         if (pa <= pb && pa <= pc)
-            p = a;
-         else if (pb <= pc)
-            p = b;
-         else
-            p = c;
-#endif /* PNG_SLOW_PAETH */
-
-         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                  PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-            PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
-      if (sum < mins)
-      {
-         best_row = png_ptr->paeth_row;
-      }
-   }
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-   /* Do the actual writing of the filtered row data from the chosen filter. */
-
-   png_write_filtered_row(png_ptr, best_row);
-
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   /* Save the type of filter we picked this time for future calculations */
-   if (png_ptr->num_prev_filters > 0)
-   {
-      int j;
-      for (j = 1; j < num_p_filters; j++)
-      {
-         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
-      }
-      png_ptr->prev_filters[j] = best_row[0];
-   }
-#endif
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-}
-
-
-/* Do the actual writing of a previously filtered row. */
-void /* PRIVATE */
-png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
-{
-   png_debug(1, "in png_write_filtered_row");
-
-   png_debug1(2, "filter = %d", filtered_row[0]);
-   /* Set up the zlib input buffer */
-
-   png_ptr->zstream.next_in = filtered_row;
-   png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
-   /* Repeat until we have compressed all the data */
-   do
-   {
-      int ret; /* Return of zlib */
-
-      /* Compress the data */
-      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
-      /* Check for compression errors */
-      if (ret != Z_OK)
-      {
-         if (png_ptr->zstream.msg != NULL)
-            png_error(png_ptr, png_ptr->zstream.msg);
-         else
-            png_error(png_ptr, "zlib error");
-      }
-
-      /* See if it is time to write another IDAT */
-      if (!(png_ptr->zstream.avail_out))
-      {
-         /* Write the IDAT and reset the zlib output buffer */
-         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
-         png_ptr->zstream.next_out = png_ptr->zbuf;
-         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-      }
-   /* Repeat until all data has been compressed */
-   } while (png_ptr->zstream.avail_in);
-
-   /* Swap the current and previous rows */
-   if (png_ptr->prev_row != NULL)
-   {
-      png_bytep tptr;
-
-      tptr = png_ptr->prev_row;
-      png_ptr->prev_row = png_ptr->row_buf;
-      png_ptr->row_buf = tptr;
-   }
-
-   /* Finish row - updates counters and flushes zlib if last row */
-   png_write_finish_row(png_ptr);
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-   png_ptr->flush_rows++;
-
-   if (png_ptr->flush_dist > 0 &&
-       png_ptr->flush_rows >= png_ptr->flush_dist)
-   {
-      png_write_flush(png_ptr);
-   }
-#endif
-}
-#endif /* PNG_WRITE_SUPPORTED */
diff --git a/thirdparty/libtiff/CMakeLists.txt b/thirdparty/libtiff/CMakeLists.txt
deleted file mode 100644
index 14601f0..0000000
--- a/thirdparty/libtiff/CMakeLists.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
-project(libtiff C)
-
-INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}")
-#
-ADD_DEFINITIONS(-DHAVE_STRING_H=1)
-
-SET(TARGET_FILES
-	t4.h
-    tiffiop.h
-    tif_aux.c
-    tif_close.c
-    tif_codec.c
-    tif_color.c
-    tif_compress.c
-    tif_dir.c
-    tif_dir.h
-    tif_dirinfo.c
-    tif_dirread.c
-    tif_dirwrite.c
-    tif_dumpmode.c
-    tif_error.c
-    tif_extension.c
-    tif_fax3.c
-    tif_fax3.h
-    tif_fax3sm.c
-    tif_flush.c
-    tif_getimage.c
-    tif_jbig.c
-    tif_jpeg.c
-    tif_luv.c
-    tif_lzw.c
-    tif_next.c
-    tif_ojpeg.c
-    tif_open.c
-    tif_packbits.c
-    tif_pixarlog.c
-    tif_predict.c
-    tif_predict.h
-    tif_print.c
-    tif_read.c
-    tif_strip.c
-    tif_swab.c
-    tif_thunder.c
-    tif_tile.c
-    tif_version.c
-    tif_warning.c
-    tif_write.c
-    tif_zip.c
-    uvcode.h
-    )
-
-IF(UNIX)
-    SET(TARGET_FILES ${TARGET_FILES} tif_unix.c)
-ENDIF()
-
-IF(WIN32)
-    SET(TARGET_FILES ${TARGET_FILES} tif_win32.c)
-ENDIF(WIN32)
-
-#IF(APPLE)
-#    SET(TARGET_FILES ${TARGET_FILES} tif_apple.c)
-#ENDIF(APPLE)
-
-SET(LIBTARGET "tiff")
-#
-ADD_LIBRARY(${LIBTARGET} STATIC ${TARGET_FILES})
-#
-IF(MSVC)
-  SET_TARGET_PROPERTIES(${LIBTARGET} PROPERTIES PREFIX "lib")
-ENDIF(MSVC)
-#
-SET_TARGET_PROPERTIES(${LIBTARGET}
-  PROPERTIES
-  OUTPUT_NAME "${LIBTARGET}"
-  ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/thirdparty/lib
-)
-#
diff --git a/thirdparty/libtiff/t4.h b/thirdparty/libtiff/t4.h
deleted file mode 100644
index 870704f..0000000
--- a/thirdparty/libtiff/t4.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/* $Id: t4.h,v 1.1.1.1.2.1 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _T4_
-#define	_T4_
-/*
- * CCITT T.4 1D Huffman runlength codes and
- * related definitions.  Given the small sizes
- * of these tables it does not seem
- * worthwhile to make code & length 8 bits.
- */
-typedef struct tableentry {
-    unsigned short length;	/* bit length of g3 code */
-    unsigned short code;	/* g3 code */
-    short	runlen;		/* run length in bits */
-} tableentry;
-
-#define	EOL	0x001	/* EOL code value - 0000 0000 0000 1 */
-
-/* status values returned instead of a run length */
-#define	G3CODE_EOL	-1	/* NB: ACT_EOL - ACT_WRUNT */
-#define	G3CODE_INVALID	-2	/* NB: ACT_INVALID - ACT_WRUNT */
-#define	G3CODE_EOF	-3	/* end of input data */
-#define	G3CODE_INCOMP	-4	/* incomplete run code */
-
-/*
- * Note that these tables are ordered such that the
- * index into the table is known to be either the
- * run length, or (run length / 64) + a fixed offset.
- *
- * NB: The G3CODE_INVALID entries are only used
- *     during state generation (see mkg3states.c).
- */
-#ifdef G3CODES
-const tableentry TIFFFaxWhiteCodes[] = {
-    { 8, 0x35, 0 },	/* 0011 0101 */
-    { 6, 0x7, 1 },	/* 0001 11 */
-    { 4, 0x7, 2 },	/* 0111 */
-    { 4, 0x8, 3 },	/* 1000 */
-    { 4, 0xB, 4 },	/* 1011 */
-    { 4, 0xC, 5 },	/* 1100 */
-    { 4, 0xE, 6 },	/* 1110 */
-    { 4, 0xF, 7 },	/* 1111 */
-    { 5, 0x13, 8 },	/* 1001 1 */
-    { 5, 0x14, 9 },	/* 1010 0 */
-    { 5, 0x7, 10 },	/* 0011 1 */
-    { 5, 0x8, 11 },	/* 0100 0 */
-    { 6, 0x8, 12 },	/* 0010 00 */
-    { 6, 0x3, 13 },	/* 0000 11 */
-    { 6, 0x34, 14 },	/* 1101 00 */
-    { 6, 0x35, 15 },	/* 1101 01 */
-    { 6, 0x2A, 16 },	/* 1010 10 */
-    { 6, 0x2B, 17 },	/* 1010 11 */
-    { 7, 0x27, 18 },	/* 0100 111 */
-    { 7, 0xC, 19 },	/* 0001 100 */
-    { 7, 0x8, 20 },	/* 0001 000 */
-    { 7, 0x17, 21 },	/* 0010 111 */
-    { 7, 0x3, 22 },	/* 0000 011 */
-    { 7, 0x4, 23 },	/* 0000 100 */
-    { 7, 0x28, 24 },	/* 0101 000 */
-    { 7, 0x2B, 25 },	/* 0101 011 */
-    { 7, 0x13, 26 },	/* 0010 011 */
-    { 7, 0x24, 27 },	/* 0100 100 */
-    { 7, 0x18, 28 },	/* 0011 000 */
-    { 8, 0x2, 29 },	/* 0000 0010 */
-    { 8, 0x3, 30 },	/* 0000 0011 */
-    { 8, 0x1A, 31 },	/* 0001 1010 */
-    { 8, 0x1B, 32 },	/* 0001 1011 */
-    { 8, 0x12, 33 },	/* 0001 0010 */
-    { 8, 0x13, 34 },	/* 0001 0011 */
-    { 8, 0x14, 35 },	/* 0001 0100 */
-    { 8, 0x15, 36 },	/* 0001 0101 */
-    { 8, 0x16, 37 },	/* 0001 0110 */
-    { 8, 0x17, 38 },	/* 0001 0111 */
-    { 8, 0x28, 39 },	/* 0010 1000 */
-    { 8, 0x29, 40 },	/* 0010 1001 */
-    { 8, 0x2A, 41 },	/* 0010 1010 */
-    { 8, 0x2B, 42 },	/* 0010 1011 */
-    { 8, 0x2C, 43 },	/* 0010 1100 */
-    { 8, 0x2D, 44 },	/* 0010 1101 */
-    { 8, 0x4, 45 },	/* 0000 0100 */
-    { 8, 0x5, 46 },	/* 0000 0101 */
-    { 8, 0xA, 47 },	/* 0000 1010 */
-    { 8, 0xB, 48 },	/* 0000 1011 */
-    { 8, 0x52, 49 },	/* 0101 0010 */
-    { 8, 0x53, 50 },	/* 0101 0011 */
-    { 8, 0x54, 51 },	/* 0101 0100 */
-    { 8, 0x55, 52 },	/* 0101 0101 */
-    { 8, 0x24, 53 },	/* 0010 0100 */
-    { 8, 0x25, 54 },	/* 0010 0101 */
-    { 8, 0x58, 55 },	/* 0101 1000 */
-    { 8, 0x59, 56 },	/* 0101 1001 */
-    { 8, 0x5A, 57 },	/* 0101 1010 */
-    { 8, 0x5B, 58 },	/* 0101 1011 */
-    { 8, 0x4A, 59 },	/* 0100 1010 */
-    { 8, 0x4B, 60 },	/* 0100 1011 */
-    { 8, 0x32, 61 },	/* 0011 0010 */
-    { 8, 0x33, 62 },	/* 0011 0011 */
-    { 8, 0x34, 63 },	/* 0011 0100 */
-    { 5, 0x1B, 64 },	/* 1101 1 */
-    { 5, 0x12, 128 },	/* 1001 0 */
-    { 6, 0x17, 192 },	/* 0101 11 */
-    { 7, 0x37, 256 },	/* 0110 111 */
-    { 8, 0x36, 320 },	/* 0011 0110 */
-    { 8, 0x37, 384 },	/* 0011 0111 */
-    { 8, 0x64, 448 },	/* 0110 0100 */
-    { 8, 0x65, 512 },	/* 0110 0101 */
-    { 8, 0x68, 576 },	/* 0110 1000 */
-    { 8, 0x67, 640 },	/* 0110 0111 */
-    { 9, 0xCC, 704 },	/* 0110 0110 0 */
-    { 9, 0xCD, 768 },	/* 0110 0110 1 */
-    { 9, 0xD2, 832 },	/* 0110 1001 0 */
-    { 9, 0xD3, 896 },	/* 0110 1001 1 */
-    { 9, 0xD4, 960 },	/* 0110 1010 0 */
-    { 9, 0xD5, 1024 },	/* 0110 1010 1 */
-    { 9, 0xD6, 1088 },	/* 0110 1011 0 */
-    { 9, 0xD7, 1152 },	/* 0110 1011 1 */
-    { 9, 0xD8, 1216 },	/* 0110 1100 0 */
-    { 9, 0xD9, 1280 },	/* 0110 1100 1 */
-    { 9, 0xDA, 1344 },	/* 0110 1101 0 */
-    { 9, 0xDB, 1408 },	/* 0110 1101 1 */
-    { 9, 0x98, 1472 },	/* 0100 1100 0 */
-    { 9, 0x99, 1536 },	/* 0100 1100 1 */
-    { 9, 0x9A, 1600 },	/* 0100 1101 0 */
-    { 6, 0x18, 1664 },	/* 0110 00 */
-    { 9, 0x9B, 1728 },	/* 0100 1101 1 */
-    { 11, 0x8, 1792 },	/* 0000 0001 000 */
-    { 11, 0xC, 1856 },	/* 0000 0001 100 */
-    { 11, 0xD, 1920 },	/* 0000 0001 101 */
-    { 12, 0x12, 1984 },	/* 0000 0001 0010 */
-    { 12, 0x13, 2048 },	/* 0000 0001 0011 */
-    { 12, 0x14, 2112 },	/* 0000 0001 0100 */
-    { 12, 0x15, 2176 },	/* 0000 0001 0101 */
-    { 12, 0x16, 2240 },	/* 0000 0001 0110 */
-    { 12, 0x17, 2304 },	/* 0000 0001 0111 */
-    { 12, 0x1C, 2368 },	/* 0000 0001 1100 */
-    { 12, 0x1D, 2432 },	/* 0000 0001 1101 */
-    { 12, 0x1E, 2496 },	/* 0000 0001 1110 */
-    { 12, 0x1F, 2560 },	/* 0000 0001 1111 */
-    { 12, 0x1, G3CODE_EOL },	/* 0000 0000 0001 */
-    { 9, 0x1, G3CODE_INVALID },	/* 0000 0000 1 */
-    { 10, 0x1, G3CODE_INVALID },	/* 0000 0000 01 */
-    { 11, 0x1, G3CODE_INVALID },	/* 0000 0000 001 */
-    { 12, 0x0, G3CODE_INVALID },	/* 0000 0000 0000 */
-};
-
-const tableentry TIFFFaxBlackCodes[] = {
-    { 10, 0x37, 0 },	/* 0000 1101 11 */
-    { 3, 0x2, 1 },	/* 010 */
-    { 2, 0x3, 2 },	/* 11 */
-    { 2, 0x2, 3 },	/* 10 */
-    { 3, 0x3, 4 },	/* 011 */
-    { 4, 0x3, 5 },	/* 0011 */
-    { 4, 0x2, 6 },	/* 0010 */
-    { 5, 0x3, 7 },	/* 0001 1 */
-    { 6, 0x5, 8 },	/* 0001 01 */
-    { 6, 0x4, 9 },	/* 0001 00 */
-    { 7, 0x4, 10 },	/* 0000 100 */
-    { 7, 0x5, 11 },	/* 0000 101 */
-    { 7, 0x7, 12 },	/* 0000 111 */
-    { 8, 0x4, 13 },	/* 0000 0100 */
-    { 8, 0x7, 14 },	/* 0000 0111 */
-    { 9, 0x18, 15 },	/* 0000 1100 0 */
-    { 10, 0x17, 16 },	/* 0000 0101 11 */
-    { 10, 0x18, 17 },	/* 0000 0110 00 */
-    { 10, 0x8, 18 },	/* 0000 0010 00 */
-    { 11, 0x67, 19 },	/* 0000 1100 111 */
-    { 11, 0x68, 20 },	/* 0000 1101 000 */
-    { 11, 0x6C, 21 },	/* 0000 1101 100 */
-    { 11, 0x37, 22 },	/* 0000 0110 111 */
-    { 11, 0x28, 23 },	/* 0000 0101 000 */
-    { 11, 0x17, 24 },	/* 0000 0010 111 */
-    { 11, 0x18, 25 },	/* 0000 0011 000 */
-    { 12, 0xCA, 26 },	/* 0000 1100 1010 */
-    { 12, 0xCB, 27 },	/* 0000 1100 1011 */
-    { 12, 0xCC, 28 },	/* 0000 1100 1100 */
-    { 12, 0xCD, 29 },	/* 0000 1100 1101 */
-    { 12, 0x68, 30 },	/* 0000 0110 1000 */
-    { 12, 0x69, 31 },	/* 0000 0110 1001 */
-    { 12, 0x6A, 32 },	/* 0000 0110 1010 */
-    { 12, 0x6B, 33 },	/* 0000 0110 1011 */
-    { 12, 0xD2, 34 },	/* 0000 1101 0010 */
-    { 12, 0xD3, 35 },	/* 0000 1101 0011 */
-    { 12, 0xD4, 36 },	/* 0000 1101 0100 */
-    { 12, 0xD5, 37 },	/* 0000 1101 0101 */
-    { 12, 0xD6, 38 },	/* 0000 1101 0110 */
-    { 12, 0xD7, 39 },	/* 0000 1101 0111 */
-    { 12, 0x6C, 40 },	/* 0000 0110 1100 */
-    { 12, 0x6D, 41 },	/* 0000 0110 1101 */
-    { 12, 0xDA, 42 },	/* 0000 1101 1010 */
-    { 12, 0xDB, 43 },	/* 0000 1101 1011 */
-    { 12, 0x54, 44 },	/* 0000 0101 0100 */
-    { 12, 0x55, 45 },	/* 0000 0101 0101 */
-    { 12, 0x56, 46 },	/* 0000 0101 0110 */
-    { 12, 0x57, 47 },	/* 0000 0101 0111 */
-    { 12, 0x64, 48 },	/* 0000 0110 0100 */
-    { 12, 0x65, 49 },	/* 0000 0110 0101 */
-    { 12, 0x52, 50 },	/* 0000 0101 0010 */
-    { 12, 0x53, 51 },	/* 0000 0101 0011 */
-    { 12, 0x24, 52 },	/* 0000 0010 0100 */
-    { 12, 0x37, 53 },	/* 0000 0011 0111 */
-    { 12, 0x38, 54 },	/* 0000 0011 1000 */
-    { 12, 0x27, 55 },	/* 0000 0010 0111 */
-    { 12, 0x28, 56 },	/* 0000 0010 1000 */
-    { 12, 0x58, 57 },	/* 0000 0101 1000 */
-    { 12, 0x59, 58 },	/* 0000 0101 1001 */
-    { 12, 0x2B, 59 },	/* 0000 0010 1011 */
-    { 12, 0x2C, 60 },	/* 0000 0010 1100 */
-    { 12, 0x5A, 61 },	/* 0000 0101 1010 */
-    { 12, 0x66, 62 },	/* 0000 0110 0110 */
-    { 12, 0x67, 63 },	/* 0000 0110 0111 */
-    { 10, 0xF, 64 },	/* 0000 0011 11 */
-    { 12, 0xC8, 128 },	/* 0000 1100 1000 */
-    { 12, 0xC9, 192 },	/* 0000 1100 1001 */
-    { 12, 0x5B, 256 },	/* 0000 0101 1011 */
-    { 12, 0x33, 320 },	/* 0000 0011 0011 */
-    { 12, 0x34, 384 },	/* 0000 0011 0100 */
-    { 12, 0x35, 448 },	/* 0000 0011 0101 */
-    { 13, 0x6C, 512 },	/* 0000 0011 0110 0 */
-    { 13, 0x6D, 576 },	/* 0000 0011 0110 1 */
-    { 13, 0x4A, 640 },	/* 0000 0010 0101 0 */
-    { 13, 0x4B, 704 },	/* 0000 0010 0101 1 */
-    { 13, 0x4C, 768 },	/* 0000 0010 0110 0 */
-    { 13, 0x4D, 832 },	/* 0000 0010 0110 1 */
-    { 13, 0x72, 896 },	/* 0000 0011 1001 0 */
-    { 13, 0x73, 960 },	/* 0000 0011 1001 1 */
-    { 13, 0x74, 1024 },	/* 0000 0011 1010 0 */
-    { 13, 0x75, 1088 },	/* 0000 0011 1010 1 */
-    { 13, 0x76, 1152 },	/* 0000 0011 1011 0 */
-    { 13, 0x77, 1216 },	/* 0000 0011 1011 1 */
-    { 13, 0x52, 1280 },	/* 0000 0010 1001 0 */
-    { 13, 0x53, 1344 },	/* 0000 0010 1001 1 */
-    { 13, 0x54, 1408 },	/* 0000 0010 1010 0 */
-    { 13, 0x55, 1472 },	/* 0000 0010 1010 1 */
-    { 13, 0x5A, 1536 },	/* 0000 0010 1101 0 */
-    { 13, 0x5B, 1600 },	/* 0000 0010 1101 1 */
-    { 13, 0x64, 1664 },	/* 0000 0011 0010 0 */
-    { 13, 0x65, 1728 },	/* 0000 0011 0010 1 */
-    { 11, 0x8, 1792 },	/* 0000 0001 000 */
-    { 11, 0xC, 1856 },	/* 0000 0001 100 */
-    { 11, 0xD, 1920 },	/* 0000 0001 101 */
-    { 12, 0x12, 1984 },	/* 0000 0001 0010 */
-    { 12, 0x13, 2048 },	/* 0000 0001 0011 */
-    { 12, 0x14, 2112 },	/* 0000 0001 0100 */
-    { 12, 0x15, 2176 },	/* 0000 0001 0101 */
-    { 12, 0x16, 2240 },	/* 0000 0001 0110 */
-    { 12, 0x17, 2304 },	/* 0000 0001 0111 */
-    { 12, 0x1C, 2368 },	/* 0000 0001 1100 */
-    { 12, 0x1D, 2432 },	/* 0000 0001 1101 */
-    { 12, 0x1E, 2496 },	/* 0000 0001 1110 */
-    { 12, 0x1F, 2560 },	/* 0000 0001 1111 */
-    { 12, 0x1, G3CODE_EOL },	/* 0000 0000 0001 */
-    { 9, 0x1, G3CODE_INVALID },	/* 0000 0000 1 */
-    { 10, 0x1, G3CODE_INVALID },	/* 0000 0000 01 */
-    { 11, 0x1, G3CODE_INVALID },	/* 0000 0000 001 */
-    { 12, 0x0, G3CODE_INVALID },	/* 0000 0000 0000 */
-};
-#else
-extern	const tableentry TIFFFaxWhiteCodes[];
-extern	const tableentry TIFFFaxBlackCodes[];
-#endif
-#endif /* _T4_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_apple.c b/thirdparty/libtiff/tif_apple.c
deleted file mode 100644
index 8c48228..0000000
--- a/thirdparty/libtiff/tif_apple.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/Attic/tif_apple.c,v 1.3.2.1 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library Macintosh-specific routines.
- *
- * These routines use only Toolbox and high-level File Manager traps.
- * They make no calls to the THINK C "unix" compatibility library.  Also,
- * malloc is not used directly but it is still referenced internally by
- * the ANSI library in rare cases.  Heap fragmentation by the malloc ring
- * buffer is therefore minimized.
- *
- * O_RDONLY and O_RDWR are treated identically here.  The tif_mode flag is
- * checked in TIFFWriteCheck().
- *
- * Create below fills in a blank creator signature and sets the file type
- * to 'TIFF'.  It is much better for the application to do this by Create'ing
- * the file first and TIFFOpen'ing it later.
- * ---------
- * This code has been "Carbonized", and may not work with older MacOS versions.
- * If so, grab the tif_apple.c out of an older libtiff distribution, like
- * 3.5.5 from www.libtiff.org.
- */
-
-#include "tiffiop.h"
-#include <Errors.h>
-#include <Files.h>
-#include <Memory.h>
-#include <Script.h>
-
-#if defined(__PPCC__) || defined(__SC__) || defined(__MRC__) || defined(applec)
-#define	CtoPstr	c2pstr
-#endif
-
-static tsize_t
-_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	return (FSRead((short) fd, (long*) &size, (char*) buf) == noErr ?
-	    size : (tsize_t) -1);
-}
-
-static tsize_t
-_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	return (FSWrite((short) fd, (long*) &size, (char*) buf) == noErr ?
-	    size : (tsize_t) -1);
-}
-
-static toff_t
-_tiffSeekProc(thandle_t fd, toff_t off, int whence)
-{
-	long fpos, size;
-
-	if (GetEOF((short) fd, &size) != noErr)
-		return EOF;
-	(void) GetFPos((short) fd, &fpos);
-
-	switch (whence) {
-	case SEEK_CUR:
-		if (off + fpos > size)
-			SetEOF((short) fd, off + fpos);
-		if (SetFPos((short) fd, fsFromMark, off) != noErr)
-			return EOF;
-		break;
-	case SEEK_END:
-		if (off > 0)
-			SetEOF((short) fd, off + size);
-		if (SetFPos((short) fd, fsFromStart, off + size) != noErr)
-			return EOF;
-		break;
-	case SEEK_SET:
-		if (off > size)
-			SetEOF((short) fd, off);
-		if (SetFPos((short) fd, fsFromStart, off) != noErr)
-			return EOF;
-		break;
-	}
-
-	return (toff_t)(GetFPos((short) fd, &fpos) == noErr ? fpos : EOF);
-}
-
-static int
-_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	return (0);
-}
-
-static void
-_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-}
-
-static int
-_tiffCloseProc(thandle_t fd)
-{
-	return (FSClose((short) fd));
-}
-
-static toff_t
-_tiffSizeProc(thandle_t fd)
-{
-	long size;
-
-	if (GetEOF((short) fd, &size) != noErr) {
-		TIFFErrorExt(fd, "_tiffSizeProc", "%s: Cannot get file size");
-		return (-1L);
-	}
-	return ((toff_t) size);
-}
-
-/*
- * Open a TIFF file descriptor for read/writing.
- */
-TIFF*
-TIFFFdOpen(int fd, const char* name, const char* mode)
-{
-	TIFF* tif;
-
-	tif = TIFFClientOpen(name, mode, (thandle_t) fd,
-	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
-	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
-	if (tif)
-		tif->tif_fd = fd;
-	return (tif);
-}
-
-static void ourc2pstr( char* inString )
-{
-	int	sLen = strlen( inString );
-	BlockMoveData( inString, &inString[1], sLen );
-	inString[0] = sLen;
-}
-
-/*
- * Open a TIFF file for read/writing.
- */
-TIFF*
-TIFFOpen(const char* name, const char* mode)
-{
-	static const char module[] = "TIFFOpen";
-	Str255 pname;
-	FInfo finfo;
-	short fref;
-	OSErr err;
-	FSSpec	fSpec;
-
-	strcpy((char*) pname, name);
-	ourc2pstr((char*) pname);
-	
-	err = FSMakeFSSpec( 0, 0, pname, &fSpec );
-
-	switch (_TIFFgetMode(mode, module)) {
-	default:
-		return ((TIFF*) 0);
-	case O_RDWR | O_CREAT | O_TRUNC:
-		if (FSpGetFInfo(&fSpec, &finfo) == noErr)
-			FSpDelete(&fSpec);
-		/* fall through */
-	case O_RDWR | O_CREAT:
-		if ((err = FSpGetFInfo(&fSpec, &finfo)) == fnfErr) {
-			if (FSpCreate(&fSpec, '    ', 'TIFF', smSystemScript) != noErr)
-				goto badCreate;
-			if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)
-				goto badOpen;
-		} else if (err == noErr) {
-			if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)
-				goto badOpen;
-		} else
-			goto badOpen;
-		break;
-	case O_RDONLY:
-		if (FSpOpenDF(&fSpec, fsRdPerm, &fref) != noErr)
-			goto badOpen;
-		break;
-	case O_RDWR:
-		if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)
-			goto badOpen;
-		break;
-	}
-	return (TIFFFdOpen((int) fref, name, mode));
-badCreate:
-	TIFFErrorExt(0, module, "%s: Cannot create", name);
-	return ((TIFF*) 0);
-badOpen:
-	TIFFErrorExt(0, module, "%s: Cannot open", name);
-	return ((TIFF*) 0);
-}
-
-void
-_TIFFmemset(tdata_t p, int v, tsize_t c)
-{
-	memset(p, v, (size_t) c);
-}
-
-void
-_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c)
-{
-	memcpy(d, s, (size_t) c);
-}
-
-int
-_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)
-{
-	return (memcmp(p1, p2, (size_t) c));
-}
-
-tdata_t
-_TIFFmalloc(tsize_t s)
-{
-	return (NewPtr((size_t) s));
-}
-
-void
-_TIFFfree(tdata_t p)
-{
-	DisposePtr(p);
-}
-
-tdata_t
-_TIFFrealloc(tdata_t p, tsize_t s)
-{
-	Ptr n = p;
-
-	SetPtrSize(p, (size_t) s);
-	if (MemError() && (n = NewPtr((size_t) s)) != NULL) {
-		BlockMove(p, n, GetPtrSize(p));
-		DisposePtr(p);
-	}
-	return ((tdata_t) n);
-}
-
-static void
-appleWarningHandler(const char* module, const char* fmt, va_list ap)
-{
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	fprintf(stderr, "Warning, ");
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-}
-TIFFErrorHandler _TIFFwarningHandler = appleWarningHandler;
-
-static void
-appleErrorHandler(const char* module, const char* fmt, va_list ap)
-{
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-}
-TIFFErrorHandler _TIFFerrorHandler = appleErrorHandler;
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_aux.c b/thirdparty/libtiff/tif_aux.c
deleted file mode 100644
index 272f0d9..0000000
--- a/thirdparty/libtiff/tif_aux.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/* $Id: tif_aux.c,v 1.20.2.3 2010-06-09 21:15:27 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1991-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Auxiliary Support Routines.
- */
-#include "tiffiop.h"
-#include "tif_predict.h"
-#include <math.h>
-
-tdata_t
-_TIFFCheckRealloc(TIFF* tif, tdata_t buffer,
-		  size_t nmemb, size_t elem_size, const char* what)
-{
-	tdata_t cp = NULL;
-	tsize_t	bytes = nmemb * elem_size;
-
-	/*
-	 * XXX: Check for integer overflow.
-	 */
-	if (nmemb && elem_size && bytes / elem_size == nmemb)
-		cp = _TIFFrealloc(buffer, bytes);
-
-	if (cp == NULL)
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Failed to allocate memory for %s "
-			     "(%ld elements of %ld bytes each)",
-			     what,(long) nmemb, (long) elem_size);
-
-	return cp;
-}
-
-tdata_t
-_TIFFCheckMalloc(TIFF* tif, size_t nmemb, size_t elem_size, const char* what)
-{
-	return _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);
-}
-
-static int
-TIFFDefaultTransferFunction(TIFFDirectory* td)
-{
-	uint16 **tf = td->td_transferfunction;
-	tsize_t i, n, nbytes;
-
-	tf[0] = tf[1] = tf[2] = 0;
-	if (td->td_bitspersample >= sizeof(tsize_t) * 8 - 2)
-		return 0;
-
-	n = 1<<td->td_bitspersample;
-	nbytes = n * sizeof (uint16);
-	if (!(tf[0] = (uint16 *)_TIFFmalloc(nbytes)))
-		return 0;
-	tf[0][0] = 0;
-	for (i = 1; i < n; i++) {
-		double t = (double)i/((double) n-1.);
-		tf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5);
-	}
-
-	if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-		if (!(tf[1] = (uint16 *)_TIFFmalloc(nbytes)))
-			goto bad;
-		_TIFFmemcpy(tf[1], tf[0], nbytes);
-		if (!(tf[2] = (uint16 *)_TIFFmalloc(nbytes)))
-			goto bad;
-		_TIFFmemcpy(tf[2], tf[0], nbytes);
-	}
-	return 1;
-
-bad:
-	if (tf[0])
-		_TIFFfree(tf[0]);
-	if (tf[1])
-		_TIFFfree(tf[1]);
-	if (tf[2])
-		_TIFFfree(tf[2]);
-	tf[0] = tf[1] = tf[2] = 0;
-	return 0;
-}
-
-static int
-TIFFDefaultRefBlackWhite(TIFFDirectory* td)
-{
-	int i;
-
-	if (!(td->td_refblackwhite = (float *)_TIFFmalloc(6*sizeof (float))))
-		return 0;
-        if (td->td_photometric == PHOTOMETRIC_YCBCR) {
-		/*
-		 * YCbCr (Class Y) images must have the ReferenceBlackWhite
-		 * tag set. Fix the broken images, which lacks that tag.
-		 */
-		td->td_refblackwhite[0] = 0.0F;
-		td->td_refblackwhite[1] = td->td_refblackwhite[3] =
-			td->td_refblackwhite[5] = 255.0F;
-		td->td_refblackwhite[2] = td->td_refblackwhite[4] = 128.0F;
-	} else {
-		/*
-		 * Assume RGB (Class R)
-		 */
-		for (i = 0; i < 3; i++) {
-		    td->td_refblackwhite[2*i+0] = 0;
-		    td->td_refblackwhite[2*i+1] =
-			    (float)((1L<<td->td_bitspersample)-1L);
-		}
-	}
-	return 1;
-}
-
-/*
- * Like TIFFGetField, but return any default
- * value if the tag is not present in the directory.
- *
- * NB:	We use the value in the directory, rather than
- *	explcit values so that defaults exist only one
- *	place in the library -- in TIFFDefaultDirectory.
- */
-int
-TIFFVGetFieldDefaulted(TIFF* tif, ttag_t tag, va_list ap)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if (TIFFVGetField(tif, tag, ap))
-		return (1);
-	switch (tag) {
-	case TIFFTAG_SUBFILETYPE:
-		*va_arg(ap, uint32 *) = td->td_subfiletype;
-		return (1);
-	case TIFFTAG_BITSPERSAMPLE:
-		*va_arg(ap, uint16 *) = td->td_bitspersample;
-		return (1);
-	case TIFFTAG_THRESHHOLDING:
-		*va_arg(ap, uint16 *) = td->td_threshholding;
-		return (1);
-	case TIFFTAG_FILLORDER:
-		*va_arg(ap, uint16 *) = td->td_fillorder;
-		return (1);
-	case TIFFTAG_ORIENTATION:
-		*va_arg(ap, uint16 *) = td->td_orientation;
-		return (1);
-	case TIFFTAG_SAMPLESPERPIXEL:
-		*va_arg(ap, uint16 *) = td->td_samplesperpixel;
-		return (1);
-	case TIFFTAG_ROWSPERSTRIP:
-		*va_arg(ap, uint32 *) = td->td_rowsperstrip;
-		return (1);
-	case TIFFTAG_MINSAMPLEVALUE:
-		*va_arg(ap, uint16 *) = td->td_minsamplevalue;
-		return (1);
-	case TIFFTAG_MAXSAMPLEVALUE:
-		*va_arg(ap, uint16 *) = td->td_maxsamplevalue;
-		return (1);
-	case TIFFTAG_PLANARCONFIG:
-		*va_arg(ap, uint16 *) = td->td_planarconfig;
-		return (1);
-	case TIFFTAG_RESOLUTIONUNIT:
-		*va_arg(ap, uint16 *) = td->td_resolutionunit;
-		return (1);
-	case TIFFTAG_PREDICTOR:
-                {
-			TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;
-			*va_arg(ap, uint16*) = (uint16) sp->predictor;
-			return 1;
-                }
-	case TIFFTAG_DOTRANGE:
-		*va_arg(ap, uint16 *) = 0;
-		*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;
-		return (1);
-	case TIFFTAG_INKSET:
-		*va_arg(ap, uint16 *) = INKSET_CMYK;
-		return 1;
-	case TIFFTAG_NUMBEROFINKS:
-		*va_arg(ap, uint16 *) = 4;
-		return (1);
-	case TIFFTAG_EXTRASAMPLES:
-		*va_arg(ap, uint16 *) = td->td_extrasamples;
-		*va_arg(ap, uint16 **) = td->td_sampleinfo;
-		return (1);
-	case TIFFTAG_MATTEING:
-		*va_arg(ap, uint16 *) =
-		    (td->td_extrasamples == 1 &&
-		     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
-		return (1);
-	case TIFFTAG_TILEDEPTH:
-		*va_arg(ap, uint32 *) = td->td_tiledepth;
-		return (1);
-	case TIFFTAG_DATATYPE:
-		*va_arg(ap, uint16 *) = td->td_sampleformat-1;
-		return (1);
-	case TIFFTAG_SAMPLEFORMAT:
-		*va_arg(ap, uint16 *) = td->td_sampleformat;
-                return(1);
-	case TIFFTAG_IMAGEDEPTH:
-		*va_arg(ap, uint32 *) = td->td_imagedepth;
-		return (1);
-	case TIFFTAG_YCBCRCOEFFICIENTS:
-		{
-			/* defaults are from CCIR Recommendation 601-1 */
-			static float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };
-			*va_arg(ap, float **) = ycbcrcoeffs;
-			return 1;
-		}
-	case TIFFTAG_YCBCRSUBSAMPLING:
-		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];
-		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];
-		return (1);
-	case TIFFTAG_YCBCRPOSITIONING:
-		*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;
-		return (1);
-	case TIFFTAG_WHITEPOINT:
-		{
-			static float whitepoint[2];
-
-			/* TIFF 6.0 specification tells that it is no default
-			   value for the WhitePoint, but AdobePhotoshop TIFF
-			   Technical Note tells that it should be CIE D50. */
-			whitepoint[0] =	D50_X0 / (D50_X0 + D50_Y0 + D50_Z0);
-			whitepoint[1] =	D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);
-			*va_arg(ap, float **) = whitepoint;
-			return 1;
-		}
-	case TIFFTAG_TRANSFERFUNCTION:
-		if (!td->td_transferfunction[0] &&
-		    !TIFFDefaultTransferFunction(td)) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "No space for \"TransferFunction\" tag");
-			return (0);
-		}
-		*va_arg(ap, uint16 **) = td->td_transferfunction[0];
-		if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-			*va_arg(ap, uint16 **) = td->td_transferfunction[1];
-			*va_arg(ap, uint16 **) = td->td_transferfunction[2];
-		}
-		return (1);
-	case TIFFTAG_REFERENCEBLACKWHITE:
-		if (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))
-			return (0);
-		*va_arg(ap, float **) = td->td_refblackwhite;
-		return (1);
-	}
-	return 0;
-}
-
-/*
- * Like TIFFGetField, but return any default
- * value if the tag is not present in the directory.
- */
-int
-TIFFGetFieldDefaulted(TIFF* tif, ttag_t tag, ...)
-{
-	int ok;
-	va_list ap;
-
-	va_start(ap, tag);
-	ok =  TIFFVGetFieldDefaulted(tif, tag, ap);
-	va_end(ap);
-	return (ok);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_close.c b/thirdparty/libtiff/tif_close.c
deleted file mode 100644
index 02591ba..0000000
--- a/thirdparty/libtiff/tif_close.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/* $Id: tif_close.c,v 1.10.2.1 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- */
-#include "tiffiop.h"
-
-/************************************************************************/
-/*                            TIFFCleanup()                             */
-/************************************************************************/
-
-/**
- * Auxiliary function to free the TIFF structure. Given structure will be
- * completetly freed, so you should save opened file handle and pointer
- * to the close procedure in external variables before calling
- * _TIFFCleanup(), if you will need these ones to close the file.
- * 
- * @param tif A TIFF pointer.
- */
-
-void
-TIFFCleanup(TIFF* tif)
-{
-	if (tif->tif_mode != O_RDONLY)
-	    /*
-	     * Flush buffered data and directory (if dirty).
-	     */
-	    TIFFFlush(tif);
-	(*tif->tif_cleanup)(tif);
-	TIFFFreeDirectory(tif);
-
-	if (tif->tif_dirlist)
-		_TIFFfree(tif->tif_dirlist);
-
-	/* Clean up client info links */
-	while( tif->tif_clientinfo )
-	{
-		TIFFClientInfoLink *link = tif->tif_clientinfo;
-
-		tif->tif_clientinfo = link->next;
-		_TIFFfree( link->name );
-		_TIFFfree( link );
-	}
-
-	if (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))
-		_TIFFfree(tif->tif_rawdata);
-	if (isMapped(tif))
-		TIFFUnmapFileContents(tif, tif->tif_base, tif->tif_size);
-
-	/* Clean up custom fields */
-	if (tif->tif_nfields > 0)
-	{
-		size_t  i;
-
-	    for (i = 0; i < tif->tif_nfields; i++) 
-	    {
-		TIFFFieldInfo *fld = tif->tif_fieldinfo[i];
-		if (fld->field_bit == FIELD_CUSTOM && 
-		    strncmp("Tag ", fld->field_name, 4) == 0) 
-		{
-		    _TIFFfree(fld->field_name);
-		    _TIFFfree(fld);
-		}
-	    }   
-	  
-	    _TIFFfree(tif->tif_fieldinfo);
-	}
-
-	_TIFFfree(tif);
-}
-
-/************************************************************************/
-/*                            TIFFClose()                               */
-/************************************************************************/
-
-/**
- * Close a previously opened TIFF file.
- *
- * TIFFClose closes a file that was previously opened with TIFFOpen().
- * Any buffered data are flushed to the file, including the contents of
- * the current directory (if modified); and all resources are reclaimed.
- * 
- * @param tif A TIFF pointer.
- */
-
-void
-TIFFClose(TIFF* tif)
-{
-	TIFFCloseProc closeproc = tif->tif_closeproc;
-	thandle_t fd = tif->tif_clientdata;
-
-	TIFFCleanup(tif);
-	(void) (*closeproc)(fd);
-}
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_codec.c b/thirdparty/libtiff/tif_codec.c
deleted file mode 100644
index d5c6fd1..0000000
--- a/thirdparty/libtiff/tif_codec.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* $Id: tif_codec.c,v 1.10.2.2 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library
- *
- * Builtin Compression Scheme Configuration Support.
- */
-#include "tiffiop.h"
-
-static	int NotConfigured(TIFF*, int);
-
-#ifndef	LZW_SUPPORT
-#define	TIFFInitLZW		NotConfigured
-#endif
-#ifndef	PACKBITS_SUPPORT
-#define	TIFFInitPackBits	NotConfigured
-#endif
-#ifndef	THUNDER_SUPPORT
-#define	TIFFInitThunderScan	NotConfigured
-#endif
-#ifndef	NEXT_SUPPORT
-#define	TIFFInitNeXT		NotConfigured
-#endif
-#ifndef	JPEG_SUPPORT
-#define	TIFFInitJPEG		NotConfigured
-#endif
-#ifndef	OJPEG_SUPPORT
-#define	TIFFInitOJPEG		NotConfigured
-#endif
-#ifndef	CCITT_SUPPORT
-#define	TIFFInitCCITTRLE	NotConfigured
-#define	TIFFInitCCITTRLEW	NotConfigured
-#define	TIFFInitCCITTFax3	NotConfigured
-#define	TIFFInitCCITTFax4	NotConfigured
-#endif
-#ifndef JBIG_SUPPORT
-#define	TIFFInitJBIG		NotConfigured
-#endif
-#ifndef	ZIP_SUPPORT
-#define	TIFFInitZIP		NotConfigured
-#endif
-#ifndef	PIXARLOG_SUPPORT
-#define	TIFFInitPixarLog	NotConfigured
-#endif
-#ifndef LOGLUV_SUPPORT
-#define TIFFInitSGILog		NotConfigured
-#endif
-
-/*
- * Compression schemes statically built into the library.
- */
-#ifdef VMS
-const TIFFCodec _TIFFBuiltinCODECS[] = {
-#else
-TIFFCodec _TIFFBuiltinCODECS[] = {
-#endif
-    { "None",		COMPRESSION_NONE,	TIFFInitDumpMode },
-    { "LZW",		COMPRESSION_LZW,	TIFFInitLZW },
-    { "PackBits",	COMPRESSION_PACKBITS,	TIFFInitPackBits },
-    { "ThunderScan",	COMPRESSION_THUNDERSCAN,TIFFInitThunderScan },
-    { "NeXT",		COMPRESSION_NEXT,	TIFFInitNeXT },
-    { "JPEG",		COMPRESSION_JPEG,	TIFFInitJPEG },
-    { "Old-style JPEG",	COMPRESSION_OJPEG,	TIFFInitOJPEG },
-    { "CCITT RLE",	COMPRESSION_CCITTRLE,	TIFFInitCCITTRLE },
-    { "CCITT RLE/W",	COMPRESSION_CCITTRLEW,	TIFFInitCCITTRLEW },
-    { "CCITT Group 3",	COMPRESSION_CCITTFAX3,	TIFFInitCCITTFax3 },
-    { "CCITT Group 4",	COMPRESSION_CCITTFAX4,	TIFFInitCCITTFax4 },
-    { "ISO JBIG",	COMPRESSION_JBIG,	TIFFInitJBIG },
-    { "Deflate",	COMPRESSION_DEFLATE,	TIFFInitZIP },
-    { "AdobeDeflate",   COMPRESSION_ADOBE_DEFLATE , TIFFInitZIP }, 
-    { "PixarLog",	COMPRESSION_PIXARLOG,	TIFFInitPixarLog },
-    { "SGILog",		COMPRESSION_SGILOG,	TIFFInitSGILog },
-    { "SGILog24",	COMPRESSION_SGILOG24,	TIFFInitSGILog },
-    { NULL,             0,                      NULL }
-};
-
-static int
-_notConfigured(TIFF* tif)
-{
-	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
-        char compression_code[20];
-        
-        sprintf( compression_code, "%d", tif->tif_dir.td_compression );
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-                     "%s compression support is not configured", 
-                     c ? c->name : compression_code );
-	return (0);
-}
-
-static int
-NotConfigured(TIFF* tif, int scheme)
-{
-    (void) scheme;
-    
-    tif->tif_decodestatus = FALSE;
-    tif->tif_setupdecode = _notConfigured;
-    tif->tif_encodestatus = FALSE;
-    tif->tif_setupencode = _notConfigured;
-    return (1);
-}
-
-/************************************************************************/
-/*                       TIFFIsCODECConfigured()                        */
-/************************************************************************/
-
-/**
- * Check whether we have working codec for the specific coding scheme.
- * 
- * @return returns 1 if the codec is configured and working. Otherwise
- * 0 will be returned.
- */
-
-int
-TIFFIsCODECConfigured(uint16 scheme)
-{
-	const TIFFCodec* codec = TIFFFindCODEC(scheme);
-
-	if(codec == NULL) {
-            return 0;
-        }
-        if(codec->init == NULL) {
-            return 0;
-        }
-	if(codec->init != NotConfigured){
-            return 1;
-        }
-	return 0;
-}
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_color.c b/thirdparty/libtiff/tif_color.c
deleted file mode 100644
index 02eb346..0000000
--- a/thirdparty/libtiff/tif_color.c
+++ /dev/null
@@ -1,282 +0,0 @@
-/* $Id: tif_color.c,v 1.12.2.1 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * CIE L*a*b* to CIE XYZ and CIE XYZ to RGB conversion routines are taken
- * from the VIPS library (http://www.vips.ecs.soton.ac.uk) with
- * the permission of John Cupitt, the VIPS author.
- */
-
-/*
- * TIFF Library.
- *
- * Color space conversion routines.
- */
-
-#include "tiffiop.h"
-#include <math.h>
-
-/*
- * Convert color value from the CIE L*a*b* 1976 space to CIE XYZ.
- */
-void
-TIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32 l, int32 a, int32 b,
-		float *X, float *Y, float *Z)
-{
-	float L = (float)l * 100.0F / 255.0F;
-	float cby, tmp;
-
-	if( L < 8.856F ) {
-		*Y = (L * cielab->Y0) / 903.292F;
-		cby = 7.787F * (*Y / cielab->Y0) + 16.0F / 116.0F;
-	} else {
-		cby = (L + 16.0F) / 116.0F;
-		*Y = cielab->Y0 * cby * cby * cby;
-	}
-
-	tmp = (float)a / 500.0F + cby;
-	if( tmp < 0.2069F )
-		*X = cielab->X0 * (tmp - 0.13793F) / 7.787F;
-	else    
-		*X = cielab->X0 * tmp * tmp * tmp;
-
-	tmp = cby - (float)b / 200.0F;
-	if( tmp < 0.2069F )
-		*Z = cielab->Z0 * (tmp - 0.13793F) / 7.787F;
-	else    
-		*Z = cielab->Z0 * tmp * tmp * tmp;
-}
-
-#define RINT(R) ((uint32)((R)>0?((R)+0.5):((R)-0.5)))
-/*
- * Convert color value from the XYZ space to RGB.
- */
-void
-TIFFXYZToRGB(TIFFCIELabToRGB *cielab, float X, float Y, float Z,
-	     uint32 *r, uint32 *g, uint32 *b)
-{
-	int i;
-	float Yr, Yg, Yb;
-	float *matrix = &cielab->display.d_mat[0][0];
-
-	/* Multiply through the matrix to get luminosity values. */
-	Yr =  matrix[0] * X + matrix[1] * Y + matrix[2] * Z;
-	Yg =  matrix[3] * X + matrix[4] * Y + matrix[5] * Z;
-	Yb =  matrix[6] * X + matrix[7] * Y + matrix[8] * Z;
-
-	/* Clip input */
-	Yr = TIFFmax(Yr, cielab->display.d_Y0R);
-	Yg = TIFFmax(Yg, cielab->display.d_Y0G);
-	Yb = TIFFmax(Yb, cielab->display.d_Y0B);
-
-	/* Avoid overflow in case of wrong input values */
-	Yr = TIFFmin(Yr, cielab->display.d_YCR);
-	Yg = TIFFmin(Yg, cielab->display.d_YCG);
-	Yb = TIFFmin(Yb, cielab->display.d_YCB);
-
-	/* Turn luminosity to colour value. */
-	i = (int)((Yr - cielab->display.d_Y0R) / cielab->rstep);
-	i = TIFFmin(cielab->range, i);
-	*r = RINT(cielab->Yr2r[i]);
-
-	i = (int)((Yg - cielab->display.d_Y0G) / cielab->gstep);
-	i = TIFFmin(cielab->range, i);
-	*g = RINT(cielab->Yg2g[i]);
-
-	i = (int)((Yb - cielab->display.d_Y0B) / cielab->bstep);
-	i = TIFFmin(cielab->range, i);
-	*b = RINT(cielab->Yb2b[i]);
-
-	/* Clip output. */
-	*r = TIFFmin(*r, cielab->display.d_Vrwr);
-	*g = TIFFmin(*g, cielab->display.d_Vrwg);
-	*b = TIFFmin(*b, cielab->display.d_Vrwb);
-}
-#undef RINT
-
-/* 
- * Allocate conversion state structures and make look_up tables for
- * the Yr,Yb,Yg <=> r,g,b conversions.
- */
-int
-TIFFCIELabToRGBInit(TIFFCIELabToRGB* cielab,
-		    TIFFDisplay *display, float *refWhite)
-{
-	int i;
-	double gamma;
-
-	cielab->range = CIELABTORGB_TABLE_RANGE;
-
-	_TIFFmemcpy(&cielab->display, display, sizeof(TIFFDisplay));
-
-	/* Red */
-	gamma = 1.0 / cielab->display.d_gammaR ;
-	cielab->rstep =
-		(cielab->display.d_YCR - cielab->display.d_Y0R)	/ cielab->range;
-	for(i = 0; i <= cielab->range; i++) {
-		cielab->Yr2r[i] = cielab->display.d_Vrwr
-		    * ((float)pow((double)i / cielab->range, gamma));
-	}
-
-	/* Green */
-	gamma = 1.0 / cielab->display.d_gammaG ;
-	cielab->gstep =
-	    (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;
-	for(i = 0; i <= cielab->range; i++) {
-		cielab->Yg2g[i] = cielab->display.d_Vrwg
-		    * ((float)pow((double)i / cielab->range, gamma));
-	}
-
-	/* Blue */
-	gamma = 1.0 / cielab->display.d_gammaB ;
-	cielab->bstep =
-	    (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;
-	for(i = 0; i <= cielab->range; i++) {
-		cielab->Yb2b[i] = cielab->display.d_Vrwb
-		    * ((float)pow((double)i / cielab->range, gamma));
-	}
-
-	/* Init reference white point */
-	cielab->X0 = refWhite[0];
-	cielab->Y0 = refWhite[1];
-	cielab->Z0 = refWhite[2];
-
-	return 0;
-}
-
-/* 
- * Convert color value from the YCbCr space to CIE XYZ.
- * The colorspace conversion algorithm comes from the IJG v5a code;
- * see below for more information on how it works.
- */
-#define	SHIFT			16
-#define	FIX(x)			((int32)((x) * (1L<<SHIFT) + 0.5))
-#define	ONE_HALF		((int32)(1<<(SHIFT-1)))
-#define	Code2V(c, RB, RW, CR)	((((c)-(int32)(RB))*(float)(CR))/(float)(((RW)-(RB)) ? ((RW)-(RB)) : 1))
-#define	CLAMP(f,min,max)	((f)<(min)?(min):(f)>(max)?(max):(f))
-#define HICLAMP(f,max)		((f)>(max)?(max):(f))
-
-void
-TIFFYCbCrtoRGB(TIFFYCbCrToRGB *ycbcr, uint32 Y, int32 Cb, int32 Cr,
-	       uint32 *r, uint32 *g, uint32 *b)
-{
-	/* XXX: Only 8-bit YCbCr input supported for now */
-	Y = HICLAMP(Y, 255), Cb = CLAMP(Cb, 0, 255), Cr = CLAMP(Cr, 0, 255);
-
-	*r = ycbcr->clamptab[ycbcr->Y_tab[Y] + ycbcr->Cr_r_tab[Cr]];
-	*g = ycbcr->clamptab[ycbcr->Y_tab[Y]
-	    + (int)((ycbcr->Cb_g_tab[Cb] + ycbcr->Cr_g_tab[Cr]) >> SHIFT)];
-	*b = ycbcr->clamptab[ycbcr->Y_tab[Y] + ycbcr->Cb_b_tab[Cb]];
-}
-
-/*
- * Initialize the YCbCr->RGB conversion tables.  The conversion
- * is done according to the 6.0 spec:
- *
- *    R = Y + Cr*(2 - 2*LumaRed)
- *    B = Y + Cb*(2 - 2*LumaBlue)
- *    G =   Y
- *        - LumaBlue*Cb*(2-2*LumaBlue)/LumaGreen
- *        - LumaRed*Cr*(2-2*LumaRed)/LumaGreen
- *
- * To avoid floating point arithmetic the fractional constants that
- * come out of the equations are represented as fixed point values
- * in the range 0...2^16.  We also eliminate multiplications by
- * pre-calculating possible values indexed by Cb and Cr (this code
- * assumes conversion is being done for 8-bit samples).
- */
-int
-TIFFYCbCrToRGBInit(TIFFYCbCrToRGB* ycbcr, float *luma, float *refBlackWhite)
-{
-    TIFFRGBValue* clamptab;
-    int i;
-    
-#define LumaRed	    luma[0]
-#define LumaGreen   luma[1]
-#define LumaBlue    luma[2]
-
-    clamptab = (TIFFRGBValue*)(
-	(tidata_t) ycbcr+TIFFroundup(sizeof (TIFFYCbCrToRGB), sizeof (long)));
-    _TIFFmemset(clamptab, 0, 256);		/* v < 0 => 0 */
-    ycbcr->clamptab = (clamptab += 256);
-    for (i = 0; i < 256; i++)
-	clamptab[i] = (TIFFRGBValue) i;
-    _TIFFmemset(clamptab+256, 255, 2*256);	/* v > 255 => 255 */
-    ycbcr->Cr_r_tab = (int*) (clamptab + 3*256);
-    ycbcr->Cb_b_tab = ycbcr->Cr_r_tab + 256;
-    ycbcr->Cr_g_tab = (int32*) (ycbcr->Cb_b_tab + 256);
-    ycbcr->Cb_g_tab = ycbcr->Cr_g_tab + 256;
-    ycbcr->Y_tab = ycbcr->Cb_g_tab + 256;
-
-    { float f1 = 2-2*LumaRed;		int32 D1 = FIX(f1);
-      float f2 = LumaRed*f1/LumaGreen;	int32 D2 = -FIX(f2);
-      float f3 = 2-2*LumaBlue;		int32 D3 = FIX(f3);
-      float f4 = LumaBlue*f3/LumaGreen;	int32 D4 = -FIX(f4);
-      int x;
-
-#undef LumaBlue
-#undef LumaGreen
-#undef LumaRed
-      
-      /*
-       * i is the actual input pixel value in the range 0..255
-       * Cb and Cr values are in the range -128..127 (actually
-       * they are in a range defined by the ReferenceBlackWhite
-       * tag) so there is some range shifting to do here when
-       * constructing tables indexed by the raw pixel data.
-       */
-      for (i = 0, x = -128; i < 256; i++, x++) {
-	    int32 Cr = (int32)Code2V(x, refBlackWhite[4] - 128.0F,
-			    refBlackWhite[5] - 128.0F, 127);
-	    int32 Cb = (int32)Code2V(x, refBlackWhite[2] - 128.0F,
-			    refBlackWhite[3] - 128.0F, 127);
-
-	    ycbcr->Cr_r_tab[i] = (int32)((D1*Cr + ONE_HALF)>>SHIFT);
-	    ycbcr->Cb_b_tab[i] = (int32)((D3*Cb + ONE_HALF)>>SHIFT);
-	    ycbcr->Cr_g_tab[i] = D2*Cr;
-	    ycbcr->Cb_g_tab[i] = D4*Cb + ONE_HALF;
-	    ycbcr->Y_tab[i] =
-		    (int32)Code2V(x + 128, refBlackWhite[0], refBlackWhite[1], 255);
-      }
-    }
-
-    return 0;
-}
-#undef	HICLAMP
-#undef	CLAMP
-#undef	Code2V
-#undef	SHIFT
-#undef	ONE_HALF
-#undef	FIX
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_compress.c b/thirdparty/libtiff/tif_compress.c
deleted file mode 100644
index 0ce509b..0000000
--- a/thirdparty/libtiff/tif_compress.c
+++ /dev/null
@@ -1,295 +0,0 @@
-/* $Id: tif_compress.c,v 1.13.2.1 2010-06-08 18:50:41 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library
- *
- * Compression Scheme Configuration Support.
- */
-#include "tiffiop.h"
-
-static int
-TIFFNoEncode(TIFF* tif, const char* method)
-{
-	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
-
-	if (c) { 
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%s %s encoding is not implemented",
-			     c->name, method);
-	} else { 
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"Compression scheme %u %s encoding is not implemented",
-			     tif->tif_dir.td_compression, method);
-	}
-	return (-1);
-}
-
-int
-_TIFFNoRowEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoEncode(tif, "scanline"));
-}
-
-int
-_TIFFNoStripEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoEncode(tif, "strip"));
-}
-
-int
-_TIFFNoTileEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoEncode(tif, "tile"));
-}
-
-static int
-TIFFNoDecode(TIFF* tif, const char* method)
-{
-	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
-
-	if (c)
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%s %s decoding is not implemented",
-			     c->name, method);
-	else
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Compression scheme %u %s decoding is not implemented",
-			     tif->tif_dir.td_compression, method);
-	return (-1);
-}
-
-int
-_TIFFNoRowDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoDecode(tif, "scanline"));
-}
-
-int
-_TIFFNoStripDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoDecode(tif, "strip"));
-}
-
-int
-_TIFFNoTileDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) pp; (void) cc; (void) s;
-	return (TIFFNoDecode(tif, "tile"));
-}
-
-int
-_TIFFNoSeek(TIFF* tif, uint32 off)
-{
-	(void) off;
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		     "Compression algorithm does not support random access");
-	return (0);
-}
-
-int
-_TIFFNoPreCode(TIFF* tif, tsample_t s)
-{
-	(void) tif; (void) s;
-	return (1);
-}
-
-static int _TIFFtrue(TIFF* tif) { (void) tif; return (1); }
-static void _TIFFvoid(TIFF* tif) { (void) tif; }
-
-void
-_TIFFSetDefaultCompressionState(TIFF* tif)
-{
-	tif->tif_decodestatus = TRUE;
-	tif->tif_setupdecode = _TIFFtrue;
-	tif->tif_predecode = _TIFFNoPreCode;
-	tif->tif_decoderow = _TIFFNoRowDecode;
-	tif->tif_decodestrip = _TIFFNoStripDecode;
-	tif->tif_decodetile = _TIFFNoTileDecode;
-	tif->tif_encodestatus = TRUE;
-	tif->tif_setupencode = _TIFFtrue;
-	tif->tif_preencode = _TIFFNoPreCode;
-	tif->tif_postencode = _TIFFtrue;
-	tif->tif_encoderow = _TIFFNoRowEncode;
-	tif->tif_encodestrip = _TIFFNoStripEncode;
-	tif->tif_encodetile = _TIFFNoTileEncode;
-	tif->tif_close = _TIFFvoid;
-	tif->tif_seek = _TIFFNoSeek;
-	tif->tif_cleanup = _TIFFvoid;
-	tif->tif_defstripsize = _TIFFDefaultStripSize;
-	tif->tif_deftilesize = _TIFFDefaultTileSize;
-	tif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);
-}
-
-int
-TIFFSetCompressionScheme(TIFF* tif, int scheme)
-{
-	const TIFFCodec *c = TIFFFindCODEC((uint16) scheme);
-
-	_TIFFSetDefaultCompressionState(tif);
-	/*
-	 * Don't treat an unknown compression scheme as an error.
-	 * This permits applications to open files with data that
-	 * the library does not have builtin support for, but which
-	 * may still be meaningful.
-	 */
-	return (c ? (*c->init)(tif, scheme) : 1);
-}
-
-/*
- * Other compression schemes may be registered.  Registered
- * schemes can also override the builtin versions provided
- * by this library.
- */
-typedef struct _codec {
-	struct _codec*	next;
-	TIFFCodec*	info;
-} codec_t;
-static	codec_t* registeredCODECS = NULL;
-
-const TIFFCodec*
-TIFFFindCODEC(uint16 scheme)
-{
-	const TIFFCodec* c;
-	codec_t* cd;
-
-	for (cd = registeredCODECS; cd; cd = cd->next)
-		if (cd->info->scheme == scheme)
-			return ((const TIFFCodec*) cd->info);
-	for (c = _TIFFBuiltinCODECS; c->name; c++)
-		if (c->scheme == scheme)
-			return (c);
-	return ((const TIFFCodec*) 0);
-}
-
-TIFFCodec*
-TIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init)
-{
-	codec_t* cd = (codec_t*)
-	    _TIFFmalloc(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1);
-
-	if (cd != NULL) {
-		cd->info = (TIFFCodec*) ((tidata_t) cd + sizeof (codec_t));
-		cd->info->name = (char*)
-		    ((tidata_t) cd->info + sizeof (TIFFCodec));
-		strcpy(cd->info->name, name);
-		cd->info->scheme = scheme;
-		cd->info->init = init;
-		cd->next = registeredCODECS;
-		registeredCODECS = cd;
-	} else {
-		TIFFErrorExt(0, "TIFFRegisterCODEC",
-		    "No space to register compression scheme %s", name);
-		return NULL;
-	}
-	return (cd->info);
-}
-
-void
-TIFFUnRegisterCODEC(TIFFCodec* c)
-{
-	codec_t* cd;
-	codec_t** pcd;
-
-	for (pcd = &registeredCODECS; (cd = *pcd); pcd = &cd->next)
-		if (cd->info == c) {
-			*pcd = cd->next;
-			_TIFFfree(cd);
-			return;
-		}
-	TIFFErrorExt(0, "TIFFUnRegisterCODEC",
-	    "Cannot remove compression scheme %s; not registered", c->name);
-}
-
-/************************************************************************/
-/*                       TIFFGetConfisuredCODECs()                      */
-/************************************************************************/
-
-/**
- * Get list of configured codecs, both built-in and registered by user.
- * Caller is responsible to free this structure.
- * 
- * @return returns array of TIFFCodec records (the last record should be NULL)
- * or NULL if function failed.
- */
-
-TIFFCodec*
-TIFFGetConfiguredCODECs()
-{
-	int		i = 1;
-        codec_t		*cd;
-        const TIFFCodec	*c;
-	TIFFCodec	*codecs = NULL, *new_codecs;
-
-        for (cd = registeredCODECS; cd; cd = cd->next) {
-                new_codecs = (TIFFCodec *)
-			_TIFFrealloc(codecs, i * sizeof(TIFFCodec));
-		if (!new_codecs) {
-			_TIFFfree (codecs);
-			return NULL;
-		}
-		codecs = new_codecs;
-		_TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec));
-		i++;
-	}
-        for (c = _TIFFBuiltinCODECS; c->name; c++) {
-                if (TIFFIsCODECConfigured(c->scheme)) {
-                        new_codecs = (TIFFCodec *)
-				_TIFFrealloc(codecs, i * sizeof(TIFFCodec));
-			if (!new_codecs) {
-				_TIFFfree (codecs);
-				return NULL;
-			}
-			codecs = new_codecs;
-			_TIFFmemcpy(codecs + i - 1, (const tdata_t)c, sizeof(TIFFCodec));
-			i++;
-		}
-	}
-
-	new_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec));
-	if (!new_codecs) {
-		_TIFFfree (codecs);
-		return NULL;
-	}
-	codecs = new_codecs;
-	_TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec));
-
-        return codecs;
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_config.h b/thirdparty/libtiff/tif_config.h
deleted file mode 100644
index 08d1f0d..0000000
--- a/thirdparty/libtiff/tif_config.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/* Define to 1 if you have the <assert.h> header file. */
-#define HAVE_ASSERT_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-/* Define to 1 if you have the `jbg_newlen' function. */
-#define HAVE_JBG_NEWLEN 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <io.h> header file. */
-#define HAVE_IO_H 1
-
-/* Define to 1 if you have the <search.h> header file. */
-#define HAVE_SEARCH_H 1
-
-/* Define to 1 if you have the `setmode' function. */
-#define HAVE_SETMODE 1
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* The size of a `long', as computed by sizeof. */
-#define SIZEOF_LONG 4
-
-
-#ifdef _MSC_VER
-/* Signed 64-bit type */
-#define TIFF_INT64_T signed __int64
-/* Unsigned 64-bit type */
-#define TIFF_UINT64_T unsigned __int64
-#else
-/* Signed 64-bit type */
-#define TIFF_INT64_T long long
-/* Signed 64-bit type */
-#define TIFF_UINT64_T unsigned long long
-#endif
-
-/* Set the native cpu bit order */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-# ifndef inline
-#  define inline __inline
-# endif
-#endif
-
-#define lfind _lfind
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dir.c b/thirdparty/libtiff/tif_dir.c
deleted file mode 100644
index ac44b38..0000000
--- a/thirdparty/libtiff/tif_dir.c
+++ /dev/null
@@ -1,1389 +0,0 @@
-/* $Id: tif_dir.c,v 1.75.2.5 2010-06-09 21:15:27 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Directory Tag Get & Set Routines.
- * (and also some miscellaneous stuff)
- */
-#include "tiffiop.h"
-
-/*
- * These are used in the backwards compatibility code...
- */
-#define DATATYPE_VOID		0       /* !untyped data */
-#define DATATYPE_INT		1       /* !signed integer data */
-#define DATATYPE_UINT		2       /* !unsigned integer data */
-#define DATATYPE_IEEEFP		3       /* !IEEE floating point data */
-
-static void
-setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)
-{
-	if (*vpp)
-		_TIFFfree(*vpp), *vpp = 0;
-	if (vp) {
-		tsize_t	bytes = nmemb * elem_size;
-		if (elem_size && bytes / elem_size == nmemb)
-			*vpp = (void*) _TIFFmalloc(bytes);
-		if (*vpp)
-			_TIFFmemcpy(*vpp, vp, bytes);
-	}
-}
-void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)
-    { setByteArray(vpp, vp, n, 1); }
-void _TIFFsetString(char** cpp, char* cp)
-    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }
-void _TIFFsetNString(char** cpp, char* cp, uint32 n)
-    { setByteArray((void**) cpp, (void*) cp, n, 1); }
-void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)
-    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }
-void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)
-    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }
-void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)
-    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }
-void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)
-    { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }
-
-/*
- * Install extra samples information.
- */
-static int
-setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)
-{
-/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
-#define EXTRASAMPLE_COREL_UNASSALPHA 999 
-
-	uint16* va;
-	uint32 i;
-
-	*v = va_arg(ap, uint32);
-	if ((uint16) *v > td->td_samplesperpixel)
-		return 0;
-	va = va_arg(ap, uint16*);
-	if (*v > 0 && va == NULL)		/* typically missing param */
-		return 0;
-	for (i = 0; i < *v; i++) {
-		if (va[i] > EXTRASAMPLE_UNASSALPHA) {
-			/*
-			 * XXX: Corel Draw is known to produce incorrect
-			 * ExtraSamples tags which must be patched here if we
-			 * want to be able to open some of the damaged TIFF
-			 * files: 
-			 */
-			if (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)
-				va[i] = EXTRASAMPLE_UNASSALPHA;
-			else
-				return 0;
-		}
-	}
-	td->td_extrasamples = (uint16) *v;
-	_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);
-	return 1;
-
-#undef EXTRASAMPLE_COREL_UNASSALPHA
-}
-
-static uint32
-checkInkNamesString(TIFF* tif, uint32 slen, const char* s)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	uint16 i = td->td_samplesperpixel;
-
-	if (slen > 0) {
-		const char* ep = s+slen;
-		const char* cp = s;
-		for (; i > 0; i--) {
-			for (; *cp != '\0'; cp++)
-				if (cp >= ep)
-					goto bad;
-			cp++;				/* skip \0 */
-		}
-		return (cp-s);
-	}
-bad:
-	TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
-	    "%s: Invalid InkNames value; expecting %d names, found %d",
-	    tif->tif_name,
-	    td->td_samplesperpixel,
-	    td->td_samplesperpixel-i);
-	return (0);
-}
-
-static int
-_TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	static const char module[] = "_TIFFVSetField";
-
-	TIFFDirectory* td = &tif->tif_dir;
-	int status = 1;
-	uint32 v32, i, v;
-	char* s;
-
-	switch (tag) {
-	case TIFFTAG_SUBFILETYPE:
-		td->td_subfiletype = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_IMAGEWIDTH:
-		td->td_imagewidth = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_IMAGELENGTH:
-		td->td_imagelength = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_BITSPERSAMPLE:
-		td->td_bitspersample = (uint16) va_arg(ap, int);
-		/*
-		 * If the data require post-decoding processing to byte-swap
-		 * samples, set it up here.  Note that since tags are required
-		 * to be ordered, compression code can override this behaviour
-		 * in the setup method if it wants to roll the post decoding
-		 * work in with its normal work.
-		 */
-		if (tif->tif_flags & TIFF_SWAB) {
-			if (td->td_bitspersample == 16)
-				tif->tif_postdecode = _TIFFSwab16BitData;
-			else if (td->td_bitspersample == 24)
-				tif->tif_postdecode = _TIFFSwab24BitData;
-			else if (td->td_bitspersample == 32)
-				tif->tif_postdecode = _TIFFSwab32BitData;
-			else if (td->td_bitspersample == 64)
-				tif->tif_postdecode = _TIFFSwab64BitData;
-			else if (td->td_bitspersample == 128) /* two 64's */
-				tif->tif_postdecode = _TIFFSwab64BitData;
-		}
-		break;
-	case TIFFTAG_COMPRESSION:
-		v = va_arg(ap, uint32) & 0xffff;
-		/*
-		 * If we're changing the compression scheme, the notify the
-		 * previous module so that it can cleanup any state it's
-		 * setup.
-		 */
-		if (TIFFFieldSet(tif, FIELD_COMPRESSION)) {
-			if (td->td_compression == v)
-				break;
-			(*tif->tif_cleanup)(tif);
-			tif->tif_flags &= ~TIFF_CODERSETUP;
-		}
-		/*
-		 * Setup new compression routine state.
-		 */
-		if( (status = TIFFSetCompressionScheme(tif, v)) != 0 )
-                    td->td_compression = (uint16) v;
-                else
-                    status = 0;
-		break;
-	case TIFFTAG_PHOTOMETRIC:
-		td->td_photometric = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_THRESHHOLDING:
-		td->td_threshholding = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_FILLORDER:
-		v = va_arg(ap, uint32);
-		if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)
-			goto badvalue;
-		td->td_fillorder = (uint16) v;
-		break;
-	case TIFFTAG_ORIENTATION:
-		v = va_arg(ap, uint32);
-		if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)
-			goto badvalue;
-		else
-			td->td_orientation = (uint16) v;
-		break;
-	case TIFFTAG_SAMPLESPERPIXEL:
-		/* XXX should cross check -- e.g. if pallette, then 1 */
-		v = va_arg(ap, uint32);
-		if (v == 0)
-			goto badvalue;
-		td->td_samplesperpixel = (uint16) v;
-		break;
-	case TIFFTAG_ROWSPERSTRIP:
-		v32 = va_arg(ap, uint32);
-		if (v32 == 0)
-			goto badvalue32;
-		td->td_rowsperstrip = v32;
-		if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
-			td->td_tilelength = v32;
-			td->td_tilewidth = td->td_imagewidth;
-		}
-		break;
-	case TIFFTAG_MINSAMPLEVALUE:
-		td->td_minsamplevalue = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_MAXSAMPLEVALUE:
-		td->td_maxsamplevalue = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_SMINSAMPLEVALUE:
-		td->td_sminsamplevalue = va_arg(ap, double);
-		break;
-	case TIFFTAG_SMAXSAMPLEVALUE:
-		td->td_smaxsamplevalue = va_arg(ap, double);
-		break;
-	case TIFFTAG_XRESOLUTION:
-		td->td_xresolution = (float) va_arg(ap, double);
-		break;
-	case TIFFTAG_YRESOLUTION:
-		td->td_yresolution = (float) va_arg(ap, double);
-		break;
-	case TIFFTAG_PLANARCONFIG:
-		v = va_arg(ap, uint32);
-		if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)
-			goto badvalue;
-		td->td_planarconfig = (uint16) v;
-		break;
-	case TIFFTAG_XPOSITION:
-		td->td_xposition = (float) va_arg(ap, double);
-		break;
-	case TIFFTAG_YPOSITION:
-		td->td_yposition = (float) va_arg(ap, double);
-		break;
-	case TIFFTAG_RESOLUTIONUNIT:
-		v = va_arg(ap, uint32);
-		if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)
-			goto badvalue;
-		td->td_resolutionunit = (uint16) v;
-		break;
-	case TIFFTAG_PAGENUMBER:
-		td->td_pagenumber[0] = (uint16) va_arg(ap, int);
-		td->td_pagenumber[1] = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_HALFTONEHINTS:
-		td->td_halftonehints[0] = (uint16) va_arg(ap, int);
-		td->td_halftonehints[1] = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_COLORMAP:
-		v32 = (uint32)(1L<<td->td_bitspersample);
-		_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);
-		_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);
-		_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);
-		break;
-	case TIFFTAG_EXTRASAMPLES:
-		if (!setExtraSamples(td, ap, &v))
-			goto badvalue;
-		break;
-	case TIFFTAG_MATTEING:
-		td->td_extrasamples = (uint16) (va_arg(ap, int) != 0);
-		if (td->td_extrasamples) {
-			uint16 sv = EXTRASAMPLE_ASSOCALPHA;
-			_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);
-		}
-		break;
-	case TIFFTAG_TILEWIDTH:
-		v32 = va_arg(ap, uint32);
-		if (v32 % 16) {
-			if (tif->tif_mode != O_RDONLY)
-				goto badvalue32;
-			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-				"Nonstandard tile width %d, convert file", v32);
-		}
-		td->td_tilewidth = v32;
-		tif->tif_flags |= TIFF_ISTILED;
-		break;
-	case TIFFTAG_TILELENGTH:
-		v32 = va_arg(ap, uint32);
-		if (v32 % 16) {
-			if (tif->tif_mode != O_RDONLY)
-				goto badvalue32;
-			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-			    "Nonstandard tile length %d, convert file", v32);
-		}
-		td->td_tilelength = v32;
-		tif->tif_flags |= TIFF_ISTILED;
-		break;
-	case TIFFTAG_TILEDEPTH:
-		v32 = va_arg(ap, uint32);
-		if (v32 == 0)
-			goto badvalue32;
-		td->td_tiledepth = v32;
-		break;
-	case TIFFTAG_DATATYPE:
-		v = va_arg(ap, uint32);
-		switch (v) {
-		case DATATYPE_VOID:	v = SAMPLEFORMAT_VOID;	break;
-		case DATATYPE_INT:	v = SAMPLEFORMAT_INT;	break;
-		case DATATYPE_UINT:	v = SAMPLEFORMAT_UINT;	break;
-		case DATATYPE_IEEEFP:	v = SAMPLEFORMAT_IEEEFP;break;
-		default:		goto badvalue;
-		}
-		td->td_sampleformat = (uint16) v;
-		break;
-	case TIFFTAG_SAMPLEFORMAT:
-		v = va_arg(ap, uint32);
-		if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)
-			goto badvalue;
-		td->td_sampleformat = (uint16) v;
-
-                /*  Try to fix up the SWAB function for complex data. */
-                if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT 
-                    && td->td_bitspersample == 32
-                    && tif->tif_postdecode == _TIFFSwab32BitData )
-                    tif->tif_postdecode = _TIFFSwab16BitData;
-                else if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT 
-                          || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)
-                         && td->td_bitspersample == 64
-                         && tif->tif_postdecode == _TIFFSwab64BitData )
-                    tif->tif_postdecode = _TIFFSwab32BitData;
-		break;
-	case TIFFTAG_IMAGEDEPTH:
-		td->td_imagedepth = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_SUBIFD:
-		if ((tif->tif_flags & TIFF_INSUBIFD) == 0) {
-			td->td_nsubifd = (uint16) va_arg(ap, int);
-			_TIFFsetLongArray(&td->td_subifd, va_arg(ap, uint32*),
-			    (long) td->td_nsubifd);
-		} else {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "%s: Sorry, cannot nest SubIFDs",
-				     tif->tif_name);
-			status = 0;
-		}
-		break;
-	case TIFFTAG_YCBCRPOSITIONING:
-		td->td_ycbcrpositioning = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_YCBCRSUBSAMPLING:
-		td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, int);
-		td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_TRANSFERFUNCTION:
-		v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;
-		for (i = 0; i < v; i++)
-			_TIFFsetShortArray(&td->td_transferfunction[i],
-			    va_arg(ap, uint16*), 1L<<td->td_bitspersample);
-		break;
-	case TIFFTAG_REFERENCEBLACKWHITE:
-		/* XXX should check for null range */
-		_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);
-		break;
-	case TIFFTAG_INKNAMES:
-		v = va_arg(ap, uint32);
-		s = va_arg(ap, char*);
-		v = checkInkNamesString(tif, v, s);
-                status = v > 0;
-		if( v > 0 ) {
-			_TIFFsetNString(&td->td_inknames, s, v);
-			td->td_inknameslen = v;
-		}
-		break;
-        default: {
-            TIFFTagValue *tv;
-            int tv_size, iCustom;
-	    const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);
-
-            /*
-	     * This can happen if multiple images are open with different
-	     * codecs which have private tags.  The global tag information
-	     * table may then have tags that are valid for one file but not
-	     * the other. If the client tries to set a tag that is not valid
-	     * for the image's codec then we'll arrive here.  This
-	     * happens, for example, when tiffcp is used to convert between
-	     * compression schemes and codec-specific tags are blindly copied.
-             */
-            if(fip == NULL || fip->field_bit != FIELD_CUSTOM) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s: Invalid %stag \"%s\" (not supported by codec)",
-			     tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "",
-			     fip ? fip->field_name : "Unknown");
-		status = 0;
-		break;
-            }
-
-            /*
-             * Find the existing entry for this custom value.
-             */
-            tv = NULL;
-            for (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {
-		    if (td->td_customValues[iCustom].info->field_tag == tag) {
-			    tv = td->td_customValues + iCustom;
-			    if (tv->value != NULL) {
-				    _TIFFfree(tv->value);
-				    tv->value = NULL;
-			    }
-			    break;
-		    }
-            }
-
-            /*
-             * Grow the custom list if the entry was not found.
-             */
-            if(tv == NULL) {
-		TIFFTagValue	*new_customValues;
-		
-		td->td_customValueCount++;
-		new_customValues = (TIFFTagValue *)
-			_TIFFrealloc(td->td_customValues,
-				     sizeof(TIFFTagValue) * td->td_customValueCount);
-		if (!new_customValues) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-		"%s: Failed to allocate space for list of custom values",
-				  tif->tif_name);
-			status = 0;
-			goto end;
-		}
-
-		td->td_customValues = new_customValues;
-
-                tv = td->td_customValues + (td->td_customValueCount - 1);
-                tv->info = fip;
-                tv->value = NULL;
-                tv->count = 0;
-            }
-
-            /*
-             * Set custom value ... save a copy of the custom tag value.
-             */
-	    tv_size = _TIFFDataSize(fip->field_type);
-	    if (tv_size == 0) {
-		    status = 0;
-		    TIFFErrorExt(tif->tif_clientdata, module,
-				 "%s: Bad field type %d for \"%s\"",
-				 tif->tif_name, fip->field_type,
-				 fip->field_name);
-		    goto end;
-	    }
-           
-            if(fip->field_passcount) {
-		    if (fip->field_writecount == TIFF_VARIABLE2)
-			tv->count = (uint32) va_arg(ap, uint32);
-		    else
-			tv->count = (int) va_arg(ap, int);
-	    } else if (fip->field_writecount == TIFF_VARIABLE
-		       || fip->field_writecount == TIFF_VARIABLE2)
-		tv->count = 1;
-	    else if (fip->field_writecount == TIFF_SPP)
-		tv->count = td->td_samplesperpixel;
-	    else
-                tv->count = fip->field_writecount;
-            
-    
-	    if (fip->field_type == TIFF_ASCII)
-		    _TIFFsetString((char **)&tv->value, va_arg(ap, char *));
-	    else {
-		tv->value = _TIFFCheckMalloc(tif, tv_size, tv->count,
-					     "Tag Value");
-		if (!tv->value) {
-		    status = 0;
-		    goto end;
-		}
-
-		if ((fip->field_passcount
-		    || fip->field_writecount == TIFF_VARIABLE
-		    || fip->field_writecount == TIFF_VARIABLE2
-		    || fip->field_writecount == TIFF_SPP
-		    || tv->count > 1)
-		    && fip->field_tag != TIFFTAG_PAGENUMBER
-		    && fip->field_tag != TIFFTAG_HALFTONEHINTS
-		    && fip->field_tag != TIFFTAG_YCBCRSUBSAMPLING
-		    && fip->field_tag != TIFFTAG_DOTRANGE) {
-                    _TIFFmemcpy(tv->value, va_arg(ap, void *),
-				tv->count * tv_size);
-		} else {
-		    /*
-		     * XXX: The following loop required to handle
-		     * TIFFTAG_PAGENUMBER, TIFFTAG_HALFTONEHINTS,
-		     * TIFFTAG_YCBCRSUBSAMPLING and TIFFTAG_DOTRANGE tags.
-		     * These tags are actually arrays and should be passed as
-		     * array pointers to TIFFSetField() function, but actually
-		     * passed as a list of separate values. This behaviour
-		     * must be changed in the future!
-		     */
-		    int i;
-		    char *val = (char *)tv->value;
-
-		    for (i = 0; i < tv->count; i++, val += tv_size) {
-			    switch (fip->field_type) {
-				case TIFF_BYTE:
-				case TIFF_UNDEFINED:
-				    {
-					uint8 v = (uint8)va_arg(ap, int);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_SBYTE:
-				    {
-					int8 v = (int8)va_arg(ap, int);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_SHORT:
-				    {
-					uint16 v = (uint16)va_arg(ap, int);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_SSHORT:
-				    {
-					int16 v = (int16)va_arg(ap, int);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_LONG:
-				case TIFF_IFD:
-				    {
-					uint32 v = va_arg(ap, uint32);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_SLONG:
-				    {
-					int32 v = va_arg(ap, int32);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_RATIONAL:
-				case TIFF_SRATIONAL:
-				case TIFF_FLOAT:
-				    {
-					float v = (float)va_arg(ap, double);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				case TIFF_DOUBLE:
-				    {
-					double v = va_arg(ap, double);
-					_TIFFmemcpy(val, &v, tv_size);
-				    }
-				    break;
-				default:
-				    _TIFFmemset(val, 0, tv_size);
-				    status = 0;
-				    break;
-			    }
-		    }
-		}
-	    }
-          }
-	}
-	if (status) {
-		TIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit);
-		tif->tif_flags |= TIFF_DIRTYDIRECT;
-	}
-
-end:
-	va_end(ap);
-	return (status);
-badvalue:
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: Bad value %d for \"%s\" tag",
-		     tif->tif_name, v,
-		     _TIFFFieldWithTag(tif, tag)->field_name);
-	va_end(ap);
-	return (0);
-badvalue32:
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: Bad value %u for \"%s\" tag",
-		     tif->tif_name, v32,
-		     _TIFFFieldWithTag(tif, tag)->field_name);
-	va_end(ap);
-	return (0);
-}
-
-/*
- * Return 1/0 according to whether or not
- * it is permissible to set the tag's value.
- * Note that we allow ImageLength to be changed
- * so that we can append and extend to images.
- * Any other tag may not be altered once writing
- * has commenced, unless its value has no effect
- * on the format of the data that is written.
- */
-static int
-OkToChangeTag(TIFF* tif, ttag_t tag)
-{
-	const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);
-	if (!fip) {			/* unknown tag */
-		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField", "%s: Unknown %stag %u",
-		    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "", tag);
-		return (0);
-	}
-	if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&
-	    !fip->field_oktochange) {
-		/*
-		 * Consult info table to see if tag can be changed
-		 * after we've started writing.  We only allow changes
-		 * to those tags that don't/shouldn't affect the
-		 * compression and/or format of the data.
-		 */
-		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
-		    "%s: Cannot modify tag \"%s\" while writing",
-		    tif->tif_name, fip->field_name);
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * Record the value of a field in the
- * internal directory structure.  The
- * field will be written to the file
- * when/if the directory structure is
- * updated.
- */
-int
-TIFFSetField(TIFF* tif, ttag_t tag, ...)
-{
-	va_list ap;
-	int status;
-
-	va_start(ap, tag);
-	status = TIFFVSetField(tif, tag, ap);
-	va_end(ap);
-	return (status);
-}
-
-/*
- * Like TIFFSetField, but taking a varargs
- * parameter list.  This routine is useful
- * for building higher-level interfaces on
- * top of the library.
- */
-int
-TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	return OkToChangeTag(tif, tag) ?
-	    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;
-}
-
-static int
-_TIFFVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-    TIFFDirectory* td = &tif->tif_dir;
-    int            ret_val = 1;
-
-    switch (tag) {
-	case TIFFTAG_SUBFILETYPE:
-            *va_arg(ap, uint32*) = td->td_subfiletype;
-            break;
-	case TIFFTAG_IMAGEWIDTH:
-            *va_arg(ap, uint32*) = td->td_imagewidth;
-            break;
-	case TIFFTAG_IMAGELENGTH:
-            *va_arg(ap, uint32*) = td->td_imagelength;
-            break;
-	case TIFFTAG_BITSPERSAMPLE:
-            *va_arg(ap, uint16*) = td->td_bitspersample;
-            break;
-	case TIFFTAG_COMPRESSION:
-            *va_arg(ap, uint16*) = td->td_compression;
-            break;
-	case TIFFTAG_PHOTOMETRIC:
-            *va_arg(ap, uint16*) = td->td_photometric;
-            break;
-	case TIFFTAG_THRESHHOLDING:
-            *va_arg(ap, uint16*) = td->td_threshholding;
-            break;
-	case TIFFTAG_FILLORDER:
-            *va_arg(ap, uint16*) = td->td_fillorder;
-            break;
-	case TIFFTAG_ORIENTATION:
-            *va_arg(ap, uint16*) = td->td_orientation;
-            break;
-	case TIFFTAG_SAMPLESPERPIXEL:
-            *va_arg(ap, uint16*) = td->td_samplesperpixel;
-            break;
-	case TIFFTAG_ROWSPERSTRIP:
-            *va_arg(ap, uint32*) = td->td_rowsperstrip;
-            break;
-	case TIFFTAG_MINSAMPLEVALUE:
-            *va_arg(ap, uint16*) = td->td_minsamplevalue;
-            break;
-	case TIFFTAG_MAXSAMPLEVALUE:
-            *va_arg(ap, uint16*) = td->td_maxsamplevalue;
-            break;
-	case TIFFTAG_SMINSAMPLEVALUE:
-            *va_arg(ap, double*) = td->td_sminsamplevalue;
-            break;
-	case TIFFTAG_SMAXSAMPLEVALUE:
-            *va_arg(ap, double*) = td->td_smaxsamplevalue;
-            break;
-	case TIFFTAG_XRESOLUTION:
-            *va_arg(ap, float*) = td->td_xresolution;
-            break;
-	case TIFFTAG_YRESOLUTION:
-            *va_arg(ap, float*) = td->td_yresolution;
-            break;
-	case TIFFTAG_PLANARCONFIG:
-            *va_arg(ap, uint16*) = td->td_planarconfig;
-            break;
-	case TIFFTAG_XPOSITION:
-            *va_arg(ap, float*) = td->td_xposition;
-            break;
-	case TIFFTAG_YPOSITION:
-            *va_arg(ap, float*) = td->td_yposition;
-            break;
-	case TIFFTAG_RESOLUTIONUNIT:
-            *va_arg(ap, uint16*) = td->td_resolutionunit;
-            break;
-	case TIFFTAG_PAGENUMBER:
-            *va_arg(ap, uint16*) = td->td_pagenumber[0];
-            *va_arg(ap, uint16*) = td->td_pagenumber[1];
-            break;
-	case TIFFTAG_HALFTONEHINTS:
-            *va_arg(ap, uint16*) = td->td_halftonehints[0];
-            *va_arg(ap, uint16*) = td->td_halftonehints[1];
-            break;
-	case TIFFTAG_COLORMAP:
-            *va_arg(ap, uint16**) = td->td_colormap[0];
-            *va_arg(ap, uint16**) = td->td_colormap[1];
-            *va_arg(ap, uint16**) = td->td_colormap[2];
-            break;
-	case TIFFTAG_STRIPOFFSETS:
-	case TIFFTAG_TILEOFFSETS:
-            *va_arg(ap, uint32**) = td->td_stripoffset;
-            break;
-	case TIFFTAG_STRIPBYTECOUNTS:
-	case TIFFTAG_TILEBYTECOUNTS:
-            *va_arg(ap, uint32**) = td->td_stripbytecount;
-            break;
-	case TIFFTAG_MATTEING:
-            *va_arg(ap, uint16*) =
-                (td->td_extrasamples == 1 &&
-                 td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
-            break;
-	case TIFFTAG_EXTRASAMPLES:
-            *va_arg(ap, uint16*) = td->td_extrasamples;
-            *va_arg(ap, uint16**) = td->td_sampleinfo;
-            break;
-	case TIFFTAG_TILEWIDTH:
-            *va_arg(ap, uint32*) = td->td_tilewidth;
-            break;
-	case TIFFTAG_TILELENGTH:
-            *va_arg(ap, uint32*) = td->td_tilelength;
-            break;
-	case TIFFTAG_TILEDEPTH:
-            *va_arg(ap, uint32*) = td->td_tiledepth;
-            break;
-	case TIFFTAG_DATATYPE:
-            switch (td->td_sampleformat) {
-		case SAMPLEFORMAT_UINT:
-                    *va_arg(ap, uint16*) = DATATYPE_UINT;
-                    break;
-		case SAMPLEFORMAT_INT:
-                    *va_arg(ap, uint16*) = DATATYPE_INT;
-                    break;
-		case SAMPLEFORMAT_IEEEFP:
-                    *va_arg(ap, uint16*) = DATATYPE_IEEEFP;
-                    break;
-		case SAMPLEFORMAT_VOID:
-                    *va_arg(ap, uint16*) = DATATYPE_VOID;
-                    break;
-            }
-            break;
-	case TIFFTAG_SAMPLEFORMAT:
-            *va_arg(ap, uint16*) = td->td_sampleformat;
-            break;
-	case TIFFTAG_IMAGEDEPTH:
-            *va_arg(ap, uint32*) = td->td_imagedepth;
-            break;
-	case TIFFTAG_SUBIFD:
-            *va_arg(ap, uint16*) = td->td_nsubifd;
-            *va_arg(ap, uint32**) = td->td_subifd;
-            break;
-	case TIFFTAG_YCBCRPOSITIONING:
-            *va_arg(ap, uint16*) = td->td_ycbcrpositioning;
-            break;
-	case TIFFTAG_YCBCRSUBSAMPLING:
-            *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
-            *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
-            break;
-	case TIFFTAG_TRANSFERFUNCTION:
-            *va_arg(ap, uint16**) = td->td_transferfunction[0];
-            if (td->td_samplesperpixel - td->td_extrasamples > 1) {
-                *va_arg(ap, uint16**) = td->td_transferfunction[1];
-                *va_arg(ap, uint16**) = td->td_transferfunction[2];
-            }
-            break;
-	case TIFFTAG_REFERENCEBLACKWHITE:
-	    *va_arg(ap, float**) = td->td_refblackwhite;
-	    break;
-	case TIFFTAG_INKNAMES:
-            *va_arg(ap, char**) = td->td_inknames;
-            break;
-        default:
-        {
-            const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);
-            int           i;
-            
-            /*
-	     * This can happen if multiple images are open with different
-	     * codecs which have private tags.  The global tag information
-	     * table may then have tags that are valid for one file but not
-	     * the other. If the client tries to get a tag that is not valid
-	     * for the image's codec then we'll arrive here.
-             */
-            if( fip == NULL || fip->field_bit != FIELD_CUSTOM )
-            {
-		    TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
-				 "%s: Invalid %stag \"%s\" "
-				 "(not supported by codec)",
-				 tif->tif_name,
-				 isPseudoTag(tag) ? "pseudo-" : "",
-				 fip ? fip->field_name : "Unknown");
-		    ret_val = 0;
-		    break;
-            }
-
-            /*
-	     * Do we have a custom value?
-	     */
-            ret_val = 0;
-            for (i = 0; i < td->td_customValueCount; i++) {
-		TIFFTagValue *tv = td->td_customValues + i;
-
-		if (tv->info->field_tag != tag)
-			continue;
-                
-		if (fip->field_passcount) {
-			if (fip->field_readcount == TIFF_VARIABLE2) 
-				*va_arg(ap, uint32*) = (uint32)tv->count;
-			else	/* Assume TIFF_VARIABLE */
-				*va_arg(ap, uint16*) = (uint16)tv->count;
-			*va_arg(ap, void **) = tv->value;
-			ret_val = 1;
-                } else {
-			if ((fip->field_type == TIFF_ASCII
-			    || fip->field_readcount == TIFF_VARIABLE
-			    || fip->field_readcount == TIFF_VARIABLE2
-			    || fip->field_readcount == TIFF_SPP
-			    || tv->count > 1)
-			    && fip->field_tag != TIFFTAG_PAGENUMBER
-			    && fip->field_tag != TIFFTAG_HALFTONEHINTS
-			    && fip->field_tag != TIFFTAG_YCBCRSUBSAMPLING
-			    && fip->field_tag != TIFFTAG_DOTRANGE) {
-				*va_arg(ap, void **) = tv->value;
-				ret_val = 1;
-			} else {
-			    int j;
-			    char *val = (char *)tv->value;
-
-			    for (j = 0; j < tv->count;
-				 j++, val += _TIFFDataSize(tv->info->field_type)) {
-				switch (fip->field_type) {
-					case TIFF_BYTE:
-					case TIFF_UNDEFINED:
-						*va_arg(ap, uint8*) =
-							*(uint8 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_SBYTE:
-						*va_arg(ap, int8*) =
-							*(int8 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_SHORT:
-						*va_arg(ap, uint16*) =
-							*(uint16 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_SSHORT:
-						*va_arg(ap, int16*) =
-							*(int16 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_LONG:
-					case TIFF_IFD:
-						*va_arg(ap, uint32*) =
-							*(uint32 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_SLONG:
-						*va_arg(ap, int32*) =
-							*(int32 *)val;
-						ret_val = 1;
-						break;
-					case TIFF_RATIONAL:
-					case TIFF_SRATIONAL:
-					case TIFF_FLOAT:
-						*va_arg(ap, float*) =
-							*(float *)val;
-						ret_val = 1;
-						break;
-					case TIFF_DOUBLE:
-						*va_arg(ap, double*) =
-							*(double *)val;
-						ret_val = 1;
-						break;
-					default:
-						ret_val = 0;
-						break;
-				}
-			    }
-			}
-                }
-		break;
-            }
-        }
-    }
-    return(ret_val);
-}
-
-/*
- * Return the value of a field in the
- * internal directory structure.
- */
-int
-TIFFGetField(TIFF* tif, ttag_t tag, ...)
-{
-	int status;
-	va_list ap;
-
-	va_start(ap, tag);
-	status = TIFFVGetField(tif, tag, ap);
-	va_end(ap);
-	return (status);
-}
-
-/*
- * Like TIFFGetField, but taking a varargs
- * parameter list.  This routine is useful
- * for building higher-level interfaces on
- * top of the library.
- */
-int
-TIFFVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);
-	return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?
-	    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);
-}
-
-#define	CleanupField(member) {		\
-    if (td->member) {			\
-	_TIFFfree(td->member);		\
-	td->member = 0;			\
-    }					\
-}
-
-/*
- * Release storage associated with a directory.
- */
-void
-TIFFFreeDirectory(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	int            i;
-
-	_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);
-	CleanupField(td_colormap[0]);
-	CleanupField(td_colormap[1]);
-	CleanupField(td_colormap[2]);
-	CleanupField(td_sampleinfo);
-	CleanupField(td_subifd);
-	CleanupField(td_inknames);
-	CleanupField(td_refblackwhite);
-	CleanupField(td_transferfunction[0]);
-	CleanupField(td_transferfunction[1]);
-	CleanupField(td_transferfunction[2]);
-	CleanupField(td_stripoffset);
-	CleanupField(td_stripbytecount);
-	TIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);
-	TIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);
-
-	/* Cleanup custom tag values */
-	for( i = 0; i < td->td_customValueCount; i++ ) {
-		if (td->td_customValues[i].value)
-			_TIFFfree(td->td_customValues[i].value);
-	}
-
-	td->td_customValueCount = 0;
-	CleanupField(td_customValues);
-}
-#undef CleanupField
-
-/*
- * Client Tag extension support (from Niles Ritter).
- */
-static TIFFExtendProc _TIFFextender = (TIFFExtendProc) NULL;
-
-TIFFExtendProc
-TIFFSetTagExtender(TIFFExtendProc extender)
-{
-	TIFFExtendProc prev = _TIFFextender;
-	_TIFFextender = extender;
-	return (prev);
-}
-
-/*
- * Setup for a new directory.  Should we automatically call
- * TIFFWriteDirectory() if the current one is dirty?
- *
- * The newly created directory will not exist on the file till
- * TIFFWriteDirectory(), TIFFFlush() or TIFFClose() is called.
- */
-int
-TIFFCreateDirectory(TIFF* tif)
-{
-    TIFFDefaultDirectory(tif);
-    tif->tif_diroff = 0;
-    tif->tif_nextdiroff = 0;
-    tif->tif_curoff = 0;
-    tif->tif_row = (uint32) -1;
-    tif->tif_curstrip = (tstrip_t) -1;
-
-    return 0;
-}
-
-/*
- * Setup a default directory structure.
- */
-int
-TIFFDefaultDirectory(TIFF* tif)
-{
-	register TIFFDirectory* td = &tif->tif_dir;
-
-	size_t tiffFieldInfoCount;
-	const TIFFFieldInfo *tiffFieldInfo =
-	    _TIFFGetFieldInfo(&tiffFieldInfoCount);
-	_TIFFSetupFieldInfo(tif, tiffFieldInfo, tiffFieldInfoCount);
-
-	_TIFFmemset(td, 0, sizeof (*td));
-	td->td_fillorder = FILLORDER_MSB2LSB;
-	td->td_bitspersample = 1;
-	td->td_threshholding = THRESHHOLD_BILEVEL;
-	td->td_orientation = ORIENTATION_TOPLEFT;
-	td->td_samplesperpixel = 1;
-	td->td_rowsperstrip = (uint32) -1;
-	td->td_tilewidth = 0;
-	td->td_tilelength = 0;
-	td->td_tiledepth = 1;
-	td->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */
-	td->td_resolutionunit = RESUNIT_INCH;
-	td->td_sampleformat = SAMPLEFORMAT_UINT;
-	td->td_imagedepth = 1;
-	td->td_ycbcrsubsampling[0] = 2;
-	td->td_ycbcrsubsampling[1] = 2;
-	td->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;
-	tif->tif_postdecode = _TIFFNoPostDecode;
-	tif->tif_foundfield = NULL;
-	tif->tif_tagmethods.vsetfield = _TIFFVSetField;
-	tif->tif_tagmethods.vgetfield = _TIFFVGetField;
-	tif->tif_tagmethods.printdir = NULL;
-	/*
-	 *  Give client code a chance to install their own
-	 *  tag extensions & methods, prior to compression overloads.
-	 */
-	if (_TIFFextender)
-		(*_TIFFextender)(tif);
-	(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
-	/*
-	 * NB: The directory is marked dirty as a result of setting
-	 * up the default compression scheme.  However, this really
-	 * isn't correct -- we want TIFF_DIRTYDIRECT to be set only
-	 * if the user does something.  We could just do the setup
-	 * by hand, but it seems better to use the normal mechanism
-	 * (i.e. TIFFSetField).
-	 */
-	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
-
-	/*
-	 * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19
-	 * we clear the ISTILED flag when setting up a new directory.
-	 * Should we also be clearing stuff like INSUBIFD?
-	 */
-	tif->tif_flags &= ~TIFF_ISTILED;
-        /*
-         * Clear other directory-specific fields.
-         */
-        tif->tif_tilesize = -1;
-        tif->tif_scanlinesize = -1;
-
-	return (1);
-}
-
-static int
-TIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off)
-{
-	static const char module[] = "TIFFAdvanceDirectory";
-	uint16 dircount;
-	if (isMapped(tif))
-	{
-		toff_t poff=*nextdir;
-		if (poff+sizeof(uint16) > tif->tif_size)
-		{
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
-			    tif->tif_name);
-			return (0);
-		}
-		_TIFFmemcpy(&dircount, tif->tif_base+poff, sizeof (uint16));
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		poff+=sizeof (uint16)+dircount*sizeof (TIFFDirEntry);
-		if (off != NULL)
-			*off = poff;
-		if (((toff_t) (poff+sizeof (uint32))) > tif->tif_size)
-		{
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory link",
-			    tif->tif_name);
-			return (0);
-		}
-		_TIFFmemcpy(nextdir, tif->tif_base+poff, sizeof (uint32));
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabLong(nextdir);
-		return (1);
-	}
-	else
-	{
-		if (!SeekOK(tif, *nextdir) ||
-		    !ReadOK(tif, &dircount, sizeof (uint16))) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
-			    tif->tif_name);
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		if (off != NULL)
-			*off = TIFFSeekFile(tif,
-			    dircount*sizeof (TIFFDirEntry), SEEK_CUR);
-		else
-			(void) TIFFSeekFile(tif,
-			    dircount*sizeof (TIFFDirEntry), SEEK_CUR);
-		if (!ReadOK(tif, nextdir, sizeof (uint32))) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory link",
-			    tif->tif_name);
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabLong(nextdir);
-		return (1);
-	}
-}
-
-/*
- * Count the number of directories in a file.
- */
-tdir_t
-TIFFNumberOfDirectories(TIFF* tif)
-{
-    toff_t nextdir = tif->tif_header.tiff_diroff;
-    tdir_t n = 0;
-    
-    while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))
-        n++;
-    return (n);
-}
-
-/*
- * Set the n-th directory as the current directory.
- * NB: Directories are numbered starting at 0.
- */
-int
-TIFFSetDirectory(TIFF* tif, tdir_t dirn)
-{
-	toff_t nextdir;
-	tdir_t n;
-
-	nextdir = tif->tif_header.tiff_diroff;
-	for (n = dirn; n > 0 && nextdir != 0; n--)
-		if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
-			return (0);
-	tif->tif_nextdiroff = nextdir;
-	/*
-	 * Set curdir to the actual directory index.  The
-	 * -1 is because TIFFReadDirectory will increment
-	 * tif_curdir after successfully reading the directory.
-	 */
-	tif->tif_curdir = (dirn - n) - 1;
-	/*
-	 * Reset tif_dirnumber counter and start new list of seen directories.
-	 * We need this to prevent IFD loops.
-	 */
-	tif->tif_dirnumber = 0;
-	return (TIFFReadDirectory(tif));
-}
-
-/*
- * Set the current directory to be the directory
- * located at the specified file offset.  This interface
- * is used mainly to access directories linked with
- * the SubIFD tag (e.g. thumbnail images).
- */
-int
-TIFFSetSubDirectory(TIFF* tif, uint32 diroff)
-{
-	tif->tif_nextdiroff = diroff;
-	/*
-	 * Reset tif_dirnumber counter and start new list of seen directories.
-	 * We need this to prevent IFD loops.
-	 */
-	tif->tif_dirnumber = 0;
-	return (TIFFReadDirectory(tif));
-}
-
-/*
- * Return file offset of the current directory.
- */
-uint32
-TIFFCurrentDirOffset(TIFF* tif)
-{
-	return (tif->tif_diroff);
-}
-
-/*
- * Return an indication of whether or not we are
- * at the last directory in the file.
- */
-int
-TIFFLastDirectory(TIFF* tif)
-{
-	return (tif->tif_nextdiroff == 0);
-}
-
-/*
- * Unlink the specified directory from the directory chain.
- */
-int
-TIFFUnlinkDirectory(TIFF* tif, tdir_t dirn)
-{
-	static const char module[] = "TIFFUnlinkDirectory";
-	toff_t nextdir;
-	toff_t off;
-	tdir_t n;
-
-	if (tif->tif_mode == O_RDONLY) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-                             "Can not unlink directory in read-only file");
-		return (0);
-	}
-	/*
-	 * Go to the directory before the one we want
-	 * to unlink and nab the offset of the link
-	 * field we'll need to patch.
-	 */
-	nextdir = tif->tif_header.tiff_diroff;
-	off = sizeof (uint16) + sizeof (uint16);
-	for (n = dirn-1; n > 0; n--) {
-		if (nextdir == 0) {
-			TIFFErrorExt(tif->tif_clientdata, module, "Directory %d does not exist", dirn);
-			return (0);
-		}
-		if (!TIFFAdvanceDirectory(tif, &nextdir, &off))
-			return (0);
-	}
-	/*
-	 * Advance to the directory to be unlinked and fetch
-	 * the offset of the directory that follows.
-	 */
-	if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
-		return (0);
-	/*
-	 * Go back and patch the link field of the preceding
-	 * directory to point to the offset of the directory
-	 * that follows.
-	 */
-	(void) TIFFSeekFile(tif, off, SEEK_SET);
-	if (tif->tif_flags & TIFF_SWAB)
-		TIFFSwabLong(&nextdir);
-	if (!WriteOK(tif, &nextdir, sizeof (uint32))) {
-		TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
-		return (0);
-	}
-	/*
-	 * Leave directory state setup safely.  We don't have
-	 * facilities for doing inserting and removing directories,
-	 * so it's safest to just invalidate everything.  This
-	 * means that the caller can only append to the directory
-	 * chain.
-	 */
-	(*tif->tif_cleanup)(tif);
-	if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {
-		_TIFFfree(tif->tif_rawdata);
-		tif->tif_rawdata = NULL;
-		tif->tif_rawcc = 0;
-	}
-	tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE);
-	TIFFFreeDirectory(tif);
-	TIFFDefaultDirectory(tif);
-	tif->tif_diroff = 0;			/* force link on next write */
-	tif->tif_nextdiroff = 0;		/* next write must be at end */
-	tif->tif_curoff = 0;
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (tstrip_t) -1;
-	return (1);
-}
-
-/*			[BFC]
- *
- * Author: Bruce Cameron <cameron@petris.com>
- *
- * Set a table of tags that are to be replaced during directory process by the
- * 'IGNORE' state - or return TRUE/FALSE for the requested tag such that
- * 'ReadDirectory' can use the stored information.
- *
- * FIXME: this is never used properly. Should be removed in the future.
- */
-int
-TIFFReassignTagToIgnore (enum TIFFIgnoreSense task, int TIFFtagID)
-{
-    static int TIFFignoretags [FIELD_LAST];
-    static int tagcount = 0 ;
-    int		i;					/* Loop index */
-    int		j;					/* Loop index */
-
-    switch (task)
-    {
-      case TIS_STORE:
-        if ( tagcount < (FIELD_LAST - 1) )
-        {
-            for ( j = 0 ; j < tagcount ; ++j )
-            {					/* Do not add duplicate tag */
-                if ( TIFFignoretags [j] == TIFFtagID )
-                    return (TRUE) ;
-            }
-            TIFFignoretags [tagcount++] = TIFFtagID ;
-            return (TRUE) ;
-        }
-        break ;
-        
-      case TIS_EXTRACT:
-        for ( i = 0 ; i < tagcount ; ++i )
-        {
-            if ( TIFFignoretags [i] == TIFFtagID )
-                return (TRUE) ;
-        }
-        break;
-        
-      case TIS_EMPTY:
-        tagcount = 0 ;			/* Clear the list */
-        return (TRUE) ;
-        
-      default:
-        break;
-    }
-    
-    return (FALSE);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dir.h b/thirdparty/libtiff/tif_dir.h
deleted file mode 100644
index 515af19..0000000
--- a/thirdparty/libtiff/tif_dir.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/* $Id: tif_dir.h,v 1.30.2.3 2010-06-09 21:15:27 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFDIR_
-#define	_TIFFDIR_
-/*
- * ``Library-private'' Directory-related Definitions.
- */
-
-/*
- * Internal format of a TIFF directory entry.
- */
-typedef	struct {
-#define	FIELD_SETLONGS	4
-	/* bit vector of fields that are set */
-	unsigned long	td_fieldsset[FIELD_SETLONGS];
-
-	uint32  td_imagewidth, td_imagelength, td_imagedepth;
-	uint32  td_tilewidth, td_tilelength, td_tiledepth;
-	uint32  td_subfiletype;
-	uint16  td_bitspersample;
-	uint16  td_sampleformat;
-	uint16  td_compression;
-	uint16  td_photometric;
-	uint16  td_threshholding;
-	uint16  td_fillorder;
-	uint16  td_orientation;
-	uint16  td_samplesperpixel;
-	uint32  td_rowsperstrip;
-	uint16  td_minsamplevalue, td_maxsamplevalue;
-	double  td_sminsamplevalue, td_smaxsamplevalue;
-	float   td_xresolution, td_yresolution;
-	uint16  td_resolutionunit;
-	uint16  td_planarconfig;
-	float   td_xposition, td_yposition;
-	uint16  td_pagenumber[2];
-	uint16* td_colormap[3];
-	uint16  td_halftonehints[2];
-	uint16  td_extrasamples;
-	uint16* td_sampleinfo;
-	/* even though the name is misleading, td_stripsperimage is the number
-	 * of striles (=strips or tiles) per plane, and td_nstrips the total
-	 * number of striles */
-	tstrile_t td_stripsperimage;
-	tstrile_t td_nstrips;            /* size of offset & bytecount arrays */
-	toff_t* td_stripoffset;
-	toff_t* td_stripbytecount;	 /* FIXME: it should be tsize_t array */
-	int     td_stripbytecountsorted; /* is the bytecount array sorted ascending? */
-	uint16  td_nsubifd;
-	uint32* td_subifd;
-	/* YCbCr parameters */
-	uint16  td_ycbcrsubsampling[2];
-	uint16  td_ycbcrpositioning;
-	/* Colorimetry parameters */
-	float*	td_refblackwhite;
-	uint16* td_transferfunction[3];
-	/* CMYK parameters */
-	int     td_inknameslen;
-	char*   td_inknames;
-
-	int     td_customValueCount;
-        TIFFTagValue *td_customValues;
-} TIFFDirectory;
-
-/*
- * Field flags used to indicate fields that have
- * been set in a directory, and to reference fields
- * when manipulating a directory.
- */
-
-/*
- * FIELD_IGNORE is used to signify tags that are to
- * be processed but otherwise ignored.  This permits
- * antiquated tags to be quietly read and discarded.
- * Note that a bit *is* allocated for ignored tags;
- * this is understood by the directory reading logic
- * which uses this fact to avoid special-case handling
- */ 
-#define	FIELD_IGNORE			0
-
-/* multi-item fields */
-#define	FIELD_IMAGEDIMENSIONS		1
-#define FIELD_TILEDIMENSIONS		2
-#define	FIELD_RESOLUTION		3
-#define	FIELD_POSITION			4
-
-/* single-item fields */
-#define	FIELD_SUBFILETYPE		5
-#define	FIELD_BITSPERSAMPLE		6
-#define	FIELD_COMPRESSION		7
-#define	FIELD_PHOTOMETRIC		8
-#define	FIELD_THRESHHOLDING		9
-#define	FIELD_FILLORDER			10
-#define	FIELD_ORIENTATION		15
-#define	FIELD_SAMPLESPERPIXEL		16
-#define	FIELD_ROWSPERSTRIP		17
-#define	FIELD_MINSAMPLEVALUE		18
-#define	FIELD_MAXSAMPLEVALUE		19
-#define	FIELD_PLANARCONFIG		20
-#define	FIELD_RESOLUTIONUNIT		22
-#define	FIELD_PAGENUMBER		23
-#define	FIELD_STRIPBYTECOUNTS		24
-#define	FIELD_STRIPOFFSETS		25
-#define	FIELD_COLORMAP			26
-#define	FIELD_EXTRASAMPLES		31
-#define FIELD_SAMPLEFORMAT		32
-#define	FIELD_SMINSAMPLEVALUE		33
-#define	FIELD_SMAXSAMPLEVALUE		34
-#define FIELD_IMAGEDEPTH		35
-#define FIELD_TILEDEPTH			36
-#define	FIELD_HALFTONEHINTS		37
-#define FIELD_YCBCRSUBSAMPLING		39
-#define FIELD_YCBCRPOSITIONING		40
-#define	FIELD_REFBLACKWHITE		41
-#define	FIELD_TRANSFERFUNCTION		44
-#define	FIELD_INKNAMES			46
-#define	FIELD_SUBIFD			49
-/*      FIELD_CUSTOM (see tiffio.h)     65 */
-/* end of support for well-known tags; codec-private tags follow */
-#define	FIELD_CODEC			66	/* base of codec-private tags */
-
-
-/*
- * Pseudo-tags don't normally need field bits since they
- * are not written to an output file (by definition).
- * The library also has express logic to always query a
- * codec for a pseudo-tag so allocating a field bit for
- * one is a waste.   If codec wants to promote the notion
- * of a pseudo-tag being ``set'' or ``unset'' then it can
- * do using internal state flags without polluting the
- * field bit space defined for real tags.
- */
-#define	FIELD_PSEUDO			0
-
-#define	FIELD_LAST			(32*FIELD_SETLONGS-1)
-
-#define	TIFFExtractData(tif, type, v) \
-    ((uint32) ((tif)->tif_header.tiff_magic == TIFF_BIGENDIAN ? \
-        ((v) >> (tif)->tif_typeshift[type]) & (tif)->tif_typemask[type] : \
-	(v) & (tif)->tif_typemask[type]))
-#define	TIFFInsertData(tif, type, v) \
-    ((uint32) ((tif)->tif_header.tiff_magic == TIFF_BIGENDIAN ? \
-        ((v) & (tif)->tif_typemask[type]) << (tif)->tif_typeshift[type] : \
-	(v) & (tif)->tif_typemask[type]))
-
-
-#define BITn(n)				(((unsigned long)1L)<<((n)&0x1f)) 
-#define BITFIELDn(tif, n)		((tif)->tif_dir.td_fieldsset[(n)/32]) 
-#define TIFFFieldSet(tif, field)	(BITFIELDn(tif, field) & BITn(field)) 
-#define TIFFSetFieldBit(tif, field)	(BITFIELDn(tif, field) |= BITn(field))
-#define TIFFClrFieldBit(tif, field)	(BITFIELDn(tif, field) &= ~BITn(field))
-
-#define	FieldSet(fields, f)		(fields[(f)/32] & BITn(f))
-#define	ResetFieldBit(fields, f)	(fields[(f)/32] &= ~BITn(f))
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	const TIFFFieldInfo *_TIFFGetFieldInfo(size_t *);
-extern	const TIFFFieldInfo *_TIFFGetExifFieldInfo(size_t *);
-extern	void _TIFFSetupFieldInfo(TIFF*, const TIFFFieldInfo[], size_t);
-extern	int _TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], int);
-extern	void _TIFFPrintFieldInfo(TIFF*, FILE*);
-extern	TIFFDataType _TIFFSampleToTagType(TIFF*);
-extern  const TIFFFieldInfo* _TIFFFindOrRegisterFieldInfo( TIFF *tif,
-							   ttag_t tag,
-							   TIFFDataType dt );
-extern  TIFFFieldInfo* _TIFFCreateAnonFieldInfo( TIFF *tif, ttag_t tag,
-                                                 TIFFDataType dt );
-
-#define _TIFFFindFieldInfo	    TIFFFindFieldInfo
-#define _TIFFFindFieldInfoByName    TIFFFindFieldInfoByName
-#define _TIFFFieldWithTag	    TIFFFieldWithTag
-#define _TIFFFieldWithName	    TIFFFieldWithName
-
-#if defined(__cplusplus)
-}
-#endif
-#endif /* _TIFFDIR_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dirinfo.c b/thirdparty/libtiff/tif_dirinfo.c
deleted file mode 100644
index 57c29d5..0000000
--- a/thirdparty/libtiff/tif_dirinfo.c
+++ /dev/null
@@ -1,904 +0,0 @@
-/* $Id: tif_dirinfo.c,v 1.65.2.9 2010-06-09 21:15:27 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Core Directory Tag Support.
- */
-#include "tiffiop.h"
-#include <stdlib.h>
-#include <string.h>
-
-/*
- * NB: NB: THIS ARRAY IS ASSUMED TO BE SORTED BY TAG.
- *       If a tag can have both LONG and SHORT types then the LONG must be
- *       placed before the SHORT for writing to work properly.
- *
- * NOTE: The second field (field_readcount) and third field (field_writecount)
- *       sometimes use the values TIFF_VARIABLE (-1), TIFF_VARIABLE2 (-3)
- *       and TIFFTAG_SPP (-2). The macros should be used but would throw off 
- *       the formatting of the code, so please interprete the -1, -2 and -3 
- *       values accordingly.
- */
-static const TIFFFieldInfo
-tiffFieldInfo[] = {
-    { TIFFTAG_SUBFILETYPE,	 1, 1,	TIFF_LONG,	FIELD_SUBFILETYPE,
-      1,	0,	"SubfileType" },
-/* XXX SHORT for compatibility w/ old versions of the library */
-    { TIFFTAG_SUBFILETYPE,	 1, 1,	TIFF_SHORT,	FIELD_SUBFILETYPE,
-      1,	0,	"SubfileType" },
-    { TIFFTAG_OSUBFILETYPE,	 1, 1,	TIFF_SHORT,	FIELD_SUBFILETYPE,
-      1,	0,	"OldSubfileType" },
-    { TIFFTAG_IMAGEWIDTH,	 1, 1,	TIFF_LONG,	FIELD_IMAGEDIMENSIONS,
-      0,	0,	"ImageWidth" },
-    { TIFFTAG_IMAGEWIDTH,	 1, 1,	TIFF_SHORT,	FIELD_IMAGEDIMENSIONS,
-      0,	0,	"ImageWidth" },
-    { TIFFTAG_IMAGELENGTH,	 1, 1,	TIFF_LONG,	FIELD_IMAGEDIMENSIONS,
-      1,	0,	"ImageLength" },
-    { TIFFTAG_IMAGELENGTH,	 1, 1,	TIFF_SHORT,	FIELD_IMAGEDIMENSIONS,
-      1,	0,	"ImageLength" },
-    { TIFFTAG_BITSPERSAMPLE,	-1,-1,	TIFF_SHORT,	FIELD_BITSPERSAMPLE,
-      0,	0,	"BitsPerSample" },
-/* XXX LONG for compatibility with some broken TIFF writers */
-    { TIFFTAG_BITSPERSAMPLE,	-1,-1,	TIFF_LONG,	FIELD_BITSPERSAMPLE,
-      0,	0,	"BitsPerSample" },
-    { TIFFTAG_COMPRESSION,	-1, 1,	TIFF_SHORT,	FIELD_COMPRESSION,
-      0,	0,	"Compression" },
-/* XXX LONG for compatibility with some broken TIFF writers */
-    { TIFFTAG_COMPRESSION,	-1, 1,	TIFF_LONG,	FIELD_COMPRESSION,
-      0,	0,	"Compression" },
-    { TIFFTAG_PHOTOMETRIC,	 1, 1,	TIFF_SHORT,	FIELD_PHOTOMETRIC,
-      0,	0,	"PhotometricInterpretation" },
-/* XXX LONG for compatibility with some broken TIFF writers */
-    { TIFFTAG_PHOTOMETRIC,	 1, 1,	TIFF_LONG,	FIELD_PHOTOMETRIC,
-      0,	0,	"PhotometricInterpretation" },
-    { TIFFTAG_THRESHHOLDING,	 1, 1,	TIFF_SHORT,	FIELD_THRESHHOLDING,
-      1,	0,	"Threshholding" },
-    { TIFFTAG_CELLWIDTH,	 1, 1,	TIFF_SHORT,	FIELD_IGNORE,
-      1,	0,	"CellWidth" },
-    { TIFFTAG_CELLLENGTH,	 1, 1,	TIFF_SHORT,	FIELD_IGNORE,
-      1,	0,	"CellLength" },
-    { TIFFTAG_FILLORDER,	 1, 1,	TIFF_SHORT,	FIELD_FILLORDER,
-      0,	0,	"FillOrder" },
-    { TIFFTAG_DOCUMENTNAME,	-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"DocumentName" },
-    { TIFFTAG_IMAGEDESCRIPTION,	-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"ImageDescription" },
-    { TIFFTAG_MAKE,		-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"Make" },
-    { TIFFTAG_MODEL,		-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"Model" },
-    { TIFFTAG_STRIPOFFSETS,	-1,-1,	TIFF_LONG,	FIELD_STRIPOFFSETS,
-      0,	0,	"StripOffsets" },
-    { TIFFTAG_STRIPOFFSETS,	-1,-1,	TIFF_SHORT,	FIELD_STRIPOFFSETS,
-      0,	0,	"StripOffsets" },
-    { TIFFTAG_ORIENTATION,	 1, 1,	TIFF_SHORT,	FIELD_ORIENTATION,
-      0,	0,	"Orientation" },
-    { TIFFTAG_SAMPLESPERPIXEL,	 1, 1,	TIFF_SHORT,	FIELD_SAMPLESPERPIXEL,
-      0,	0,	"SamplesPerPixel" },
-    { TIFFTAG_ROWSPERSTRIP,	 1, 1,	TIFF_LONG,	FIELD_ROWSPERSTRIP,
-      0,	0,	"RowsPerStrip" },
-    { TIFFTAG_ROWSPERSTRIP,	 1, 1,	TIFF_SHORT,	FIELD_ROWSPERSTRIP,
-      0,	0,	"RowsPerStrip" },
-    { TIFFTAG_STRIPBYTECOUNTS,	-1,-1,	TIFF_LONG,	FIELD_STRIPBYTECOUNTS,
-      0,	0,	"StripByteCounts" },
-    { TIFFTAG_STRIPBYTECOUNTS,	-1,-1,	TIFF_SHORT,	FIELD_STRIPBYTECOUNTS,
-      0,	0,	"StripByteCounts" },
-    { TIFFTAG_MINSAMPLEVALUE,	-2,-1,	TIFF_SHORT,	FIELD_MINSAMPLEVALUE,
-      1,	0,	"MinSampleValue" },
-    { TIFFTAG_MAXSAMPLEVALUE,	-2,-1,	TIFF_SHORT,	FIELD_MAXSAMPLEVALUE,
-      1,	0,	"MaxSampleValue" },
-    { TIFFTAG_XRESOLUTION,	 1, 1,	TIFF_RATIONAL,	FIELD_RESOLUTION,
-      1,	0,	"XResolution" },
-    { TIFFTAG_YRESOLUTION,	 1, 1,	TIFF_RATIONAL,	FIELD_RESOLUTION,
-      1,	0,	"YResolution" },
-    { TIFFTAG_PLANARCONFIG,	 1, 1,	TIFF_SHORT,	FIELD_PLANARCONFIG,
-      0,	0,	"PlanarConfiguration" },
-    { TIFFTAG_PAGENAME,		-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"PageName" },
-    { TIFFTAG_XPOSITION,	 1, 1,	TIFF_RATIONAL,	FIELD_POSITION,
-      1,	0,	"XPosition" },
-    { TIFFTAG_YPOSITION,	 1, 1,	TIFF_RATIONAL,	FIELD_POSITION,
-      1,	0,	"YPosition" },
-    { TIFFTAG_FREEOFFSETS,	-1,-1,	TIFF_LONG,	FIELD_IGNORE,
-      0,	0,	"FreeOffsets" },
-    { TIFFTAG_FREEBYTECOUNTS,	-1,-1,	TIFF_LONG,	FIELD_IGNORE,
-      0,	0,	"FreeByteCounts" },
-    { TIFFTAG_GRAYRESPONSEUNIT,	 1, 1,	TIFF_SHORT,	FIELD_IGNORE,
-      1,	0,	"GrayResponseUnit" },
-    { TIFFTAG_GRAYRESPONSECURVE,-1,-1,	TIFF_SHORT,	FIELD_IGNORE,
-      1,	0,	"GrayResponseCurve" },
-    { TIFFTAG_RESOLUTIONUNIT,	 1, 1,	TIFF_SHORT,	FIELD_RESOLUTIONUNIT,
-      1,	0,	"ResolutionUnit" },
-    { TIFFTAG_PAGENUMBER,	 2, 2,	TIFF_SHORT,	FIELD_PAGENUMBER,
-      1,	0,	"PageNumber" },
-    { TIFFTAG_COLORRESPONSEUNIT, 1, 1,	TIFF_SHORT,	FIELD_IGNORE,
-      1,	0,	"ColorResponseUnit" },
-    { TIFFTAG_TRANSFERFUNCTION,	-1,-1,	TIFF_SHORT,	FIELD_TRANSFERFUNCTION,
-      1,	0,	"TransferFunction" },
-    { TIFFTAG_SOFTWARE,		-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"Software" },
-    { TIFFTAG_DATETIME,		20,20,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"DateTime" },
-    { TIFFTAG_ARTIST,		-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"Artist" },
-    { TIFFTAG_HOSTCOMPUTER,	-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"HostComputer" },
-    { TIFFTAG_WHITEPOINT,	 2, 2,	TIFF_RATIONAL,	FIELD_CUSTOM,
-      1,	0,	"WhitePoint" },
-    { TIFFTAG_PRIMARYCHROMATICITIES,6,6,TIFF_RATIONAL,	FIELD_CUSTOM,
-      1,	0,	"PrimaryChromaticities" },
-    { TIFFTAG_COLORMAP,		-1,-1,	TIFF_SHORT,	FIELD_COLORMAP,
-      1,	0,	"ColorMap" },
-    { TIFFTAG_HALFTONEHINTS,	 2, 2,	TIFF_SHORT,	FIELD_HALFTONEHINTS,
-      1,	0,	"HalftoneHints" },
-    { TIFFTAG_TILEWIDTH,	 1, 1,	TIFF_LONG,	FIELD_TILEDIMENSIONS,
-      0,	0,	"TileWidth" },
-    { TIFFTAG_TILEWIDTH,	 1, 1,	TIFF_SHORT,	FIELD_TILEDIMENSIONS,
-      0,	0,	"TileWidth" },
-    { TIFFTAG_TILELENGTH,	 1, 1,	TIFF_LONG,	FIELD_TILEDIMENSIONS,
-      0,	0,	"TileLength" },
-    { TIFFTAG_TILELENGTH,	 1, 1,	TIFF_SHORT,	FIELD_TILEDIMENSIONS,
-      0,	0,	"TileLength" },
-    { TIFFTAG_TILEOFFSETS,	-1, 1,	TIFF_LONG,	FIELD_STRIPOFFSETS,
-      0,	0,	"TileOffsets" },
-    { TIFFTAG_TILEBYTECOUNTS,	-1, 1,	TIFF_LONG,	FIELD_STRIPBYTECOUNTS,
-      0,	0,	"TileByteCounts" },
-    { TIFFTAG_TILEBYTECOUNTS,	-1, 1,	TIFF_SHORT,	FIELD_STRIPBYTECOUNTS,
-      0,	0,	"TileByteCounts" },
-    { TIFFTAG_SUBIFD,		-1,-1,	TIFF_IFD,	FIELD_SUBIFD,
-      1,	1,	"SubIFD" },
-    { TIFFTAG_SUBIFD,		-1,-1,	TIFF_LONG,	FIELD_SUBIFD,
-      1,	1,	"SubIFD" },
-    { TIFFTAG_INKSET,		 1, 1,	TIFF_SHORT,	FIELD_CUSTOM,
-      0,	0,	"InkSet" },
-    { TIFFTAG_INKNAMES,		-1,-1,	TIFF_ASCII,	FIELD_INKNAMES,
-      1,	1,	"InkNames" },
-    { TIFFTAG_NUMBEROFINKS,	 1, 1,	TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"NumberOfInks" },
-    { TIFFTAG_DOTRANGE,		 2, 2,	TIFF_SHORT,	FIELD_CUSTOM,
-      0,	0,	"DotRange" },
-    { TIFFTAG_DOTRANGE,		 2, 2,	TIFF_BYTE,	FIELD_CUSTOM,
-      0,	0,	"DotRange" },
-    { TIFFTAG_TARGETPRINTER,	-1,-1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"TargetPrinter" },
-    { TIFFTAG_EXTRASAMPLES,	-1,-1,	TIFF_SHORT,	FIELD_EXTRASAMPLES,
-      0,	1,	"ExtraSamples" },
-/* XXX for bogus Adobe Photoshop v2.5 files */
-    { TIFFTAG_EXTRASAMPLES,	-1,-1,	TIFF_BYTE,	FIELD_EXTRASAMPLES,
-      0,	1,	"ExtraSamples" },
-    { TIFFTAG_SAMPLEFORMAT,	-1,-1,	TIFF_SHORT,	FIELD_SAMPLEFORMAT,
-      0,	0,	"SampleFormat" },
-    { TIFFTAG_SMINSAMPLEVALUE,	-2,-1,	TIFF_ANY,	FIELD_SMINSAMPLEVALUE,
-      1,	0,	"SMinSampleValue" },
-    { TIFFTAG_SMAXSAMPLEVALUE,	-2,-1,	TIFF_ANY,	FIELD_SMAXSAMPLEVALUE,
-      1,	0,	"SMaxSampleValue" },
-    { TIFFTAG_CLIPPATH,		-1, -3, TIFF_BYTE,	FIELD_CUSTOM,
-      0,	1,	"ClipPath" },
-    { TIFFTAG_XCLIPPATHUNITS,	 1, 1,	TIFF_SLONG,	FIELD_CUSTOM,
-      0,	0,	"XClipPathUnits" },
-    { TIFFTAG_XCLIPPATHUNITS,	 1, 1,	TIFF_SSHORT,	FIELD_CUSTOM,
-      0,	0,	"XClipPathUnits" },
-    { TIFFTAG_XCLIPPATHUNITS,	 1, 1,	TIFF_SBYTE,	FIELD_CUSTOM,
-      0,	0,	"XClipPathUnits" },
-    { TIFFTAG_YCLIPPATHUNITS,	 1, 1,	TIFF_SLONG,	FIELD_CUSTOM,
-      0,	0,	"YClipPathUnits" },
-    { TIFFTAG_YCLIPPATHUNITS,	 1, 1,	TIFF_SSHORT,	FIELD_CUSTOM,
-      0,	0,	"YClipPathUnits" },
-    { TIFFTAG_YCLIPPATHUNITS,	 1, 1,	TIFF_SBYTE,	FIELD_CUSTOM,
-      0,	0,	"YClipPathUnits" },
-    { TIFFTAG_YCBCRCOEFFICIENTS, 3, 3,	TIFF_RATIONAL,	FIELD_CUSTOM,
-      0,	0,	"YCbCrCoefficients" },
-    { TIFFTAG_YCBCRSUBSAMPLING,	 2, 2,	TIFF_SHORT,	FIELD_YCBCRSUBSAMPLING,
-      0,	0,	"YCbCrSubsampling" },
-    { TIFFTAG_YCBCRPOSITIONING,	 1, 1,	TIFF_SHORT,	FIELD_YCBCRPOSITIONING,
-      0,	0,	"YCbCrPositioning" },
-    { TIFFTAG_REFERENCEBLACKWHITE, 6, 6, TIFF_RATIONAL,	FIELD_REFBLACKWHITE,
-      1,	0,	"ReferenceBlackWhite" },
-/* XXX temporarily accept LONG for backwards compatibility */
-    { TIFFTAG_REFERENCEBLACKWHITE, 6, 6, TIFF_LONG,	FIELD_REFBLACKWHITE,
-      1,	0,	"ReferenceBlackWhite" },
-    { TIFFTAG_XMLPACKET,	-3,-3,	TIFF_BYTE,	FIELD_CUSTOM,
-      0,	1,	"XMLPacket" },
-/* begin SGI tags */
-    { TIFFTAG_MATTEING,		 1, 1,	TIFF_SHORT,	FIELD_EXTRASAMPLES,
-      0,	0,	"Matteing" },
-    { TIFFTAG_DATATYPE,		-2,-1,	TIFF_SHORT,	FIELD_SAMPLEFORMAT,
-      0,	0,	"DataType" },
-    { TIFFTAG_IMAGEDEPTH,	 1, 1,	TIFF_LONG,	FIELD_IMAGEDEPTH,
-      0,	0,	"ImageDepth" },
-    { TIFFTAG_IMAGEDEPTH,	 1, 1,	TIFF_SHORT,	FIELD_IMAGEDEPTH,
-      0,	0,	"ImageDepth" },
-    { TIFFTAG_TILEDEPTH,	 1, 1,	TIFF_LONG,	FIELD_TILEDEPTH,
-      0,	0,	"TileDepth" },
-    { TIFFTAG_TILEDEPTH,	 1, 1,	TIFF_SHORT,	FIELD_TILEDEPTH,
-      0,	0,	"TileDepth" },
-/* end SGI tags */
-/* begin Pixar tags */
-    { TIFFTAG_PIXAR_IMAGEFULLWIDTH,  1, 1, TIFF_LONG,	FIELD_CUSTOM,
-      1,	0,	"ImageFullWidth" },
-    { TIFFTAG_PIXAR_IMAGEFULLLENGTH, 1, 1, TIFF_LONG,	FIELD_CUSTOM,
-      1,	0,	"ImageFullLength" },
-    { TIFFTAG_PIXAR_TEXTUREFORMAT,  -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"TextureFormat" },
-    { TIFFTAG_PIXAR_WRAPMODES,	    -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"TextureWrapModes" },
-    { TIFFTAG_PIXAR_FOVCOT,	     1, 1, TIFF_FLOAT,	FIELD_CUSTOM,
-      1,	0,	"FieldOfViewCotangent" },
-    { TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN,	16,16,	TIFF_FLOAT,
-      FIELD_CUSTOM,	1,	0,	"MatrixWorldToScreen" },
-    { TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA,	16,16,	TIFF_FLOAT,
-       FIELD_CUSTOM,	1,	0,	"MatrixWorldToCamera" },
-    { TIFFTAG_COPYRIGHT,	-1, -1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"Copyright" },
-/* end Pixar tags */
-    { TIFFTAG_RICHTIFFIPTC, -3, -3,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,    1,   "RichTIFFIPTC" },
-    { TIFFTAG_PHOTOSHOP,    -3, -3,	TIFF_BYTE,	FIELD_CUSTOM, 
-      0,    1,   "Photoshop" },
-    { TIFFTAG_EXIFIFD,		1, 1,	TIFF_LONG,	FIELD_CUSTOM,
-      0,	0,	"EXIFIFDOffset" },
-    { TIFFTAG_ICCPROFILE,	-3, -3,	TIFF_UNDEFINED,	FIELD_CUSTOM,
-      0,	1,	"ICC Profile" },
-    { TIFFTAG_GPSIFD,		1, 1,	TIFF_LONG,	FIELD_CUSTOM,
-      0,	0,	"GPSIFDOffset" },
-    { TIFFTAG_STONITS,		 1, 1,	TIFF_DOUBLE,	FIELD_CUSTOM,
-      0,	0,	"StoNits" },
-    { TIFFTAG_INTEROPERABILITYIFD, 1, 1, TIFF_LONG,	FIELD_CUSTOM,
-      0,	0,	"InteroperabilityIFDOffset" },
-/* begin DNG tags */
-    { TIFFTAG_DNGVERSION,	4, 4,	TIFF_BYTE,	FIELD_CUSTOM, 
-      0,	0,	"DNGVersion" },
-    { TIFFTAG_DNGBACKWARDVERSION, 4, 4,	TIFF_BYTE,	FIELD_CUSTOM, 
-      0,	0,	"DNGBackwardVersion" },
-    { TIFFTAG_UNIQUECAMERAMODEL,    -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"UniqueCameraModel" },
-    { TIFFTAG_LOCALIZEDCAMERAMODEL, -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"LocalizedCameraModel" },
-    { TIFFTAG_LOCALIZEDCAMERAMODEL, -1, -1, TIFF_BYTE,	FIELD_CUSTOM,
-      1,	1,	"LocalizedCameraModel" },
-    { TIFFTAG_CFAPLANECOLOR,	-1, -1,	TIFF_BYTE,	FIELD_CUSTOM, 
-      0,	1,	"CFAPlaneColor" },
-    { TIFFTAG_CFALAYOUT,	1, 1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"CFALayout" },
-    { TIFFTAG_LINEARIZATIONTABLE, -1, -1, TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	1,	"LinearizationTable" },
-    { TIFFTAG_BLACKLEVELREPEATDIM, 2, 2, TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"BlackLevelRepeatDim" },
-    { TIFFTAG_BLACKLEVEL,	-1, -1,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	1,	"BlackLevel" },
-    { TIFFTAG_BLACKLEVEL,	-1, -1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	1,	"BlackLevel" },
-    { TIFFTAG_BLACKLEVEL,	-1, -1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"BlackLevel" },
-    { TIFFTAG_BLACKLEVELDELTAH,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"BlackLevelDeltaH" },
-    { TIFFTAG_BLACKLEVELDELTAV,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"BlackLevelDeltaV" },
-    { TIFFTAG_WHITELEVEL,	-2, -2,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	0,	"WhiteLevel" },
-    { TIFFTAG_WHITELEVEL,	-2, -2,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"WhiteLevel" },
-    { TIFFTAG_DEFAULTSCALE,	2, 2,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"DefaultScale" },
-    { TIFFTAG_BESTQUALITYSCALE,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"BestQualityScale" },
-    { TIFFTAG_DEFAULTCROPORIGIN,	2, 2,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropOrigin" },
-    { TIFFTAG_DEFAULTCROPORIGIN,	2, 2,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropOrigin" },
-    { TIFFTAG_DEFAULTCROPORIGIN,	2, 2,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropOrigin" },
-    { TIFFTAG_DEFAULTCROPSIZE,	2, 2,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropSize" },
-    { TIFFTAG_DEFAULTCROPSIZE,	2, 2,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropSize" },
-    { TIFFTAG_DEFAULTCROPSIZE,	2, 2,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"DefaultCropSize" },
-    { TIFFTAG_COLORMATRIX1,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"ColorMatrix1" },
-    { TIFFTAG_COLORMATRIX2,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"ColorMatrix2" },
-    { TIFFTAG_CAMERACALIBRATION1,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"CameraCalibration1" },
-    { TIFFTAG_CAMERACALIBRATION2,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"CameraCalibration2" },
-    { TIFFTAG_REDUCTIONMATRIX1,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"ReductionMatrix1" },
-    { TIFFTAG_REDUCTIONMATRIX2,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"ReductionMatrix2" },
-    { TIFFTAG_ANALOGBALANCE,	-1, -1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"AnalogBalance" },
-    { TIFFTAG_ASSHOTNEUTRAL,	-1, -1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	1,	"AsShotNeutral" },
-    { TIFFTAG_ASSHOTNEUTRAL,	-1, -1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"AsShotNeutral" },
-    { TIFFTAG_ASSHOTWHITEXY,	2, 2,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"AsShotWhiteXY" },
-    { TIFFTAG_BASELINEEXPOSURE,	1, 1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"BaselineExposure" },
-    { TIFFTAG_BASELINENOISE,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"BaselineNoise" },
-    { TIFFTAG_BASELINESHARPNESS,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"BaselineSharpness" },
-    { TIFFTAG_BAYERGREENSPLIT,	1, 1,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	0,	"BayerGreenSplit" },
-    { TIFFTAG_LINEARRESPONSELIMIT,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"LinearResponseLimit" },
-    { TIFFTAG_CAMERASERIALNUMBER,    -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"CameraSerialNumber" },
-    { TIFFTAG_LENSINFO,	4, 4,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"LensInfo" },
-    { TIFFTAG_CHROMABLURRADIUS,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"ChromaBlurRadius" },
-    { TIFFTAG_ANTIALIASSTRENGTH,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"AntiAliasStrength" },
-    { TIFFTAG_SHADOWSCALE,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      0,	0,	"ShadowScale" },
-    { TIFFTAG_DNGPRIVATEDATA,    -1, -1, TIFF_BYTE,	FIELD_CUSTOM,
-      0,	1,	"DNGPrivateData" },
-    { TIFFTAG_MAKERNOTESAFETY,	1, 1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"MakerNoteSafety" },
-    { TIFFTAG_CALIBRATIONILLUMINANT1,	1, 1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"CalibrationIlluminant1" },
-    { TIFFTAG_CALIBRATIONILLUMINANT2,	1, 1,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"CalibrationIlluminant2" },
-    { TIFFTAG_RAWDATAUNIQUEID,	16, 16,	TIFF_BYTE,	FIELD_CUSTOM, 
-      0,	0,	"RawDataUniqueID" },
-    { TIFFTAG_ORIGINALRAWFILENAME,    -1, -1, TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"OriginalRawFileName" },
-    { TIFFTAG_ORIGINALRAWFILENAME,    -1, -1, TIFF_BYTE,	FIELD_CUSTOM,
-      1,	1,	"OriginalRawFileName" },
-    { TIFFTAG_ORIGINALRAWFILEDATA,    -1, -1, TIFF_UNDEFINED,	FIELD_CUSTOM,
-      0,	1,	"OriginalRawFileData" },
-    { TIFFTAG_ACTIVEAREA,	4, 4,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	0,	"ActiveArea" },
-    { TIFFTAG_ACTIVEAREA,	4, 4,	TIFF_SHORT,	FIELD_CUSTOM, 
-      0,	0,	"ActiveArea" },
-    { TIFFTAG_MASKEDAREAS,	-1, -1,	TIFF_LONG,	FIELD_CUSTOM, 
-      0,	1,	"MaskedAreas" },
-    { TIFFTAG_ASSHOTICCPROFILE,    -1, -1, TIFF_UNDEFINED,	FIELD_CUSTOM,
-      0,	1,	"AsShotICCProfile" },
-    { TIFFTAG_ASSHOTPREPROFILEMATRIX,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"AsShotPreProfileMatrix" },
-    { TIFFTAG_CURRENTICCPROFILE,    -1, -1, TIFF_UNDEFINED,	FIELD_CUSTOM,
-      0,	1,	"CurrentICCProfile" },
-    { TIFFTAG_CURRENTPREPROFILEMATRIX,	-1, -1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      0,	1,	"CurrentPreProfileMatrix" },
-/* end DNG tags */
-};
-
-static const TIFFFieldInfo
-exifFieldInfo[] = {
-    { EXIFTAG_EXPOSURETIME,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"ExposureTime" },
-    { EXIFTAG_FNUMBER,		1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"FNumber" },
-    { EXIFTAG_EXPOSUREPROGRAM,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"ExposureProgram" },
-    { EXIFTAG_SPECTRALSENSITIVITY,    -1, -1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"SpectralSensitivity" },
-    { EXIFTAG_ISOSPEEDRATINGS,  -1, -1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	1,	"ISOSpeedRatings" },
-    { EXIFTAG_OECF,	-1, -1,			TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"OptoelectricConversionFactor" },
-    { EXIFTAG_EXIFVERSION,	4, 4,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	0,	"ExifVersion" },
-    { EXIFTAG_DATETIMEORIGINAL,	20, 20,		TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"DateTimeOriginal" },
-    { EXIFTAG_DATETIMEDIGITIZED, 20, 20,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"DateTimeDigitized" },
-    { EXIFTAG_COMPONENTSCONFIGURATION,	 4, 4,	TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	0,	"ComponentsConfiguration" },
-    { EXIFTAG_COMPRESSEDBITSPERPIXEL,	 1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM,
-      1,	0,	"CompressedBitsPerPixel" },
-    { EXIFTAG_SHUTTERSPEEDVALUE,	1, 1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"ShutterSpeedValue" },
-    { EXIFTAG_APERTUREVALUE,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"ApertureValue" },
-    { EXIFTAG_BRIGHTNESSVALUE,	1, 1,		TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"BrightnessValue" },
-    { EXIFTAG_EXPOSUREBIASVALUE,	1, 1,	TIFF_SRATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"ExposureBiasValue" },
-    { EXIFTAG_MAXAPERTUREVALUE,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"MaxApertureValue" },
-    { EXIFTAG_SUBJECTDISTANCE,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"SubjectDistance" },
-    { EXIFTAG_METERINGMODE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"MeteringMode" },
-    { EXIFTAG_LIGHTSOURCE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"LightSource" },
-    { EXIFTAG_FLASH,	1, 1,			TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"Flash" },
-    { EXIFTAG_FOCALLENGTH,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"FocalLength" },
-    { EXIFTAG_SUBJECTAREA,	-1, -1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	1,	"SubjectArea" },
-    { EXIFTAG_MAKERNOTE,	-1, -1,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"MakerNote" },
-    { EXIFTAG_USERCOMMENT,	-1, -1,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"UserComment" },
-    { EXIFTAG_SUBSECTIME,    -1, -1,		TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"SubSecTime" },
-    { EXIFTAG_SUBSECTIMEORIGINAL, -1, -1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"SubSecTimeOriginal" },
-    { EXIFTAG_SUBSECTIMEDIGITIZED,-1, -1,	TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"SubSecTimeDigitized" },
-    { EXIFTAG_FLASHPIXVERSION,	4, 4,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	0,	"FlashpixVersion" },
-    { EXIFTAG_COLORSPACE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"ColorSpace" },
-    { EXIFTAG_PIXELXDIMENSION,	1, 1,		TIFF_LONG,	FIELD_CUSTOM,
-      1,	0,	"PixelXDimension" },
-    { EXIFTAG_PIXELXDIMENSION,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"PixelXDimension" },
-    { EXIFTAG_PIXELYDIMENSION,	1, 1,		TIFF_LONG,	FIELD_CUSTOM,
-      1,	0,	"PixelYDimension" },
-    { EXIFTAG_PIXELYDIMENSION,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"PixelYDimension" },
-    { EXIFTAG_RELATEDSOUNDFILE,	13, 13,		TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"RelatedSoundFile" },
-    { EXIFTAG_FLASHENERGY,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"FlashEnergy" },
-    { EXIFTAG_SPATIALFREQUENCYRESPONSE,	-1, -1,	TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"SpatialFrequencyResponse" },
-    { EXIFTAG_FOCALPLANEXRESOLUTION,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"FocalPlaneXResolution" },
-    { EXIFTAG_FOCALPLANEYRESOLUTION,	1, 1,	TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"FocalPlaneYResolution" },
-    { EXIFTAG_FOCALPLANERESOLUTIONUNIT,	1, 1,	TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"FocalPlaneResolutionUnit" },
-    { EXIFTAG_SUBJECTLOCATION,	2, 2,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"SubjectLocation" },
-    { EXIFTAG_EXPOSUREINDEX,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"ExposureIndex" },
-    { EXIFTAG_SENSINGMETHOD,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"SensingMethod" },
-    { EXIFTAG_FILESOURCE,	1, 1,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	0,	"FileSource" },
-    { EXIFTAG_SCENETYPE,	1, 1,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	0,	"SceneType" },
-    { EXIFTAG_CFAPATTERN,	-1, -1,		TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"CFAPattern" },
-    { EXIFTAG_CUSTOMRENDERED,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"CustomRendered" },
-    { EXIFTAG_EXPOSUREMODE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"ExposureMode" },
-    { EXIFTAG_WHITEBALANCE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"WhiteBalance" },
-    { EXIFTAG_DIGITALZOOMRATIO,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"DigitalZoomRatio" },
-    { EXIFTAG_FOCALLENGTHIN35MMFILM, 1, 1,	TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"FocalLengthIn35mmFilm" },
-    { EXIFTAG_SCENECAPTURETYPE,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"SceneCaptureType" },
-    { EXIFTAG_GAINCONTROL,	1, 1,		TIFF_RATIONAL,	FIELD_CUSTOM, 
-      1,	0,	"GainControl" },
-    { EXIFTAG_CONTRAST,		1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"Contrast" },
-    { EXIFTAG_SATURATION,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"Saturation" },
-    { EXIFTAG_SHARPNESS,	1, 1,		TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"Sharpness" },
-    { EXIFTAG_DEVICESETTINGDESCRIPTION,	-1, -1,	TIFF_UNDEFINED,	FIELD_CUSTOM,
-      1,	1,	"DeviceSettingDescription" },
-    { EXIFTAG_SUBJECTDISTANCERANGE, 1, 1,	TIFF_SHORT,	FIELD_CUSTOM,
-      1,	0,	"SubjectDistanceRange" },
-    { EXIFTAG_IMAGEUNIQUEID,	33, 33,		TIFF_ASCII,	FIELD_CUSTOM,
-      1,	0,	"ImageUniqueID" }
-};
-
-const TIFFFieldInfo *
-_TIFFGetFieldInfo(size_t *size)
-{
-	*size = TIFFArrayCount(tiffFieldInfo);
-	return tiffFieldInfo;
-}
-
-const TIFFFieldInfo *
-_TIFFGetExifFieldInfo(size_t *size)
-{
-	*size = TIFFArrayCount(exifFieldInfo);
-	return exifFieldInfo;
-}
-
-void
-_TIFFSetupFieldInfo(TIFF* tif, const TIFFFieldInfo info[], size_t n)
-{
-	if (tif->tif_fieldinfo) {
-		size_t  i;
-
-		for (i = 0; i < tif->tif_nfields; i++) 
-		{
-			TIFFFieldInfo *fld = tif->tif_fieldinfo[i];
-			if (fld->field_bit == FIELD_CUSTOM && 
-				strncmp("Tag ", fld->field_name, 4) == 0) {
-					_TIFFfree(fld->field_name);
-					_TIFFfree(fld);
-				}
-		}   
-      
-		_TIFFfree(tif->tif_fieldinfo);
-		tif->tif_nfields = 0;
-	}
-	if (!_TIFFMergeFieldInfo(tif, info, n))
-	{
-		TIFFErrorExt(tif->tif_clientdata, "_TIFFSetupFieldInfo",
-			     "Setting up field info failed");
-	}
-}
-
-static int
-tagCompare(const void* a, const void* b)
-{
-	const TIFFFieldInfo* ta = *(const TIFFFieldInfo**) a;
-	const TIFFFieldInfo* tb = *(const TIFFFieldInfo**) b;
-	/* NB: be careful of return values for 16-bit platforms */
-	if (ta->field_tag != tb->field_tag)
-		return (int)ta->field_tag - (int)tb->field_tag;
-	else
-		return (ta->field_type == TIFF_ANY) ?
-			0 : ((int)tb->field_type - (int)ta->field_type);
-}
-
-static int
-tagNameCompare(const void* a, const void* b)
-{
-	const TIFFFieldInfo* ta = *(const TIFFFieldInfo**) a;
-	const TIFFFieldInfo* tb = *(const TIFFFieldInfo**) b;
-	int ret = strcmp(ta->field_name, tb->field_name);
-
-	if (ret)
-		return ret;
-	else
-		return (ta->field_type == TIFF_ANY) ?
-			0 : ((int)tb->field_type - (int)ta->field_type);
-}
-
-void
-TIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], int n)
-{
-	if (_TIFFMergeFieldInfo(tif, info, n) < 0)
-	{
-		TIFFErrorExt(tif->tif_clientdata, "TIFFMergeFieldInfo",
-			     "Merging block of %d fields failed", n);
-	}
-}
-
-int
-_TIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], int n)
-{
-	static const char module[] = "_TIFFMergeFieldInfo";
-	static const char reason[] = "for field info array";
-	TIFFFieldInfo** tp;
-	int i;
-
-        tif->tif_foundfield = NULL;
-
-	if (tif->tif_nfields > 0) {
-		tif->tif_fieldinfo = (TIFFFieldInfo**)
-			_TIFFCheckRealloc(tif, tif->tif_fieldinfo,
-					  (tif->tif_nfields + n),
-					  sizeof (TIFFFieldInfo*), reason);
-	} else {
-		tif->tif_fieldinfo = (TIFFFieldInfo**)
-			_TIFFCheckMalloc(tif, n, sizeof (TIFFFieldInfo*),
-					 reason);
-	}
-	if (!tif->tif_fieldinfo) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Failed to allocate field info array");
-		return 0;
-	}
-	tp = tif->tif_fieldinfo + tif->tif_nfields;
-	for (i = 0; i < n; i++)
-        {
-            const TIFFFieldInfo *fip =
-                _TIFFFindFieldInfo(tif, info[i].field_tag, info[i].field_type);
-
-            /* only add definitions that aren't already present */
-            if (!fip) {
-                *tp++ = (TIFFFieldInfo*) (info + i);
-                tif->tif_nfields++;
-            }
-        }
-
-        /* Sort the field info by tag number */
-        qsort(tif->tif_fieldinfo, tif->tif_nfields,
-	      sizeof (TIFFFieldInfo*), tagCompare);
-
-	return n;
-}
-
-void
-_TIFFPrintFieldInfo(TIFF* tif, FILE* fd)
-{
-	size_t i;
-
-	fprintf(fd, "%s: \n", tif->tif_name);
-	for (i = 0; i < tif->tif_nfields; i++) {
-		const TIFFFieldInfo* fip = tif->tif_fieldinfo[i];
-		fprintf(fd, "field[%2d] %5lu, %2d, %2d, %d, %2d, %5s, %5s, %s\n"
-			, (int)i
-			, (unsigned long) fip->field_tag
-			, fip->field_readcount, fip->field_writecount
-			, fip->field_type
-			, fip->field_bit
-			, fip->field_oktochange ? "TRUE" : "FALSE"
-			, fip->field_passcount ? "TRUE" : "FALSE"
-			, fip->field_name
-		);
-	}
-}
-
-/*
- * Return size of TIFFDataType in bytes
- */
-int
-TIFFDataWidth(TIFFDataType type)
-{
-	switch(type)
-	{
-	case 0:  /* nothing */
-	case 1:  /* TIFF_BYTE */
-	case 2:  /* TIFF_ASCII */
-	case 6:  /* TIFF_SBYTE */
-	case 7:  /* TIFF_UNDEFINED */
-		return 1;
-	case 3:  /* TIFF_SHORT */
-	case 8:  /* TIFF_SSHORT */
-		return 2;
-	case 4:  /* TIFF_LONG */
-	case 9:  /* TIFF_SLONG */
-	case 11: /* TIFF_FLOAT */
-        case 13: /* TIFF_IFD */
-		return 4;
-	case 5:  /* TIFF_RATIONAL */
-	case 10: /* TIFF_SRATIONAL */
-	case 12: /* TIFF_DOUBLE */
-		return 8;
-	default:
-		return 0; /* will return 0 for unknown types */
-	}
-}
-
-/*
- * Return size of TIFFDataType in bytes.
- *
- * XXX: We need a separate function to determine the space needed
- * to store the value. For TIFF_RATIONAL values TIFFDataWidth() returns 8,
- * but we use 4-byte float to represent rationals.
- */
-int
-_TIFFDataSize(TIFFDataType type)
-{
-	switch (type) {
-		case TIFF_BYTE:
-		case TIFF_SBYTE:
-		case TIFF_ASCII:
-		case TIFF_UNDEFINED:
-		    return 1;
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-		    return 2;
-		case TIFF_LONG:
-		case TIFF_SLONG:
-		case TIFF_FLOAT:
-		case TIFF_IFD:
-		case TIFF_RATIONAL:
-		case TIFF_SRATIONAL:
-		    return 4;
-		case TIFF_DOUBLE:
-		    return 8;
-		default:
-		    return 0;
-	}
-}
-
-/*
- * Return nearest TIFFDataType to the sample type of an image.
- */
-TIFFDataType
-_TIFFSampleToTagType(TIFF* tif)
-{
-	uint32 bps = TIFFhowmany8(tif->tif_dir.td_bitspersample);
-
-	switch (tif->tif_dir.td_sampleformat) {
-	case SAMPLEFORMAT_IEEEFP:
-		return (bps == 4 ? TIFF_FLOAT : TIFF_DOUBLE);
-	case SAMPLEFORMAT_INT:
-		return (bps <= 1 ? TIFF_SBYTE :
-		    bps <= 2 ? TIFF_SSHORT : TIFF_SLONG);
-	case SAMPLEFORMAT_UINT:
-		return (bps <= 1 ? TIFF_BYTE :
-		    bps <= 2 ? TIFF_SHORT : TIFF_LONG);
-	case SAMPLEFORMAT_VOID:
-		return (TIFF_UNDEFINED);
-	}
-	/*NOTREACHED*/
-	return (TIFF_UNDEFINED);
-}
-
-const TIFFFieldInfo*
-_TIFFFindFieldInfo(TIFF* tif, ttag_t tag, TIFFDataType dt)
-{
-        TIFFFieldInfo key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0};
-	TIFFFieldInfo* pkey = &key;
-	const TIFFFieldInfo **ret;
-
-	if (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&
-	    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))
-		return tif->tif_foundfield;
-
-	/* If we are invoked with no field information, then just return. */
-	if ( !tif->tif_fieldinfo ) {
-		return NULL;
-	}
-
-	/* NB: use sorted search (e.g. binary search) */
-	key.field_tag = tag;
-        key.field_type = dt;
-
-	ret = (const TIFFFieldInfo **) bsearch(&pkey,
-					       tif->tif_fieldinfo, 
-					       tif->tif_nfields,
-					       sizeof(TIFFFieldInfo *), 
-					       tagCompare);
-	return tif->tif_foundfield = (ret ? *ret : NULL);
-}
-
-#undef lfind
-static void *
-lfind(const void *key, const void *base, size_t *nmemb, size_t size,
-      int(*compar)(const void *, const void *))
-{
-	char *element, *end;
-    
-	end = (char *)base + *nmemb * size;
-	for (element = (char *)base; element < end; element += size)
-		if (!compar(element, key))		/* key found */
-			return element;
-    
-	return NULL;
-}
-
-
-const TIFFFieldInfo*
-_TIFFFindFieldInfoByName(TIFF* tif, const char *field_name, TIFFDataType dt)
-{
-        TIFFFieldInfo key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0};
-	TIFFFieldInfo* pkey = &key;
-	const TIFFFieldInfo **ret;
-
-	if (tif->tif_foundfield
-	    && streq(tif->tif_foundfield->field_name, field_name)
-	    && (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))
-		return (tif->tif_foundfield);
-
-	/* If we are invoked with no field information, then just return. */
-	if ( !tif->tif_fieldinfo ) {
-		return NULL;
-	}
-
-	/* NB: use sorted search (e.g. binary search) */
-        key.field_name = (char *)field_name;
-        key.field_type = dt;
-
-        ret = (const TIFFFieldInfo **) lfind(&pkey,
-					     tif->tif_fieldinfo, 
-					     &tif->tif_nfields,
-					     sizeof(TIFFFieldInfo *),
-					     tagNameCompare);
-	return tif->tif_foundfield = (ret ? *ret : NULL);
-}
-
-const TIFFFieldInfo*
-_TIFFFieldWithTag(TIFF* tif, ttag_t tag)
-{
-	const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);
-	if (!fip) {
-		TIFFErrorExt(tif->tif_clientdata, "TIFFFieldWithTag",
-			     "Internal error, unknown tag 0x%x",
-			     (unsigned int) tag);
-		assert(fip != NULL);
-		/*NOTREACHED*/
-	}
-	return (fip);
-}
-
-const TIFFFieldInfo*
-_TIFFFieldWithName(TIFF* tif, const char *field_name)
-{
-	const TIFFFieldInfo* fip =
-		_TIFFFindFieldInfoByName(tif, field_name, TIFF_ANY);
-	if (!fip) {
-		TIFFErrorExt(tif->tif_clientdata, "TIFFFieldWithName",
-			     "Internal error, unknown tag %s", field_name);
-		assert(fip != NULL);
-		/*NOTREACHED*/
-	}
-	return (fip);
-}
-
-const TIFFFieldInfo*
-_TIFFFindOrRegisterFieldInfo( TIFF *tif, ttag_t tag, TIFFDataType dt )
-
-{
-    const TIFFFieldInfo *fld;
-
-    fld = _TIFFFindFieldInfo( tif, tag, dt );
-    if( fld == NULL )
-    {
-        fld = _TIFFCreateAnonFieldInfo( tif, tag, dt );
-        if (!_TIFFMergeFieldInfo(tif, fld, 1))
-		return NULL;
-    }
-
-    return fld;
-}
-
-TIFFFieldInfo*
-_TIFFCreateAnonFieldInfo(TIFF *tif, ttag_t tag, TIFFDataType field_type)
-{
-	TIFFFieldInfo *fld;
-	(void) tif;
-
-	fld = (TIFFFieldInfo *) _TIFFmalloc(sizeof (TIFFFieldInfo));
-	if (fld == NULL)
-	    return NULL;
-	_TIFFmemset( fld, 0, sizeof(TIFFFieldInfo) );
-
-	fld->field_tag = tag;
-	fld->field_readcount = TIFF_VARIABLE2;
-	fld->field_writecount = TIFF_VARIABLE2;
-	fld->field_type = field_type;
-	fld->field_bit = FIELD_CUSTOM;
-	fld->field_oktochange = TRUE;
-	fld->field_passcount = TRUE;
-	fld->field_name = (char *) _TIFFmalloc(32);
-	if (fld->field_name == NULL) {
-	    _TIFFfree(fld);
-	    return NULL;
-	}
-
-	/* 
-	 * note that this name is a special sign to TIFFClose() and
-	 * _TIFFSetupFieldInfo() to free the field
-	 */
-	sprintf(fld->field_name, "Tag %d", (int) tag);
-
-	return fld;    
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dirread.c b/thirdparty/libtiff/tif_dirread.c
deleted file mode 100644
index 907b531..0000000
--- a/thirdparty/libtiff/tif_dirread.c
+++ /dev/null
@@ -1,2081 +0,0 @@
-/* $Id: tif_dirread.c,v 1.92.2.9 2010-06-14 00:21:46 fwarmerdam Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Directory Read Support Routines.
- */
-#include "tiffiop.h"
-
-#define	IGNORE	0		/* tag placeholder used below */
-
-#ifdef HAVE_IEEEFP
-# define	TIFFCvtIEEEFloatToNative(tif, n, fp)
-# define	TIFFCvtIEEEDoubleToNative(tif, n, dp)
-#else
-extern	void TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);
-extern	void TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);
-#endif
-
-static  TIFFDirEntry* TIFFReadDirectoryFind(TIFFDirEntry* dir,
-					    uint16 dircount, uint16 tagid);
-static	int EstimateStripByteCounts(TIFF*, TIFFDirEntry*, uint16);
-static	void MissingRequired(TIFF*, const char*);
-static	int TIFFCheckDirOffset(TIFF*, toff_t);
-static	int CheckDirCount(TIFF*, TIFFDirEntry*, uint32);
-static	uint16 TIFFFetchDirectory(TIFF*, toff_t, TIFFDirEntry**, toff_t *);
-static	tsize_t TIFFFetchData(TIFF*, TIFFDirEntry*, char*);
-static	tsize_t TIFFFetchString(TIFF*, TIFFDirEntry*, char*);
-static	float TIFFFetchRational(TIFF*, TIFFDirEntry*);
-static	int TIFFFetchNormalTag(TIFF*, TIFFDirEntry*);
-static	int TIFFFetchPerSampleShorts(TIFF*, TIFFDirEntry*, uint16*);
-static	int TIFFFetchPerSampleLongs(TIFF*, TIFFDirEntry*, uint32*);
-static	int TIFFFetchPerSampleAnys(TIFF*, TIFFDirEntry*, double*);
-static	int TIFFFetchShortArray(TIFF*, TIFFDirEntry*, uint16*);
-static	int TIFFFetchStripThing(TIFF*, TIFFDirEntry*, long, uint32**);
-static	int TIFFFetchRefBlackWhite(TIFF*, TIFFDirEntry*);
-static	int TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);
-static	float TIFFFetchFloat(TIFF*, TIFFDirEntry*);
-static	int TIFFFetchFloatArray(TIFF*, TIFFDirEntry*, float*);
-static	int TIFFFetchDoubleArray(TIFF*, TIFFDirEntry*, double*);
-static	int TIFFFetchAnyArray(TIFF*, TIFFDirEntry*, double*);
-static	int TIFFFetchShortPair(TIFF*, TIFFDirEntry*);
-static	void ChopUpSingleUncompressedStrip(TIFF*);
-
-/*
- * Read the next TIFF directory from a file and convert it to the internal
- * format. We read directories sequentially.
- */
-int
-TIFFReadDirectory(TIFF* tif)
-{
-	static const char module[] = "TIFFReadDirectory";
-
-	int n;
-	TIFFDirectory* td;
-	TIFFDirEntry *dp, *dir = NULL;
-	uint16 iv;
-	uint32 v;
-	const TIFFFieldInfo* fip;
-	size_t fix;
-	uint16 dircount;
-	int diroutoforderwarning = 0, compressionknown = 0;
-	int haveunknowntags = 0;
-
-	tif->tif_diroff = tif->tif_nextdiroff;
-	/*
-	 * Check whether we have the last offset or bad offset (IFD looping).
-	 */
-	if (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))
-		return 0;
-	/*
-	 * Cleanup any previous compression state.
-	 */
-	(*tif->tif_cleanup)(tif);
-	tif->tif_curdir++;
-	dircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,
-				      &dir, &tif->tif_nextdiroff);
-	if (!dircount) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s: Failed to read directory at offset %u",
-			     tif->tif_name, tif->tif_nextdiroff);
-		return 0;
-	}
-
-	tif->tif_flags &= ~TIFF_BEENWRITING;	/* reset before new dir */
-	/*
-	 * Setup default value and then make a pass over
-	 * the fields to check type and tag information,
-	 * and to extract info required to size data
-	 * structures.  A second pass is made afterwards
-	 * to read in everthing not taken in the first pass.
-	 */
-	td = &tif->tif_dir;
-	/* free any old stuff and reinit */
-	TIFFFreeDirectory(tif);
-	TIFFDefaultDirectory(tif);
-	/*
-	 * Electronic Arts writes gray-scale TIFF files
-	 * without a PlanarConfiguration directory entry.
-	 * Thus we setup a default value here, even though
-	 * the TIFF spec says there is no default value.
-	 */
-	TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
-
-	/*
-	 * Sigh, we must make a separate pass through the
-	 * directory for the following reason:
-	 *
-	 * We must process the Compression tag in the first pass
-	 * in order to merge in codec-private tag definitions (otherwise
-	 * we may get complaints about unknown tags).  However, the
-	 * Compression tag may be dependent on the SamplesPerPixel
-	 * tag value because older TIFF specs permited Compression
-	 * to be written as a SamplesPerPixel-count tag entry.
-	 * Thus if we don't first figure out the correct SamplesPerPixel
-	 * tag value then we may end up ignoring the Compression tag
-	 * value because it has an incorrect count value (if the
-	 * true value of SamplesPerPixel is not 1).
-	 *
-	 * It sure would have been nice if Aldus had really thought
-	 * this stuff through carefully.
-	 */
-	for (dp = dir, n = dircount; n > 0; n--, dp++) {
-		if (tif->tif_flags & TIFF_SWAB) {
-			TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
-			TIFFSwabArrayOfLong(&dp->tdir_count, 2);
-		}
-		if (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {
-			if (!TIFFFetchNormalTag(tif, dp))
-				goto bad;
-			dp->tdir_tag = IGNORE;
-		}
-	}
-	/*
-	 * First real pass over the directory.
-	 */
-	fix = 0;
-	for (dp = dir, n = dircount; n > 0; n--, dp++) {
-
-		if (dp->tdir_tag == IGNORE)
-			continue;
-		if (fix >= tif->tif_nfields)
-			fix = 0;
-
-		/*
-		 * Silicon Beach (at least) writes unordered
-		 * directory tags (violating the spec).  Handle
-		 * it here, but be obnoxious (maybe they'll fix it?).
-		 */
-		if (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {
-			if (!diroutoforderwarning) {
-				TIFFWarningExt(tif->tif_clientdata, module,
-	"%s: invalid TIFF directory; tags are not sorted in ascending order",
-					    tif->tif_name);
-				diroutoforderwarning = 1;
-			}
-			fix = 0;			/* O(n^2) */
-		}
-		while (fix < tif->tif_nfields &&
-		    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
-			fix++;
-		if (fix >= tif->tif_nfields ||
-		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {
-			/* Unknown tag ... we'll deal with it below */
-			haveunknowntags = 1;
-			continue;
-		}
-		/*
-		 * Null out old tags that we ignore.
-		 */
-		if (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {
-	ignore:
-			dp->tdir_tag = IGNORE;
-			continue;
-		}
-		/*
-		 * Check data type.
-		 */
-		fip = tif->tif_fieldinfo[fix];
-		while (dp->tdir_type != (unsigned short) fip->field_type
-		    && fix < tif->tif_nfields) {
-			if (fip->field_type == TIFF_ANY)	/* wildcard */
-				break;
-			fip = tif->tif_fieldinfo[++fix];
-			if (fix >= tif->tif_nfields ||
-			    fip->field_tag != dp->tdir_tag) {
-				TIFFWarningExt(tif->tif_clientdata, module,
-			"%s: wrong data type %d for \"%s\"; tag ignored",
-					    tif->tif_name, dp->tdir_type,
-					    tif->tif_fieldinfo[fix-1]->field_name);
-				goto ignore;
-			}
-		}
-		/*
-		 * Check count if known in advance.
-		 */
-		if (fip->field_readcount != TIFF_VARIABLE
-		    && fip->field_readcount != TIFF_VARIABLE2) {
-			uint32 expected = (fip->field_readcount == TIFF_SPP) ?
-			    (uint32) td->td_samplesperpixel :
-			    (uint32) fip->field_readcount;
-			if (!CheckDirCount(tif, dp, expected))
-				goto ignore;
-		}
-
-		switch (dp->tdir_tag) {
-		case TIFFTAG_COMPRESSION:
-			/*
-			 * The 5.0 spec says the Compression tag has
-			 * one value, while earlier specs say it has
-			 * one value per sample.  Because of this, we
-			 * accept the tag if one value is supplied.
-			 */
-			if (dp->tdir_count == 1) {
-				v = TIFFExtractData(tif,
-				    dp->tdir_type, dp->tdir_offset);
-				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-				else
-					compressionknown = 1;
-				break;
-			/* XXX: workaround for broken TIFFs */
-			} else if (dp->tdir_type == TIFF_LONG) {
-				if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
-				    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-			} else {
-				if (!TIFFFetchPerSampleShorts(tif, dp, &iv)
-				    || !TIFFSetField(tif, dp->tdir_tag, iv))
-					goto bad;
-			}
-			dp->tdir_tag = IGNORE;
-			break;
-		case TIFFTAG_STRIPOFFSETS:
-		case TIFFTAG_STRIPBYTECOUNTS:
-		case TIFFTAG_TILEOFFSETS:
-		case TIFFTAG_TILEBYTECOUNTS:
-			TIFFSetFieldBit(tif, fip->field_bit);
-			break;
-		case TIFFTAG_IMAGEWIDTH:
-		case TIFFTAG_IMAGELENGTH:
-		case TIFFTAG_IMAGEDEPTH:
-		case TIFFTAG_TILELENGTH:
-		case TIFFTAG_TILEWIDTH:
-		case TIFFTAG_TILEDEPTH:
-		case TIFFTAG_PLANARCONFIG:
-		case TIFFTAG_ROWSPERSTRIP:
-		case TIFFTAG_EXTRASAMPLES:
-			if (!TIFFFetchNormalTag(tif, dp))
-				goto bad;
-			dp->tdir_tag = IGNORE;
-			break;
-		}
-	}
-
-	/*
-	 * If we saw any unknown tags, make an extra pass over the directory
-	 * to deal with them.  This must be done separately because the tags
-	 * could have become known when we registered a codec after finding
-	 * the Compression tag.  In a correctly-sorted directory there's
-	 * no problem because Compression will come before any codec-private
-	 * tags, but if the sorting is wrong that might not hold.
-	 */
-	if (haveunknowntags) {
-	    fix = 0;
-	    for (dp = dir, n = dircount; n > 0; n--, dp++) {
-		if (dp->tdir_tag == IGNORE)
-			continue;
-		if (fix >= tif->tif_nfields ||
-		    dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag)
-			fix = 0;			/* O(n^2) */
-		while (fix < tif->tif_nfields &&
-		    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
-			fix++;
-		if (fix >= tif->tif_nfields ||
-		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {
-
-					TIFFWarningExt(tif->tif_clientdata,
-						       module,
-                        "%s: unknown field with tag %d (0x%x) encountered",
-						       tif->tif_name,
-						       dp->tdir_tag,
-						       dp->tdir_tag);
-
-					if (!_TIFFMergeFieldInfo(tif,
-						_TIFFCreateAnonFieldInfo(tif,
-						dp->tdir_tag,
-						(TIFFDataType) dp->tdir_type),
-						1))
-					{
-					TIFFWarningExt(tif->tif_clientdata,
-						       module,
-			"Registering anonymous field with tag %d (0x%x) failed",
-						       dp->tdir_tag,
-						       dp->tdir_tag);
-					dp->tdir_tag = IGNORE;
-					continue;
-					}
-			fix = 0;
-			while (fix < tif->tif_nfields &&
-			       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
-				fix++;
-		}
-		/*
-		 * Check data type.
-		 */
-		fip = tif->tif_fieldinfo[fix];
-		while (dp->tdir_type != (unsigned short) fip->field_type
-		    && fix < tif->tif_nfields) {
-			if (fip->field_type == TIFF_ANY)	/* wildcard */
-				break;
-			fip = tif->tif_fieldinfo[++fix];
-			if (fix >= tif->tif_nfields ||
-			    fip->field_tag != dp->tdir_tag) {
-				TIFFWarningExt(tif->tif_clientdata, module,
-			"%s: wrong data type %d for \"%s\"; tag ignored",
-					    tif->tif_name, dp->tdir_type,
-					    tif->tif_fieldinfo[fix-1]->field_name);
-				dp->tdir_tag = IGNORE;
-				break;
-			}
-		}
-	    }
-	}
-
-	/*
-	 * XXX: OJPEG hack.
-	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,
-	 * c) strip offsets/bytecounts tag are both present and
-	 * d) both contain exactly one value, then we consistently find
-	 * that the buggy implementation of the buggy compression scheme
-	 * matches contig planarconfig best. So we 'fix-up' the tag here
-	 */
-	if ((td->td_compression==COMPRESSION_OJPEG) &&
-	    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {
-		dp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);
-		if ((dp!=0) && (dp->tdir_count==1)) {
-			dp = TIFFReadDirectoryFind(dir, dircount,
-						   TIFFTAG_STRIPBYTECOUNTS);
-			if ((dp!=0) && (dp->tdir_count==1)) {
-				td->td_planarconfig=PLANARCONFIG_CONTIG;
-				TIFFWarningExt(tif->tif_clientdata,
-					       "TIFFReadDirectory",
-				"Planarconfig tag value assumed incorrect, "
-				"assuming data is contig instead of chunky");
-			}
-		}
-	}
-
-	/*
-	 * Allocate directory structure and setup defaults.
-	 */
-	if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {
-		MissingRequired(tif, "ImageLength");
-		goto bad;
-	}
-	/* 
-	 * Setup appropriate structures (by strip or by tile)
-	 */
-	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
-		td->td_nstrips = TIFFNumberOfStrips(tif);
-		td->td_tilewidth = td->td_imagewidth;
-		td->td_tilelength = td->td_rowsperstrip;
-		td->td_tiledepth = td->td_imagedepth;
-		tif->tif_flags &= ~TIFF_ISTILED;
-	} else {
-		td->td_nstrips = TIFFNumberOfTiles(tif);
-		tif->tif_flags |= TIFF_ISTILED;
-	}
-	if (!td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s: cannot handle zero number of %s",
-			     tif->tif_name, isTiled(tif) ? "tiles" : "strips");
-		goto bad;
-	}
-	td->td_stripsperimage = td->td_nstrips;
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		td->td_stripsperimage /= td->td_samplesperpixel;
-	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
-		if ((td->td_compression==COMPRESSION_OJPEG) &&
-		    (isTiled(tif)==0) &&
-		    (td->td_nstrips==1)) {
-			/*
-			 * XXX: OJPEG hack.
-			 * If a) compression is OJPEG, b) it's not a tiled TIFF,
-			 * and c) the number of strips is 1,
-			 * then we tolerate the absence of stripoffsets tag,
-			 * because, presumably, all required data is in the
-			 * JpegInterchangeFormat stream.
-			 */
-			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
-		} else {
-			MissingRequired(tif,
-				isTiled(tif) ? "TileOffsets" : "StripOffsets");
-			goto bad;
-		}
-	}
-
-	/*
-	 * Second pass: extract other information.
-	 */
-	for (dp = dir, n = dircount; n > 0; n--, dp++) {
-		if (dp->tdir_tag == IGNORE)
-			continue;
-		switch (dp->tdir_tag) {
-		case TIFFTAG_MINSAMPLEVALUE:
-		case TIFFTAG_MAXSAMPLEVALUE:
-		case TIFFTAG_BITSPERSAMPLE:
-		case TIFFTAG_DATATYPE:
-		case TIFFTAG_SAMPLEFORMAT:
-			/*
-			 * The 5.0 spec says the Compression tag has
-			 * one value, while earlier specs say it has
-			 * one value per sample.  Because of this, we
-			 * accept the tag if one value is supplied.
-			 *
-			 * The MinSampleValue, MaxSampleValue, BitsPerSample
-			 * DataType and SampleFormat tags are supposed to be
-			 * written as one value/sample, but some vendors
-			 * incorrectly write one value only -- so we accept
-			 * that as well (yech). Other vendors write correct
-			 * value for NumberOfSamples, but incorrect one for
-			 * BitsPerSample and friends, and we will read this
-			 * too.
-			 */
-			if (dp->tdir_count == 1) {
-				v = TIFFExtractData(tif,
-				    dp->tdir_type, dp->tdir_offset);
-				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-			/* XXX: workaround for broken TIFFs */
-			} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE
-				   && dp->tdir_type == TIFF_LONG) {
-				if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
-				    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-			} else {
-				if (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||
-				    !TIFFSetField(tif, dp->tdir_tag, iv))
-					goto bad;
-			}
-			break;
-		case TIFFTAG_SMINSAMPLEVALUE:
-		case TIFFTAG_SMAXSAMPLEVALUE:
-			{
-				double dv = 0.0;
-				if (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||
-				    !TIFFSetField(tif, dp->tdir_tag, dv))
-					goto bad;
-			}
-			break;
-		case TIFFTAG_STRIPOFFSETS:
-		case TIFFTAG_TILEOFFSETS:
-			if (!TIFFFetchStripThing(tif, dp,
-			    td->td_nstrips, &td->td_stripoffset))
-				goto bad;
-			break;
-		case TIFFTAG_STRIPBYTECOUNTS:
-		case TIFFTAG_TILEBYTECOUNTS:
-			if (!TIFFFetchStripThing(tif, dp,
-			    td->td_nstrips, &td->td_stripbytecount))
-				goto bad;
-			break;
-		case TIFFTAG_COLORMAP:
-		case TIFFTAG_TRANSFERFUNCTION:
-			{
-				char* cp;
-				/*
-				 * TransferFunction can have either 1x or 3x
-				 * data values; Colormap can have only 3x
-				 * items.
-				 */
-				v = 1L<<td->td_bitspersample;
-				if (dp->tdir_tag == TIFFTAG_COLORMAP ||
-				    dp->tdir_count != v) {
-					if (!CheckDirCount(tif, dp, 3 * v))
-						break;
-				}
-				v *= sizeof(uint16);
-				cp = (char *)_TIFFCheckMalloc(tif,
-							      dp->tdir_count,
-							      sizeof (uint16),
-					"to read \"TransferFunction\" tag");
-				if (cp != NULL) {
-					if (TIFFFetchData(tif, dp, cp)) {
-						/*
-						 * This deals with there being
-						 * only one array to apply to
-						 * all samples.
-						 */
-						uint32 c = 1L << td->td_bitspersample;
-						if (dp->tdir_count == c)
-							v = 0L;
-						TIFFSetField(tif, dp->tdir_tag,
-						    cp, cp+v, cp+2*v);
-					}
-					_TIFFfree(cp);
-				}
-				break;
-			}
-		case TIFFTAG_PAGENUMBER:
-		case TIFFTAG_HALFTONEHINTS:
-		case TIFFTAG_YCBCRSUBSAMPLING:
-		case TIFFTAG_DOTRANGE:
-			(void) TIFFFetchShortPair(tif, dp);
-			break;
-		case TIFFTAG_REFERENCEBLACKWHITE:
-			(void) TIFFFetchRefBlackWhite(tif, dp);
-			break;
-/* BEGIN REV 4.0 COMPATIBILITY */
-		case TIFFTAG_OSUBFILETYPE:
-			v = 0L;
-			switch (TIFFExtractData(tif, dp->tdir_type,
-			    dp->tdir_offset)) {
-			case OFILETYPE_REDUCEDIMAGE:
-				v = FILETYPE_REDUCEDIMAGE;
-				break;
-			case OFILETYPE_PAGE:
-				v = FILETYPE_PAGE;
-				break;
-			}
-			if (v)
-				TIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);
-			break;
-/* END REV 4.0 COMPATIBILITY */
-		default:
-			(void) TIFFFetchNormalTag(tif, dp);
-			break;
-		}
-	}
-	/*
-	 * OJPEG hack:
-	 * - If a) compression is OJPEG, and b) photometric tag is missing,
-	 * then we consistently find that photometric should be YCbCr
-	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,
-	 * then we consistently find that the buggy implementation of the
-	 * buggy compression scheme matches photometric YCbCr instead.
-	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,
-	 * then we consistently find bitspersample should be 8.
-	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
-	 * and c) photometric is RGB or YCbCr, then we consistently find
-	 * samplesperpixel should be 3
-	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
-	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently
-	 * find samplesperpixel should be 3
-	 */
-	if (td->td_compression==COMPRESSION_OJPEG)
-	{
-		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
-		{
-			TIFFWarningExt(tif->tif_clientdata, "TIFFReadDirectory",
-			"Photometric tag is missing, assuming data is YCbCr");
-			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
-				goto bad;
-		}
-		else if (td->td_photometric==PHOTOMETRIC_RGB)
-		{
-			td->td_photometric=PHOTOMETRIC_YCBCR;
-			TIFFWarningExt(tif->tif_clientdata, "TIFFReadDirectory",
-			"Photometric tag value assumed incorrect, "
-			"assuming data is YCbCr instead of RGB");
-		}
-		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
-		{
-			TIFFWarningExt(tif->tif_clientdata,"TIFFReadDirectory",
-		"BitsPerSample tag is missing, assuming 8 bits per sample");
-			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
-				goto bad;
-		}
-		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
-		{
-			if ((td->td_photometric==PHOTOMETRIC_RGB)
-			    || (td->td_photometric==PHOTOMETRIC_YCBCR))
-			{
-				TIFFWarningExt(tif->tif_clientdata,
-					       "TIFFReadDirectory",
-				"SamplesPerPixel tag is missing, "
-				"assuming correct SamplesPerPixel value is 3");
-				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
-					goto bad;
-			}
-			else if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)
-				 || (td->td_photometric==PHOTOMETRIC_MINISBLACK))
-			{
-				TIFFWarningExt(tif->tif_clientdata,
-					       "TIFFReadDirectory",
-				"SamplesPerPixel tag is missing, "
-				"assuming correct SamplesPerPixel value is 1");
-				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
-					goto bad;
-			}
-		}
-	}
-	/*
-	 * Verify Palette image has a Colormap.
-	 */
-	if (td->td_photometric == PHOTOMETRIC_PALETTE &&
-	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
-		MissingRequired(tif, "Colormap");
-		goto bad;
-	}
-	/*
-	 * OJPEG hack:
-	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG
-	 * TIFFs
-	 */
-	if (td->td_compression!=COMPRESSION_OJPEG)
-	{
-		/*
-		 * Attempt to deal with a missing StripByteCounts tag.
-		 */
-		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
-			/*
-			 * Some manufacturers violate the spec by not giving
-			 * the size of the strips.  In this case, assume there
-			 * is one uncompressed strip of data.
-			 */
-			if ((td->td_planarconfig == PLANARCONFIG_CONTIG &&
-			    td->td_nstrips > 1) ||
-			    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&
-			     td->td_nstrips != td->td_samplesperpixel)) {
-			    MissingRequired(tif, "StripByteCounts");
-			    goto bad;
-			}
-			TIFFWarningExt(tif->tif_clientdata, module,
-				"%s: TIFF directory is missing required "
-				"\"%s\" field, calculating from imagelength",
-				tif->tif_name,
-				_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
-			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
-			    goto bad;
-		/*
-		 * Assume we have wrong StripByteCount value (in case
-		 * of single strip) in following cases:
-		 *   - it is equal to zero along with StripOffset;
-		 *   - it is larger than file itself (in case of uncompressed
-		 *     image);
-		 *   - it is smaller than the size of the bytes per row
-		 *     multiplied on the number of rows.  The last case should
-		 *     not be checked in the case of writing new image,
-		 *     because we may do not know the exact strip size
-		 *     until the whole image will be written and directory
-		 *     dumped out.
-		 */
-		#define	BYTECOUNTLOOKSBAD \
-		    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \
-		      (td->td_compression == COMPRESSION_NONE && \
-		       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \
-		      (tif->tif_mode == O_RDONLY && \
-		       td->td_compression == COMPRESSION_NONE && \
-		       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )
-
-		} else if (td->td_nstrips == 1
-			   && td->td_stripoffset[0] != 0
-			   && BYTECOUNTLOOKSBAD) {
-			/*
-			 * XXX: Plexus (and others) sometimes give a value of
-			 * zero for a tag when they don't know what the
-			 * correct value is!  Try and handle the simple case
-			 * of estimating the size of a one strip image.
-			 */
-			TIFFWarningExt(tif->tif_clientdata, module,
-	"%s: Bogus \"%s\" field, ignoring and calculating from imagelength",
-				    tif->tif_name,
-				    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
-			if(EstimateStripByteCounts(tif, dir, dircount) < 0)
-			    goto bad;
-		} else if (td->td_planarconfig == PLANARCONFIG_CONTIG
-			   && td->td_nstrips > 2
-			   && td->td_compression == COMPRESSION_NONE
-			   && td->td_stripbytecount[0] != td->td_stripbytecount[1]
-                           && td->td_stripbytecount[0] != 0 
-                           && td->td_stripbytecount[1] != 0 ) {
-			/*
-			 * XXX: Some vendors fill StripByteCount array with 
-                         * absolutely wrong values (it can be equal to 
-                         * StripOffset array, for example). Catch this case 
-                         * here.
-			 */
-			TIFFWarningExt(tif->tif_clientdata, module,
-	"%s: Wrong \"%s\" field, ignoring and calculating from imagelength",
-				    tif->tif_name,
-				    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
-			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
-			    goto bad;
-		}
-	}
-	if (dir) {
-		_TIFFfree((char *)dir);
-		dir = NULL;
-	}
-	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
-		td->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);
-	/*
-	 * Setup default compression scheme.
-	 */
-
-	/*
-	 * XXX: We can optimize checking for the strip bounds using the sorted
-	 * bytecounts array. See also comments for TIFFAppendToStrip()
-	 * function in tif_write.c.
-	 */
-	if (td->td_nstrips > 1) {
-		tstrip_t strip;
-
-		td->td_stripbytecountsorted = 1;
-		for (strip = 1; strip < td->td_nstrips; strip++) {
-			if (td->td_stripoffset[strip - 1] >
-			    td->td_stripoffset[strip]) {
-				td->td_stripbytecountsorted = 0;
-				break;
-			}
-		}
-	}
-
-	if (!TIFFFieldSet(tif, FIELD_COMPRESSION))
-		TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
-	/*
-	 * Some manufacturers make life difficult by writing
-	 * large amounts of uncompressed data as a single strip.
-	 * This is contrary to the recommendations of the spec.
-	 * The following makes an attempt at breaking such images
-	 * into strips closer to the recommended 8k bytes.  A
-	 * side effect, however, is that the RowsPerStrip tag
-	 * value may be changed.
-	 */
-	if (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&
-	    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)
-		ChopUpSingleUncompressedStrip(tif);
-
-	/*
-	 * Reinitialize i/o since we are starting on a new directory.
-	 */
-	tif->tif_row = (uint32) -1;
-	tif->tif_curstrip = (tstrip_t) -1;
-	tif->tif_col = (uint32) -1;
-	tif->tif_curtile = (ttile_t) -1;
-	tif->tif_tilesize = (tsize_t) -1;
-
-	tif->tif_scanlinesize = TIFFScanlineSize(tif);
-	if (!tif->tif_scanlinesize) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "%s: cannot handle zero scanline size",
-			     tif->tif_name);
-		return (0);
-	}
-
-	if (isTiled(tif)) {
-		tif->tif_tilesize = TIFFTileSize(tif);
-		if (!tif->tif_tilesize) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "%s: cannot handle zero tile size",
-				     tif->tif_name);
-			return (0);
-		}
-	} else {
-		if (!TIFFStripSize(tif)) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "%s: cannot handle zero strip size",
-				     tif->tif_name);
-			return (0);
-		}
-	}
-	return (1);
-bad:
-	if (dir)
-		_TIFFfree(dir);
-	return (0);
-}
-
-static TIFFDirEntry*
-TIFFReadDirectoryFind(TIFFDirEntry* dir, uint16 dircount, uint16 tagid)
-{
-	TIFFDirEntry* m;
-	uint16 n;
-	for (m=dir, n=0; n<dircount; m++, n++)
-	{
-		if (m->tdir_tag==tagid)
-			return(m);
-	}
-	return(0);
-}
-
-/*
- * Read custom directory from the arbitarry offset.
- * The code is very similar to TIFFReadDirectory().
- */
-int
-TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
-			const TIFFFieldInfo info[], size_t n)
-{
-	static const char module[] = "TIFFReadCustomDirectory";
-
-	TIFFDirectory* td = &tif->tif_dir;
-	TIFFDirEntry *dp, *dir = NULL;
-	const TIFFFieldInfo* fip;
-	size_t fix;
-	uint16 i, dircount;
-
-	_TIFFSetupFieldInfo(tif, info, n);
-
-	dircount = TIFFFetchDirectory(tif, diroff, &dir, NULL);
-	if (!dircount) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			"%s: Failed to read custom directory at offset %u",
-			     tif->tif_name, diroff);
-		return 0;
-	}
-
-	TIFFFreeDirectory(tif);
-        _TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));
-
-	fix = 0;
-	for (dp = dir, i = dircount; i > 0; i--, dp++) {
-		if (tif->tif_flags & TIFF_SWAB) {
-			TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
-			TIFFSwabArrayOfLong(&dp->tdir_count, 2);
-		}
-
-		if (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)
-			continue;
-
-		while (fix < tif->tif_nfields &&
-		       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
-			fix++;
-
-		if (fix >= tif->tif_nfields ||
-		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {
-
-			TIFFWarningExt(tif->tif_clientdata, module,
-                        "%s: unknown field with tag %d (0x%x) encountered",
-				    tif->tif_name, dp->tdir_tag, dp->tdir_tag);
-			if (!_TIFFMergeFieldInfo(tif,
-						 _TIFFCreateAnonFieldInfo(tif,
-						 dp->tdir_tag,
-						 (TIFFDataType) dp->tdir_type),
-						 1))
-			{
-				TIFFWarningExt(tif->tif_clientdata, module,
-			"Registering anonymous field with tag %d (0x%x) failed",
-						dp->tdir_tag, dp->tdir_tag);
-				goto ignore;
-			}
-
-			fix = 0;
-			while (fix < tif->tif_nfields &&
-			       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
-				fix++;
-		}
-		/*
-		 * Null out old tags that we ignore.
-		 */
-		if (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {
-	ignore:
-			dp->tdir_tag = IGNORE;
-			continue;
-		}
-		/*
-		 * Check data type.
-		 */
-		fip = tif->tif_fieldinfo[fix];
-		while (dp->tdir_type != (unsigned short) fip->field_type
-                       && fix < tif->tif_nfields) {
-			if (fip->field_type == TIFF_ANY)	/* wildcard */
-				break;
-                        fip = tif->tif_fieldinfo[++fix];
-			if (fix >= tif->tif_nfields ||
-			    fip->field_tag != dp->tdir_tag) {
-				TIFFWarningExt(tif->tif_clientdata, module,
-			"%s: wrong data type %d for \"%s\"; tag ignored",
-					    tif->tif_name, dp->tdir_type,
-					    tif->tif_fieldinfo[fix-1]->field_name);
-				goto ignore;
-			}
-		}
-		/*
-		 * Check count if known in advance.
-		 */
-		if (fip->field_readcount != TIFF_VARIABLE
-		    && fip->field_readcount != TIFF_VARIABLE2) {
-			uint32 expected = (fip->field_readcount == TIFF_SPP) ?
-			    (uint32) td->td_samplesperpixel :
-			    (uint32) fip->field_readcount;
-			if (!CheckDirCount(tif, dp, expected))
-				goto ignore;
-		}
-
-		/*
-		 * EXIF tags which need to be specifically processed.
-		 */
-		switch (dp->tdir_tag) {
-			case EXIFTAG_SUBJECTDISTANCE:
-				(void) TIFFFetchSubjectDistance(tif, dp);
-				break;
-			default:
-				(void) TIFFFetchNormalTag(tif, dp);
-				break;
-		}
-	}
-	
-	if (dir)
-		_TIFFfree(dir);
-	return 1;
-}
-
-/*
- * EXIF is important special case of custom IFD, so we have a special
- * function to read it.
- */
-int
-TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)
-{
-	size_t exifFieldInfoCount;
-	const TIFFFieldInfo *exifFieldInfo =
-		_TIFFGetExifFieldInfo(&exifFieldInfoCount);
-	return TIFFReadCustomDirectory(tif, diroff, exifFieldInfo,
-				       exifFieldInfoCount);
-}
-
-static int
-EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
-{
-	static const char module[] = "EstimateStripByteCounts";
-
-	TIFFDirEntry *dp;
-	TIFFDirectory *td = &tif->tif_dir;
-	uint32 strip;
-
-	if (td->td_stripbytecount)
-		_TIFFfree(td->td_stripbytecount);
-	td->td_stripbytecount = (uint32*)
-	    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint32),
-		"for \"StripByteCounts\" array");
-        if( td->td_stripbytecount == NULL )
-            return -1;
-
-	if (td->td_compression != COMPRESSION_NONE) {
-		uint32 space = (uint32)(sizeof (TIFFHeader)
-		    + sizeof (uint16)
-		    + (dircount * sizeof (TIFFDirEntry))
-		    + sizeof (uint32));
-		toff_t filesize = TIFFGetFileSize(tif);
-		uint16 n;
-
-		/* calculate amount of space used by indirect values */
-		for (dp = dir, n = dircount; n > 0; n--, dp++)
-		{
-			uint32 cc = TIFFDataWidth((TIFFDataType) dp->tdir_type);
-			if (cc == 0) {
-				TIFFErrorExt(tif->tif_clientdata, module,
-			"%s: Cannot determine size of unknown tag type %d",
-					  tif->tif_name, dp->tdir_type);
-				return -1;
-			}
-			cc = cc * dp->tdir_count;
-			if (cc > sizeof (uint32))
-				space += cc;
-		}
-		space = filesize - space;
-		if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-			space /= td->td_samplesperpixel;
-		for (strip = 0; strip < td->td_nstrips; strip++)
-			td->td_stripbytecount[strip] = space;
-		/*
-		 * This gross hack handles the case were the offset to
-		 * the last strip is past the place where we think the strip
-		 * should begin.  Since a strip of data must be contiguous,
-		 * it's safe to assume that we've overestimated the amount
-		 * of data in the strip and trim this number back accordingly.
-		 */ 
-		strip--;
-		if (((toff_t)(td->td_stripoffset[strip]+
-			      td->td_stripbytecount[strip])) > filesize)
-			td->td_stripbytecount[strip] =
-			    filesize - td->td_stripoffset[strip];
-	} else if (isTiled(tif)) {
-		uint32 bytespertile = TIFFTileSize(tif);
-
-		for (strip = 0; strip < td->td_nstrips; strip++)
-                    td->td_stripbytecount[strip] = bytespertile;
-	} else {
-		uint32 rowbytes = TIFFScanlineSize(tif);
-		uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;
-		for (strip = 0; strip < td->td_nstrips; strip++)
-			td->td_stripbytecount[strip] = rowbytes * rowsperstrip;
-	}
-	TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
-	if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))
-		td->td_rowsperstrip = td->td_imagelength;
-	return 1;
-}
-
-static void
-MissingRequired(TIFF* tif, const char* tagname)
-{
-	static const char module[] = "MissingRequired";
-
-	TIFFErrorExt(tif->tif_clientdata, module,
-		  "%s: TIFF directory is missing required \"%s\" field",
-		  tif->tif_name, tagname);
-}
-
-/*
- * Check the directory offset against the list of already seen directory
- * offsets. This is a trick to prevent IFD looping. The one can create TIFF
- * file with looped directory pointers. We will maintain a list of already
- * seen directories and check every IFD offset against that list.
- */
-static int
-TIFFCheckDirOffset(TIFF* tif, toff_t diroff)
-{
-	uint16 n;
-
-	if (diroff == 0)			/* no more directories */
-		return 0;
-
-	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {
-		if (tif->tif_dirlist[n] == diroff)
-			return 0;
-	}
-
-	tif->tif_dirnumber++;
-
-	if (tif->tif_dirnumber > tif->tif_dirlistsize) {
-		toff_t* new_dirlist;
-
-		/*
-		 * XXX: Reduce memory allocation granularity of the dirlist
-		 * array.
-		 */
-		new_dirlist = (toff_t *)_TIFFCheckRealloc(tif,
-							  tif->tif_dirlist,
-							  tif->tif_dirnumber,
-							  2 * sizeof(toff_t),
-							  "for IFD list");
-		if (!new_dirlist)
-			return 0;
-		tif->tif_dirlistsize = 2 * tif->tif_dirnumber;
-		tif->tif_dirlist = new_dirlist;
-	}
-
-	tif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;
-
-	return 1;
-}
-
-/*
- * Check the count field of a directory entry against a known value.  The
- * caller is expected to skip/ignore the tag if there is a mismatch.
- */
-static int
-CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
-{
-	if (count > dir->tdir_count) {
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-	"incorrect count for field \"%s\" (%u, expecting %u); tag ignored",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
-		    dir->tdir_count, count);
-		return (0);
-	} else if (count < dir->tdir_count) {
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-	"incorrect count for field \"%s\" (%u, expecting %u); tag trimmed",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
-		    dir->tdir_count, count);
-		return (1);
-	}
-	return (1);
-}
-
-/*
- * Read IFD structure from the specified offset. If the pointer to
- * nextdiroff variable has been specified, read it too. Function returns a
- * number of fields in the directory or 0 if failed.
- */
-static uint16
-TIFFFetchDirectory(TIFF* tif, toff_t diroff, TIFFDirEntry **pdir,
-		   toff_t *nextdiroff)
-{
-	static const char module[] = "TIFFFetchDirectory";
-
-	TIFFDirEntry *dir;
-	uint16 dircount;
-
-	assert(pdir);
-
-	tif->tif_diroff = diroff;
-	if (nextdiroff)
-		*nextdiroff = 0;
-	if (!isMapped(tif)) {
-		if (!SeekOK(tif, tif->tif_diroff)) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"%s: Seek error accessing TIFF directory",
-				tif->tif_name);
-			return 0;
-		}
-		if (!ReadOK(tif, &dircount, sizeof (uint16))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"%s: Can not read TIFF directory count",
-				tif->tif_name);
-			return 0;
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,
-						sizeof (TIFFDirEntry),
-						"to read TIFF directory");
-		if (dir == NULL)
-			return 0;
-		if (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"%.100s: Can not read TIFF directory",
-				tif->tif_name);
-			_TIFFfree(dir);
-			return 0;
-		}
-		/*
-		 * Read offset to next directory for sequential scans if
-		 * needed.
-		 */
-		if (nextdiroff)
-			(void) ReadOK(tif, nextdiroff, sizeof(uint32));
-	} else {
-		toff_t off = tif->tif_diroff;
-
-		/*
-		 * Check for integer overflow when validating the dir_off,
-		 * otherwise a very high offset may cause an OOB read and
-		 * crash the client. Make two comparisons instead of
-		 *
-		 *  off + sizeof(uint16) > tif->tif_size
-		 *
-		 * to avoid overflow.
-		 */
-		if (tif->tif_size < sizeof (uint16) ||
-		    off > tif->tif_size - sizeof(uint16)) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				"%s: Can not read TIFF directory count",
-				tif->tif_name);
-			return 0;
-		} else {
-			_TIFFmemcpy(&dircount, tif->tif_base + off,
-				    sizeof(uint16));
-		}
-		off += sizeof (uint16);
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,
-						sizeof(TIFFDirEntry),
-						"to read TIFF directory");
-		if (dir == NULL)
-			return 0;
-		if (off + dircount * sizeof (TIFFDirEntry) > tif->tif_size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "%s: Can not read TIFF directory",
-				     tif->tif_name);
-			_TIFFfree(dir);
-			return 0;
-		} else {
-			_TIFFmemcpy(dir, tif->tif_base + off,
-				    dircount * sizeof(TIFFDirEntry));
-		}
-		if (nextdiroff) {
-			off += dircount * sizeof (TIFFDirEntry);
-			if (off + sizeof (uint32) <= tif->tif_size) {
-				_TIFFmemcpy(nextdiroff, tif->tif_base + off,
-					    sizeof (uint32));
-			}
-		}
-	}
-	if (nextdiroff && tif->tif_flags & TIFF_SWAB)
-		TIFFSwabLong(nextdiroff);
-	*pdir = dir;
-	return dircount;
-}
-
-/*
- * Fetch a contiguous directory item.
- */
-static tsize_t
-TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)
-{
-	uint32 w = TIFFDataWidth((TIFFDataType) dir->tdir_type);
-	/* 
-	 * FIXME: butecount should have tsize_t type, but for now libtiff
-	 * defines tsize_t as a signed 32-bit integer and we are losing
-	 * ability to read arrays larger than 2^31 bytes. So we are using
-	 * uint32 instead of tsize_t here.
-	 */
-	uint32 cc = dir->tdir_count * w;
-
-	/* Check for overflow. */
-	if (!dir->tdir_count || !w || cc / w != dir->tdir_count)
-		goto bad;
-
-	if (!isMapped(tif)) {
-		if (!SeekOK(tif, dir->tdir_offset))
-			goto bad;
-		if (!ReadOK(tif, cp, cc))
-			goto bad;
-	} else {
-		/* Check for overflow. */
-		if (dir->tdir_offset + cc < dir->tdir_offset
-		    || dir->tdir_offset + cc < cc
-		    || dir->tdir_offset + cc > tif->tif_size)
-			goto bad;
-		_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);
-	}
-	if (tif->tif_flags & TIFF_SWAB) {
-		switch (dir->tdir_type) {
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-			TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);
-			break;
-		case TIFF_LONG:
-		case TIFF_SLONG:
-		case TIFF_FLOAT:
-			TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);
-			break;
-		case TIFF_RATIONAL:
-		case TIFF_SRATIONAL:
-			TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);
-			break;
-		case TIFF_DOUBLE:
-			TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);
-			break;
-		}
-	}
-	return (cc);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		     "Error fetching data for field \"%s\"",
-		     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-	return (tsize_t) 0;
-}
-
-/*
- * Fetch an ASCII item from the file.
- */
-static tsize_t
-TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)
-{
-	if (dir->tdir_count <= 4) {
-		uint32 l = dir->tdir_offset;
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabLong(&l);
-		_TIFFmemcpy(cp, &l, dir->tdir_count);
-		return (1);
-	}
-	return (TIFFFetchData(tif, dir, cp));
-}
-
-/*
- * Convert numerator+denominator to float.
- */
-static int
-cvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)
-{
-	if (denom == 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "%s: Rational with zero denominator (num = %u)",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);
-		return (0);
-	} else {
-		if (dir->tdir_type == TIFF_RATIONAL)
-			*rv = ((float)num / (float)denom);
-		else
-			*rv = ((float)(int32)num / (float)(int32)denom);
-		return (1);
-	}
-}
-
-/*
- * Fetch a rational item from the file at offset off and return the value as a
- * floating point number.
- */
-static float
-TIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)
-{
-	uint32 l[2];
-	float v;
-
-	return (!TIFFFetchData(tif, dir, (char *)l) ||
-	    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);
-}
-
-/*
- * Fetch a single floating point value from the offset field and return it as
- * a native float.
- */
-static float
-TIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir)
-{
-	float v;
-	int32 l = TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);
-        _TIFFmemcpy(&v, &l, sizeof(float));
-	TIFFCvtIEEEFloatToNative(tif, 1, &v);
-	return (v);
-}
-
-/*
- * Fetch an array of BYTE or SBYTE values.
- */
-static int
-TIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint8* v)
-{
-    if (dir->tdir_count <= 4) {
-        /*
-         * Extract data from offset field.
-         */
-        if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
-	    if (dir->tdir_type == TIFF_SBYTE)
-                switch (dir->tdir_count) {
-                    case 4: v[3] = dir->tdir_offset & 0xff;
-                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;
-                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;
-		    case 1: v[0] = dir->tdir_offset >> 24;
-                }
-	    else
-                switch (dir->tdir_count) {
-                    case 4: v[3] = dir->tdir_offset & 0xff;
-                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;
-                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;
-		    case 1: v[0] = dir->tdir_offset >> 24;
-                }
-	} else {
-	    if (dir->tdir_type == TIFF_SBYTE)
-                switch (dir->tdir_count) {
-                    case 4: v[3] = dir->tdir_offset >> 24;
-                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;
-                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;
-                    case 1: v[0] = dir->tdir_offset & 0xff;
-		}
-	    else
-                switch (dir->tdir_count) {
-                    case 4: v[3] = dir->tdir_offset >> 24;
-                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;
-                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;
-                    case 1: v[0] = dir->tdir_offset & 0xff;
-		}
-	}
-        return (1);
-    } else
-        return (TIFFFetchData(tif, dir, (char*) v) != 0);	/* XXX */
-}
-
-/*
- * Fetch an array of SHORT or SSHORT values.
- */
-static int
-TIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)
-{
-	if (dir->tdir_count <= 2) {
-		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
-			switch (dir->tdir_count) {
-			case 2: v[1] = (uint16) (dir->tdir_offset & 0xffff);
-			case 1: v[0] = (uint16) (dir->tdir_offset >> 16);
-			}
-		} else {
-			switch (dir->tdir_count) {
-			case 2: v[1] = (uint16) (dir->tdir_offset >> 16);
-			case 1: v[0] = (uint16) (dir->tdir_offset & 0xffff);
-			}
-		}
-		return (1);
-	} else
-		return (TIFFFetchData(tif, dir, (char *)v) != 0);
-}
-
-/*
- * Fetch a pair of SHORT or BYTE values. Some tags may have either BYTE
- * or SHORT type and this function works with both ones.
- */
-static int
-TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)
-{
-	/*
-	 * Prevent overflowing the v stack arrays below by performing a sanity
-	 * check on tdir_count, this should never be greater than two.
-	 */
-	if (dir->tdir_count > 2) {
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-		"unexpected count for field \"%s\", %u, expected 2; ignored",
-			_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
-			dir->tdir_count);
-		return 0;
-	}
-
-	switch (dir->tdir_type) {
-		case TIFF_BYTE:
-		case TIFF_SBYTE:
-			{
-			uint8 v[4];
-			return TIFFFetchByteArray(tif, dir, v)
-				&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);
-			}
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-			{
-			uint16 v[2];
-			return TIFFFetchShortArray(tif, dir, v)
-				&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);
-			}
-		default:
-			return 0;
-	}
-}
-
-/*
- * Fetch an array of LONG or SLONG values.
- */
-static int
-TIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)
-{
-	if (dir->tdir_count == 1) {
-		v[0] = dir->tdir_offset;
-		return (1);
-	} else
-		return (TIFFFetchData(tif, dir, (char*) v) != 0);
-}
-
-/*
- * Fetch an array of RATIONAL or SRATIONAL values.
- */
-static int
-TIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)
-{
-	int ok = 0;
-	uint32* l;
-
-	l = (uint32*)_TIFFCheckMalloc(tif,
-	    dir->tdir_count, TIFFDataWidth((TIFFDataType) dir->tdir_type),
-	    "to fetch array of rationals");
-	if (l) {
-		if (TIFFFetchData(tif, dir, (char *)l)) {
-			uint32 i;
-			for (i = 0; i < dir->tdir_count; i++) {
-				ok = cvtRational(tif, dir,
-				    l[2*i+0], l[2*i+1], &v[i]);
-				if (!ok)
-					break;
-			}
-		}
-		_TIFFfree((char *)l);
-	}
-	return (ok);
-}
-
-/*
- * Fetch an array of FLOAT values.
- */
-static int
-TIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)
-{
-
-	if (dir->tdir_count == 1) {
-	        union
-		{
-		  float  f;
-		  uint32 i;
-		} float_union;
-
-		float_union.i=dir->tdir_offset;
-		v[0]=float_union.f;
-		TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);
-		return (1);
-	} else	if (TIFFFetchData(tif, dir, (char*) v)) {
-		TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);
-		return (1);
-	} else
-		return (0);
-}
-
-/*
- * Fetch an array of DOUBLE values.
- */
-static int
-TIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)
-{
-	if (TIFFFetchData(tif, dir, (char*) v)) {
-		TIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);
-		return (1);
-	} else
-		return (0);
-}
-
-/*
- * Fetch an array of ANY values.  The actual values are returned as doubles
- * which should be able hold all the types.  Yes, there really should be an
- * tany_t to avoid this potential non-portability ...  Note in particular that
- * we assume that the double return value vector is large enough to read in
- * any fundamental type.  We use that vector as a buffer to read in the base
- * type vector and then convert it in place to double (from end to front of
- * course).
- */
-static int
-TIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v)
-{
-	int i;
-
-	switch (dir->tdir_type) {
-	case TIFF_BYTE:
-	case TIFF_SBYTE:
-		if (!TIFFFetchByteArray(tif, dir, (uint8*) v))
-			return (0);
-		if (dir->tdir_type == TIFF_BYTE) {
-			uint8* vp = (uint8*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		} else {
-			int8* vp = (int8*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		}
-		break;
-	case TIFF_SHORT:
-	case TIFF_SSHORT:
-		if (!TIFFFetchShortArray(tif, dir, (uint16*) v))
-			return (0);
-		if (dir->tdir_type == TIFF_SHORT) {
-			uint16* vp = (uint16*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		} else {
-			int16* vp = (int16*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		}
-		break;
-	case TIFF_LONG:
-	case TIFF_SLONG:
-		if (!TIFFFetchLongArray(tif, dir, (uint32*) v))
-			return (0);
-		if (dir->tdir_type == TIFF_LONG) {
-			uint32* vp = (uint32*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		} else {
-			int32* vp = (int32*) v;
-			for (i = dir->tdir_count-1; i >= 0; i--)
-				v[i] = vp[i];
-		}
-		break;
-	case TIFF_RATIONAL:
-	case TIFF_SRATIONAL:
-		if (!TIFFFetchRationalArray(tif, dir, (float*) v))
-			return (0);
-		{ float* vp = (float*) v;
-		  for (i = dir->tdir_count-1; i >= 0; i--)
-			v[i] = vp[i];
-		}
-		break;
-	case TIFF_FLOAT:
-		if (!TIFFFetchFloatArray(tif, dir, (float*) v))
-			return (0);
-		{ float* vp = (float*) v;
-		  for (i = dir->tdir_count-1; i >= 0; i--)
-			v[i] = vp[i];
-		}
-		break;
-	case TIFF_DOUBLE:
-		return (TIFFFetchDoubleArray(tif, dir, (double*) v));
-	default:
-		/* TIFF_NOTYPE */
-		/* TIFF_ASCII */
-		/* TIFF_UNDEFINED */
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "cannot read TIFF_ANY type %d for field \"%s\"",
-			     dir->tdir_type,
-			     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * Fetch a tag that is not handled by special case code.
- */
-static int
-TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)
-{
-	static const char mesg[] = "to fetch tag value";
-	int ok = 0;
-	const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);
-
-	if (dp->tdir_count > 1) {		/* array of values */
-		char* cp = NULL;
-
-		switch (dp->tdir_type) {
-		case TIFF_BYTE:
-		case TIFF_SBYTE:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (uint8), mesg);
-			ok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);
-			break;
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (uint16), mesg);
-			ok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);
-			break;
-		case TIFF_LONG:
-		case TIFF_SLONG:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (uint32), mesg);
-			ok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);
-			break;
-		case TIFF_RATIONAL:
-		case TIFF_SRATIONAL:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (float), mesg);
-			ok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);
-			break;
-		case TIFF_FLOAT:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (float), mesg);
-			ok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);
-			break;
-		case TIFF_DOUBLE:
-			cp = (char *)_TIFFCheckMalloc(tif,
-			    dp->tdir_count, sizeof (double), mesg);
-			ok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);
-			break;
-		case TIFF_ASCII:
-		case TIFF_UNDEFINED:		/* bit of a cheat... */
-			/*
-			 * Some vendors write strings w/o the trailing
-			 * NULL byte, so always append one just in case.
-			 */
-			cp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,
-						      1, mesg);
-			if( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )
-				cp[dp->tdir_count] = '\0';	/* XXX */
-			break;
-		}
-		if (ok) {
-			ok = (fip->field_passcount ?
-			    TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, cp)
-			  : TIFFSetField(tif, dp->tdir_tag, cp));
-		}
-		if (cp != NULL)
-			_TIFFfree(cp);
-	} else if (CheckDirCount(tif, dp, 1)) {	/* singleton value */
-		switch (dp->tdir_type) {
-		case TIFF_BYTE:
-		case TIFF_SBYTE:
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-			/*
-			 * If the tag is also acceptable as a LONG or SLONG
-			 * then TIFFSetField will expect an uint32 parameter
-			 * passed to it (through varargs).  Thus, for machines
-			 * where sizeof (int) != sizeof (uint32) we must do
-			 * a careful check here.  It's hard to say if this
-			 * is worth optimizing.
-			 *
-			 * NB: We use TIFFFieldWithTag here knowing that
-			 *     it returns us the first entry in the table
-			 *     for the tag and that that entry is for the
-			 *     widest potential data type the tag may have.
-			 */
-			{ TIFFDataType type = fip->field_type;
-			  if (type != TIFF_LONG && type != TIFF_SLONG) {
-				uint16 v = (uint16)
-			   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);
-				ok = (fip->field_passcount ?
-				    TIFFSetField(tif, dp->tdir_tag, 1, &v)
-				  : TIFFSetField(tif, dp->tdir_tag, v));
-				break;
-			  }
-			}
-			/* fall thru... */
-		case TIFF_LONG:
-		case TIFF_SLONG:
-			{ uint32 v32 =
-		    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);
-			  ok = (fip->field_passcount ? 
-			      TIFFSetField(tif, dp->tdir_tag, 1, &v32)
-			    : TIFFSetField(tif, dp->tdir_tag, v32));
-			}
-			break;
-		case TIFF_RATIONAL:
-		case TIFF_SRATIONAL:
-		case TIFF_FLOAT:
-			{ float v = (dp->tdir_type == TIFF_FLOAT ? 
-			      TIFFFetchFloat(tif, dp)
-			    : TIFFFetchRational(tif, dp));
-			  ok = (fip->field_passcount ?
-			      TIFFSetField(tif, dp->tdir_tag, 1, &v)
-			    : TIFFSetField(tif, dp->tdir_tag, v));
-			}
-			break;
-		case TIFF_DOUBLE:
-			{ double v;
-			  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&
-			    (fip->field_passcount ?
-			      TIFFSetField(tif, dp->tdir_tag, 1, &v)
-			    : TIFFSetField(tif, dp->tdir_tag, v))
-			  );
-			}
-			break;
-		case TIFF_ASCII:
-		case TIFF_UNDEFINED:		/* bit of a cheat... */
-			{ char c[2];
-			  if( (ok = (TIFFFetchString(tif, dp, c) != 0)) != 0 ) {
-				c[1] = '\0';		/* XXX paranoid */
-				ok = (fip->field_passcount ?
-					TIFFSetField(tif, dp->tdir_tag, 1, c)
-				      : TIFFSetField(tif, dp->tdir_tag, c));
-			  }
-			}
-			break;
-		}
-	}
-	return (ok);
-}
-
-#define	NITEMS(x)	(sizeof (x) / sizeof (x[0]))
-/*
- * Fetch samples/pixel short values for 
- * the specified tag and verify that
- * all values are the same.
- */
-static int
-TIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, uint16* pl)
-{
-    uint16 samples = tif->tif_dir.td_samplesperpixel;
-    int status = 0;
-
-    if (CheckDirCount(tif, dir, (uint32) samples)) {
-        uint16 buf[10];
-        uint16* v = buf;
-
-        if (dir->tdir_count > NITEMS(buf))
-            v = (uint16*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint16),
-                                      "to fetch per-sample values");
-        if (v && TIFFFetchShortArray(tif, dir, v)) {
-            uint16 i;
-            int check_count = dir->tdir_count;
-            if( samples < check_count )
-                check_count = samples;
-
-            for (i = 1; i < check_count; i++)
-                if (v[i] != v[0]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-                "Cannot handle different per-sample values for field \"%s\"",
-			_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-			goto bad;
-                }
-            *pl = v[0];
-            status = 1;
-        }
-      bad:
-        if (v && v != buf)
-            _TIFFfree(v);
-    }
-    return (status);
-}
-
-/*
- * Fetch samples/pixel long values for 
- * the specified tag and verify that
- * all values are the same.
- */
-static int
-TIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, uint32* pl)
-{
-    uint16 samples = tif->tif_dir.td_samplesperpixel;
-    int status = 0;
-
-    if (CheckDirCount(tif, dir, (uint32) samples)) {
-        uint32 buf[10];
-        uint32* v = buf;
-
-        if (dir->tdir_count > NITEMS(buf))
-            v = (uint32*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint32),
-                                      "to fetch per-sample values");
-        if (v && TIFFFetchLongArray(tif, dir, v)) {
-            uint16 i;
-            int check_count = dir->tdir_count;
-
-            if( samples < check_count )
-                check_count = samples;
-            for (i = 1; i < check_count; i++)
-                if (v[i] != v[0]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-                "Cannot handle different per-sample values for field \"%s\"",
-			_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-			goto bad;
-                }
-            *pl = v[0];
-            status = 1;
-        }
-      bad:
-        if (v && v != buf)
-            _TIFFfree(v);
-    }
-    return (status);
-}
-
-/*
- * Fetch samples/pixel ANY values for the specified tag and verify that all
- * values are the same.
- */
-static int
-TIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)
-{
-    uint16 samples = tif->tif_dir.td_samplesperpixel;
-    int status = 0;
-
-    if (CheckDirCount(tif, dir, (uint32) samples)) {
-        double buf[10];
-        double* v = buf;
-
-        if (dir->tdir_count > NITEMS(buf))
-            v = (double*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (double),
-                                      "to fetch per-sample values");
-        if (v && TIFFFetchAnyArray(tif, dir, v)) {
-            uint16 i;
-            int check_count = dir->tdir_count;
-            if( samples < check_count )
-                check_count = samples;
-
-            for (i = 1; i < check_count; i++)
-                if (v[i] != v[0]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"Cannot handle different per-sample values for field \"%s\"",
-			_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-			goto bad;
-                }
-            *pl = v[0];
-            status = 1;
-        }
-      bad:
-        if (v && v != buf)
-            _TIFFfree(v);
-    }
-    return (status);
-}
-#undef NITEMS
-
-/*
- * Fetch a set of offsets or lengths.
- * While this routine says "strips", in fact it's also used for tiles.
- */
-static int
-TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)
-{
-	register uint32* lp;
-	int status;
-
-        CheckDirCount(tif, dir, (uint32) nstrips);
-
-	/*
-	 * Allocate space for strip information.
-	 */
-	if (*lpp == NULL &&
-	    (*lpp = (uint32 *)_TIFFCheckMalloc(tif,
-	      nstrips, sizeof (uint32), "for strip array")) == NULL)
-		return (0);
-	lp = *lpp;
-        _TIFFmemset( lp, 0, sizeof(uint32) * nstrips );
-
-	if (dir->tdir_type == (int)TIFF_SHORT) {
-		/*
-		 * Handle uint16->uint32 expansion.
-		 */
-		uint16* dp = (uint16*) _TIFFCheckMalloc(tif,
-		    dir->tdir_count, sizeof (uint16), "to fetch strip tag");
-		if (dp == NULL)
-			return (0);
-		if( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {
-                    int i;
-                    
-                    for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )
-                    {
-                        lp[i] = dp[i];
-                    }
-		}
-		_TIFFfree((char*) dp);
-
-        } else if( nstrips != (int) dir->tdir_count ) {
-            /* Special case to correct length */
-
-            uint32* dp = (uint32*) _TIFFCheckMalloc(tif,
-		    dir->tdir_count, sizeof (uint32), "to fetch strip tag");
-            if (dp == NULL)
-                return (0);
-
-            status = TIFFFetchLongArray(tif, dir, dp);
-            if( status != 0 ) {
-                int i;
-
-                for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )
-                {
-                    lp[i] = dp[i];
-                }
-            }
-
-            _TIFFfree( (char *) dp );
-	} else
-            status = TIFFFetchLongArray(tif, dir, lp);
-        
-	return (status);
-}
-
-/*
- * Fetch and set the RefBlackWhite tag.
- */
-static int
-TIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)
-{
-	static const char mesg[] = "for \"ReferenceBlackWhite\" array";
-	char* cp;
-	int ok;
-
-	if (dir->tdir_type == TIFF_RATIONAL)
-		return (TIFFFetchNormalTag(tif, dir));
-	/*
-	 * Handle LONG's for backward compatibility.
-	 */
-	cp = (char *)_TIFFCheckMalloc(tif, dir->tdir_count,
-				      sizeof (uint32), mesg);
-	if( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {
-		float* fp = (float*)
-		    _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);
-		if( (ok = (fp != NULL)) != 0 ) {
-			uint32 i;
-			for (i = 0; i < dir->tdir_count; i++)
-				fp[i] = (float)((uint32*) cp)[i];
-			ok = TIFFSetField(tif, dir->tdir_tag, fp);
-			_TIFFfree((char*) fp);
-		}
-	}
-	if (cp)
-		_TIFFfree(cp);
-	return (ok);
-}
-
-/*
- * Fetch and set the SubjectDistance EXIF tag.
- */
-static int
-TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)
-{
-	uint32 l[2];
-	float v;
-	int ok = 0;
-
-    if( dir->tdir_count != 1 || dir->tdir_type != TIFF_RATIONAL )
-    {
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-                       "incorrect count or type for SubjectDistance, tag ignored" );
-		return (0);
-    }
-
-	if (TIFFFetchData(tif, dir, (char *)l)
-	    && cvtRational(tif, dir, l[0], l[1], &v)) {
-		/*
-		 * XXX: Numerator 0xFFFFFFFF means that we have infinite
-		 * distance. Indicate that with a negative floating point
-		 * SubjectDistance value.
-		 */
-		ok = TIFFSetField(tif, dir->tdir_tag,
-				  (l[0] != 0xFFFFFFFF) ? v : -v);
-	}
-
-	return ok;
-}
-
-/*
- * Replace a single strip (tile) of uncompressed data by multiple strips
- * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for
- * dealing with large images or for dealing with machines with a limited
- * amount memory.
- */
-static void
-ChopUpSingleUncompressedStrip(TIFF* tif)
-{
-	register TIFFDirectory *td = &tif->tif_dir;
-	uint32 bytecount = td->td_stripbytecount[0];
-	uint32 offset = td->td_stripoffset[0];
-	tsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;
-	tstrip_t strip, nstrips, rowsperstrip;
-	uint32* newcounts;
-	uint32* newoffsets;
-
-	/*
-	 * Make the rows hold at least one scanline, but fill specified amount
-	 * of data if possible.
-	 */
-	if (rowbytes > STRIP_SIZE_DEFAULT) {
-		stripbytes = rowbytes;
-		rowsperstrip = 1;
-	} else if (rowbytes > 0 ) {
-		rowsperstrip = STRIP_SIZE_DEFAULT / rowbytes;
-		stripbytes = rowbytes * rowsperstrip;
-	}
-        else
-            return;
-
-	/* 
-	 * never increase the number of strips in an image
-	 */
-	if (rowsperstrip >= td->td_rowsperstrip)
-		return;
-	nstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);
-        if( nstrips == 0 ) /* something is wonky, do nothing. */
-            return;
-
-	newcounts = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),
-				"for chopped \"StripByteCounts\" array");
-	newoffsets = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),
-				"for chopped \"StripOffsets\" array");
-	if (newcounts == NULL || newoffsets == NULL) {
-	        /*
-		 * Unable to allocate new strip information, give up and use
-		 * the original one strip information.
-		 */
-		if (newcounts != NULL)
-			_TIFFfree(newcounts);
-		if (newoffsets != NULL)
-			_TIFFfree(newoffsets);
-		return;
-	}
-	/*
-	 * Fill the strip information arrays with new bytecounts and offsets
-	 * that reflect the broken-up format.
-	 */
-	for (strip = 0; strip < nstrips; strip++) {
-		if ((uint32)stripbytes > bytecount)
-			stripbytes = bytecount;
-		newcounts[strip] = stripbytes;
-		newoffsets[strip] = offset;
-		offset += stripbytes;
-		bytecount -= stripbytes;
-	}
-	/*
-	 * Replace old single strip info with multi-strip info.
-	 */
-	td->td_stripsperimage = td->td_nstrips = nstrips;
-	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
-
-	_TIFFfree(td->td_stripbytecount);
-	_TIFFfree(td->td_stripoffset);
-	td->td_stripbytecount = newcounts;
-	td->td_stripoffset = newoffsets;
-	td->td_stripbytecountsorted = 1;
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dirwrite.c b/thirdparty/libtiff/tif_dirwrite.c
deleted file mode 100644
index 8d308c4..0000000
--- a/thirdparty/libtiff/tif_dirwrite.c
+++ /dev/null
@@ -1,1414 +0,0 @@
-/* $Id: tif_dirwrite.c,v 1.37.2.7 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Directory Write Support Routines.
- */
-#include "tiffiop.h"
-
-#ifdef HAVE_IEEEFP
-# define	TIFFCvtNativeToIEEEFloat(tif, n, fp)
-# define	TIFFCvtNativeToIEEEDouble(tif, n, dp)
-#else
-extern	void TIFFCvtNativeToIEEEFloat(TIFF*, uint32, float*);
-extern	void TIFFCvtNativeToIEEEDouble(TIFF*, uint32, double*);
-#endif
-
-static	int TIFFWriteNormalTag(TIFF*, TIFFDirEntry*, const TIFFFieldInfo*);
-static	void TIFFSetupShortLong(TIFF*, ttag_t, TIFFDirEntry*, uint32);
-static	void TIFFSetupShort(TIFF*, ttag_t, TIFFDirEntry*, uint16);
-static	int TIFFSetupShortPair(TIFF*, ttag_t, TIFFDirEntry*);
-static	int TIFFWritePerSampleShorts(TIFF*, ttag_t, TIFFDirEntry*);
-static	int TIFFWritePerSampleAnys(TIFF*, TIFFDataType, ttag_t, TIFFDirEntry*);
-static	int TIFFWriteShortTable(TIFF*, ttag_t, TIFFDirEntry*, uint32, uint16**);
-static	int TIFFWriteShortArray(TIFF*, TIFFDirEntry*, uint16*);
-static	int TIFFWriteLongArray(TIFF *, TIFFDirEntry*, uint32*);
-static	int TIFFWriteRationalArray(TIFF *, TIFFDirEntry*, float*);
-static	int TIFFWriteFloatArray(TIFF *, TIFFDirEntry*, float*);
-static	int TIFFWriteDoubleArray(TIFF *, TIFFDirEntry*, double*);
-static	int TIFFWriteByteArray(TIFF*, TIFFDirEntry*, char*);
-static	int TIFFWriteAnyArray(TIFF*,
-	    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, double*);
-static	int TIFFWriteTransferFunction(TIFF*, TIFFDirEntry*);
-static	int TIFFWriteInkNames(TIFF*, TIFFDirEntry*);
-static	int TIFFWriteData(TIFF*, TIFFDirEntry*, char*);
-static	int TIFFLinkDirectory(TIFF*);
-
-#define	WriteRationalPair(type, tag1, v1, tag2, v2) {		\
-	TIFFWriteRational((tif), (type), (tag1), (dir), (v1))	\
-	TIFFWriteRational((tif), (type), (tag2), (dir)+1, (v2))	\
-	(dir)++;						\
-}
-#define	TIFFWriteRational(tif, type, tag, dir, v)		\
-	(dir)->tdir_tag = (tag);				\
-	(dir)->tdir_type = (type);				\
-	(dir)->tdir_count = 1;					\
-	if (!TIFFWriteRationalArray((tif), (dir), &(v)))	\
-		goto bad;
-
-/*
- * Write the contents of the current directory
- * to the specified file.  This routine doesn't
- * handle overwriting a directory with auxiliary
- * storage that's been changed.
- */
-static int
-_TIFFWriteDirectory(TIFF* tif, int done)
-{
-	uint16 dircount;
-	toff_t diroff;
-	ttag_t tag;
-	uint32 nfields;
-	tsize_t dirsize;
-	char* data;
-	TIFFDirEntry* dir;
-	TIFFDirectory* td;
-	unsigned long b, fields[FIELD_SETLONGS];
-	int fi, nfi;
-
-	if (tif->tif_mode == O_RDONLY)
-		return (1);
-	/*
-	 * Clear write state so that subsequent images with
-	 * different characteristics get the right buffers
-	 * setup for them.
-	 */
-	if (done)
-	{
-		if (tif->tif_flags & TIFF_POSTENCODE) {
-			tif->tif_flags &= ~TIFF_POSTENCODE;
-			if (!(*tif->tif_postencode)(tif)) {
-				TIFFErrorExt(tif->tif_clientdata,
-					     tif->tif_name,
-				"Error post-encoding before directory write");
-				return (0);
-			}
-		}
-		(*tif->tif_close)(tif);		/* shutdown encoder */
-		/*
-		 * Flush any data that might have been written
- 		 * by the compression close+cleanup routines.
-		 */
-		if (tif->tif_rawcc > 0
-                    && (tif->tif_flags & TIFF_BEENWRITING) != 0
-                    && !TIFFFlushData1(tif)) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "Error flushing data before directory write");
-			return (0);
-		}
-		if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {
-			_TIFFfree(tif->tif_rawdata);
-			tif->tif_rawdata = NULL;
-			tif->tif_rawcc = 0;
-			tif->tif_rawdatasize = 0;
-		}
-		tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);
-	}
-
-	td = &tif->tif_dir;
-	/*
-	 * Size the directory so that we can calculate
-	 * offsets for the data items that aren't kept
-	 * in-place in each field.
-	 */
-	nfields = 0;
-	for (b = 0; b <= FIELD_LAST; b++)
-		if (TIFFFieldSet(tif, b) && b != FIELD_CUSTOM)
-			nfields += (b < FIELD_SUBFILETYPE ? 2 : 1);
-	nfields += td->td_customValueCount;
-	dirsize = nfields * sizeof (TIFFDirEntry);
-	data = (char*) _TIFFmalloc(dirsize);
-	if (data == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Cannot write directory, out of space");
-		return (0);
-	}
-	/*
-	 * Directory hasn't been placed yet, put
-	 * it at the end of the file and link it
-	 * into the existing directory structure.
-	 */
-	if (tif->tif_diroff == 0 && !TIFFLinkDirectory(tif))
-		goto bad;
-	tif->tif_dataoff = (toff_t)(
-	    tif->tif_diroff + sizeof (uint16) + dirsize + sizeof (toff_t));
-	if (tif->tif_dataoff & 1)
-		tif->tif_dataoff++;
-	(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);
-	tif->tif_curdir++;
-	dir = (TIFFDirEntry*) data;
-	/*
-	 * Setup external form of directory
-	 * entries and write data items.
-	 */
-	_TIFFmemcpy(fields, td->td_fieldsset, sizeof (fields));
-	/*
-	 * Write out ExtraSamples tag only if
-	 * extra samples are present in the data.
-	 */
-	if (FieldSet(fields, FIELD_EXTRASAMPLES) && !td->td_extrasamples) {
-		ResetFieldBit(fields, FIELD_EXTRASAMPLES);
-		nfields--;
-		dirsize -= sizeof (TIFFDirEntry);
-	}								/*XXX*/
-	for (fi = 0, nfi = tif->tif_nfields; nfi > 0; nfi--, fi++) {
-		const TIFFFieldInfo* fip = tif->tif_fieldinfo[fi];
-
-		/*
-		 * For custom fields, we test to see if the custom field
-		 * is set or not.  For normal fields, we just use the
-		 * FieldSet test.
-		*/
-		if( fip->field_bit == FIELD_CUSTOM )
-		{
-			int ci, is_set = FALSE;
-
-			for( ci = 0; ci < td->td_customValueCount; ci++ )
-				is_set |= (td->td_customValues[ci].info == fip);
-
-			if( !is_set )
-				continue;
-		}
-		else if (!FieldSet(fields, fip->field_bit))
-			continue;
-
-		/*
-		 * Handle other fields.
-		 */
-		switch (fip->field_bit)
-		{
-		case FIELD_STRIPOFFSETS:
-			/*
-			 * We use one field bit for both strip and tile
-
-			 * offsets, and so must be careful in selecting
-			 * the appropriate field descriptor (so that tags
-			 * are written in sorted order).
-			 */
-			tag = isTiled(tif) ?
-			    TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS;
-			if (tag != fip->field_tag)
-				continue;
-			
-			dir->tdir_tag = (uint16) tag;
-			dir->tdir_type = (uint16) TIFF_LONG;
-			dir->tdir_count = (uint32) td->td_nstrips;
-			if (!TIFFWriteLongArray(tif, dir, td->td_stripoffset))
-				goto bad;
-			break;
-		case FIELD_STRIPBYTECOUNTS:
-			/*
-			 * We use one field bit for both strip and tile
-			 * byte counts, and so must be careful in selecting
-			 * the appropriate field descriptor (so that tags
-			 * are written in sorted order).
-			 */
-			tag = isTiled(tif) ?
-			    TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS;
-			if (tag != fip->field_tag)
-				continue;
-			
-			dir->tdir_tag = (uint16) tag;
-			dir->tdir_type = (uint16) TIFF_LONG;
-			dir->tdir_count = (uint32) td->td_nstrips;
-			if (!TIFFWriteLongArray(tif, dir, td->td_stripbytecount))
-				goto bad;
-			break;
-		case FIELD_ROWSPERSTRIP:
-			TIFFSetupShortLong(tif, TIFFTAG_ROWSPERSTRIP,
-			    dir, td->td_rowsperstrip);
-			break;
-		case FIELD_COLORMAP:
-			if (!TIFFWriteShortTable(tif, TIFFTAG_COLORMAP, dir,
-			    3, td->td_colormap))
-				goto bad;
-			break;
-		case FIELD_IMAGEDIMENSIONS:
-			TIFFSetupShortLong(tif, TIFFTAG_IMAGEWIDTH,
-			    dir++, td->td_imagewidth);
-			TIFFSetupShortLong(tif, TIFFTAG_IMAGELENGTH,
-			    dir, td->td_imagelength);
-			break;
-		case FIELD_TILEDIMENSIONS:
-			TIFFSetupShortLong(tif, TIFFTAG_TILEWIDTH,
-			    dir++, td->td_tilewidth);
-			TIFFSetupShortLong(tif, TIFFTAG_TILELENGTH,
-			    dir, td->td_tilelength);
-			break;
-		case FIELD_COMPRESSION:
-			TIFFSetupShort(tif, TIFFTAG_COMPRESSION,
-			    dir, td->td_compression);
-			break;
-		case FIELD_PHOTOMETRIC:
-			TIFFSetupShort(tif, TIFFTAG_PHOTOMETRIC,
-			    dir, td->td_photometric);
-			break;
-		case FIELD_POSITION:
-			WriteRationalPair(TIFF_RATIONAL,
-			    TIFFTAG_XPOSITION, td->td_xposition,
-			    TIFFTAG_YPOSITION, td->td_yposition);
-			break;
-		case FIELD_RESOLUTION:
-			WriteRationalPair(TIFF_RATIONAL,
-			    TIFFTAG_XRESOLUTION, td->td_xresolution,
-			    TIFFTAG_YRESOLUTION, td->td_yresolution);
-			break;
-		case FIELD_BITSPERSAMPLE:
-		case FIELD_MINSAMPLEVALUE:
-		case FIELD_MAXSAMPLEVALUE:
-		case FIELD_SAMPLEFORMAT:
-			if (!TIFFWritePerSampleShorts(tif, fip->field_tag, dir))
-				goto bad;
-			break;
-		case FIELD_SMINSAMPLEVALUE:
-		case FIELD_SMAXSAMPLEVALUE:
-			if (!TIFFWritePerSampleAnys(tif,
-			    _TIFFSampleToTagType(tif), fip->field_tag, dir))
-				goto bad;
-			break;
-		case FIELD_PAGENUMBER:
-		case FIELD_HALFTONEHINTS:
-		case FIELD_YCBCRSUBSAMPLING:
-			if (!TIFFSetupShortPair(tif, fip->field_tag, dir))
-				goto bad;
-			break;
-		case FIELD_INKNAMES:
-			if (!TIFFWriteInkNames(tif, dir))
-				goto bad;
-			break;
-		case FIELD_TRANSFERFUNCTION:
-			if (!TIFFWriteTransferFunction(tif, dir))
-				goto bad;
-			break;
-		case FIELD_SUBIFD:
-			/*
-			 * XXX: Always write this field using LONG type
-			 * for backward compatibility.
-			 */
-			dir->tdir_tag = (uint16) fip->field_tag;
-			dir->tdir_type = (uint16) TIFF_LONG;
-			dir->tdir_count = (uint32) td->td_nsubifd;
-			if (!TIFFWriteLongArray(tif, dir, td->td_subifd))
-				goto bad;
-			/*
-			 * Total hack: if this directory includes a SubIFD
-			 * tag then force the next <n> directories to be
-			 * written as ``sub directories'' of this one.  This
-			 * is used to write things like thumbnails and
-			 * image masks that one wants to keep out of the
-			 * normal directory linkage access mechanism.
-			 */
-			if (dir->tdir_count > 0) {
-				tif->tif_flags |= TIFF_INSUBIFD;
-				tif->tif_nsubifd = (uint16) dir->tdir_count;
-				if (dir->tdir_count > 1)
-					tif->tif_subifdoff = dir->tdir_offset;
-				else
-					tif->tif_subifdoff = (uint32)(
-					      tif->tif_diroff
-					    + sizeof (uint16)
-					    + ((char*)&dir->tdir_offset-data));
-			}
-			break;
-		default:
-			/* XXX: Should be fixed and removed. */
-			if (fip->field_tag == TIFFTAG_DOTRANGE) {
-				if (!TIFFSetupShortPair(tif, fip->field_tag, dir))
-					goto bad;
-			}
-			else if (!TIFFWriteNormalTag(tif, dir, fip))
-				goto bad;
-			break;
-		}
-		dir++;
-                
-		if( fip->field_bit != FIELD_CUSTOM )
-			ResetFieldBit(fields, fip->field_bit);
-	}
-
-	/*
-	 * Write directory.
-	 */
-	dircount = (uint16) nfields;
-	diroff = (uint32) tif->tif_nextdiroff;
-	if (tif->tif_flags & TIFF_SWAB) {
-		/*
-		 * The file's byte order is opposite to the
-		 * native machine architecture.  We overwrite
-		 * the directory information with impunity
-		 * because it'll be released below after we
-		 * write it to the file.  Note that all the
-		 * other tag construction routines assume that
-		 * we do this byte-swapping; i.e. they only
-		 * byte-swap indirect data.
-		 */
-		for (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) {
-			TIFFSwabArrayOfShort(&dir->tdir_tag, 2);
-			TIFFSwabArrayOfLong(&dir->tdir_count, 2);
-		}
-		dircount = (uint16) nfields;
-		TIFFSwabShort(&dircount);
-		TIFFSwabLong(&diroff);
-	}
-	(void) TIFFSeekFile(tif, tif->tif_diroff, SEEK_SET);
-	if (!WriteOK(tif, &dircount, sizeof (dircount))) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory count");
-		goto bad;
-	}
-	if (!WriteOK(tif, data, dirsize)) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory contents");
-		goto bad;
-	}
-	if (!WriteOK(tif, &diroff, sizeof (uint32))) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory link");
-		goto bad;
-	}
-	if (done) {
-		TIFFFreeDirectory(tif);
-		tif->tif_flags &= ~TIFF_DIRTYDIRECT;
-		(*tif->tif_cleanup)(tif);
-
-		/*
-		* Reset directory-related state for subsequent
-		* directories.
-		*/
-		TIFFCreateDirectory(tif);
-	}
-	_TIFFfree(data);
-	return (1);
-bad:
-	_TIFFfree(data);
-	return (0);
-}
-#undef WriteRationalPair
-
-int
-TIFFWriteDirectory(TIFF* tif)
-{
-	return _TIFFWriteDirectory(tif, TRUE);
-}
-
-/*
- * Similar to TIFFWriteDirectory(), writes the directory out
- * but leaves all data structures in memory so that it can be
- * written again.  This will make a partially written TIFF file
- * readable before it is successfully completed/closed.
- */ 
-int
-TIFFCheckpointDirectory(TIFF* tif)
-{
-	int rc;
-	/* Setup the strips arrays, if they haven't already been. */
-	if (tif->tif_dir.td_stripoffset == NULL)
-	    (void) TIFFSetupStrips(tif);
-	rc = _TIFFWriteDirectory(tif, FALSE);
-	(void) TIFFSetWriteOffset(tif, TIFFSeekFile(tif, 0, SEEK_END));
-	return rc;
-}
-
-static int
-_TIFFWriteCustomDirectory(TIFF* tif, toff_t *pdiroff)
-{
-	uint16 dircount;
-	uint32 nfields;
-	tsize_t dirsize;
-	char* data;
-	TIFFDirEntry* dir;
-	TIFFDirectory* td;
-	unsigned long b, fields[FIELD_SETLONGS];
-	int fi, nfi;
-
-	if (tif->tif_mode == O_RDONLY)
-		return (1);
-
-	td = &tif->tif_dir;
-	/*
-	 * Size the directory so that we can calculate
-	 * offsets for the data items that aren't kept
-	 * in-place in each field.
-	 */
-	nfields = 0;
-	for (b = 0; b <= FIELD_LAST; b++)
-		if (TIFFFieldSet(tif, b) && b != FIELD_CUSTOM)
-			nfields += (b < FIELD_SUBFILETYPE ? 2 : 1);
-	nfields += td->td_customValueCount;
-	dirsize = nfields * sizeof (TIFFDirEntry);
-	data = (char*) _TIFFmalloc(dirsize);
-	if (data == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Cannot write directory, out of space");
-		return (0);
-	}
-	/*
-	 * Put the directory  at the end of the file.
-	 */
-	tif->tif_diroff = (TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;
-	tif->tif_dataoff = (toff_t)(
-	    tif->tif_diroff + sizeof (uint16) + dirsize + sizeof (toff_t));
-	if (tif->tif_dataoff & 1)
-		tif->tif_dataoff++;
-	(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);
-	dir = (TIFFDirEntry*) data;
-	/*
-	 * Setup external form of directory
-	 * entries and write data items.
-	 */
-	_TIFFmemcpy(fields, td->td_fieldsset, sizeof (fields));
-
-	for (fi = 0, nfi = tif->tif_nfields; nfi > 0; nfi--, fi++) {
-		const TIFFFieldInfo* fip = tif->tif_fieldinfo[fi];
-
-		/*
-		 * For custom fields, we test to see if the custom field
-		 * is set or not.  For normal fields, we just use the
-		 * FieldSet test.
-		*/
-		if( fip->field_bit == FIELD_CUSTOM )
-		{
-			int ci, is_set = FALSE;
-
-			for( ci = 0; ci < td->td_customValueCount; ci++ )
-				is_set |= (td->td_customValues[ci].info == fip);
-
-			if( !is_set )
-				continue;
-		}
-		else if (!FieldSet(fields, fip->field_bit))
-			continue;
-                
-		if( fip->field_bit != FIELD_CUSTOM )
-			ResetFieldBit(fields, fip->field_bit);
-	}
-
-	/*
-	 * Write directory.
-	 */
-	dircount = (uint16) nfields;
-	*pdiroff = (uint32) tif->tif_nextdiroff;
-	if (tif->tif_flags & TIFF_SWAB) {
-		/*
-		 * The file's byte order is opposite to the
-		 * native machine architecture.  We overwrite
-		 * the directory information with impunity
-		 * because it'll be released below after we
-		 * write it to the file.  Note that all the
-		 * other tag construction routines assume that
-		 * we do this byte-swapping; i.e. they only
-		 * byte-swap indirect data.
-		 */
-		for (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) {
-			TIFFSwabArrayOfShort(&dir->tdir_tag, 2);
-			TIFFSwabArrayOfLong(&dir->tdir_count, 2);
-		}
-		dircount = (uint16) nfields;
-		TIFFSwabShort(&dircount);
-		TIFFSwabLong(pdiroff);
-	}
-	(void) TIFFSeekFile(tif, tif->tif_diroff, SEEK_SET);
-	if (!WriteOK(tif, &dircount, sizeof (dircount))) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory count");
-		goto bad;
-	}
-	if (!WriteOK(tif, data, dirsize)) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory contents");
-		goto bad;
-	}
-	if (!WriteOK(tif, pdiroff, sizeof (uint32))) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Error writing directory link");
-		goto bad;
-	}
-	_TIFFfree(data);
-	return (1);
-bad:
-	_TIFFfree(data);
-	return (0);
-}
-
-int
-TIFFWriteCustomDirectory(TIFF* tif, toff_t *pdiroff)
-{
-	return _TIFFWriteCustomDirectory(tif, pdiroff);
-}
-
-/*
- * Process tags that are not special cased.
- */
-static int
-TIFFWriteNormalTag(TIFF* tif, TIFFDirEntry* dir, const TIFFFieldInfo* fip)
-{
-	uint16 wc = (uint16) fip->field_writecount;
-	uint32 wc2;
-
-	dir->tdir_tag = (uint16) fip->field_tag;
-	dir->tdir_type = (uint16) fip->field_type;
-	dir->tdir_count = wc;
-	
-	switch (fip->field_type) {
-	case TIFF_SHORT:
-	case TIFF_SSHORT:
-		if (fip->field_passcount) {
-			uint16* wp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &wp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &wp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteShortArray(tif, dir, wp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				uint16 sv;
-				TIFFGetField(tif, fip->field_tag, &sv);
-				dir->tdir_offset =
-					TIFFInsertData(tif, dir->tdir_type, sv);
-			} else {
-				uint16* wp;
-				TIFFGetField(tif, fip->field_tag, &wp);
-				if (!TIFFWriteShortArray(tif, dir, wp))
-					return 0;
-			}
-		}
-		break;
-	case TIFF_LONG:
-	case TIFF_SLONG:
-	case TIFF_IFD:
-		if (fip->field_passcount) {
-			uint32* lp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &lp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &lp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteLongArray(tif, dir, lp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				/* XXX handle LONG->SHORT conversion */
-				TIFFGetField(tif, fip->field_tag,
-					     &dir->tdir_offset);
-			} else {
-				uint32* lp;
-				TIFFGetField(tif, fip->field_tag, &lp);
-				if (!TIFFWriteLongArray(tif, dir, lp))
-					return 0;
-			}
-		}
-		break;
-	case TIFF_RATIONAL:
-	case TIFF_SRATIONAL:
-		if (fip->field_passcount) {
-			float* fp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &fp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &fp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteRationalArray(tif, dir, fp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				float fv;
-				TIFFGetField(tif, fip->field_tag, &fv);
-				if (!TIFFWriteRationalArray(tif, dir, &fv))
-					return 0;
-			} else {
-				float* fp;
-				TIFFGetField(tif, fip->field_tag, &fp);
-				if (!TIFFWriteRationalArray(tif, dir, fp))
-					return 0;
-			}
-		}
-		break;
-	case TIFF_FLOAT:
-		if (fip->field_passcount) {
-			float* fp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &fp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &fp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteFloatArray(tif, dir, fp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				float fv;
-				TIFFGetField(tif, fip->field_tag, &fv);
-				if (!TIFFWriteFloatArray(tif, dir, &fv))
-					return 0;
-			} else {
-				float* fp;
-				TIFFGetField(tif, fip->field_tag, &fp);
-				if (!TIFFWriteFloatArray(tif, dir, fp))
-					return 0;
-			}
-		}
-		break;
-	case TIFF_DOUBLE:
-		if (fip->field_passcount) {
-			double* dp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &dp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &dp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteDoubleArray(tif, dir, dp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				double dv;
-				TIFFGetField(tif, fip->field_tag, &dv);
-				if (!TIFFWriteDoubleArray(tif, dir, &dv))
-					return 0;
-			} else {
-				double* dp;
-				TIFFGetField(tif, fip->field_tag, &dp);
-				if (!TIFFWriteDoubleArray(tif, dir, dp))
-					return 0;
-			}
-		}
-		break;
-	case TIFF_ASCII:
-		{ 
-                    char* cp;
-                    if (fip->field_passcount)
-                    {
-                        if( wc == (uint16) TIFF_VARIABLE2 )
-                            TIFFGetField(tif, fip->field_tag, &wc2, &cp);
-                        else
-                            TIFFGetField(tif, fip->field_tag, &wc, &cp);
-                    }
-                    else
-                        TIFFGetField(tif, fip->field_tag, &cp);
-
-                    dir->tdir_count = (uint32) (strlen(cp) + 1);
-                    if (!TIFFWriteByteArray(tif, dir, cp))
-                        return (0);
-		}
-		break;
-
-        case TIFF_BYTE:
-        case TIFF_SBYTE:          
-		if (fip->field_passcount) {
-			char* cp;
-			if (wc == (uint16) TIFF_VARIABLE2) {
-				TIFFGetField(tif, fip->field_tag, &wc2, &cp);
-				dir->tdir_count = wc2;
-			} else {	/* Assume TIFF_VARIABLE */
-				TIFFGetField(tif, fip->field_tag, &wc, &cp);
-				dir->tdir_count = wc;
-			}
-			if (!TIFFWriteByteArray(tif, dir, cp))
-				return 0;
-		} else {
-			if (wc == 1) {
-				char cv;
-				TIFFGetField(tif, fip->field_tag, &cv);
-				if (!TIFFWriteByteArray(tif, dir, &cv))
-					return 0;
-			} else {
-				char* cp;
-				TIFFGetField(tif, fip->field_tag, &cp);
-				if (!TIFFWriteByteArray(tif, dir, cp))
-					return 0;
-			}
-		}
-                break;
-
-	case TIFF_UNDEFINED:
-		{ char* cp;
-		  if (wc == (unsigned short) TIFF_VARIABLE) {
-			TIFFGetField(tif, fip->field_tag, &wc, &cp);
-			dir->tdir_count = wc;
-		  } else if (wc == (unsigned short) TIFF_VARIABLE2) {
-			TIFFGetField(tif, fip->field_tag, &wc2, &cp);
-			dir->tdir_count = wc2;
-		  } else 
-			TIFFGetField(tif, fip->field_tag, &cp);
-		  if (!TIFFWriteByteArray(tif, dir, cp))
-			return (0);
-		}
-		break;
-
-        case TIFF_NOTYPE:
-                break;
-	}
-	return (1);
-}
-
-/*
- * Setup a directory entry with either a SHORT
- * or LONG type according to the value.
- */
-static void
-TIFFSetupShortLong(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint32 v)
-{
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_count = 1;
-	if (v > 0xffffL) {
-		dir->tdir_type = (short) TIFF_LONG;
-		dir->tdir_offset = v;
-	} else {
-		dir->tdir_type = (short) TIFF_SHORT;
-		dir->tdir_offset = TIFFInsertData(tif, (int) TIFF_SHORT, v);
-	}
-}
-
-/*
- * Setup a SHORT directory entry
- */
-static void
-TIFFSetupShort(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint16 v)
-{
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_count = 1;
-	dir->tdir_type = (short) TIFF_SHORT;
-	dir->tdir_offset = TIFFInsertData(tif, (int) TIFF_SHORT, v);
-}
-#undef MakeShortDirent
-
-#define	NITEMS(x)	(sizeof (x) / sizeof (x[0]))
-/*
- * Setup a directory entry that references a
- * samples/pixel array of SHORT values and
- * (potentially) write the associated indirect
- * values.
- */
-static int
-TIFFWritePerSampleShorts(TIFF* tif, ttag_t tag, TIFFDirEntry* dir)
-{
-	uint16 buf[10], v;
-	uint16* w = buf;
-	uint16 i, samples = tif->tif_dir.td_samplesperpixel;
-	int status;
-
-	if (samples > NITEMS(buf)) {
-		w = (uint16*) _TIFFmalloc(samples * sizeof (uint16));
-		if (w == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "No space to write per-sample shorts");
-			return (0);
-		}
-	}
-	TIFFGetField(tif, tag, &v);
-	for (i = 0; i < samples; i++)
-		w[i] = v;
-	
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_type = (uint16) TIFF_SHORT;
-	dir->tdir_count = samples;
-	status = TIFFWriteShortArray(tif, dir, w);
-	if (w != buf)
-		_TIFFfree((char*) w);
-	return (status);
-}
-
-/*
- * Setup a directory entry that references a samples/pixel array of ``type''
- * values and (potentially) write the associated indirect values.  The source
- * data from TIFFGetField() for the specified tag must be returned as double.
- */
-static int
-TIFFWritePerSampleAnys(TIFF* tif,
-    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir)
-{
-	double buf[10], v;
-	double* w = buf;
-	uint16 i, samples = tif->tif_dir.td_samplesperpixel;
-	int status;
-
-	if (samples > NITEMS(buf)) {
-		w = (double*) _TIFFmalloc(samples * sizeof (double));
-		if (w == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "No space to write per-sample values");
-			return (0);
-		}
-	}
-	TIFFGetField(tif, tag, &v);
-	for (i = 0; i < samples; i++)
-		w[i] = v;
-	status = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);
-	if (w != buf)
-		_TIFFfree(w);
-	return (status);
-}
-#undef NITEMS
-
-/*
- * Setup a pair of shorts that are returned by
- * value, rather than as a reference to an array.
- */
-static int
-TIFFSetupShortPair(TIFF* tif, ttag_t tag, TIFFDirEntry* dir)
-{
-	uint16 v[2];
-
-	TIFFGetField(tif, tag, &v[0], &v[1]);
-
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_type = (uint16) TIFF_SHORT;
-	dir->tdir_count = 2;
-	return (TIFFWriteShortArray(tif, dir, v));
-}
-
-/*
- * Setup a directory entry for an NxM table of shorts,
- * where M is known to be 2**bitspersample, and write
- * the associated indirect data.
- */
-static int
-TIFFWriteShortTable(TIFF* tif,
-    ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16** table)
-{
-	uint32 i, off;
-
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_type = (short) TIFF_SHORT;
-	/* XXX -- yech, fool TIFFWriteData */
-	dir->tdir_count = (uint32) (1L<<tif->tif_dir.td_bitspersample);
-	off = tif->tif_dataoff;
-	for (i = 0; i < n; i++)
-		if (!TIFFWriteData(tif, dir, (char *)table[i]))
-			return (0);
-	dir->tdir_count *= n;
-	dir->tdir_offset = off;
-	return (1);
-}
-
-/*
- * Write/copy data associated with an ASCII or opaque tag value.
- */
-static int
-TIFFWriteByteArray(TIFF* tif, TIFFDirEntry* dir, char* cp)
-{
-	if (dir->tdir_count <= 4) {
-		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
-			dir->tdir_offset = (uint32)cp[0] << 24;
-			if (dir->tdir_count >= 2)
-				dir->tdir_offset |= (uint32)cp[1] << 16;
-			if (dir->tdir_count >= 3)
-				dir->tdir_offset |= (uint32)cp[2] << 8;
-			if (dir->tdir_count == 4)
-				dir->tdir_offset |= cp[3];
-		} else {
-			dir->tdir_offset = cp[0];
-			if (dir->tdir_count >= 2)
-				dir->tdir_offset |= (uint32) cp[1] << 8;
-			if (dir->tdir_count >= 3)
-				dir->tdir_offset |= (uint32) cp[2] << 16;
-			if (dir->tdir_count == 4)
-				dir->tdir_offset |= (uint32) cp[3] << 24;
-		}
-		return 1;
-	} else
-		return TIFFWriteData(tif, dir, cp);
-}
-
-/*
- * Setup a directory entry of an array of SHORT
- * or SSHORT and write the associated indirect values.
- */
-static int
-TIFFWriteShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)
-{
-	if (dir->tdir_count <= 2) {
-		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
-			dir->tdir_offset = (uint32) v[0] << 16;
-			if (dir->tdir_count == 2)
-				dir->tdir_offset |= v[1] & 0xffff;
-		} else {
-			dir->tdir_offset = v[0] & 0xffff;
-			if (dir->tdir_count == 2)
-				dir->tdir_offset |= (uint32) v[1] << 16;
-		}
-		return (1);
-	} else
-		return (TIFFWriteData(tif, dir, (char*) v));
-}
-
-/*
- * Setup a directory entry of an array of LONG
- * or SLONG and write the associated indirect values.
- */
-static int
-TIFFWriteLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)
-{
-	if (dir->tdir_count == 1) {
-		dir->tdir_offset = v[0];
-		return (1);
-	} else
-		return (TIFFWriteData(tif, dir, (char*) v));
-}
-
-/*
- * Setup a directory entry of an array of RATIONAL
- * or SRATIONAL and write the associated indirect values.
- */
-static int
-TIFFWriteRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)
-{
-	uint32 i;
-	uint32* t;
-	int status;
-
-	t = (uint32*) _TIFFmalloc(2 * dir->tdir_count * sizeof (uint32));
-	if (t == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "No space to write RATIONAL array");
-		return (0);
-	}
-	for (i = 0; i < dir->tdir_count; i++) {
-		float fv = v[i];
-		int sign = 1;
-		uint32 den;
-
-		if (fv < 0) {
-			if (dir->tdir_type == TIFF_RATIONAL) {
-				TIFFWarningExt(tif->tif_clientdata,
-					       tif->tif_name,
-	"\"%s\": Information lost writing value (%g) as (unsigned) RATIONAL",
-				_TIFFFieldWithTag(tif,dir->tdir_tag)->field_name,
-						fv);
-				fv = 0;
-			} else
-				fv = -fv, sign = -1;
-		}
-		den = 1L;
-		if (fv > 0) {
-			while (fv < 1L<<(31-3) && den < 1L<<(31-3))
-				fv *= 1<<3, den *= 1L<<3;
-		}
-		t[2*i+0] = (uint32) (sign * (fv + 0.5));
-		t[2*i+1] = den;
-	}
-	status = TIFFWriteData(tif, dir, (char *)t);
-	_TIFFfree((char*) t);
-	return (status);
-}
-
-static int
-TIFFWriteFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)
-{
-	TIFFCvtNativeToIEEEFloat(tif, dir->tdir_count, v);
-	if (dir->tdir_count == 1) {
-		dir->tdir_offset = *(uint32*) &v[0];
-		return (1);
-	} else
-		return (TIFFWriteData(tif, dir, (char*) v));
-}
-
-static int
-TIFFWriteDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)
-{
-	TIFFCvtNativeToIEEEDouble(tif, dir->tdir_count, v);
-	return (TIFFWriteData(tif, dir, (char*) v));
-}
-
-/*
- * Write an array of ``type'' values for a specified tag (i.e. this is a tag
- * which is allowed to have different types, e.g. SMaxSampleType).
- * Internally the data values are represented as double since a double can
- * hold any of the TIFF tag types (yes, this should really be an abstract
- * type tany_t for portability).  The data is converted into the specified
- * type in a temporary buffer and then handed off to the appropriate array
- * writer.
- */
-static int
-TIFFWriteAnyArray(TIFF* tif,
-    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v)
-{
-	char buf[10 * sizeof(double)];
-	char* w = buf;
-	int i, status = 0;
-
-	if (n * TIFFDataWidth(type) > sizeof buf) {
-		w = (char*) _TIFFmalloc(n * TIFFDataWidth(type));
-		if (w == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				     "No space to write array");
-			return (0);
-		}
-	}
-
-	dir->tdir_tag = (uint16) tag;
-	dir->tdir_type = (uint16) type;
-	dir->tdir_count = n;
-
-	switch (type) {
-	case TIFF_BYTE:
-		{ 
-			uint8* bp = (uint8*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (uint8) v[i];
-			if (!TIFFWriteByteArray(tif, dir, (char*) bp))
-				goto out;
-		}
-		break;
-	case TIFF_SBYTE:
-		{ 
-			int8* bp = (int8*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (int8) v[i];
-			if (!TIFFWriteByteArray(tif, dir, (char*) bp))
-				goto out;
-		}
-		break;
-	case TIFF_SHORT:
-		{
-			uint16* bp = (uint16*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (uint16) v[i];
-			if (!TIFFWriteShortArray(tif, dir, (uint16*)bp))
-				goto out;
-		}
-		break;
-	case TIFF_SSHORT:
-		{ 
-			int16* bp = (int16*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (int16) v[i];
-			if (!TIFFWriteShortArray(tif, dir, (uint16*)bp))
-				goto out;
-		}
-		break;
-	case TIFF_LONG:
-		{
-			uint32* bp = (uint32*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (uint32) v[i];
-			if (!TIFFWriteLongArray(tif, dir, bp))
-				goto out;
-		}
-		break;
-	case TIFF_SLONG:
-		{
-			int32* bp = (int32*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (int32) v[i];
-			if (!TIFFWriteLongArray(tif, dir, (uint32*) bp))
-				goto out;
-		}
-		break;
-	case TIFF_FLOAT:
-		{ 
-			float* bp = (float*) w;
-			for (i = 0; i < (int) n; i++)
-				bp[i] = (float) v[i];
-			if (!TIFFWriteFloatArray(tif, dir, bp))
-				goto out;
-		}
-		break;
-	case TIFF_DOUBLE:
-                {
-                    if( !TIFFWriteDoubleArray(tif, dir, v))
-                        goto out;
-                }
-		break;
-	default:
-		/* TIFF_NOTYPE */
-		/* TIFF_ASCII */
-		/* TIFF_UNDEFINED */
-		/* TIFF_RATIONAL */
-		/* TIFF_SRATIONAL */
-		goto out;
-	}
-	status = 1;
- out:
-	if (w != buf)
-		_TIFFfree(w);
-	return (status);
-}
-
-static int
-TIFFWriteTransferFunction(TIFF* tif, TIFFDirEntry* dir)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	tsize_t n = (1L<<td->td_bitspersample) * sizeof (uint16);
-	uint16** tf = td->td_transferfunction;
-	int ncols;
-
-	/*
-	 * Check if the table can be written as a single column,
-	 * or if it must be written as 3 columns.  Note that we
-	 * write a 3-column tag if there are 2 samples/pixel and
-	 * a single column of data won't suffice--hmm.
-	 */
-	switch (td->td_samplesperpixel - td->td_extrasamples) {
-	default:	if (_TIFFmemcmp(tf[0], tf[2], n)) { ncols = 3; break; }
-	case 2:		if (_TIFFmemcmp(tf[0], tf[1], n)) { ncols = 3; break; }
-	case 1: case 0:	ncols = 1;
-	}
-	return (TIFFWriteShortTable(tif,
-	    TIFFTAG_TRANSFERFUNCTION, dir, ncols, tf));
-}
-
-static int
-TIFFWriteInkNames(TIFF* tif, TIFFDirEntry* dir)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-
-	dir->tdir_tag = TIFFTAG_INKNAMES;
-	dir->tdir_type = (short) TIFF_ASCII;
-	dir->tdir_count = td->td_inknameslen;
-	return (TIFFWriteByteArray(tif, dir, td->td_inknames));
-}
-
-/*
- * Write a contiguous directory item.
- */
-static int
-TIFFWriteData(TIFF* tif, TIFFDirEntry* dir, char* cp)
-{
-	tsize_t cc;
-
-	if (tif->tif_flags & TIFF_SWAB) {
-		switch (dir->tdir_type) {
-		case TIFF_SHORT:
-		case TIFF_SSHORT:
-			TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);
-			break;
-		case TIFF_LONG:
-		case TIFF_SLONG:
-		case TIFF_FLOAT:
-			TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);
-			break;
-		case TIFF_RATIONAL:
-		case TIFF_SRATIONAL:
-			TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);
-			break;
-		case TIFF_DOUBLE:
-			TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);
-			break;
-		}
-	}
-	dir->tdir_offset = tif->tif_dataoff;
-	cc = dir->tdir_count * TIFFDataWidth((TIFFDataType) dir->tdir_type);
-	if (SeekOK(tif, dir->tdir_offset) &&
-	    WriteOK(tif, cp, cc)) {
-		tif->tif_dataoff += (cc + 1) & ~1;
-		return (1);
-	}
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		     "Error writing data for field \"%s\"",
-	_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-	return (0);
-}
-
-/*
- * Similar to TIFFWriteDirectory(), but if the directory has already
- * been written once, it is relocated to the end of the file, in case it
- * has changed in size.  Note that this will result in the loss of the 
- * previously used directory space. 
- */ 
-
-int 
-TIFFRewriteDirectory( TIFF *tif )
-{
-    static const char module[] = "TIFFRewriteDirectory";
-
-    /* We don't need to do anything special if it hasn't been written. */
-    if( tif->tif_diroff == 0 )
-        return TIFFWriteDirectory( tif );
-
-    /*
-    ** Find and zero the pointer to this directory, so that TIFFLinkDirectory
-    ** will cause it to be added after this directories current pre-link.
-    */
-    
-    /* Is it the first directory in the file? */
-    if (tif->tif_header.tiff_diroff == tif->tif_diroff) 
-    {
-        tif->tif_header.tiff_diroff = 0;
-        tif->tif_diroff = 0;
-
-        TIFFSeekFile(tif, (toff_t)(TIFF_MAGIC_SIZE+TIFF_VERSION_SIZE),
-		     SEEK_SET);
-        if (!WriteOK(tif, &(tif->tif_header.tiff_diroff), 
-                     sizeof (tif->tif_diroff))) 
-        {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				     "Error updating TIFF header");
-            return (0);
-        }
-    }
-    else
-    {
-        toff_t  nextdir, off;
-
-	nextdir = tif->tif_header.tiff_diroff;
-	do {
-		uint16 dircount;
-
-		if (!SeekOK(tif, nextdir) ||
-		    !ReadOK(tif, &dircount, sizeof (dircount))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "Error fetching directory count");
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		(void) TIFFSeekFile(tif,
-		    dircount * sizeof (TIFFDirEntry), SEEK_CUR);
-		if (!ReadOK(tif, &nextdir, sizeof (nextdir))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "Error fetching directory link");
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabLong(&nextdir);
-	} while (nextdir != tif->tif_diroff && nextdir != 0);
-        off = TIFFSeekFile(tif, 0, SEEK_CUR); /* get current offset */
-        (void) TIFFSeekFile(tif, off - (toff_t)sizeof(nextdir), SEEK_SET);
-        tif->tif_diroff = 0;
-	if (!WriteOK(tif, &(tif->tif_diroff), sizeof (nextdir))) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Error writing directory link");
-		return (0);
-	}
-    }
-
-    /*
-    ** Now use TIFFWriteDirectory() normally.
-    */
-
-    return TIFFWriteDirectory( tif );
-}
-
-
-/*
- * Link the current directory into the directory chain for the file.
- */
-static int
-TIFFLinkDirectory(TIFF* tif)
-{
-	static const char module[] = "TIFFLinkDirectory";
-	toff_t nextdir;
-	toff_t diroff, off;
-
-	tif->tif_diroff = (TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;
-	diroff = tif->tif_diroff;
-	if (tif->tif_flags & TIFF_SWAB)
-		TIFFSwabLong(&diroff);
-
-	/*
-	 * Handle SubIFDs
-	 */
-        if (tif->tif_flags & TIFF_INSUBIFD) {
-		(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);
-		if (!WriteOK(tif, &diroff, sizeof (diroff))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "%s: Error writing SubIFD directory link",
-				     tif->tif_name);
-			return (0);
-		}
-		/*
-		 * Advance to the next SubIFD or, if this is
-		 * the last one configured, revert back to the
-		 * normal directory linkage.
-		 */
-		if (--tif->tif_nsubifd)
-			tif->tif_subifdoff += sizeof (diroff);
-		else
-			tif->tif_flags &= ~TIFF_INSUBIFD;
-		return (1);
-	}
-
-	if (tif->tif_header.tiff_diroff == 0) {
-		/*
-		 * First directory, overwrite offset in header.
-		 */
-		tif->tif_header.tiff_diroff = tif->tif_diroff;
-		(void) TIFFSeekFile(tif,
-				    (toff_t)(TIFF_MAGIC_SIZE+TIFF_VERSION_SIZE),
-                                    SEEK_SET);
-		if (!WriteOK(tif, &diroff, sizeof (diroff))) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				     "Error writing TIFF header");
-			return (0);
-		}
-		return (1);
-	}
-	/*
-	 * Not the first directory, search to the last and append.
-	 */
-	nextdir = tif->tif_header.tiff_diroff;
-	do {
-		uint16 dircount;
-
-		if (!SeekOK(tif, nextdir) ||
-		    !ReadOK(tif, &dircount, sizeof (dircount))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "Error fetching directory count");
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&dircount);
-		(void) TIFFSeekFile(tif,
-		    dircount * sizeof (TIFFDirEntry), SEEK_CUR);
-		if (!ReadOK(tif, &nextdir, sizeof (nextdir))) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "Error fetching directory link");
-			return (0);
-		}
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabLong(&nextdir);
-	} while (nextdir != 0);
-        off = TIFFSeekFile(tif, 0, SEEK_CUR); /* get current offset */
-        (void) TIFFSeekFile(tif, off - (toff_t)sizeof(nextdir), SEEK_SET);
-	if (!WriteOK(tif, &diroff, sizeof (diroff))) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Error writing directory link");
-		return (0);
-	}
-	return (1);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_dumpmode.c b/thirdparty/libtiff/tif_dumpmode.c
deleted file mode 100644
index da86150..0000000
--- a/thirdparty/libtiff/tif_dumpmode.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_dumpmode.c,v 1.5.2.2 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * "Null" Compression Algorithm Support.
- */
-#include "tiffiop.h"
-
-/*
- * Encode a hunk of pixels.
- */
-static int
-DumpModeEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-	(void) s;
-	while (cc > 0) {
-		tsize_t n;
-
-		n = cc;
-		if (tif->tif_rawcc + n > tif->tif_rawdatasize)
-			n = tif->tif_rawdatasize - tif->tif_rawcc;
-
-		assert( n > 0 );
-                
-		/*
-		 * Avoid copy if client has setup raw
-		 * data buffer to avoid extra copy.
-		 */
-		if (tif->tif_rawcp != pp)
-			_TIFFmemcpy(tif->tif_rawcp, pp, n);
-		tif->tif_rawcp += n;
-		tif->tif_rawcc += n;
-		pp += n;
-		cc -= n;
-		if (tif->tif_rawcc >= tif->tif_rawdatasize &&
-		    !TIFFFlushData1(tif))
-			return (-1);
-	}
-	return (1);
-}
-
-/*
- * Decode a hunk of pixels.
- */
-static int
-DumpModeDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	(void) s;
-/*         fprintf(stderr,"DumpModeDecode: scanline %ld, expected %ld bytes, got %ld bytes\n", */
-/*                 (long) tif->tif_row, (long) tif->tif_rawcc, (long) cc); */
-	if (tif->tif_rawcc < cc) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "DumpModeDecode: Not enough data for scanline %d",
-		    tif->tif_row);
-		return (0);
-	}
-	/*
-	 * Avoid copy if client has setup raw
-	 * data buffer to avoid extra copy.
-	 */
-	if (tif->tif_rawcp != buf)
-		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
-	tif->tif_rawcp += cc;
-	tif->tif_rawcc -= cc;
-	return (1);
-}
-
-/*
- * Seek forwards nrows in the current strip.
- */
-static int
-DumpModeSeek(TIFF* tif, uint32 nrows)
-{
-	tif->tif_rawcp += nrows * tif->tif_scanlinesize;
-	tif->tif_rawcc -= nrows * tif->tif_scanlinesize;
-	return (1);
-}
-
-/*
- * Initialize dump mode.
- */
-int
-TIFFInitDumpMode(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	tif->tif_decoderow = DumpModeDecode;
-	tif->tif_decodestrip = DumpModeDecode;
-	tif->tif_decodetile = DumpModeDecode;
-	tif->tif_encoderow = DumpModeEncode;
-	tif->tif_encodestrip = DumpModeEncode;
-	tif->tif_encodetile = DumpModeEncode;
-	tif->tif_seek = DumpModeSeek;
-	return (1);
-}
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_error.c b/thirdparty/libtiff/tif_error.c
deleted file mode 100644
index 2377abd..0000000
--- a/thirdparty/libtiff/tif_error.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_error.c,v 1.4.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- */
-#include "tiffiop.h"
-
-TIFFErrorHandlerExt _TIFFerrorHandlerExt = NULL;
-
-TIFFErrorHandler
-TIFFSetErrorHandler(TIFFErrorHandler handler)
-{
-	TIFFErrorHandler prev = _TIFFerrorHandler;
-	_TIFFerrorHandler = handler;
-	return (prev);
-}
-
-TIFFErrorHandlerExt
-TIFFSetErrorHandlerExt(TIFFErrorHandlerExt handler)
-{
-	TIFFErrorHandlerExt prev = _TIFFerrorHandlerExt;
-	_TIFFerrorHandlerExt = handler;
-	return (prev);
-}
-
-void
-TIFFError(const char* module, const char* fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	if (_TIFFerrorHandler)
-		(*_TIFFerrorHandler)(module, fmt, ap);
-	if (_TIFFerrorHandlerExt)
-		(*_TIFFerrorHandlerExt)(0, module, fmt, ap);
-	va_end(ap);
-}
-
-void
-TIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	if (_TIFFerrorHandler)
-		(*_TIFFerrorHandler)(module, fmt, ap);
-	if (_TIFFerrorHandlerExt)
-		(*_TIFFerrorHandlerExt)(fd, module, fmt, ap);
-	va_end(ap);
-}
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_extension.c b/thirdparty/libtiff/tif_extension.c
deleted file mode 100644
index b67c0f0..0000000
--- a/thirdparty/libtiff/tif_extension.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_extension.c,v 1.4.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Various routines support external extension of the tag set, and other
- * application extension capabilities. 
- */
-
-#include "tiffiop.h"
-
-int TIFFGetTagListCount( TIFF *tif )
-
-{
-    TIFFDirectory* td = &tif->tif_dir;
-    
-    return td->td_customValueCount;
-}
-
-ttag_t TIFFGetTagListEntry( TIFF *tif, int tag_index )
-
-{
-    TIFFDirectory* td = &tif->tif_dir;
-
-    if( tag_index < 0 || tag_index >= td->td_customValueCount )
-        return (ttag_t) -1;
-    else
-        return td->td_customValues[tag_index].info->field_tag;
-}
-
-/*
-** This provides read/write access to the TIFFTagMethods within the TIFF
-** structure to application code without giving access to the private
-** TIFF structure.
-*/
-TIFFTagMethods *TIFFAccessTagMethods( TIFF *tif )
-
-{
-    return &(tif->tif_tagmethods);
-}
-
-void *TIFFGetClientInfo( TIFF *tif, const char *name )
-
-{
-    TIFFClientInfoLink *link = tif->tif_clientinfo;
-
-    while( link != NULL && strcmp(link->name,name) != 0 )
-        link = link->next;
-
-    if( link != NULL )
-        return link->data;
-    else
-        return NULL;
-}
-
-void TIFFSetClientInfo( TIFF *tif, void *data, const char *name )
-
-{
-    TIFFClientInfoLink *link = tif->tif_clientinfo;
-
-    /*
-    ** Do we have an existing link with this name?  If so, just
-    ** set it.
-    */
-    while( link != NULL && strcmp(link->name,name) != 0 )
-        link = link->next;
-
-    if( link != NULL )
-    {
-        link->data = data;
-        return;
-    }
-
-    /*
-    ** Create a new link.
-    */
-
-    link = (TIFFClientInfoLink *) _TIFFmalloc(sizeof(TIFFClientInfoLink));
-    assert (link != NULL);
-    link->next = tif->tif_clientinfo;
-    link->name = (char *) _TIFFmalloc(strlen(name)+1);
-    assert (link->name != NULL);
-    strcpy(link->name, name);
-    link->data = data;
-
-    tif->tif_clientinfo = link;
-}
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_fax3.c b/thirdparty/libtiff/tif_fax3.c
deleted file mode 100644
index 9eec4ab..0000000
--- a/thirdparty/libtiff/tif_fax3.c
+++ /dev/null
@@ -1,1626 +0,0 @@
-/* $Id: tif_fax3.c,v 1.43.2.10 2010-06-09 17:16:58 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1990-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef CCITT_SUPPORT
-/*
- * TIFF Library.
- *
- * CCITT Group 3 (T.4) and Group 4 (T.6) Compression Support.
- *
- * This file contains support for decoding and encoding TIFF
- * compression algorithms 2, 3, 4, and 32771.
- *
- * Decoder support is derived, with permission, from the code
- * in Frank Cringle's viewfax program;
- *      Copyright (C) 1990, 1995  Frank D. Cringle.
- */
-#include "tif_fax3.h"
-#define	G3CODES
-#include "t4.h"
-#include <stdio.h>
-
-/*
- * Compression+decompression state blocks are
- * derived from this ``base state'' block.
- */
-typedef struct {
-        int     rw_mode;                /* O_RDONLY for decode, else encode */
-	int	mode;			/* operating mode */
-	uint32	rowbytes;		/* bytes in a decoded scanline */
-	uint32	rowpixels;		/* pixels in a scanline */
-
-	uint16	cleanfaxdata;		/* CleanFaxData tag */
-	uint32	badfaxrun;		/* BadFaxRun tag */
-	uint32	badfaxlines;		/* BadFaxLines tag */
-	uint32	groupoptions;		/* Group 3/4 options tag */
-	uint32	recvparams;		/* encoded Class 2 session params */
-	char*	subaddress;		/* subaddress string */
-	uint32	recvtime;		/* time spent receiving (secs) */
-	char*	faxdcs;			/* Table 2/T.30 encoded session params */
-	TIFFVGetMethod vgetparent;	/* super-class method */
-	TIFFVSetMethod vsetparent;	/* super-class method */
-	TIFFPrintMethod printdir;	/* super-class method */
-} Fax3BaseState;
-#define	Fax3State(tif)		((Fax3BaseState*) (tif)->tif_data)
-
-typedef enum { G3_1D, G3_2D } Ttag;
-typedef struct {
-	Fax3BaseState b;
-
-	/* Decoder state info */
-	const unsigned char* bitmap;	/* bit reversal table */
-	uint32	data;			/* current i/o byte/word */
-	int	bit;			/* current i/o bit in byte */
-	int	EOLcnt;			/* count of EOL codes recognized */
-	TIFFFaxFillFunc fill;		/* fill routine */
-	uint32*	runs;			/* b&w runs for current/previous row */
-	uint32*	refruns;		/* runs for reference line */
-	uint32*	curruns;		/* runs for current line */
-
-	/* Encoder state info */
-	Ttag    tag;			/* encoding state */
-	unsigned char*	refline;	/* reference line for 2d decoding */
-	int	k;			/* #rows left that can be 2d encoded */
-	int	maxk;			/* max #rows that can be 2d encoded */
-
-	int line;
-} Fax3CodecState;
-#define	DecoderState(tif)	((Fax3CodecState*) Fax3State(tif))
-#define	EncoderState(tif)	((Fax3CodecState*) Fax3State(tif))
-
-#define	is2DEncoding(sp) \
-	(sp->b.groupoptions & GROUP3OPT_2DENCODING)
-#define	isAligned(p,t)	((((unsigned long)(p)) & (sizeof (t)-1)) == 0)
-
-/*
- * Group 3 and Group 4 Decoding.
- */
-
-/*
- * These macros glue the TIFF library state to
- * the state expected by Frank's decoder.
- */
-#define	DECLARE_STATE(tif, sp, mod)					\
-    static const char module[] = mod;					\
-    Fax3CodecState* sp = DecoderState(tif);				\
-    int a0;				/* reference element */		\
-    int lastx = sp->b.rowpixels;	/* last element in row */	\
-    uint32 BitAcc;			/* bit accumulator */		\
-    int BitsAvail;			/* # valid bits in BitAcc */	\
-    int RunLength;			/* length of current run */	\
-    unsigned char* cp;			/* next byte of input data */	\
-    unsigned char* ep;			/* end of input data */		\
-    uint32* pa;				/* place to stuff next run */	\
-    uint32* thisrun;			/* current row's run array */	\
-    int EOLcnt;				/* # EOL codes recognized */	\
-    const unsigned char* bitmap = sp->bitmap;	/* input data bit reverser */	\
-    const TIFFFaxTabEnt* TabEnt
-#define	DECLARE_STATE_2D(tif, sp, mod)					\
-    DECLARE_STATE(tif, sp, mod);					\
-    int b1;				/* next change on prev line */	\
-    uint32* pb				/* next run in reference line */\
-/*
- * Load any state that may be changed during decoding.
- */
-#define	CACHE_STATE(tif, sp) do {					\
-    BitAcc = sp->data;							\
-    BitsAvail = sp->bit;						\
-    EOLcnt = sp->EOLcnt;						\
-    cp = (unsigned char*) tif->tif_rawcp;				\
-    ep = cp + tif->tif_rawcc;						\
-} while (0)
-/*
- * Save state possibly changed during decoding.
- */
-#define	UNCACHE_STATE(tif, sp) do {					\
-    sp->bit = BitsAvail;						\
-    sp->data = BitAcc;							\
-    sp->EOLcnt = EOLcnt;						\
-    tif->tif_rawcc -= (tidata_t) cp - tif->tif_rawcp;			\
-    tif->tif_rawcp = (tidata_t) cp;					\
-} while (0)
-
-/*
- * Setup state for decoding a strip.
- */
-static int
-Fax3PreDecode(TIFF* tif, tsample_t s)
-{
-	Fax3CodecState* sp = DecoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-	sp->bit = 0;			/* force initial read */
-	sp->data = 0;
-	sp->EOLcnt = 0;			/* force initial scan for EOL */
-	/*
-	 * Decoder assumes lsb-to-msb bit order.  Note that we select
-	 * this here rather than in Fax3SetupState so that viewers can
-	 * hold the image open, fiddle with the FillOrder tag value,
-	 * and then re-decode the image.  Otherwise they'd need to close
-	 * and open the image to get the state reset.
-	 */
-	sp->bitmap =
-	    TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB);
-	if (sp->refruns) {		/* init reference line to white */
-		sp->refruns[0] = (uint32) sp->b.rowpixels;
-		sp->refruns[1] = 0;
-	}
-	sp->line = 0;
-	return (1);
-}
-
-/*
- * Routine for handling various errors/conditions.
- * Note how they are "glued into the decoder" by
- * overriding the definitions used by the decoder.
- */
-
-static void
-Fax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0)
-{
-	TIFFErrorExt(tif->tif_clientdata, module, "%s: Bad code word at line %u of %s %u (x %u)",
-		     tif->tif_name, line, isTiled(tif) ? "tile" : "strip",
-		     (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
-		     a0);
-}
-#define	unexpected(table, a0)	Fax3Unexpected(module, tif, sp->line, a0)
-
-static void
-Fax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0)
-{
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: Uncompressed data (not supported) at line %u of %s %u (x %u)",
-		     tif->tif_name, line, isTiled(tif) ? "tile" : "strip",
-		     (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
-		     a0);
-}
-#define	extension(a0)	Fax3Extension(module, tif, sp->line, a0)
-
-static void
-Fax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 lastx)
-{
-	TIFFWarningExt(tif->tif_clientdata, module, "%s: %s at line %u of %s %u (got %u, expected %u)",
-		       tif->tif_name,
-		       a0 < lastx ? "Premature EOL" : "Line length mismatch",
-		       line, isTiled(tif) ? "tile" : "strip",
-		       (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
-		       a0, lastx);
-}
-#define	badlength(a0,lastx)	Fax3BadLength(module, tif, sp->line, a0, lastx)
-
-static void
-Fax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0)
-{
-	TIFFWarningExt(tif->tif_clientdata, module, "%s: Premature EOF at line %u of %s %u (x %u)",
-	    tif->tif_name,
-		       line, isTiled(tif) ? "tile" : "strip",
-		       (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),
-		       a0);
-}
-#define	prematureEOF(a0)	Fax3PrematureEOF(module, tif, sp->line, a0)
-
-#define	Nop
-
-/*
- * Decode the requested amount of G3 1D-encoded data.
- */
-static int
-Fax3Decode1D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	DECLARE_STATE(tif, sp, "Fax3Decode1D");
-
-	(void) s;
-	CACHE_STATE(tif, sp);
-	thisrun = sp->curruns;
-	while ((long)occ > 0) {
-		a0 = 0;
-		RunLength = 0;
-		pa = thisrun;
-#ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
-		printf("-------------------- %d\n", tif->tif_row);
-		fflush(stdout);
-#endif
-		SYNC_EOL(EOF1D);
-		EXPAND1D(EOF1Da);
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		buf += sp->b.rowbytes;
-		occ -= sp->b.rowbytes;
-		sp->line++;
-		continue;
-	EOF1D:				/* premature EOF */
-		CLEANUP_RUNS();
-	EOF1Da:				/* premature EOF */
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		UNCACHE_STATE(tif, sp);
-		return (-1);
-	}
-	UNCACHE_STATE(tif, sp);
-	return (1);
-}
-
-#define	SWAP(t,a,b)	{ t x; x = (a); (a) = (b); (b) = x; }
-/*
- * Decode the requested amount of G3 2D-encoded data.
- */
-static int
-Fax3Decode2D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	DECLARE_STATE_2D(tif, sp, "Fax3Decode2D");
-	int is1D;			/* current line is 1d/2d-encoded */
-
-	(void) s;
-	CACHE_STATE(tif, sp);
-	while ((long)occ > 0) {
-		a0 = 0;
-		RunLength = 0;
-		pa = thisrun = sp->curruns;
-#ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d",
-		    BitAcc, BitsAvail, EOLcnt);
-#endif
-		SYNC_EOL(EOF2D);
-		NeedBits8(1, EOF2D);
-		is1D = GetBits(1);	/* 1D/2D-encoding tag bit */
-		ClrBits(1);
-#ifdef FAX3_DEBUG
-		printf(" %s\n-------------------- %d\n",
-		    is1D ? "1D" : "2D", tif->tif_row);
-		fflush(stdout);
-#endif
-		pb = sp->refruns;
-		b1 = *pb++;
-		if (is1D)
-			EXPAND1D(EOF2Da);
-		else
-			EXPAND2D(EOF2Da);
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		SETVALUE(0);		/* imaginary change for reference */
-		SWAP(uint32*, sp->curruns, sp->refruns);
-		buf += sp->b.rowbytes;
-		occ -= sp->b.rowbytes;
-		sp->line++;
-		continue;
-	EOF2D:				/* premature EOF */
-		CLEANUP_RUNS();
-	EOF2Da:				/* premature EOF */
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		UNCACHE_STATE(tif, sp);
-		return (-1);
-	}
-	UNCACHE_STATE(tif, sp);
-	return (1);
-}
-#undef SWAP
-
-/*
- * The ZERO & FILL macros must handle spans < 2*sizeof(long) bytes.
- * For machines with 64-bit longs this is <16 bytes; otherwise
- * this is <8 bytes.  We optimize the code here to reflect the
- * machine characteristics.
- */
-#if SIZEOF_LONG == 8
-# define FILL(n, cp)							    \
-    switch (n) {							    \
-    case 15:(cp)[14] = 0xff; case 14:(cp)[13] = 0xff; case 13: (cp)[12] = 0xff;\
-    case 12:(cp)[11] = 0xff; case 11:(cp)[10] = 0xff; case 10: (cp)[9] = 0xff;\
-    case  9: (cp)[8] = 0xff; case  8: (cp)[7] = 0xff; case  7: (cp)[6] = 0xff;\
-    case  6: (cp)[5] = 0xff; case  5: (cp)[4] = 0xff; case  4: (cp)[3] = 0xff;\
-    case  3: (cp)[2] = 0xff; case  2: (cp)[1] = 0xff;			      \
-    case  1: (cp)[0] = 0xff; (cp) += (n); case 0:  ;			      \
-    }
-# define ZERO(n, cp)							\
-    switch (n) {							\
-    case 15:(cp)[14] = 0; case 14:(cp)[13] = 0; case 13: (cp)[12] = 0;	\
-    case 12:(cp)[11] = 0; case 11:(cp)[10] = 0; case 10: (cp)[9] = 0;	\
-    case  9: (cp)[8] = 0; case  8: (cp)[7] = 0; case  7: (cp)[6] = 0;	\
-    case  6: (cp)[5] = 0; case  5: (cp)[4] = 0; case  4: (cp)[3] = 0;	\
-    case  3: (cp)[2] = 0; case  2: (cp)[1] = 0;				\
-    case  1: (cp)[0] = 0; (cp) += (n); case 0:  ;			\
-    }
-#else
-# define FILL(n, cp)							    \
-    switch (n) {							    \
-    case 7: (cp)[6] = 0xff; case 6: (cp)[5] = 0xff; case 5: (cp)[4] = 0xff; \
-    case 4: (cp)[3] = 0xff; case 3: (cp)[2] = 0xff; case 2: (cp)[1] = 0xff; \
-    case 1: (cp)[0] = 0xff; (cp) += (n); case 0:  ;			    \
-    }
-# define ZERO(n, cp)							\
-    switch (n) {							\
-    case 7: (cp)[6] = 0; case 6: (cp)[5] = 0; case 5: (cp)[4] = 0;	\
-    case 4: (cp)[3] = 0; case 3: (cp)[2] = 0; case 2: (cp)[1] = 0;	\
-    case 1: (cp)[0] = 0; (cp) += (n); case 0:  ;			\
-    }
-#endif
-
-/*
- * Bit-fill a row according to the white/black
- * runs generated during G3/G4 decoding.
- */
-void
-_TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
-{
-	static const unsigned char _fillmasks[] =
-	    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };
-	unsigned char* cp;
-	uint32 x, bx, run;
-	int32 n, nw;
-	long* lp;
-
-	if ((erun-runs)&1)
-	    *erun++ = 0;
-	x = 0;
-	for (; runs < erun; runs += 2) {
-	    run = runs[0];
-	    if (x+run > lastx || run > lastx )
-		run = runs[0] = (uint32) (lastx - x);
-	    if (run) {
-		cp = buf + (x>>3);
-		bx = x&7;
-		if (run > 8-bx) {
-		    if (bx) {			/* align to byte boundary */
-			*cp++ &= 0xff << (8-bx);
-			run -= 8-bx;
-		    }
-		    if( (n = run >> 3) != 0 ) {	/* multiple bytes to fill */
-			if ((n/sizeof (long)) > 1) {
-			    /*
-			     * Align to longword boundary and fill.
-			     */
-			    for (; n && !isAligned(cp, long); n--)
-				    *cp++ = 0x00;
-			    lp = (long*) cp;
-			    nw = (int32)(n / sizeof (long));
-			    n -= nw * sizeof (long);
-			    do {
-				    *lp++ = 0L;
-			    } while (--nw);
-			    cp = (unsigned char*) lp;
-			}
-			ZERO(n, cp);
-			run &= 7;
-		    }
-		    if (run)
-			cp[0] &= 0xff >> run;
-		} else
-		    cp[0] &= ~(_fillmasks[run]>>bx);
-		x += runs[0];
-	    }
-	    run = runs[1];
-	    if (x+run > lastx || run > lastx )
-		run = runs[1] = lastx - x;
-	    if (run) {
-		cp = buf + (x>>3);
-		bx = x&7;
-		if (run > 8-bx) {
-		    if (bx) {			/* align to byte boundary */
-			*cp++ |= 0xff >> bx;
-			run -= 8-bx;
-		    }
-		    if( (n = run>>3) != 0 ) {	/* multiple bytes to fill */
-			if ((n/sizeof (long)) > 1) {
-			    /*
-			     * Align to longword boundary and fill.
-			     */
-			    for (; n && !isAligned(cp, long); n--)
-				*cp++ = 0xff;
-			    lp = (long*) cp;
-			    nw = (int32)(n / sizeof (long));
-			    n -= nw * sizeof (long);
-			    do {
-				*lp++ = -1L;
-			    } while (--nw);
-			    cp = (unsigned char*) lp;
-			}
-			FILL(n, cp);
-			run &= 7;
-		    }
-		    if (run)
-			cp[0] |= 0xff00 >> run;
-		} else
-		    cp[0] |= _fillmasks[run]>>bx;
-		x += runs[1];
-	    }
-	}
-	assert(x == lastx);
-}
-#undef	ZERO
-#undef	FILL
-
-/*
- * Setup G3/G4-related compression/decompression state
- * before data is processed.  This routine is called once
- * per image -- it sets up different state based on whether
- * or not decoding or encoding is being done and whether
- * 1D- or 2D-encoded data is involved.
- */
-static int
-Fax3SetupState(TIFF* tif)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	Fax3BaseState* sp = Fax3State(tif);
-	int needsRefLine;
-	Fax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif);
-	uint32 rowbytes, rowpixels, nruns;
-
-	if (td->td_bitspersample != 1) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "Bits/sample must be 1 for Group 3/4 encoding/decoding");
-		return (0);
-	}
-	/*
-	 * Calculate the scanline/tile widths.
-	 */
-	if (isTiled(tif)) {
-		rowbytes = TIFFTileRowSize(tif);
-		rowpixels = td->td_tilewidth;
-	} else {
-		rowbytes = TIFFScanlineSize(tif);
-		rowpixels = td->td_imagewidth;
-	}
-	sp->rowbytes = (uint32) rowbytes;
-	sp->rowpixels = (uint32) rowpixels;
-	/*
-	 * Allocate any additional space required for decoding/encoding.
-	 */
-	needsRefLine = (
-	    (sp->groupoptions & GROUP3OPT_2DENCODING) ||
-	    td->td_compression == COMPRESSION_CCITTFAX4
-	);
-
-	/*
-	  Assure that allocation computations do not overflow.
-  
-	  TIFFroundup and TIFFSafeMultiply return zero on integer overflow
-	*/
-	dsp->runs=(uint32*) NULL;
-	nruns = TIFFroundup(rowpixels,32);
-	if (needsRefLine) {
-		nruns = TIFFSafeMultiply(uint32,nruns,2);
-	}
-	if ((nruns == 0) || (TIFFSafeMultiply(uint32,nruns,2) == 0)) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "Row pixels integer overflow (rowpixels %u)",
-			     rowpixels);
-		return (0);
-	}
-	dsp->runs = (uint32*) _TIFFCheckMalloc(tif,
-					       TIFFSafeMultiply(uint32,nruns,2),
-					       sizeof (uint32),
-					       "for Group 3/4 run arrays");
-	if (dsp->runs == NULL)
-		return (0);
-	dsp->curruns = dsp->runs;
-	if (needsRefLine)
-		dsp->refruns = dsp->runs + nruns;
-	else
-		dsp->refruns = NULL;
-	if (td->td_compression == COMPRESSION_CCITTFAX3
-	    && is2DEncoding(dsp)) {	/* NB: default is 1D routine */
-		tif->tif_decoderow = Fax3Decode2D;
-		tif->tif_decodestrip = Fax3Decode2D;
-		tif->tif_decodetile = Fax3Decode2D;
-	}
-
-	if (needsRefLine) {		/* 2d encoding */
-		Fax3CodecState* esp = EncoderState(tif);
-		/*
-		 * 2d encoding requires a scanline
-		 * buffer for the ``reference line''; the
-		 * scanline against which delta encoding
-		 * is referenced.  The reference line must
-		 * be initialized to be ``white'' (done elsewhere).
-		 */
-		esp->refline = (unsigned char*) _TIFFmalloc(rowbytes);
-		if (esp->refline == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, "Fax3SetupState",
-			    "%s: No space for Group 3/4 reference line",
-			    tif->tif_name);
-			return (0);
-		}
-	} else					/* 1d encoding */
-		EncoderState(tif)->refline = NULL;
-
-	return (1);
-}
-
-/*
- * CCITT Group 3 FAX Encoding.
- */
-
-#define	Fax3FlushBits(tif, sp) {				\
-	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize)		\
-		(void) TIFFFlushData1(tif);			\
-	*(tif)->tif_rawcp++ = (tidataval_t) (sp)->data;		\
-	(tif)->tif_rawcc++;					\
-	(sp)->data = 0, (sp)->bit = 8;				\
-}
-#define	_FlushBits(tif) {					\
-	if ((tif)->tif_rawcc >= (tif)->tif_rawdatasize)		\
-		(void) TIFFFlushData1(tif);			\
-	*(tif)->tif_rawcp++ = (tidataval_t) data;		\
-	(tif)->tif_rawcc++;					\
-	data = 0, bit = 8;					\
-}
-static const int _msbmask[9] =
-    { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
-#define	_PutBits(tif, bits, length) {				\
-	while (length > bit) {					\
-		data |= bits >> (length - bit);			\
-		length -= bit;					\
-		_FlushBits(tif);				\
-	}							\
-	data |= (bits & _msbmask[length]) << (bit - length);	\
-	bit -= length;						\
-	if (bit == 0)						\
-		_FlushBits(tif);				\
-}
-	
-/*
- * Write a variable-length bit-value to
- * the output stream.  Values are
- * assumed to be at most 16 bits.
- */
-static void
-Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-	unsigned int bit = sp->bit;
-	int data = sp->data;
-
-	_PutBits(tif, bits, length);
-
-	sp->data = data;
-	sp->bit = bit;
-}
-
-/*
- * Write a code to the output stream.
- */
-#define putcode(tif, te)	Fax3PutBits(tif, (te)->code, (te)->length)
-
-#ifdef FAX3_DEBUG
-#define	DEBUG_COLOR(w) (tab == TIFFFaxWhiteCodes ? w "W" : w "B")
-#define	DEBUG_PRINT(what,len) {						\
-    int t;								\
-    printf("%08X/%-2d: %s%5d\t", data, bit, DEBUG_COLOR(what), len);	\
-    for (t = length-1; t >= 0; t--)					\
-	putchar(code & (1<<t) ? '1' : '0');				\
-    putchar('\n');							\
-}
-#endif
-
-/*
- * Write the sequence of codes that describes
- * the specified span of zero's or one's.  The
- * appropriate table that holds the make-up and
- * terminating codes is supplied.
- */
-static void
-putspan(TIFF* tif, int32 span, const tableentry* tab)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-	unsigned int bit = sp->bit;
-	int data = sp->data;
-	unsigned int code, length;
-
-	while (span >= 2624) {
-		const tableentry* te = &tab[63 + (2560>>6)];
-		code = te->code, length = te->length;
-#ifdef FAX3_DEBUG
-		DEBUG_PRINT("MakeUp", te->runlen);
-#endif
-		_PutBits(tif, code, length);
-		span -= te->runlen;
-	}
-	if (span >= 64) {
-		const tableentry* te = &tab[63 + (span>>6)];
-		assert(te->runlen == 64*(span>>6));
-		code = te->code, length = te->length;
-#ifdef FAX3_DEBUG
-		DEBUG_PRINT("MakeUp", te->runlen);
-#endif
-		_PutBits(tif, code, length);
-		span -= te->runlen;
-	}
-	code = tab[span].code, length = tab[span].length;
-#ifdef FAX3_DEBUG
-	DEBUG_PRINT("  Term", tab[span].runlen);
-#endif
-	_PutBits(tif, code, length);
-
-	sp->data = data;
-	sp->bit = bit;
-}
-
-/*
- * Write an EOL code to the output stream.  The zero-fill
- * logic for byte-aligning encoded scanlines is handled
- * here.  We also handle writing the tag bit for the next
- * scanline when doing 2d encoding.
- */
-static void
-Fax3PutEOL(TIFF* tif)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-	unsigned int bit = sp->bit;
-	int data = sp->data;
-	unsigned int code, length, tparm;
-
-	if (sp->b.groupoptions & GROUP3OPT_FILLBITS) {
-		/*
-		 * Force bit alignment so EOL will terminate on
-		 * a byte boundary.  That is, force the bit alignment
-		 * to 16-12 = 4 before putting out the EOL code.
-		 */
-		int align = 8 - 4;
-		if (align != sp->bit) {
-			if (align > sp->bit)
-				align = sp->bit + (8 - align);
-			else
-				align = sp->bit - align;
-			code = 0;
-			tparm=align; 
-			_PutBits(tif, 0, tparm);
-		}
-	}
-	code = EOL, length = 12;
-	if (is2DEncoding(sp))
-		code = (code<<1) | (sp->tag == G3_1D), length++;
-	_PutBits(tif, code, length);
-
-	sp->data = data;
-	sp->bit = bit;
-}
-
-/*
- * Reset encoding state at the start of a strip.
- */
-static int
-Fax3PreEncode(TIFF* tif, tsample_t s)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-	sp->bit = 8;
-	sp->data = 0;
-	sp->tag = G3_1D;
-	/*
-	 * This is necessary for Group 4; otherwise it isn't
-	 * needed because the first scanline of each strip ends
-	 * up being copied into the refline.
-	 */
-	if (sp->refline)
-		_TIFFmemset(sp->refline, 0x00, sp->b.rowbytes);
-	if (is2DEncoding(sp)) {
-		float res = tif->tif_dir.td_yresolution;
-		/*
-		 * The CCITT spec says that when doing 2d encoding, you
-		 * should only do it on K consecutive scanlines, where K
-		 * depends on the resolution of the image being encoded
-		 * (2 for <= 200 lpi, 4 for > 200 lpi).  Since the directory
-		 * code initializes td_yresolution to 0, this code will
-		 * select a K of 2 unless the YResolution tag is set
-		 * appropriately.  (Note also that we fudge a little here
-		 * and use 150 lpi to avoid problems with units conversion.)
-		 */
-		if (tif->tif_dir.td_resolutionunit == RESUNIT_CENTIMETER)
-			res *= 2.54f;		/* convert to inches */
-		sp->maxk = (res > 150 ? 4 : 2);
-		sp->k = sp->maxk-1;
-	} else
-		sp->k = sp->maxk = 0;
-	sp->line = 0;
-	return (1);
-}
-
-static const unsigned char zeroruns[256] = {
-    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,	/* 0x00 - 0x0f */
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* 0x10 - 0x1f */
-    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0x20 - 0x2f */
-    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0x30 - 0x3f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x40 - 0x4f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x50 - 0x5f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x60 - 0x6f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x70 - 0x7f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x80 - 0x8f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x90 - 0x9f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xa0 - 0xaf */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xb0 - 0xbf */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xc0 - 0xcf */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xd0 - 0xdf */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xe0 - 0xef */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xf0 - 0xff */
-};
-static const unsigned char oneruns[256] = {
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x00 - 0x0f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x10 - 0x1f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x20 - 0x2f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x30 - 0x3f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x40 - 0x4f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x50 - 0x5f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x60 - 0x6f */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x70 - 0x7f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x80 - 0x8f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x90 - 0x9f */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0xa0 - 0xaf */
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0xb0 - 0xbf */
-    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xc0 - 0xcf */
-    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xd0 - 0xdf */
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* 0xe0 - 0xef */
-    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8,	/* 0xf0 - 0xff */
-};
-
-/*
- * On certain systems it pays to inline
- * the routines that find pixel spans.
- */
-#ifdef VAXC
-static	int32 find0span(unsigned char*, int32, int32);
-static	int32 find1span(unsigned char*, int32, int32);
-#pragma inline(find0span,find1span)
-#endif
-
-/*
- * Find a span of ones or zeros using the supplied
- * table.  The ``base'' of the bit string is supplied
- * along with the start+end bit indices.
- */
-static int32
-find0span(unsigned char* bp, int32 bs, int32 be)
-{
-	int32 bits = be - bs;
-	int32 n, span;
-
-	bp += bs>>3;
-	/*
-	 * Check partial byte on lhs.
-	 */
-	if (bits > 0 && (n = (bs & 7))) {
-		span = zeroruns[(*bp << n) & 0xff];
-		if (span > 8-n)		/* table value too generous */
-			span = 8-n;
-		if (span > bits)	/* constrain span to bit range */
-			span = bits;
-		if (n+span < 8)		/* doesn't extend to edge of byte */
-			return (span);
-		bits -= span;
-		bp++;
-	} else
-		span = 0;
-	if (bits >= (int32)(2 * 8 * sizeof(long))) {
-		long* lp;
-		/*
-		 * Align to longword boundary and check longwords.
-		 */
-		while (!isAligned(bp, long)) {
-			if (*bp != 0x00)
-				return (span + zeroruns[*bp]);
-			span += 8, bits -= 8;
-			bp++;
-		}
-		lp = (long*) bp;
-		while ((bits >= (int32)(8 * sizeof(long))) && (0 == *lp)) {
-			span += 8*sizeof (long), bits -= 8*sizeof (long);
-			lp++;
-		}
-		bp = (unsigned char*) lp;
-	}
-	/*
-	 * Scan full bytes for all 0's.
-	 */
-	while (bits >= 8) {
-		if (*bp != 0x00)	/* end of run */
-			return (span + zeroruns[*bp]);
-		span += 8, bits -= 8;
-		bp++;
-	}
-	/*
-	 * Check partial byte on rhs.
-	 */
-	if (bits > 0) {
-		n = zeroruns[*bp];
-		span += (n > bits ? bits : n);
-	}
-	return (span);
-}
-
-static int32
-find1span(unsigned char* bp, int32 bs, int32 be)
-{
-	int32 bits = be - bs;
-	int32 n, span;
-
-	bp += bs>>3;
-	/*
-	 * Check partial byte on lhs.
-	 */
-	if (bits > 0 && (n = (bs & 7))) {
-		span = oneruns[(*bp << n) & 0xff];
-		if (span > 8-n)		/* table value too generous */
-			span = 8-n;
-		if (span > bits)	/* constrain span to bit range */
-			span = bits;
-		if (n+span < 8)		/* doesn't extend to edge of byte */
-			return (span);
-		bits -= span;
-		bp++;
-	} else
-		span = 0;
-	if (bits >= (int32)(2 * 8 * sizeof(long))) {
-		long* lp;
-		/*
-		 * Align to longword boundary and check longwords.
-		 */
-		while (!isAligned(bp, long)) {
-			if (*bp != 0xff)
-				return (span + oneruns[*bp]);
-			span += 8, bits -= 8;
-			bp++;
-		}
-		lp = (long*) bp;
-		while ((bits >= (int32)(8 * sizeof(long))) && (~0 == *lp)) {
-			span += 8*sizeof (long), bits -= 8*sizeof (long);
-			lp++;
-		}
-		bp = (unsigned char*) lp;
-	}
-	/*
-	 * Scan full bytes for all 1's.
-	 */
-	while (bits >= 8) {
-		if (*bp != 0xff)	/* end of run */
-			return (span + oneruns[*bp]);
-		span += 8, bits -= 8;
-		bp++;
-	}
-	/*
-	 * Check partial byte on rhs.
-	 */
-	if (bits > 0) {
-		n = oneruns[*bp];
-		span += (n > bits ? bits : n);
-	}
-	return (span);
-}
-
-/*
- * Return the offset of the next bit in the range
- * [bs..be] that is different from the specified
- * color.  The end, be, is returned if no such bit
- * exists.
- */
-#define	finddiff(_cp, _bs, _be, _color)	\
-	(_bs + (_color ? find1span(_cp,_bs,_be) : find0span(_cp,_bs,_be)))
-/*
- * Like finddiff, but also check the starting bit
- * against the end in case start > end.
- */
-#define	finddiff2(_cp, _bs, _be, _color) \
-	(_bs < _be ? finddiff(_cp,_bs,_be,_color) : _be)
-
-/*
- * 1d-encode a row of pixels.  The encoding is
- * a sequence of all-white or all-black spans
- * of pixels encoded with Huffman codes.
- */
-static int
-Fax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-	int32 span;
-        uint32 bs = 0;
-
-	for (;;) {
-		span = find0span(bp, bs, bits);		/* white span */
-		putspan(tif, span, TIFFFaxWhiteCodes);
-		bs += span;
-		if (bs >= bits)
-			break;
-		span = find1span(bp, bs, bits);		/* black span */
-		putspan(tif, span, TIFFFaxBlackCodes);
-		bs += span;
-		if (bs >= bits)
-			break;
-	}
-	if (sp->b.mode & (FAXMODE_BYTEALIGN|FAXMODE_WORDALIGN)) {
-		if (sp->bit != 8)			/* byte-align */
-			Fax3FlushBits(tif, sp);
-		if ((sp->b.mode&FAXMODE_WORDALIGN) &&
-		    !isAligned(tif->tif_rawcp, uint16))
-			Fax3FlushBits(tif, sp);
-	}
-	return (1);
-}
-
-static const tableentry horizcode =
-    { 3, 0x1, 0 };	/* 001 */
-static const tableentry passcode =
-    { 4, 0x1, 0 };	/* 0001 */
-static const tableentry vcodes[7] = {
-    { 7, 0x03, 0 },	/* 0000 011 */
-    { 6, 0x03, 0 },	/* 0000 11 */
-    { 3, 0x03, 0 },	/* 011 */
-    { 1, 0x1, 0 },	/* 1 */
-    { 3, 0x2, 0 },	/* 010 */
-    { 6, 0x02, 0 },	/* 0000 10 */
-    { 7, 0x02, 0 }	/* 0000 010 */
-};
-
-/*
- * 2d-encode a row of pixels.  Consult the CCITT
- * documentation for the algorithm.
- */
-static int
-Fax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits)
-{
-#define	PIXEL(buf,ix)	((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1)
-        uint32 a0 = 0;
-	uint32 a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0));
-	uint32 b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0));
-	uint32 a2, b2;
-
-	for (;;) {
-		b2 = finddiff2(rp, b1, bits, PIXEL(rp,b1));
-		if (b2 >= a1) {
-			int32 d = b1 - a1;
-			if (!(-3 <= d && d <= 3)) {	/* horizontal mode */
-				a2 = finddiff2(bp, a1, bits, PIXEL(bp,a1));
-				putcode(tif, &horizcode);
-				if (a0+a1 == 0 || PIXEL(bp, a0) == 0) {
-					putspan(tif, a1-a0, TIFFFaxWhiteCodes);
-					putspan(tif, a2-a1, TIFFFaxBlackCodes);
-				} else {
-					putspan(tif, a1-a0, TIFFFaxBlackCodes);
-					putspan(tif, a2-a1, TIFFFaxWhiteCodes);
-				}
-				a0 = a2;
-			} else {			/* vertical mode */
-				putcode(tif, &vcodes[d+3]);
-				a0 = a1;
-			}
-		} else {				/* pass mode */
-			putcode(tif, &passcode);
-			a0 = b2;
-		}
-		if (a0 >= bits)
-			break;
-		a1 = finddiff(bp, a0, bits, PIXEL(bp,a0));
-		b1 = finddiff(rp, a0, bits, !PIXEL(bp,a0));
-		b1 = finddiff(rp, b1, bits, PIXEL(bp,a0));
-	}
-	return (1);
-#undef PIXEL
-}
-
-/*
- * Encode a buffer of pixels.
- */
-static int
-Fax3Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-
-	(void) s;
-	while ((long)cc > 0) {
-		if ((sp->b.mode & FAXMODE_NOEOL) == 0)
-			Fax3PutEOL(tif);
-		if (is2DEncoding(sp)) {
-			if (sp->tag == G3_1D) {
-				if (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))
-					return (0);
-				sp->tag = G3_2D;
-			} else {
-				if (!Fax3Encode2DRow(tif, bp, sp->refline,
-                                                     sp->b.rowpixels))
-					return (0);
-				sp->k--;
-			}
-			if (sp->k == 0) {
-				sp->tag = G3_1D;
-				sp->k = sp->maxk-1;
-			} else
-				_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);
-		} else {
-			if (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))
-				return (0);
-		}
-		bp += sp->b.rowbytes;
-		cc -= sp->b.rowbytes;
-	}
-	return (1);
-}
-
-static int
-Fax3PostEncode(TIFF* tif)
-{
-	Fax3CodecState* sp = EncoderState(tif);
-
-	if (sp->bit != 8)
-		Fax3FlushBits(tif, sp);
-	return (1);
-}
-
-static void
-Fax3Close(TIFF* tif)
-{
-	if ((Fax3State(tif)->mode & FAXMODE_NORTC) == 0) {
-		Fax3CodecState* sp = EncoderState(tif);
-		unsigned int code = EOL;
-		unsigned int length = 12;
-		int i;
-
-		if (is2DEncoding(sp))
-			code = (code<<1) | (sp->tag == G3_1D), length++;
-		for (i = 0; i < 6; i++)
-			Fax3PutBits(tif, code, length);
-		Fax3FlushBits(tif, sp);
-	}
-}
-
-static void
-Fax3Cleanup(TIFF* tif)
-{
-	Fax3CodecState* sp = DecoderState(tif);
-	
-	assert(sp != 0);
-
-	tif->tif_tagmethods.vgetfield = sp->b.vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->b.vsetparent;
-	tif->tif_tagmethods.printdir = sp->b.printdir;
-
-	if (sp->runs)
-		_TIFFfree(sp->runs);
-	if (sp->refline)
-		_TIFFfree(sp->refline);
-
-	if (Fax3State(tif)->subaddress)
-		_TIFFfree(Fax3State(tif)->subaddress);
-	if (Fax3State(tif)->faxdcs)
-		_TIFFfree(Fax3State(tif)->faxdcs);
-
-	_TIFFfree(tif->tif_data);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-#define	FIELD_BADFAXLINES	(FIELD_CODEC+0)
-#define	FIELD_CLEANFAXDATA	(FIELD_CODEC+1)
-#define	FIELD_BADFAXRUN		(FIELD_CODEC+2)
-#define	FIELD_RECVPARAMS	(FIELD_CODEC+3)
-#define	FIELD_SUBADDRESS	(FIELD_CODEC+4)
-#define	FIELD_RECVTIME		(FIELD_CODEC+5)
-#define	FIELD_FAXDCS		(FIELD_CODEC+6)
-
-#define	FIELD_OPTIONS		(FIELD_CODEC+7)
-
-static const TIFFFieldInfo faxFieldInfo[] = {
-    { TIFFTAG_FAXMODE,		 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      FALSE,	FALSE,	"FaxMode" },
-    { TIFFTAG_FAXFILLFUNC,	 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      FALSE,	FALSE,	"FaxFillFunc" },
-    { TIFFTAG_BADFAXLINES,	 1, 1,	TIFF_LONG,	FIELD_BADFAXLINES,
-      TRUE,	FALSE,	"BadFaxLines" },
-    { TIFFTAG_BADFAXLINES,	 1, 1,	TIFF_SHORT,	FIELD_BADFAXLINES,
-      TRUE,	FALSE,	"BadFaxLines" },
-    { TIFFTAG_CLEANFAXDATA,	 1, 1,	TIFF_SHORT,	FIELD_CLEANFAXDATA,
-      TRUE,	FALSE,	"CleanFaxData" },
-    { TIFFTAG_CONSECUTIVEBADFAXLINES,1,1, TIFF_LONG,	FIELD_BADFAXRUN,
-      TRUE,	FALSE,	"ConsecutiveBadFaxLines" },
-    { TIFFTAG_CONSECUTIVEBADFAXLINES,1,1, TIFF_SHORT,	FIELD_BADFAXRUN,
-      TRUE,	FALSE,	"ConsecutiveBadFaxLines" },
-    { TIFFTAG_FAXRECVPARAMS,	 1, 1, TIFF_LONG,	FIELD_RECVPARAMS,
-      TRUE,	FALSE,	"FaxRecvParams" },
-    { TIFFTAG_FAXSUBADDRESS,	-1,-1, TIFF_ASCII,	FIELD_SUBADDRESS,
-      TRUE,	FALSE,	"FaxSubAddress" },
-    { TIFFTAG_FAXRECVTIME,	 1, 1, TIFF_LONG,	FIELD_RECVTIME,
-      TRUE,	FALSE,	"FaxRecvTime" },
-    { TIFFTAG_FAXDCS,		-1,-1, TIFF_ASCII,	FIELD_FAXDCS,
-      TRUE,	FALSE,	"FaxDcs" },
-};
-static const TIFFFieldInfo fax3FieldInfo[] = {
-    { TIFFTAG_GROUP3OPTIONS,	 1, 1,	TIFF_LONG,	FIELD_OPTIONS,
-      FALSE,	FALSE,	"Group3Options" },
-};
-static const TIFFFieldInfo fax4FieldInfo[] = {
-    { TIFFTAG_GROUP4OPTIONS,	 1, 1,	TIFF_LONG,	FIELD_OPTIONS,
-      FALSE,	FALSE,	"Group4Options" },
-};
-#define	N(a)	(sizeof (a) / sizeof (a[0]))
-
-static int
-Fax3VSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	Fax3BaseState* sp = Fax3State(tif);
-	const TIFFFieldInfo* fip;
-
-	assert(sp != 0);
-	assert(sp->vsetparent != 0);
-
-	switch (tag) {
-	case TIFFTAG_FAXMODE:
-		sp->mode = va_arg(ap, int);
-		return 1;			/* NB: pseudo tag */
-	case TIFFTAG_FAXFILLFUNC:
-		DecoderState(tif)->fill = va_arg(ap, TIFFFaxFillFunc);
-		return 1;			/* NB: pseudo tag */
-	case TIFFTAG_GROUP3OPTIONS:
-		/* XXX: avoid reading options if compression mismatches. */
-		if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3)
-			sp->groupoptions = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_GROUP4OPTIONS:
-		/* XXX: avoid reading options if compression mismatches. */
-		if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4)
-			sp->groupoptions = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_BADFAXLINES:
-		sp->badfaxlines = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_CLEANFAXDATA:
-		sp->cleanfaxdata = (uint16) va_arg(ap, int);
-		break;
-	case TIFFTAG_CONSECUTIVEBADFAXLINES:
-		sp->badfaxrun = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_FAXRECVPARAMS:
-		sp->recvparams = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_FAXSUBADDRESS:
-		_TIFFsetString(&sp->subaddress, va_arg(ap, char*));
-		break;
-	case TIFFTAG_FAXRECVTIME:
-		sp->recvtime = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_FAXDCS:
-		_TIFFsetString(&sp->faxdcs, va_arg(ap, char*));
-		break;
-	default:
-		return (*sp->vsetparent)(tif, tag, ap);
-	}
-	
-	if ((fip = _TIFFFieldWithTag(tif, tag)))
-		TIFFSetFieldBit(tif, fip->field_bit);
-	else
-		return 0;
-
-	tif->tif_flags |= TIFF_DIRTYDIRECT;
-	return 1;
-}
-
-static int
-Fax3VGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	Fax3BaseState* sp = Fax3State(tif);
-
-	assert(sp != 0);
-
-	switch (tag) {
-	case TIFFTAG_FAXMODE:
-		*va_arg(ap, int*) = sp->mode;
-		break;
-	case TIFFTAG_FAXFILLFUNC:
-		*va_arg(ap, TIFFFaxFillFunc*) = DecoderState(tif)->fill;
-		break;
-	case TIFFTAG_GROUP3OPTIONS:
-	case TIFFTAG_GROUP4OPTIONS:
-		*va_arg(ap, uint32*) = sp->groupoptions;
-		break;
-	case TIFFTAG_BADFAXLINES:
-		*va_arg(ap, uint32*) = sp->badfaxlines;
-		break;
-	case TIFFTAG_CLEANFAXDATA:
-		*va_arg(ap, uint16*) = sp->cleanfaxdata;
-		break;
-	case TIFFTAG_CONSECUTIVEBADFAXLINES:
-		*va_arg(ap, uint32*) = sp->badfaxrun;
-		break;
-	case TIFFTAG_FAXRECVPARAMS:
-		*va_arg(ap, uint32*) = sp->recvparams;
-		break;
-	case TIFFTAG_FAXSUBADDRESS:
-		*va_arg(ap, char**) = sp->subaddress;
-		break;
-	case TIFFTAG_FAXRECVTIME:
-		*va_arg(ap, uint32*) = sp->recvtime;
-		break;
-	case TIFFTAG_FAXDCS:
-		*va_arg(ap, char**) = sp->faxdcs;
-		break;
-	default:
-		return (*sp->vgetparent)(tif, tag, ap);
-	}
-	return (1);
-}
-
-static void
-Fax3PrintDir(TIFF* tif, FILE* fd, long flags)
-{
-	Fax3BaseState* sp = Fax3State(tif);
-
-	assert(sp != 0);
-
-	(void) flags;
-	if (TIFFFieldSet(tif,FIELD_OPTIONS)) {
-		const char* sep = " ";
-		if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) {
-			fprintf(fd, "  Group 4 Options:");
-			if (sp->groupoptions & GROUP4OPT_UNCOMPRESSED)
-				fprintf(fd, "%suncompressed data", sep);
-		} else {
-
-			fprintf(fd, "  Group 3 Options:");
-			if (sp->groupoptions & GROUP3OPT_2DENCODING)
-				fprintf(fd, "%s2-d encoding", sep), sep = "+";
-			if (sp->groupoptions & GROUP3OPT_FILLBITS)
-				fprintf(fd, "%sEOL padding", sep), sep = "+";
-			if (sp->groupoptions & GROUP3OPT_UNCOMPRESSED)
-				fprintf(fd, "%suncompressed data", sep);
-		}
-		fprintf(fd, " (%lu = 0x%lx)\n",
-                        (unsigned long) sp->groupoptions,
-                        (unsigned long) sp->groupoptions);
-	}
-	if (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) {
-		fprintf(fd, "  Fax Data:");
-		switch (sp->cleanfaxdata) {
-		case CLEANFAXDATA_CLEAN:
-			fprintf(fd, " clean");
-			break;
-		case CLEANFAXDATA_REGENERATED:
-			fprintf(fd, " receiver regenerated");
-			break;
-		case CLEANFAXDATA_UNCLEAN:
-			fprintf(fd, " uncorrected errors");
-			break;
-		}
-		fprintf(fd, " (%u = 0x%x)\n",
-		    sp->cleanfaxdata, sp->cleanfaxdata);
-	}
-	if (TIFFFieldSet(tif,FIELD_BADFAXLINES))
-		fprintf(fd, "  Bad Fax Lines: %lu\n",
-                        (unsigned long) sp->badfaxlines);
-	if (TIFFFieldSet(tif,FIELD_BADFAXRUN))
-		fprintf(fd, "  Consecutive Bad Fax Lines: %lu\n",
-		    (unsigned long) sp->badfaxrun);
-	if (TIFFFieldSet(tif,FIELD_RECVPARAMS))
-		fprintf(fd, "  Fax Receive Parameters: %08lx\n",
-		   (unsigned long) sp->recvparams);
-	if (TIFFFieldSet(tif,FIELD_SUBADDRESS))
-		fprintf(fd, "  Fax SubAddress: %s\n", sp->subaddress);
-	if (TIFFFieldSet(tif,FIELD_RECVTIME))
-		fprintf(fd, "  Fax Receive Time: %lu secs\n",
-		    (unsigned long) sp->recvtime);
-	if (TIFFFieldSet(tif,FIELD_FAXDCS))
-		fprintf(fd, "  Fax DCS: %s\n", sp->faxdcs);
-}
-
-static int
-InitCCITTFax3(TIFF* tif)
-{
-	Fax3BaseState* sp;
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, faxFieldInfo, N(faxFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, "InitCCITTFax3",
-			"Merging common CCITT Fax codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t)
-		_TIFFmalloc(sizeof (Fax3CodecState));
-
-	if (tif->tif_data == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, "TIFFInitCCITTFax3",
-		    "%s: No space for state block", tif->tif_name);
-		return (0);
-	}
-
-	sp = Fax3State(tif);
-        sp->rw_mode = tif->tif_mode;
-
-	/*
-	 * Override parent get/set field methods.
-	 */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield = Fax3VGetField; /* hook for codec tags */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield = Fax3VSetField; /* hook for codec tags */
-	sp->printdir = tif->tif_tagmethods.printdir;
-	tif->tif_tagmethods.printdir = Fax3PrintDir;   /* hook for codec tags */
-	sp->groupoptions = 0;	
-	sp->recvparams = 0;
-	sp->subaddress = NULL;
-	sp->faxdcs = NULL;
-
-	if (sp->rw_mode == O_RDONLY) /* FIXME: improve for in place update */
-		tif->tif_flags |= TIFF_NOBITREV; /* decoder does bit reversal */
-	DecoderState(tif)->runs = NULL;
-	TIFFSetField(tif, TIFFTAG_FAXFILLFUNC, _TIFFFax3fillruns);
-	EncoderState(tif)->refline = NULL;
-
-	/*
-	 * Install codec methods.
-	 */
-	tif->tif_setupdecode = Fax3SetupState;
-	tif->tif_predecode = Fax3PreDecode;
-	tif->tif_decoderow = Fax3Decode1D;
-	tif->tif_decodestrip = Fax3Decode1D;
-	tif->tif_decodetile = Fax3Decode1D;
-	tif->tif_setupencode = Fax3SetupState;
-	tif->tif_preencode = Fax3PreEncode;
-	tif->tif_postencode = Fax3PostEncode;
-	tif->tif_encoderow = Fax3Encode;
-	tif->tif_encodestrip = Fax3Encode;
-	tif->tif_encodetile = Fax3Encode;
-	tif->tif_close = Fax3Close;
-	tif->tif_cleanup = Fax3Cleanup;
-
-	return (1);
-}
-
-int
-TIFFInitCCITTFax3(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	if (InitCCITTFax3(tif)) {
-		/*
-		 * Merge codec-specific tag information.
-		 */
-		if (!_TIFFMergeFieldInfo(tif, fax3FieldInfo, N(fax3FieldInfo))) {
-			TIFFErrorExt(tif->tif_clientdata, "TIFFInitCCITTFax3",
-			"Merging CCITT Fax 3 codec-specific tags failed");
-			return 0;
-		}
-
-		/*
-		 * The default format is Class/F-style w/o RTC.
-		 */
-		return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_CLASSF);
-	} else
-		return 01;
-}
-
-/*
- * CCITT Group 4 (T.6) Facsimile-compatible
- * Compression Scheme Support.
- */
-
-#define	SWAP(t,a,b)	{ t x; x = (a); (a) = (b); (b) = x; }
-/*
- * Decode the requested amount of G4-encoded data.
- */
-static int
-Fax4Decode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	DECLARE_STATE_2D(tif, sp, "Fax4Decode");
-
-	(void) s;
-	CACHE_STATE(tif, sp);
-	while ((long)occ > 0) {
-		a0 = 0;
-		RunLength = 0;
-		pa = thisrun = sp->curruns;
-		pb = sp->refruns;
-		b1 = *pb++;
-#ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
-		printf("-------------------- %d\n", tif->tif_row);
-		fflush(stdout);
-#endif
-		EXPAND2D(EOFG4);
-                if (EOLcnt)
-                    goto EOFG4;
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		SETVALUE(0);		/* imaginary change for reference */
-		SWAP(uint32*, sp->curruns, sp->refruns);
-		buf += sp->b.rowbytes;
-		occ -= sp->b.rowbytes;
-		sp->line++;
-		continue;
-	EOFG4:
-                NeedBits16( 13, BADG4 );
-        BADG4:
-#ifdef FAX3_DEBUG
-                if( GetBits(13) != 0x1001 )
-                    fputs( "Bad EOFB\n", stderr );
-#endif                
-                ClrBits( 13 );
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		UNCACHE_STATE(tif, sp);
-		return ( sp->line ? 1 : -1);	/* don't error on badly-terminated strips */
-	}
-	UNCACHE_STATE(tif, sp);
-	return (1);
-}
-#undef	SWAP
-
-/*
- * Encode the requested amount of data.
- */
-static int
-Fax4Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	Fax3CodecState *sp = EncoderState(tif);
-
-	(void) s;
-	while ((long)cc > 0) {
-		if (!Fax3Encode2DRow(tif, bp, sp->refline, sp->b.rowpixels))
-			return (0);
-		_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);
-		bp += sp->b.rowbytes;
-		cc -= sp->b.rowbytes;
-	}
-	return (1);
-}
-
-static int
-Fax4PostEncode(TIFF* tif)
-{
-	Fax3CodecState *sp = EncoderState(tif);
-
-	/* terminate strip w/ EOFB */
-	Fax3PutBits(tif, EOL, 12);
-	Fax3PutBits(tif, EOL, 12);
-	if (sp->bit != 8)
-		Fax3FlushBits(tif, sp);
-	return (1);
-}
-
-int
-TIFFInitCCITTFax4(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	if (InitCCITTFax3(tif)) {		/* reuse G3 support */
-		/*
-		 * Merge codec-specific tag information.
-		 */
-		if (!_TIFFMergeFieldInfo(tif, fax4FieldInfo, N(fax4FieldInfo))) {
-			TIFFErrorExt(tif->tif_clientdata, "TIFFInitCCITTFax4",
-			"Merging CCITT Fax 4 codec-specific tags failed");
-			return 0;
-		}
-
-		tif->tif_decoderow = Fax4Decode;
-		tif->tif_decodestrip = Fax4Decode;
-		tif->tif_decodetile = Fax4Decode;
-		tif->tif_encoderow = Fax4Encode;
-		tif->tif_encodestrip = Fax4Encode;
-		tif->tif_encodetile = Fax4Encode;
-		tif->tif_postencode = Fax4PostEncode;
-		/*
-		 * Suppress RTC at the end of each strip.
-		 */
-		return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC);
-	} else
-		return (0);
-}
-
-/*
- * CCITT Group 3 1-D Modified Huffman RLE Compression Support.
- * (Compression algorithms 2 and 32771)
- */
-
-/*
- * Decode the requested amount of RLE-encoded data.
- */
-static int
-Fax3DecodeRLE(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	DECLARE_STATE(tif, sp, "Fax3DecodeRLE");
-	int mode = sp->b.mode;
-
-	(void) s;
-	CACHE_STATE(tif, sp);
-	thisrun = sp->curruns;
-	while ((long)occ > 0) {
-		a0 = 0;
-		RunLength = 0;
-		pa = thisrun;
-#ifdef FAX3_DEBUG
-		printf("\nBitAcc=%08X, BitsAvail = %d\n", BitAcc, BitsAvail);
-		printf("-------------------- %d\n", tif->tif_row);
-		fflush(stdout);
-#endif
-		EXPAND1D(EOFRLE);
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		/*
-		 * Cleanup at the end of the row.
-		 */
-		if (mode & FAXMODE_BYTEALIGN) {
-			int n = BitsAvail - (BitsAvail &~ 7);
-			ClrBits(n);
-		} else if (mode & FAXMODE_WORDALIGN) {
-			int n = BitsAvail - (BitsAvail &~ 15);
-			ClrBits(n);
-			if (BitsAvail == 0 && !isAligned(cp, uint16))
-			    cp++;
-		}
-		buf += sp->b.rowbytes;
-		occ -= sp->b.rowbytes;
-		sp->line++;
-		continue;
-	EOFRLE:				/* premature EOF */
-		(*sp->fill)(buf, thisrun, pa, lastx);
-		UNCACHE_STATE(tif, sp);
-		return (-1);
-	}
-	UNCACHE_STATE(tif, sp);
-	return (1);
-}
-
-int
-TIFFInitCCITTRLE(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	if (InitCCITTFax3(tif)) {		/* reuse G3 support */
-		tif->tif_decoderow = Fax3DecodeRLE;
-		tif->tif_decodestrip = Fax3DecodeRLE;
-		tif->tif_decodetile = Fax3DecodeRLE;
-		/*
-		 * Suppress RTC+EOLs when encoding and byte-align data.
-		 */
-		return TIFFSetField(tif, TIFFTAG_FAXMODE,
-		    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_BYTEALIGN);
-	} else
-		return (0);
-}
-
-int
-TIFFInitCCITTRLEW(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	if (InitCCITTFax3(tif)) {		/* reuse G3 support */
-		tif->tif_decoderow = Fax3DecodeRLE;
-		tif->tif_decodestrip = Fax3DecodeRLE;
-		tif->tif_decodetile = Fax3DecodeRLE;
-		/*
-		 * Suppress RTC+EOLs when encoding and word-align data.
-		 */
-		return TIFFSetField(tif, TIFFTAG_FAXMODE,
-		    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_WORDALIGN);
-	} else
-		return (0);
-}
-#endif /* CCITT_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_fax3.h b/thirdparty/libtiff/tif_fax3.h
deleted file mode 100644
index 40718bc..0000000
--- a/thirdparty/libtiff/tif_fax3.h
+++ /dev/null
@@ -1,532 +0,0 @@
-/* $Id: tif_fax3.h,v 1.5.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1990-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _FAX3_
-#define	_FAX3_
-/*
- * TIFF Library.
- *
- * CCITT Group 3 (T.4) and Group 4 (T.6) Decompression Support.
- *
- * Decoder support is derived, with permission, from the code
- * in Frank Cringle's viewfax program;
- *      Copyright (C) 1990, 1995  Frank D. Cringle.
- */
-#include "tiff.h"
-
-/*
- * To override the default routine used to image decoded
- * spans one can use the pseduo tag TIFFTAG_FAXFILLFUNC.
- * The routine must have the type signature given below;
- * for example:
- *
- * fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)
- *
- * where buf is place to set the bits, runs is the array of b&w run
- * lengths (white then black), erun is the last run in the array, and
- * lastx is the width of the row in pixels.  Fill routines can assume
- * the run array has room for at least lastx runs and can overwrite
- * data in the run array as needed (e.g. to append zero runs to bring
- * the count up to a nice multiple).
- */
-typedef	void (*TIFFFaxFillFunc)(unsigned char*, uint32*, uint32*, uint32);
-
-/*
- * The default run filler; made external for other decoders.
- */
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	void _TIFFFax3fillruns(unsigned char*, uint32*, uint32*, uint32);
-#if defined(__cplusplus)
-}
-#endif
-
-
-/* finite state machine codes */
-#define S_Null		0
-#define S_Pass		1
-#define S_Horiz		2
-#define S_V0		3
-#define S_VR		4
-#define S_VL		5
-#define S_Ext		6
-#define S_TermW		7
-#define S_TermB		8
-#define S_MakeUpW	9
-#define S_MakeUpB	10
-#define S_MakeUp	11
-#define S_EOL		12
-
-typedef struct {		/* state table entry */
-	unsigned char State;	/* see above */
-	unsigned char Width;	/* width of code in bits */
-	uint32	Param;		/* unsigned 32-bit run length in bits */
-} TIFFFaxTabEnt;
-
-extern	const TIFFFaxTabEnt TIFFFaxMainTable[];
-extern	const TIFFFaxTabEnt TIFFFaxWhiteTable[];
-extern	const TIFFFaxTabEnt TIFFFaxBlackTable[];
-
-/*
- * The following macros define the majority of the G3/G4 decoder
- * algorithm using the state tables defined elsewhere.  To build
- * a decoder you need some setup code and some glue code. Note
- * that you may also need/want to change the way the NeedBits*
- * macros get input data if, for example, you know the data to be
- * decoded is properly aligned and oriented (doing so before running
- * the decoder can be a big performance win).
- *
- * Consult the decoder in the TIFF library for an idea of what you
- * need to define and setup to make use of these definitions.
- *
- * NB: to enable a debugging version of these macros define FAX3_DEBUG
- *     before including this file.  Trace output goes to stdout.
- */
-
-#ifndef EndOfData
-#define EndOfData()	(cp >= ep)
-#endif
-/*
- * Need <=8 or <=16 bits of input data.  Unlike viewfax we
- * cannot use/assume a word-aligned, properly bit swizzled
- * input data set because data may come from an arbitrarily
- * aligned, read-only source such as a memory-mapped file.
- * Note also that the viewfax decoder does not check for
- * running off the end of the input data buffer.  This is
- * possible for G3-encoded data because it prescans the input
- * data to count EOL markers, but can cause problems for G4
- * data.  In any event, we don't prescan and must watch for
- * running out of data since we can't permit the library to
- * scan past the end of the input data buffer.
- *
- * Finally, note that we must handle remaindered data at the end
- * of a strip specially.  The coder asks for a fixed number of
- * bits when scanning for the next code.  This may be more bits
- * than are actually present in the data stream.  If we appear
- * to run out of data but still have some number of valid bits
- * remaining then we makeup the requested amount with zeros and
- * return successfully.  If the returned data is incorrect then
- * we should be called again and get a premature EOF error;
- * otherwise we should get the right answer.
- */
-#ifndef NeedBits8
-#define NeedBits8(n,eoflab) do {					\
-    if (BitsAvail < (n)) {						\
-	if (EndOfData()) {						\
-	    if (BitsAvail == 0)			/* no valid bits */	\
-		goto eoflab;						\
-	    BitsAvail = (n);			/* pad with zeros */	\
-	} else {							\
-	    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;		\
-	    BitsAvail += 8;						\
-	}								\
-    }									\
-} while (0)
-#endif
-#ifndef NeedBits16
-#define NeedBits16(n,eoflab) do {					\
-    if (BitsAvail < (n)) {						\
-	if (EndOfData()) {						\
-	    if (BitsAvail == 0)			/* no valid bits */	\
-		goto eoflab;						\
-	    BitsAvail = (n);			/* pad with zeros */	\
-	} else {							\
-	    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;		\
-	    if ((BitsAvail += 8) < (n)) {				\
-		if (EndOfData()) {					\
-		    /* NB: we know BitsAvail is non-zero here */	\
-		    BitsAvail = (n);		/* pad with zeros */	\
-		} else {						\
-		    BitAcc |= ((uint32) bitmap[*cp++])<<BitsAvail;	\
-		    BitsAvail += 8;					\
-		}							\
-	    }								\
-	}								\
-    }									\
-} while (0)
-#endif
-#define GetBits(n)	(BitAcc & ((1<<(n))-1))
-#define ClrBits(n) do {							\
-    BitsAvail -= (n);							\
-    BitAcc >>= (n);							\
-} while (0)
-
-#ifdef FAX3_DEBUG
-static const char* StateNames[] = {
-    "Null   ",
-    "Pass   ",
-    "Horiz  ",
-    "V0     ",
-    "VR     ",
-    "VL     ",
-    "Ext    ",
-    "TermW  ",
-    "TermB  ",
-    "MakeUpW",
-    "MakeUpB",
-    "MakeUp ",
-    "EOL    ",
-};
-#define DEBUG_SHOW putchar(BitAcc & (1 << t) ? '1' : '0')
-#define LOOKUP8(wid,tab,eoflab) do {					\
-    int t;								\
-    NeedBits8(wid,eoflab);						\
-    TabEnt = tab + GetBits(wid);					\
-    printf("%08lX/%d: %s%5d\t", (long) BitAcc, BitsAvail,		\
-	   StateNames[TabEnt->State], TabEnt->Param);			\
-    for (t = 0; t < TabEnt->Width; t++)					\
-	DEBUG_SHOW;							\
-    putchar('\n');							\
-    fflush(stdout);							\
-    ClrBits(TabEnt->Width);						\
-} while (0)
-#define LOOKUP16(wid,tab,eoflab) do {					\
-    int t;								\
-    NeedBits16(wid,eoflab);						\
-    TabEnt = tab + GetBits(wid);					\
-    printf("%08lX/%d: %s%5d\t", (long) BitAcc, BitsAvail,		\
-	   StateNames[TabEnt->State], TabEnt->Param);			\
-    for (t = 0; t < TabEnt->Width; t++)					\
-	DEBUG_SHOW;							\
-    putchar('\n');							\
-    fflush(stdout);							\
-    ClrBits(TabEnt->Width);						\
-} while (0)
-
-#define SETVALUE(x) do {							\
-    *pa++ = RunLength + (x);						\
-    printf("SETVALUE: %d\t%d\n", RunLength + (x), a0);			\
-    a0 += x;								\
-    RunLength = 0;							\
-} while (0)
-#else
-#define LOOKUP8(wid,tab,eoflab) do {					\
-    NeedBits8(wid,eoflab);						\
-    TabEnt = tab + GetBits(wid);					\
-    ClrBits(TabEnt->Width);						\
-} while (0)
-#define LOOKUP16(wid,tab,eoflab) do {					\
-    NeedBits16(wid,eoflab);						\
-    TabEnt = tab + GetBits(wid);					\
-    ClrBits(TabEnt->Width);						\
-} while (0)
-
-/*
- * Append a run to the run length array for the
- * current row and reset decoding state.
- */
-#define SETVALUE(x) do {							\
-    *pa++ = RunLength + (x);						\
-    a0 += (x);								\
-    RunLength = 0;							\
-} while (0)
-#endif
-
-/*
- * Synchronize input decoding at the start of each
- * row by scanning for an EOL (if appropriate) and
- * skipping any trash data that might be present
- * after a decoding error.  Note that the decoding
- * done elsewhere that recognizes an EOL only consumes
- * 11 consecutive zero bits.  This means that if EOLcnt
- * is non-zero then we still need to scan for the final flag
- * bit that is part of the EOL code.
- */
-#define	SYNC_EOL(eoflab) do {						\
-    if (EOLcnt == 0) {							\
-	for (;;) {							\
-	    NeedBits16(11,eoflab);					\
-	    if (GetBits(11) == 0)					\
-		break;							\
-	    ClrBits(1);							\
-	}								\
-    }									\
-    for (;;) {								\
-	NeedBits8(8,eoflab);						\
-	if (GetBits(8))							\
-	    break;							\
-	ClrBits(8);							\
-    }									\
-    while (GetBits(1) == 0)						\
-	ClrBits(1);							\
-    ClrBits(1);				/* EOL bit */			\
-    EOLcnt = 0;				/* reset EOL counter/flag */	\
-} while (0)
-
-/*
- * Cleanup the array of runs after decoding a row.
- * We adjust final runs to insure the user buffer is not
- * overwritten and/or undecoded area is white filled.
- */
-#define	CLEANUP_RUNS() do {						\
-    if (RunLength)							\
-	SETVALUE(0);							\
-    if (a0 != lastx) {							\
-	badlength(a0, lastx);						\
-	while (a0 > lastx && pa > thisrun)				\
-	    a0 -= *--pa;						\
-	if (a0 < lastx) {						\
-	    if (a0 < 0)							\
-		a0 = 0;							\
-	    if ((pa-thisrun)&1)						\
-		SETVALUE(0);						\
-	    SETVALUE(lastx - a0);						\
-	} else if (a0 > lastx) {					\
-	    SETVALUE(lastx);						\
-	    SETVALUE(0);							\
-	}								\
-    }									\
-} while (0)
-
-/*
- * Decode a line of 1D-encoded data.
- *
- * The line expanders are written as macros so that they can be reused
- * but still have direct access to the local variables of the "calling"
- * function.
- *
- * Note that unlike the original version we have to explicitly test for
- * a0 >= lastx after each black/white run is decoded.  This is because
- * the original code depended on the input data being zero-padded to
- * insure the decoder recognized an EOL before running out of data.
- */
-#define EXPAND1D(eoflab) do {						\
-    for (;;) {								\
-	for (;;) {							\
-	    LOOKUP16(12, TIFFFaxWhiteTable, eof1d);			\
-	    switch (TabEnt->State) {					\
-	    case S_EOL:							\
-		EOLcnt = 1;						\
-		goto done1d;						\
-	    case S_TermW:						\
-		SETVALUE(TabEnt->Param);					\
-		goto doneWhite1d;					\
-	    case S_MakeUpW:						\
-	    case S_MakeUp:						\
-		a0 += TabEnt->Param;					\
-		RunLength += TabEnt->Param;				\
-		break;							\
-	    default:							\
-		unexpected("WhiteTable", a0);				\
-		goto done1d;						\
-	    }								\
-	}								\
-    doneWhite1d:							\
-	if (a0 >= lastx)						\
-	    goto done1d;						\
-	for (;;) {							\
-	    LOOKUP16(13, TIFFFaxBlackTable, eof1d);			\
-	    switch (TabEnt->State) {					\
-	    case S_EOL:							\
-		EOLcnt = 1;						\
-		goto done1d;						\
-	    case S_TermB:						\
-		SETVALUE(TabEnt->Param);					\
-		goto doneBlack1d;					\
-	    case S_MakeUpB:						\
-	    case S_MakeUp:						\
-		a0 += TabEnt->Param;					\
-		RunLength += TabEnt->Param;				\
-		break;							\
-	    default:							\
-		unexpected("BlackTable", a0);				\
-		goto done1d;						\
-	    }								\
-	}								\
-    doneBlack1d:							\
-	if (a0 >= lastx)						\
-	    goto done1d;						\
-        if( *(pa-1) == 0 && *(pa-2) == 0 )				\
-            pa -= 2;                                                    \
-    }									\
-eof1d:									\
-    prematureEOF(a0);							\
-    CLEANUP_RUNS();							\
-    goto eoflab;							\
-done1d:									\
-    CLEANUP_RUNS();							\
-} while (0)
-
-/*
- * Update the value of b1 using the array
- * of runs for the reference line.
- */
-#define CHECK_b1 do {							\
-    if (pa != thisrun) while (b1 <= a0 && b1 < lastx) {			\
-	b1 += pb[0] + pb[1];						\
-	pb += 2;							\
-    }									\
-} while (0)
-
-/*
- * Expand a row of 2D-encoded data.
- */
-#define EXPAND2D(eoflab) do {						\
-    while (a0 < lastx) {						\
-	LOOKUP8(7, TIFFFaxMainTable, eof2d);				\
-	switch (TabEnt->State) {					\
-	case S_Pass:							\
-	    CHECK_b1;							\
-	    b1 += *pb++;						\
-	    RunLength += b1 - a0;					\
-	    a0 = b1;							\
-	    b1 += *pb++;						\
-	    break;							\
-	case S_Horiz:							\
-	    if ((pa-thisrun)&1) {					\
-		for (;;) {	/* black first */			\
-		    LOOKUP16(13, TIFFFaxBlackTable, eof2d);		\
-		    switch (TabEnt->State) {				\
-		    case S_TermB:					\
-			SETVALUE(TabEnt->Param);				\
-			goto doneWhite2da;				\
-		    case S_MakeUpB:					\
-		    case S_MakeUp:					\
-			a0 += TabEnt->Param;				\
-			RunLength += TabEnt->Param;			\
-			break;						\
-		    default:						\
-			goto badBlack2d;				\
-		    }							\
-		}							\
-	    doneWhite2da:;						\
-		for (;;) {	/* then white */			\
-		    LOOKUP16(12, TIFFFaxWhiteTable, eof2d);		\
-		    switch (TabEnt->State) {				\
-		    case S_TermW:					\
-			SETVALUE(TabEnt->Param);				\
-			goto doneBlack2da;				\
-		    case S_MakeUpW:					\
-		    case S_MakeUp:					\
-			a0 += TabEnt->Param;				\
-			RunLength += TabEnt->Param;			\
-			break;						\
-		    default:						\
-			goto badWhite2d;				\
-		    }							\
-		}							\
-	    doneBlack2da:;						\
-	    } else {							\
-		for (;;) {	/* white first */			\
-		    LOOKUP16(12, TIFFFaxWhiteTable, eof2d);		\
-		    switch (TabEnt->State) {				\
-		    case S_TermW:					\
-			SETVALUE(TabEnt->Param);				\
-			goto doneWhite2db;				\
-		    case S_MakeUpW:					\
-		    case S_MakeUp:					\
-			a0 += TabEnt->Param;				\
-			RunLength += TabEnt->Param;			\
-			break;						\
-		    default:						\
-			goto badWhite2d;				\
-		    }							\
-		}							\
-	    doneWhite2db:;						\
-		for (;;) {	/* then black */			\
-		    LOOKUP16(13, TIFFFaxBlackTable, eof2d);		\
-		    switch (TabEnt->State) {				\
-		    case S_TermB:					\
-			SETVALUE(TabEnt->Param);				\
-			goto doneBlack2db;				\
-		    case S_MakeUpB:					\
-		    case S_MakeUp:					\
-			a0 += TabEnt->Param;				\
-			RunLength += TabEnt->Param;			\
-			break;						\
-		    default:						\
-			goto badBlack2d;				\
-		    }							\
-		}							\
-	    doneBlack2db:;						\
-	    }								\
-	    CHECK_b1;							\
-	    break;							\
-	case S_V0:							\
-	    CHECK_b1;							\
-	    SETVALUE(b1 - a0);						\
-	    b1 += *pb++;						\
-	    break;							\
-	case S_VR:							\
-	    CHECK_b1;							\
-	    SETVALUE(b1 - a0 + TabEnt->Param);				\
-	    b1 += *pb++;						\
-	    break;							\
-	case S_VL:							\
-	    CHECK_b1;							\
-	    SETVALUE(b1 - a0 - TabEnt->Param);				\
-	    b1 -= *--pb;						\
-	    break;							\
-	case S_Ext:							\
-	    *pa++ = lastx - a0;						\
-	    extension(a0);						\
-	    goto eol2d;							\
-	case S_EOL:							\
-	    *pa++ = lastx - a0;						\
-	    NeedBits8(4,eof2d);						\
-	    if (GetBits(4))						\
-		unexpected("EOL", a0);					\
-            ClrBits(4);                                                 \
-	    EOLcnt = 1;							\
-	    goto eol2d;							\
-	default:							\
-	badMain2d:							\
-	    unexpected("MainTable", a0);				\
-	    goto eol2d;							\
-	badBlack2d:							\
-	    unexpected("BlackTable", a0);				\
-	    goto eol2d;							\
-	badWhite2d:							\
-	    unexpected("WhiteTable", a0);				\
-	    goto eol2d;							\
-	eof2d:								\
-	    prematureEOF(a0);						\
-	    CLEANUP_RUNS();						\
-	    goto eoflab;						\
-	}								\
-    }									\
-    if (RunLength) {							\
-	if (RunLength + a0 < lastx) {					\
-	    /* expect a final V0 */					\
-	    NeedBits8(1,eof2d);						\
-	    if (!GetBits(1))						\
-		goto badMain2d;						\
-	    ClrBits(1);							\
-	}								\
-	SETVALUE(0);							\
-    }									\
-eol2d:									\
-    CLEANUP_RUNS();							\
-} while (0)
-#endif /* _FAX3_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_fax3sm.c b/thirdparty/libtiff/tif_fax3sm.c
deleted file mode 100644
index 822191e..0000000
--- a/thirdparty/libtiff/tif_fax3sm.c
+++ /dev/null
@@ -1,1260 +0,0 @@
-/* WARNING, this file was automatically generated by the
-    mkg3states program */
-#include "tiff.h"
-#include "tif_fax3.h"
- const TIFFFaxTabEnt TIFFFaxMainTable[128] = {
-{12,7,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{1,4,0},{3,1,0},
-{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{5,6,2},{3,1,0},{5,3,1},{3,1,0},
-{2,3,0},{3,1,0},{4,3,1},{3,1,0},{1,4,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},
-{4,3,1},{3,1,0},{5,7,3},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},
-{1,4,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{4,6,2},{3,1,0},
-{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{1,4,0},{3,1,0},{5,3,1},{3,1,0},
-{2,3,0},{3,1,0},{4,3,1},{3,1,0},{6,7,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},
-{4,3,1},{3,1,0},{1,4,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},
-{5,6,2},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{1,4,0},{3,1,0},
-{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},{4,7,3},{3,1,0},{5,3,1},{3,1,0},
-{2,3,0},{3,1,0},{4,3,1},{3,1,0},{1,4,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},
-{4,3,1},{3,1,0},{4,6,2},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0},
-{1,4,0},{3,1,0},{5,3,1},{3,1,0},{2,3,0},{3,1,0},{4,3,1},{3,1,0}
-};
- const TIFFFaxTabEnt TIFFFaxWhiteTable[4096] = {
-{12,11,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},
-{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},
-{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,960},{7,4,6},{7,8,31},{7,5,8},
-{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,11,1792},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},
-{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},
-{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1600},{7,4,5},
-{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},
-{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},
-{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},
-{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},
-{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1536},{7,4,5},{7,8,43},{7,6,17},
-{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},
-{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},
-{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,768},{7,4,6},
-{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,11,1856},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,896},{7,4,6},{7,7,19},{7,5,8},
-{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},
-{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},{7,8,44},{7,6,17},{9,9,1408},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},
-{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},
-{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},
-{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},
-{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},
-{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,960},{7,4,6},
-{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},
-{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{11,12,2112},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,40},{7,6,16},{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},
-{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1600},{7,4,5},{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},
-{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},{7,8,32},{7,5,8},
-{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},
-{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},
-{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1536},{7,4,5},
-{7,8,43},{7,6,17},{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},
-{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,9,768},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,12,2368},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,896},{7,4,6},
-{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},
-{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},
-{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},{7,8,44},{7,6,17},
-{9,9,1408},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},
-{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},
-{7,8,42},{7,6,16},{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},
-{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},
-{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},
-{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},
-{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},
-{9,9,960},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},
-{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{11,12,1984},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},
-{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1600},{7,4,5},{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},
-{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},
-{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},
-{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},
-{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1536},{7,4,5},{7,8,43},{7,6,17},{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},
-{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},
-{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,9,768},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,11,1920},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},
-{9,9,896},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},
-{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},
-{7,8,44},{7,6,17},{9,9,1408},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},
-{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},
-{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},
-{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},
-{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1472},{7,4,5},{7,8,43},{7,6,17},
-{9,9,1216},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},
-{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},
-{7,8,41},{7,6,16},{9,9,960},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,704},{7,4,6},
-{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,12,2240},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,832},{7,4,6},{7,7,19},{7,5,8},
-{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},
-{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1600},{7,4,5},{7,8,44},{7,6,17},{9,9,1344},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},
-{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},
-{9,9,1088},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},
-{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},
-{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1536},{7,4,5},{7,8,43},{7,6,17},{9,9,1280},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},
-{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,1024},{7,4,6},
-{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,768},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},
-{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{11,12,2496},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,40},{7,6,16},{9,9,896},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},
-{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1728},{7,4,5},{7,8,44},{7,6,17},{9,9,1408},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},
-{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1152},{7,4,6},{7,8,32},{7,5,8},
-{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{12,11,0},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},
-{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},
-{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1472},{7,4,5},
-{7,8,43},{7,6,17},{9,9,1216},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},
-{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,960},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,9,704},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,11,1792},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,832},{7,4,6},
-{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},
-{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},
-{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1600},{7,4,5},{7,8,44},{7,6,17},
-{9,9,1344},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},
-{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},
-{7,8,42},{7,6,16},{9,9,1088},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},
-{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},
-{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},
-{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1536},{7,4,5},{7,8,43},{7,6,17},{9,9,1280},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},
-{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},
-{9,9,1024},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,768},{7,4,6},{7,8,37},{9,5,128},
-{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{11,11,1856},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,896},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},
-{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1728},{7,4,5},{7,8,44},{7,6,17},{9,9,1408},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},
-{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1152},{7,4,6},
-{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},
-{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},
-{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},
-{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,960},{7,4,6},{7,8,31},{7,5,8},
-{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,12,2176},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},
-{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},
-{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1600},{7,4,5},
-{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},
-{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},
-{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},
-{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},
-{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1536},{7,4,5},{7,8,43},{7,6,17},
-{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},
-{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},
-{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,768},{7,4,6},
-{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,12,2432},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,896},{7,4,6},{7,7,19},{7,5,8},
-{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},
-{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},{7,8,44},{7,6,17},{9,9,1408},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},
-{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},
-{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},
-{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},
-{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},
-{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,960},{7,4,6},
-{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},
-{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{11,12,2048},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,40},{7,6,16},{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},
-{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1600},{7,4,5},{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},
-{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},{7,8,32},{7,5,8},
-{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},
-{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},
-{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1536},{7,4,5},
-{7,8,43},{7,6,17},{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},
-{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,9,768},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,11,1920},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},
-{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,896},{7,4,6},
-{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},
-{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},
-{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},{7,8,44},{7,6,17},
-{9,9,1408},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},
-{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},
-{7,8,42},{7,6,16},{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},
-{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},
-{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},
-{7,8,55},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},
-{7,8,53},{7,5,9},{9,8,448},{7,4,6},{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1472},{7,4,5},{7,8,43},{7,6,17},{9,9,1216},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},
-{7,8,61},{7,4,4},{7,4,2},{7,4,7},{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},
-{9,9,960},{7,4,6},{7,8,31},{7,5,8},{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,9,704},{7,4,6},{7,8,37},{9,5,128},
-{7,7,25},{7,6,15},{9,8,320},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},
-{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{11,12,2304},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,7,20},{9,5,128},{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},
-{7,7,27},{7,4,5},{7,8,40},{7,6,16},{9,9,832},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},
-{9,8,512},{7,4,6},{7,8,36},{9,5,128},{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{9,9,1600},{7,4,5},{7,8,44},{7,6,17},{9,9,1344},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},
-{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},
-{7,4,2},{7,4,7},{7,8,48},{7,4,3},{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1088},{7,4,6},
-{7,8,32},{7,5,8},{7,8,58},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},
-{7,5,11},{7,4,5},{7,7,26},{7,5,9},{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},
-{9,8,384},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},
-{9,7,256},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{0,0,0},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},
-{7,7,24},{7,6,14},{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},
-{7,8,39},{7,6,16},{9,8,576},{7,4,6},{7,7,19},{7,5,8},{7,8,55},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,45},{7,4,3},{7,5,11},{7,4,5},{7,8,53},{7,5,9},{9,8,448},{7,4,6},
-{7,8,35},{9,5,128},{7,8,51},{7,6,15},{7,8,63},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},
-{9,9,1536},{7,4,5},{7,8,43},{7,6,17},{9,9,1280},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,8,29},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},
-{9,6,1664},{7,4,6},{7,8,33},{9,5,128},{7,8,49},{7,6,14},{7,8,61},{7,4,4},{7,4,2},{7,4,7},
-{7,8,47},{7,4,3},{7,8,59},{7,4,5},{7,8,41},{7,6,16},{9,9,1024},{7,4,6},{7,8,31},{7,5,8},
-{7,8,57},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},
-{7,7,26},{7,5,9},{9,9,768},{7,4,6},{7,8,37},{9,5,128},{7,7,25},{7,6,15},{9,8,320},{7,4,4},
-{7,4,2},{7,4,7},{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},
-{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},{11,12,2560},{7,4,3},
-{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},{7,7,20},{9,5,128},{7,7,24},{7,6,14},
-{7,7,28},{7,4,4},{7,4,2},{7,4,7},{7,7,23},{7,4,3},{7,7,27},{7,4,5},{7,8,40},{7,6,16},
-{9,9,896},{7,4,6},{7,7,19},{7,5,8},{7,8,56},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7},
-{7,8,46},{7,4,3},{7,5,11},{7,4,5},{7,8,54},{7,5,9},{9,8,512},{7,4,6},{7,8,36},{9,5,128},
-{7,8,52},{7,6,15},{7,8,0},{7,4,4},{7,4,2},{7,4,7},{7,6,13},{7,4,3},{9,9,1728},{7,4,5},
-{7,8,44},{7,6,17},{9,9,1408},{7,4,6},{7,6,1},{7,5,8},{9,6,192},{9,5,64},{7,5,10},{7,4,4},
-{7,4,2},{7,4,7},{7,8,30},{7,4,3},{7,5,11},{7,4,5},{7,6,12},{7,5,9},{9,6,1664},{7,4,6},
-{7,8,34},{9,5,128},{7,8,50},{7,6,14},{7,8,62},{7,4,4},{7,4,2},{7,4,7},{7,8,48},{7,4,3},
-{7,8,60},{7,4,5},{7,8,42},{7,6,16},{9,9,1152},{7,4,6},{7,8,32},{7,5,8},{7,8,58},{9,5,64},
-{7,5,10},{7,4,4},{7,4,2},{7,4,7},{7,7,22},{7,4,3},{7,5,11},{7,4,5},{7,7,26},{7,5,9},
-{9,8,640},{7,4,6},{7,8,38},{9,5,128},{7,7,25},{7,6,15},{9,8,384},{7,4,4},{7,4,2},{7,4,7},
-{7,6,13},{7,4,3},{7,7,18},{7,4,5},{7,7,21},{7,6,17},{9,7,256},{7,4,6},{7,6,1},{7,5,8},
-{9,6,192},{9,5,64},{7,5,10},{7,4,4},{7,4,2},{7,4,7}
-};
- const TIFFFaxTabEnt TIFFFaxBlackTable[8192] = {
-{12,11,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,18},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,17},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1792},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,23},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,20},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,11,25},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,128},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,56},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,30},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1856},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,57},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,11,21},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,54},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,52},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,48},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,12,2112},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,44},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,36},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,384},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,28},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,60},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,40},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2368},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,16},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,10,64},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,18},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,10,17},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,12,1984},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,50},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,34},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1664},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,26},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1408},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,32},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1920},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,61},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,42},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,13,1024},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,13,768},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,62},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2240},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,46},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,38},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,512},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,19},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,24},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,22},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,12,2496},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,16},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,10,64},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{12,11,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,18},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,17},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1792},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,23},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,20},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,25},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,12,192},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1280},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,31},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,11,1856},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,58},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,21},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,896},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,640},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,49},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2176},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,45},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,37},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,12,448},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,29},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,13,1536},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,41},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2432},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,16},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,10,64},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,18},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,17},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,12,2048},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,51},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,35},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,320},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,27},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,59},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,33},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1920},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,256},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,43},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,13,1152},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,55},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,63},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,12,2304},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,47},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,39},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,53},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,19},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,24},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,22},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2560},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,10,16},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,10,64},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{12,11,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,10,18},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,17},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1792},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,23},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,11,20},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,25},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,12,128},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,56},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,30},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,11,1856},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,57},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,21},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,54},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,52},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,48},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2112},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,44},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,36},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,12,384},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,28},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,60},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,40},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,12,2368},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,16},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,10,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,10,64},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,18},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,17},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,1984},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,50},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,34},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,13,1728},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,26},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,13,1472},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,32},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1920},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,61},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,42},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1088},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,832},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,62},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,12,2240},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,46},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,38},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,576},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,19},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,11,24},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,22},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2496},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,16},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,10,64},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{12,11,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,18},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,10,17},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,11,1792},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,23},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,20},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,25},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,192},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1344},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,31},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,11,1856},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,58},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,21},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{10,13,960},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,13,704},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,49},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2176},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,45},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,37},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,448},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,29},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1600},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,41},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{11,12,2432},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,16},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,10,64},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,18},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,17},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2048},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,51},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,35},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{10,12,320},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,27},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,59},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,33},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{11,11,1920},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,12,256},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,43},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,13,1216},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{0,0,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,8,13},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,9,15},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,55},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,63},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2304},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,12,47},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,12,39},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,12,53},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,12},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{0,0,0},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,8,13},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,11,19},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,11,24},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,11,22},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{11,12,2560},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,7,10},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,10,16},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2},{8,10,0},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},
-{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{10,10,64},{8,2,3},
-{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,9},{8,2,3},{8,3,1},{8,2,2},
-{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,11},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},
-{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},
-{8,8,14},{8,2,3},{8,3,1},{8,2,2},{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,6,8},{8,2,3},
-{8,3,1},{8,2,2},{8,4,5},{8,2,3},{8,3,4},{8,2,2},{8,7,12},{8,2,3},{8,3,1},{8,2,2},
-{8,4,6},{8,2,3},{8,3,4},{8,2,2},{8,5,7},{8,2,3},{8,3,1},{8,2,2},{8,4,5},{8,2,3},
-{8,3,4},{8,2,2}
-};
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_flush.c b/thirdparty/libtiff/tif_flush.c
deleted file mode 100644
index 7ecc4d8..0000000
--- a/thirdparty/libtiff/tif_flush.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_flush.c,v 1.3.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- */
-#include "tiffiop.h"
-
-int
-TIFFFlush(TIFF* tif)
-{
-
-	if (tif->tif_mode != O_RDONLY) {
-		if (!TIFFFlushData(tif))
-			return (0);
-		if ((tif->tif_flags & TIFF_DIRTYDIRECT) &&
-		    !TIFFWriteDirectory(tif))
-			return (0);
-	}
-	return (1);
-}
-
-/*
- * Flush buffered data to the file.
- *
- * Frank Warmerdam'2000: I modified this to return 1 if TIFF_BEENWRITING
- * is not set, so that TIFFFlush() will proceed to write out the directory.
- * The documentation says returning 1 is an error indicator, but not having
- * been writing isn't exactly a an error.  Hopefully this doesn't cause
- * problems for other people. 
- */
-int
-TIFFFlushData(TIFF* tif)
-{
-	if ((tif->tif_flags & TIFF_BEENWRITING) == 0)
-		return (0);
-	if (tif->tif_flags & TIFF_POSTENCODE) {
-		tif->tif_flags &= ~TIFF_POSTENCODE;
-		if (!(*tif->tif_postencode)(tif))
-			return (0);
-	}
-	return (TIFFFlushData1(tif));
-}
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_getimage.c b/thirdparty/libtiff/tif_getimage.c
deleted file mode 100644
index 38455fb..0000000
--- a/thirdparty/libtiff/tif_getimage.c
+++ /dev/null
@@ -1,2676 +0,0 @@
-/* $Id: tif_getimage.c,v 1.63.2.4 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1991-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library
- *
- * Read and return a packed RGBA image.
- */
-#include "tiffiop.h"
-#include <stdio.h>
-
-static int gtTileContig(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtTileSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtStripContig(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int gtStripSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);
-static int PickContigCase(TIFFRGBAImage*);
-static int PickSeparateCase(TIFFRGBAImage*);
-static const char photoTag[] = "PhotometricInterpretation";
-
-/* 
- * Helper constants used in Orientation tag handling
- */
-#define FLIP_VERTICALLY 0x01
-#define FLIP_HORIZONTALLY 0x02
-
-/*
- * Color conversion constants. We will define display types here.
- */
-
-TIFFDisplay display_sRGB = {
-	{			/* XYZ -> luminance matrix */
-		{  3.2410F, -1.5374F, -0.4986F },
-		{  -0.9692F, 1.8760F, 0.0416F },
-		{  0.0556F, -0.2040F, 1.0570F }
-	},	
-	100.0F, 100.0F, 100.0F,	/* Light o/p for reference white */
-	255, 255, 255,		/* Pixel values for ref. white */
-	1.0F, 1.0F, 1.0F,	/* Residual light o/p for black pixel */
-	2.4F, 2.4F, 2.4F,	/* Gamma values for the three guns */
-};
-
-/*
- * Check the image to see if TIFFReadRGBAImage can deal with it.
- * 1/0 is returned according to whether or not the image can
- * be handled.  If 0 is returned, emsg contains the reason
- * why it is being rejected.
- */
-int
-TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	uint16 photometric;
-	int colorchannels;
-
-	if (!tif->tif_decodestatus) {
-		sprintf(emsg, "Sorry, requested compression method is not configured");
-		return (0);
-	}
-	switch (td->td_bitspersample) {
-		case 1:
-		case 2:
-		case 4:
-		case 8:
-		case 16:
-			break;
-		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
-			    td->td_bitspersample);
-			return (0);
-	}
-	colorchannels = td->td_samplesperpixel - td->td_extrasamples;
-	if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {
-		switch (colorchannels) {
-			case 1:
-				photometric = PHOTOMETRIC_MINISBLACK;
-				break;
-			case 3:
-				photometric = PHOTOMETRIC_RGB;
-				break;
-			default:
-				sprintf(emsg, "Missing needed %s tag", photoTag);
-				return (0);
-		}
-	}
-	switch (photometric) {
-		case PHOTOMETRIC_MINISWHITE:
-		case PHOTOMETRIC_MINISBLACK:
-		case PHOTOMETRIC_PALETTE:
-			if (td->td_planarconfig == PLANARCONFIG_CONTIG
-			    && td->td_samplesperpixel != 1
-			    && td->td_bitspersample < 8 ) {
-				sprintf(emsg,
-				    "Sorry, can not handle contiguous data with %s=%d, "
-				    "and %s=%d and Bits/Sample=%d",
-				    photoTag, photometric,
-				    "Samples/pixel", td->td_samplesperpixel,
-				    td->td_bitspersample);
-				return (0);
-			}
-			/*
-			 * We should likely validate that any extra samples are either
-			 * to be ignored, or are alpha, and if alpha we should try to use
-			 * them.  But for now we won't bother with this.
-			*/
-			break;
-		case PHOTOMETRIC_YCBCR:
-			/*
-			 * TODO: if at all meaningful and useful, make more complete
-			 * support check here, or better still, refactor to let supporting
-			 * code decide whether there is support and what meaningfull
-			 * error to return
-			 */
-			break;
-		case PHOTOMETRIC_RGB:
-			if (colorchannels < 3) {
-				sprintf(emsg, "Sorry, can not handle RGB image with %s=%d",
-				    "Color channels", colorchannels);
-				return (0);
-			}
-			break;
-		case PHOTOMETRIC_SEPARATED:
-			{
-				uint16 inkset;
-				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
-				if (inkset != INKSET_CMYK) {
-					sprintf(emsg,
-					    "Sorry, can not handle separated image with %s=%d",
-					    "InkSet", inkset);
-					return 0;
-				}
-				if (td->td_samplesperpixel < 4) {
-					sprintf(emsg,
-					    "Sorry, can not handle separated image with %s=%d",
-					    "Samples/pixel", td->td_samplesperpixel);
-					return 0;
-				}
-				break;
-			}
-		case PHOTOMETRIC_LOGL:
-			if (td->td_compression != COMPRESSION_SGILOG) {
-				sprintf(emsg, "Sorry, LogL data must have %s=%d",
-				    "Compression", COMPRESSION_SGILOG);
-				return (0);
-			}
-			break;
-		case PHOTOMETRIC_LOGLUV:
-			if (td->td_compression != COMPRESSION_SGILOG &&
-			    td->td_compression != COMPRESSION_SGILOG24) {
-				sprintf(emsg, "Sorry, LogLuv data must have %s=%d or %d",
-				    "Compression", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
-				return (0);
-			}
-			if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
-				    "Planarconfiguration", td->td_planarconfig);
-				return (0);
-			}
-			break;
-		case PHOTOMETRIC_CIELAB:
-			break;
-		default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
-			    photoTag, photometric);
-			return (0);
-	}
-	return (1);
-}
-
-void
-TIFFRGBAImageEnd(TIFFRGBAImage* img)
-{
-	if (img->Map)
-		_TIFFfree(img->Map), img->Map = NULL;
-	if (img->BWmap)
-		_TIFFfree(img->BWmap), img->BWmap = NULL;
-	if (img->PALmap)
-		_TIFFfree(img->PALmap), img->PALmap = NULL;
-	if (img->ycbcr)
-		_TIFFfree(img->ycbcr), img->ycbcr = NULL;
-	if (img->cielab)
-		_TIFFfree(img->cielab), img->cielab = NULL;
-	if( img->redcmap ) {
-		_TIFFfree( img->redcmap );
-		_TIFFfree( img->greencmap );
-		_TIFFfree( img->bluecmap );
-	}
-}
-
-static int
-isCCITTCompression(TIFF* tif)
-{
-    uint16 compress;
-    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);
-    return (compress == COMPRESSION_CCITTFAX3 ||
-	    compress == COMPRESSION_CCITTFAX4 ||
-	    compress == COMPRESSION_CCITTRLE ||
-	    compress == COMPRESSION_CCITTRLEW);
-}
-
-int
-TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])
-{
-	uint16* sampleinfo;
-	uint16 extrasamples;
-	uint16 planarconfig;
-	uint16 compress;
-	int colorchannels;
-	uint16 *red_orig, *green_orig, *blue_orig;
-	int n_color;
-
-	/* Initialize to normal values */
-	img->row_offset = 0;
-	img->col_offset = 0;
-	img->redcmap = NULL;
-	img->greencmap = NULL;
-	img->bluecmap = NULL;
-	img->req_orientation = ORIENTATION_BOTLEFT;     /* It is the default */
-
-	img->tif = tif;
-	img->stoponerr = stop;
-	TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);
-	switch (img->bitspersample) {
-		case 1:
-		case 2:
-		case 4:
-		case 8:
-		case 16:
-			break;
-		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
-			    img->bitspersample);
-			return (0);
-	}
-	img->alpha = 0;
-	TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);
-	TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,
-	    &extrasamples, &sampleinfo);
-	if (extrasamples >= 1)
-	{
-		switch (sampleinfo[0]) {
-			case EXTRASAMPLE_UNSPECIFIED:          /* Workaround for some images without */
-				if (img->samplesperpixel > 3)  /* correct info about alpha channel */
-					img->alpha = EXTRASAMPLE_ASSOCALPHA;
-				break;
-			case EXTRASAMPLE_ASSOCALPHA:           /* data is pre-multiplied */
-			case EXTRASAMPLE_UNASSALPHA:           /* data is not pre-multiplied */
-				img->alpha = sampleinfo[0];
-				break;
-		}
-	}
-
-#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA
-	if( !TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))
-		img->photometric = PHOTOMETRIC_MINISWHITE;
-
-	if( extrasamples == 0
-	    && img->samplesperpixel == 4
-	    && img->photometric == PHOTOMETRIC_RGB )
-	{
-		img->alpha = EXTRASAMPLE_ASSOCALPHA;
-		extrasamples = 1;
-	}
-#endif
-
-	colorchannels = img->samplesperpixel - extrasamples;
-	TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);
-	TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);
-	if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {
-		switch (colorchannels) {
-			case 1:
-				if (isCCITTCompression(tif))
-					img->photometric = PHOTOMETRIC_MINISWHITE;
-				else
-					img->photometric = PHOTOMETRIC_MINISBLACK;
-				break;
-			case 3:
-				img->photometric = PHOTOMETRIC_RGB;
-				break;
-			default:
-				sprintf(emsg, "Missing needed %s tag", photoTag);
-				return (0);
-		}
-	}
-	switch (img->photometric) {
-		case PHOTOMETRIC_PALETTE:
-			if (!TIFFGetField(tif, TIFFTAG_COLORMAP,
-			    &red_orig, &green_orig, &blue_orig)) {
-				sprintf(emsg, "Missing required \"Colormap\" tag");
-				return (0);
-			}
-
-			/* copy the colormaps so we can modify them */
-			n_color = (1L << img->bitspersample);
-			img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
-			img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
-			img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
-			if( !img->redcmap || !img->greencmap || !img->bluecmap ) {
-				sprintf(emsg, "Out of memory for colormap copy");
-				return (0);
-			}
-
-			_TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );
-			_TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );
-			_TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );
-
-			/* fall thru... */
-		case PHOTOMETRIC_MINISWHITE:
-		case PHOTOMETRIC_MINISBLACK:
-			if (planarconfig == PLANARCONFIG_CONTIG
-			    && img->samplesperpixel != 1
-			    && img->bitspersample < 8 ) {
-				sprintf(emsg,
-				    "Sorry, can not handle contiguous data with %s=%d, "
-				    "and %s=%d and Bits/Sample=%d",
-				    photoTag, img->photometric,
-				    "Samples/pixel", img->samplesperpixel,
-				    img->bitspersample);
-				return (0);
-			}
-			break;
-		case PHOTOMETRIC_YCBCR:
-			/* It would probably be nice to have a reality check here. */
-			if (planarconfig == PLANARCONFIG_CONTIG)
-				/* can rely on libjpeg to convert to RGB */
-				/* XXX should restore current state on exit */
-				switch (compress) {
-					case COMPRESSION_JPEG:
-						/*
-						 * TODO: when complete tests verify complete desubsampling
-						 * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in
-						 * favor of tif_getimage.c native handling
-						 */
-						TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
-						img->photometric = PHOTOMETRIC_RGB;
-						break;
-					default:
-						/* do nothing */;
-						break;
-				}
-			/*
-			 * TODO: if at all meaningful and useful, make more complete
-			 * support check here, or better still, refactor to let supporting
-			 * code decide whether there is support and what meaningfull
-			 * error to return
-			 */
-			break;
-		case PHOTOMETRIC_RGB:
-			if (colorchannels < 3) {
-				sprintf(emsg, "Sorry, can not handle RGB image with %s=%d",
-				    "Color channels", colorchannels);
-				return (0);
-			}
-			break;
-		case PHOTOMETRIC_SEPARATED:
-			{
-				uint16 inkset;
-				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
-				if (inkset != INKSET_CMYK) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
-					    "InkSet", inkset);
-					return (0);
-				}
-				if (img->samplesperpixel < 4) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
-					    "Samples/pixel", img->samplesperpixel);
-					return (0);
-				}
-			}
-			break;
-		case PHOTOMETRIC_LOGL:
-			if (compress != COMPRESSION_SGILOG) {
-				sprintf(emsg, "Sorry, LogL data must have %s=%d",
-				    "Compression", COMPRESSION_SGILOG);
-				return (0);
-			}
-			TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);
-			img->photometric = PHOTOMETRIC_MINISBLACK;	/* little white lie */
-			img->bitspersample = 8;
-			break;
-		case PHOTOMETRIC_LOGLUV:
-			if (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {
-				sprintf(emsg, "Sorry, LogLuv data must have %s=%d or %d",
-				    "Compression", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
-				return (0);
-			}
-			if (planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
-				    "Planarconfiguration", planarconfig);
-				return (0);
-			}
-			TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);
-			img->photometric = PHOTOMETRIC_RGB;		/* little white lie */
-			img->bitspersample = 8;
-			break;
-		case PHOTOMETRIC_CIELAB:
-			break;
-		default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
-			    photoTag, img->photometric);
-			return (0);
-	}
-	img->Map = NULL;
-	img->BWmap = NULL;
-	img->PALmap = NULL;
-	img->ycbcr = NULL;
-	img->cielab = NULL;
-	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);
-	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);
-	TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);
-	img->isContig =
-	    !(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);
-	if (img->isContig) {
-		if (!PickContigCase(img)) {
-			sprintf(emsg, "Sorry, can not handle image");
-			return 0;
-		}
-	} else {
-		if (!PickSeparateCase(img)) {
-			sprintf(emsg, "Sorry, can not handle image");
-			return 0;
-		}
-	}
-	return 1;
-}
-
-int
-TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
-{
-    if (img->get == NULL) {
-		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No \"get\" routine setup");
-		return (0);
-	}
-	if (img->put.any == NULL) {
-		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),
-		"No \"put\" routine setupl; probably can not handle image format");
-		return (0);
-    }
-    return (*img->get)(img, raster, w, h);
-}
-
-/*
- * Read the specified image into an ABGR-format rastertaking in account
- * specified orientation.
- */
-int
-TIFFReadRGBAImageOriented(TIFF* tif,
-			  uint32 rwidth, uint32 rheight, uint32* raster,
-			  int orientation, int stop)
-{
-    char emsg[1024] = "";
-    TIFFRGBAImage img;
-    int ok;
-
-	if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {
-		img.req_orientation = orientation;
-		/* XXX verify rwidth and rheight against width and height */
-		ok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,
-			rwidth, img.height);
-		TIFFRGBAImageEnd(&img);
-	} else {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", emsg);
-		ok = 0;
-    }
-    return (ok);
-}
-
-/*
- * Read the specified image into an ABGR-format raster. Use bottom left
- * origin for raster by default.
- */
-int
-TIFFReadRGBAImage(TIFF* tif,
-		  uint32 rwidth, uint32 rheight, uint32* raster, int stop)
-{
-	return TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,
-					 ORIENTATION_BOTLEFT, stop);
-}
-
-static int 
-setorientation(TIFFRGBAImage* img)
-{
-	switch (img->orientation) {
-		case ORIENTATION_TOPLEFT:
-		case ORIENTATION_LEFTTOP:
-			if (img->req_orientation == ORIENTATION_TOPRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTTOP)
-				return FLIP_HORIZONTALLY;
-			else if (img->req_orientation == ORIENTATION_BOTRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTBOT)
-				return FLIP_HORIZONTALLY | FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_BOTLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTBOT)
-				return FLIP_VERTICALLY;
-			else
-				return 0;
-		case ORIENTATION_TOPRIGHT:
-		case ORIENTATION_RIGHTTOP:
-			if (img->req_orientation == ORIENTATION_TOPLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTTOP)
-				return FLIP_HORIZONTALLY;
-			else if (img->req_orientation == ORIENTATION_BOTRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTBOT)
-				return FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_BOTLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTBOT)
-				return FLIP_HORIZONTALLY | FLIP_VERTICALLY;
-			else
-				return 0;
-		case ORIENTATION_BOTRIGHT:
-		case ORIENTATION_RIGHTBOT:
-			if (img->req_orientation == ORIENTATION_TOPLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTTOP)
-				return FLIP_HORIZONTALLY | FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_TOPRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTTOP)
-				return FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_BOTLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTBOT)
-				return FLIP_HORIZONTALLY;
-			else
-				return 0;
-		case ORIENTATION_BOTLEFT:
-		case ORIENTATION_LEFTBOT:
-			if (img->req_orientation == ORIENTATION_TOPLEFT ||
-			    img->req_orientation == ORIENTATION_LEFTTOP)
-				return FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_TOPRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTTOP)
-				return FLIP_HORIZONTALLY | FLIP_VERTICALLY;
-			else if (img->req_orientation == ORIENTATION_BOTRIGHT ||
-			    img->req_orientation == ORIENTATION_RIGHTBOT)
-				return FLIP_HORIZONTALLY;
-			else
-				return 0;
-		default:	/* NOTREACHED */
-			return 0;
-	}
-}
-
-/*
- * Get an tile-organized image that has
- *	PlanarConfiguration contiguous if SamplesPerPixel > 1
- * or
- *	SamplesPerPixel == 1
- */	
-static int
-gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
-{
-    TIFF* tif = img->tif;
-    tileContigRoutine put = img->put.contig;
-    uint32 col, row, y, rowstoread;
-    uint32 pos;
-    uint32 tw, th;
-    unsigned char* buf;
-    int32 fromskew, toskew;
-    uint32 nrow;
-    int ret = 1, flip;
-
-    buf = (unsigned char*) _TIFFmalloc(TIFFTileSize(tif));
-    if (buf == 0) {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
-		return (0);
-    }
-    _TIFFmemset(buf, 0, TIFFTileSize(tif));
-    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);
-    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);
-
-    flip = setorientation(img);
-    if (flip & FLIP_VERTICALLY) {
-	    y = h - 1;
-	    toskew = -(int32)(tw + w);
-    }
-    else {
-	    y = 0;
-	    toskew = -(int32)(tw - w);
-    }
-     
-    for (row = 0; row < h; row += nrow)
-    {
-        rowstoread = th - (row + img->row_offset) % th;
-    	nrow = (row + rowstoread > h ? h - row : rowstoread);
-	for (col = 0; col < w; col += tw) 
-        {
-            if (TIFFReadTile(tif, buf, col+img->col_offset,
-                             row+img->row_offset, 0, 0) < 0 && img->stoponerr)
-            {
-                ret = 0;
-                break;
-            }
-	    
-            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif);
-
-    	    if (col + tw > w) 
-            {
-                /*
-                 * Tile is clipped horizontally.  Calculate
-                 * visible portion and skewing factors.
-                 */
-                uint32 npix = w - col;
-                fromskew = tw - npix;
-                (*put)(img, raster+y*w+col, col, y,
-                       npix, nrow, fromskew, toskew + fromskew, buf + pos);
-            }
-            else 
-            {
-                (*put)(img, raster+y*w+col, col, y, tw, nrow, 0, toskew, buf + pos);
-            }
-        }
-
-        y += (flip & FLIP_VERTICALLY ? -(int32) nrow : (int32) nrow);
-    }
-    _TIFFfree(buf);
-
-    if (flip & FLIP_HORIZONTALLY) {
-	    uint32 line;
-
-	    for (line = 0; line < h; line++) {
-		    uint32 *left = raster + (line * w);
-		    uint32 *right = left + w - 1;
-		    
-		    while ( left < right ) {
-			    uint32 temp = *left;
-			    *left = *right;
-			    *right = temp;
-			    left++, right--;
-		    }
-	    }
-    }
-
-    return (ret);
-}
-
-/*
- * Get an tile-organized image that has
- *	 SamplesPerPixel > 1
- *	 PlanarConfiguration separated
- * We assume that all such images are RGB.
- */	
-static int
-gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
-{
-	TIFF* tif = img->tif;
-	tileSeparateRoutine put = img->put.separate;
-	uint32 col, row, y, rowstoread;
-	uint32 pos;
-	uint32 tw, th;
-	unsigned char* buf;
-	unsigned char* p0;
-	unsigned char* p1;
-	unsigned char* p2;
-	unsigned char* pa;
-	tsize_t tilesize;
-	int32 fromskew, toskew;
-	int alpha = img->alpha;
-	uint32 nrow;
-	int ret = 1, flip;
-
-	tilesize = TIFFTileSize(tif);
-	buf = (unsigned char*) _TIFFmalloc((alpha?4:3)*tilesize);
-	if (buf == 0) {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
-		return (0);
-	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*tilesize);
-	p0 = buf;
-	p1 = p0 + tilesize;
-	p2 = p1 + tilesize;
-	pa = (alpha?(p2+tilesize):NULL);
-	TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);
-	TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);
-
-	flip = setorientation(img);
-	if (flip & FLIP_VERTICALLY) {
-		y = h - 1;
-		toskew = -(int32)(tw + w);
-	}
-	else {
-		y = 0;
-		toskew = -(int32)(tw - w);
-	}
-
-	for (row = 0; row < h; row += nrow)
-	{
-		rowstoread = th - (row + img->row_offset) % th;
-		nrow = (row + rowstoread > h ? h - row : rowstoread);
-		for (col = 0; col < w; col += tw)
-		{
-			if (TIFFReadTile(tif, p0, col+img->col_offset,
-			    row+img->row_offset,0,0) < 0 && img->stoponerr)
-			{
-				ret = 0;
-				break;
-			}
-			if (TIFFReadTile(tif, p1, col+img->col_offset,
-			    row+img->row_offset,0,1) < 0 && img->stoponerr)
-			{
-				ret = 0;
-				break;
-			}
-			if (TIFFReadTile(tif, p2, col+img->col_offset,
-			    row+img->row_offset,0,2) < 0 && img->stoponerr)
-			{
-				ret = 0;
-				break;
-			}
-			if (alpha)
-			{
-				if (TIFFReadTile(tif,pa,col+img->col_offset,
-				    row+img->row_offset,0,3) < 0 && img->stoponerr)
-				{
-					ret = 0;
-					break;
-				}
-			}
-
-			pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif);
-
-			if (col + tw > w)
-			{
-				/*
-				 * Tile is clipped horizontally.  Calculate
-				 * visible portion and skewing factors.
-				 */
-				uint32 npix = w - col;
-				fromskew = tw - npix;
-				(*put)(img, raster+y*w+col, col, y,
-				    npix, nrow, fromskew, toskew + fromskew,
-				    p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));
-			} else {
-				(*put)(img, raster+y*w+col, col, y,
-				    tw, nrow, 0, toskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));
-			}
-		}
-
-		y += (flip & FLIP_VERTICALLY ?-(int32) nrow : (int32) nrow);
-	}
-
-	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
-
-		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
-
-			while ( left < right ) {
-				uint32 temp = *left;
-				*left = *right;
-				*right = temp;
-				left++, right--;
-			}
-		}
-	}
-
-	_TIFFfree(buf);
-	return (ret);
-}
-
-/*
- * Get a strip-organized image that has
- *	PlanarConfiguration contiguous if SamplesPerPixel > 1
- * or
- *	SamplesPerPixel == 1
- */	
-static int
-gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
-{
-	TIFF* tif = img->tif;
-	tileContigRoutine put = img->put.contig;
-	uint32 row, y, nrow, nrowsub, rowstoread;
-	uint32 pos;
-	unsigned char* buf;
-	uint32 rowsperstrip;
-	uint16 subsamplinghor,subsamplingver;
-	uint32 imagewidth = img->width;
-	tsize_t scanline;
-	int32 fromskew, toskew;
-	int ret = 1, flip;
-
-	buf = (unsigned char*) _TIFFmalloc(TIFFStripSize(tif));
-	if (buf == 0) {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for strip buffer");
-		return (0);
-	}
-	_TIFFmemset(buf, 0, TIFFStripSize(tif));
-
-	flip = setorientation(img);
-	if (flip & FLIP_VERTICALLY) {
-		y = h - 1;
-		toskew = -(int32)(w + w);
-	} else {
-		y = 0;
-		toskew = -(int32)(w - w);
-	}
-
-	TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
-	TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);
-	scanline = TIFFNewScanlineSize(tif);
-	fromskew = (w < imagewidth ? imagewidth - w : 0);
-	for (row = 0; row < h; row += nrow)
-	{
-		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
-		nrow = (row + rowstoread > h ? h - row : rowstoread);
-		nrowsub = nrow;
-		if ((nrowsub%subsamplingver)!=0)
-			nrowsub+=subsamplingver-nrowsub%subsamplingver;
-		if (TIFFReadEncodedStrip(tif,
-		    TIFFComputeStrip(tif,row+img->row_offset, 0),
-		    buf,
-		    ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline) < 0
-		    && img->stoponerr)
-		{
-			ret = 0;
-			break;
-		}
-
-		pos = ((row + img->row_offset) % rowsperstrip) * scanline;
-		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);
-		y += (flip & FLIP_VERTICALLY ? -(int32) nrow : (int32) nrow);
-	}
-
-	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
-
-		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
-
-			while ( left < right ) {
-				uint32 temp = *left;
-				*left = *right;
-				*right = temp;
-				left++, right--;
-			}
-		}
-	}
-
-	_TIFFfree(buf);
-	return (ret);
-}
-
-/*
- * Get a strip-organized image with
- *	 SamplesPerPixel > 1
- *	 PlanarConfiguration separated
- * We assume that all such images are RGB.
- */
-static int
-gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
-{
-	TIFF* tif = img->tif;
-	tileSeparateRoutine put = img->put.separate;
-	unsigned char *buf;
-	unsigned char *p0, *p1, *p2, *pa;
-	uint32 row, y, nrow, rowstoread;
-	uint32 pos;
-	tsize_t scanline;
-	uint32 rowsperstrip, offset_row;
-	uint32 imagewidth = img->width;
-	tsize_t stripsize;
-	int32 fromskew, toskew;
-	int alpha = img->alpha;
-	int ret = 1, flip;
-
-	stripsize = TIFFStripSize(tif);
-	p0 = buf = (unsigned char *)_TIFFmalloc((alpha?4:3)*stripsize);
-	if (buf == 0) {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
-		return (0);
-	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*stripsize);
-	p1 = p0 + stripsize;
-	p2 = p1 + stripsize;
-	pa = (alpha?(p2+stripsize):NULL);
-
-	flip = setorientation(img);
-	if (flip & FLIP_VERTICALLY) {
-		y = h - 1;
-		toskew = -(int32)(w + w);
-	}
-	else {
-		y = 0;
-		toskew = -(int32)(w - w);
-	}
-
-	TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
-	scanline = TIFFScanlineSize(tif);
-	fromskew = (w < imagewidth ? imagewidth - w : 0);
-	for (row = 0; row < h; row += nrow)
-	{
-		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
-		nrow = (row + rowstoread > h ? h - row : rowstoread);
-		offset_row = row + img->row_offset;
-		if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),
-		    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0
-		    && img->stoponerr)
-		{
-			ret = 0;
-			break;
-		}
-		if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),
-		    p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0
-		    && img->stoponerr)
-		{
-			ret = 0;
-			break;
-		}
-		if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),
-		    p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0
-		    && img->stoponerr)
-		{
-			ret = 0;
-			break;
-		}
-		if (alpha)
-		{
-			if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 3),
-			    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0
-			    && img->stoponerr)
-			{
-				ret = 0;
-				break;
-			}
-		}
-
-		pos = ((row + img->row_offset) % rowsperstrip) * scanline;
-		(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,
-		    p2 + pos, (alpha?(pa+pos):NULL));
-		y += (flip & FLIP_VERTICALLY ? -(int32) nrow : (int32) nrow);
-	}
-
-	if (flip & FLIP_HORIZONTALLY) {
-		uint32 line;
-
-		for (line = 0; line < h; line++) {
-			uint32 *left = raster + (line * w);
-			uint32 *right = left + w - 1;
-
-			while ( left < right ) {
-				uint32 temp = *left;
-				*left = *right;
-				*right = temp;
-				left++, right--;
-			}
-		}
-	}
-
-	_TIFFfree(buf);
-	return (ret);
-}
-
-/*
- * The following routines move decoded data returned
- * from the TIFF library into rasters filled with packed
- * ABGR pixels (i.e. suitable for passing to lrecwrite.)
- *
- * The routines have been created according to the most
- * important cases and optimized.  PickContigCase and
- * PickSeparateCase analyze the parameters and select
- * the appropriate "get" and "put" routine to use.
- */
-#define	REPEAT8(op)	REPEAT4(op); REPEAT4(op)
-#define	REPEAT4(op)	REPEAT2(op); REPEAT2(op)
-#define	REPEAT2(op)	op; op
-#define	CASE8(x,op)			\
-    switch (x) {			\
-    case 7: op; case 6: op; case 5: op;	\
-    case 4: op; case 3: op; case 2: op;	\
-    case 1: op;				\
-    }
-#define	CASE4(x,op)	switch (x) { case 3: op; case 2: op; case 1: op; }
-#define	NOP
-
-#define	UNROLL8(w, op1, op2) {		\
-    uint32 _x;				\
-    for (_x = w; _x >= 8; _x -= 8) {	\
-	op1;				\
-	REPEAT8(op2);			\
-    }					\
-    if (_x > 0) {			\
-	op1;				\
-	CASE8(_x,op2);			\
-    }					\
-}
-#define	UNROLL4(w, op1, op2) {		\
-    uint32 _x;				\
-    for (_x = w; _x >= 4; _x -= 4) {	\
-	op1;				\
-	REPEAT4(op2);			\
-    }					\
-    if (_x > 0) {			\
-	op1;				\
-	CASE4(_x,op2);			\
-    }					\
-}
-#define	UNROLL2(w, op1, op2) {		\
-    uint32 _x;				\
-    for (_x = w; _x >= 2; _x -= 2) {	\
-	op1;				\
-	REPEAT2(op2);			\
-    }					\
-    if (_x) {				\
-	op1;				\
-	op2;				\
-    }					\
-}
-    
-#define	SKEW(r,g,b,skew)	{ r += skew; g += skew; b += skew; }
-#define	SKEW4(r,g,b,a,skew)	{ r += skew; g += skew; b += skew; a+= skew; }
-
-#define A1 (((uint32)0xffL)<<24)
-#define	PACK(r,g,b)	\
-	((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|A1)
-#define	PACK4(r,g,b,a)	\
-	((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|((uint32)(a)<<24))
-#define W2B(v) (((v)>>8)&0xff)
-#define	PACKW(r,g,b)	\
-	((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|A1)
-#define	PACKW4(r,g,b,a)	\
-	((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|((uint32)W2B(a)<<24))
-
-#define	DECLAREContigPutFunc(name) \
-static void name(\
-    TIFFRGBAImage* img, \
-    uint32* cp, \
-    uint32 x, uint32 y, \
-    uint32 w, uint32 h, \
-    int32 fromskew, int32 toskew, \
-    unsigned char* pp \
-)
-
-/*
- * 8-bit palette => colormap/RGB
- */
-DECLAREContigPutFunc(put8bitcmaptile)
-{
-    uint32** PALmap = img->PALmap;
-    int samplesperpixel = img->samplesperpixel;
-
-    (void) y;
-    while (h-- > 0) {
-	for (x = w; x-- > 0;)
-        {
-	    *cp++ = PALmap[*pp][0];
-            pp += samplesperpixel;
-        }
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 4-bit palette => colormap/RGB
- */
-DECLAREContigPutFunc(put4bitcmaptile)
-{
-    uint32** PALmap = img->PALmap;
-
-    (void) x; (void) y;
-    fromskew /= 2;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 2-bit palette => colormap/RGB
- */
-DECLAREContigPutFunc(put2bitcmaptile)
-{
-    uint32** PALmap = img->PALmap;
-
-    (void) x; (void) y;
-    fromskew /= 4;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 1-bit palette => colormap/RGB
- */
-DECLAREContigPutFunc(put1bitcmaptile)
-{
-    uint32** PALmap = img->PALmap;
-
-    (void) x; (void) y;
-    fromskew /= 8;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 8-bit greyscale => colormap/RGB
- */
-DECLAREContigPutFunc(putgreytile)
-{
-    int samplesperpixel = img->samplesperpixel;
-    uint32** BWmap = img->BWmap;
-
-    (void) y;
-    while (h-- > 0) {
-	for (x = w; x-- > 0;)
-        {
-	    *cp++ = BWmap[*pp][0];
-            pp += samplesperpixel;
-        }
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 16-bit greyscale => colormap/RGB
- */
-DECLAREContigPutFunc(put16bitbwtile)
-{
-    int samplesperpixel = img->samplesperpixel;
-    uint32** BWmap = img->BWmap;
-
-    (void) y;
-    while (h-- > 0) {
-        uint16 *wp = (uint16 *) pp;
-
-	for (x = w; x-- > 0;)
-        {
-            /* use high order byte of 16bit value */
-
-	    *cp++ = BWmap[*wp >> 8][0];
-            pp += 2 * samplesperpixel;
-            wp += samplesperpixel;
-        }
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 1-bit bilevel => colormap/RGB
- */
-DECLAREContigPutFunc(put1bitbwtile)
-{
-    uint32** BWmap = img->BWmap;
-
-    (void) x; (void) y;
-    fromskew /= 8;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 2-bit greyscale => colormap/RGB
- */
-DECLAREContigPutFunc(put2bitbwtile)
-{
-    uint32** BWmap = img->BWmap;
-
-    (void) x; (void) y;
-    fromskew /= 4;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 4-bit greyscale => colormap/RGB
- */
-DECLAREContigPutFunc(put4bitbwtile)
-{
-    uint32** BWmap = img->BWmap;
-
-    (void) x; (void) y;
-    fromskew /= 2;
-    while (h-- > 0) {
-	uint32* bw;
-	UNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 8-bit packed samples, no Map => RGB
- */
-DECLAREContigPutFunc(putRGBcontig8bittile)
-{
-    int samplesperpixel = img->samplesperpixel;
-
-    (void) x; (void) y;
-    fromskew *= samplesperpixel;
-    while (h-- > 0) {
-	UNROLL8(w, NOP,
-	    *cp++ = PACK(pp[0], pp[1], pp[2]);
-	    pp += samplesperpixel);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 8-bit packed samples => RGBA w/ associated alpha
- * (known to have Map == NULL)
- */
-DECLAREContigPutFunc(putRGBAAcontig8bittile)
-{
-    int samplesperpixel = img->samplesperpixel;
-
-    (void) x; (void) y;
-    fromskew *= samplesperpixel;
-    while (h-- > 0) {
-	UNROLL8(w, NOP,
-	    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);
-	    pp += samplesperpixel);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 8-bit packed samples => RGBA w/ unassociated alpha
- * (known to have Map == NULL)
- */
-DECLAREContigPutFunc(putRGBUAcontig8bittile)
-{
-	int samplesperpixel = img->samplesperpixel;
-	(void) y;
-	fromskew *= samplesperpixel;
-	while (h-- > 0) {
-		uint32 r, g, b, a;
-		for (x = w; x-- > 0;) {
-			a = pp[3];
-                        r = (a*pp[0] + 127) / 255;
-                        g = (a*pp[1] + 127) / 255;
-                        b = (a*pp[2] + 127) / 255;
-			*cp++ = PACK4(r,g,b,a);
-			pp += samplesperpixel;
-		}
-		cp += toskew;
-		pp += fromskew;
-	}
-}
-
-/*
- * 16-bit packed samples => RGB
- */
-DECLAREContigPutFunc(putRGBcontig16bittile)
-{
-	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
-	(void) y;
-	fromskew *= samplesperpixel;
-	while (h-- > 0) {
-		for (x = w; x-- > 0;) {
-                    *cp++ = PACKW(wp[0],wp[1],wp[2]);
-                    wp += samplesperpixel;
-		}
-		cp += toskew;
-		wp += fromskew;
-	}
-}
-
-/*
- * 16-bit packed samples => RGBA w/ associated alpha
- * (known to have Map == NULL)
- */
-DECLAREContigPutFunc(putRGBAAcontig16bittile)
-{
-	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
-	(void) y;
-	fromskew *= samplesperpixel;
-	while (h-- > 0) {
-		for (x = w; x-- > 0;) {
-                    *cp++ = PACKW4(wp[0],wp[1],wp[2],wp[3]);
-                    wp += samplesperpixel;
-		}
-		cp += toskew;
-		wp += fromskew;
-	}
-}
-
-/*
- * 16-bit packed samples => RGBA w/ unassociated alpha
- * (known to have Map == NULL)
- */
-DECLAREContigPutFunc(putRGBUAcontig16bittile)
-{
-	int samplesperpixel = img->samplesperpixel;
-	uint16 *wp = (uint16 *)pp;
-	(void) y;
-	fromskew *= samplesperpixel;
-	while (h-- > 0) {
-		uint32 r,g,b,a;
-		for (x = w; x-- > 0;) {
-                    a = W2B(wp[3]);
-                    r = (a*W2B(wp[0]) + 127) / 255;
-                    g = (a*W2B(wp[1]) + 127) / 255;
-                    b = (a*W2B(wp[2]) + 127) / 255;
-                    *cp++ = PACK4(r,g,b,a);
-                    wp += samplesperpixel;
-		}
-		cp += toskew;
-		wp += fromskew;
-	}
-}
-
-/*
- * 8-bit packed CMYK samples w/o Map => RGB
- *
- * NB: The conversion of CMYK->RGB is *very* crude.
- */
-DECLAREContigPutFunc(putRGBcontig8bitCMYKtile)
-{
-    int samplesperpixel = img->samplesperpixel;
-    uint16 r, g, b, k;
-
-    (void) x; (void) y;
-    fromskew *= samplesperpixel;
-    while (h-- > 0) {
-	UNROLL8(w, NOP,
-	    k = 255 - pp[3];
-	    r = (k*(255-pp[0]))/255;
-	    g = (k*(255-pp[1]))/255;
-	    b = (k*(255-pp[2]))/255;
-	    *cp++ = PACK(r, g, b);
-	    pp += samplesperpixel);
-	cp += toskew;
-	pp += fromskew;
-    }
-}
-
-/*
- * 8-bit packed CMYK samples w/Map => RGB
- *
- * NB: The conversion of CMYK->RGB is *very* crude.
- */
-DECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)
-{
-    int samplesperpixel = img->samplesperpixel;
-    TIFFRGBValue* Map = img->Map;
-    uint16 r, g, b, k;
-
-    (void) y;
-    fromskew *= samplesperpixel;
-    while (h-- > 0) {
-	for (x = w; x-- > 0;) {
-	    k = 255 - pp[3];
-	    r = (k*(255-pp[0]))/255;
-	    g = (k*(255-pp[1]))/255;
-	    b = (k*(255-pp[2]))/255;
-	    *cp++ = PACK(Map[r], Map[g], Map[b]);
-	    pp += samplesperpixel;
-	}
-	pp += fromskew;
-	cp += toskew;
-    }
-}
-
-#define	DECLARESepPutFunc(name) \
-static void name(\
-    TIFFRGBAImage* img,\
-    uint32* cp,\
-    uint32 x, uint32 y, \
-    uint32 w, uint32 h,\
-    int32 fromskew, int32 toskew,\
-    unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a\
-)
-
-/*
- * 8-bit unpacked samples => RGB
- */
-DECLARESepPutFunc(putRGBseparate8bittile)
-{
-    (void) img; (void) x; (void) y; (void) a;
-    while (h-- > 0) {
-	UNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));
-	SKEW(r, g, b, fromskew);
-	cp += toskew;
-    }
-}
-
-/*
- * 8-bit unpacked samples => RGBA w/ associated alpha
- */
-DECLARESepPutFunc(putRGBAAseparate8bittile)
-{
-	(void) img; (void) x; (void) y;
-	while (h-- > 0) {
-		UNROLL8(w, NOP, *cp++ = PACK4(*r++, *g++, *b++, *a++));
-		SKEW4(r, g, b, a, fromskew);
-		cp += toskew;
-	}
-}
-
-/*
- * 8-bit unpacked samples => RGBA w/ unassociated alpha
- */
-DECLARESepPutFunc(putRGBUAseparate8bittile)
-{
-	(void) img; (void) y;
-	while (h-- > 0) {
-		uint32 rv, gv, bv, av;
-		for (x = w; x-- > 0;) {
-			av = *a++;
-                        rv = (av* *r++ + 127) / 255;
-                        gv = (av* *g++ + 127) / 255;
-                        bv = (av* *b++ + 127) / 255;
-			*cp++ = PACK4(rv,gv,bv,av);
-		}
-		SKEW4(r, g, b, a, fromskew);
-		cp += toskew;
-	}
-}
-
-/*
- * 16-bit unpacked samples => RGB
- */
-DECLARESepPutFunc(putRGBseparate16bittile)
-{
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
-	(void) img; (void) y; (void) a;
-	while (h-- > 0) {
-		for (x = 0; x < w; x++)
-                    *cp++ = PACKW(*wr++,*wg++,*wb++);
-		SKEW(wr, wg, wb, fromskew);
-		cp += toskew;
-	}
-}
-
-/*
- * 16-bit unpacked samples => RGBA w/ associated alpha
- */
-DECLARESepPutFunc(putRGBAAseparate16bittile)
-{
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
-	uint16 *wa = (uint16*) a;
-	(void) img; (void) y;
-	while (h-- > 0) {
-		for (x = 0; x < w; x++)
-                    *cp++ = PACKW4(*wr++,*wg++,*wb++,*wa++);
-		SKEW4(wr, wg, wb, wa, fromskew);
-		cp += toskew;
-	}
-}
-
-/*
- * 16-bit unpacked samples => RGBA w/ unassociated alpha
- */
-DECLARESepPutFunc(putRGBUAseparate16bittile)
-{
-	uint16 *wr = (uint16*) r;
-	uint16 *wg = (uint16*) g;
-	uint16 *wb = (uint16*) b;
-	uint16 *wa = (uint16*) a;
-	(void) img; (void) y;
-	while (h-- > 0) {
-		uint32 r,g,b,a;
-		for (x = w; x-- > 0;) {
-                    a = W2B(*wa++);
-                    r = (a*W2B(*wr++) + 127) / 255;
-                    g = (a*W2B(*wg++) + 127) / 255;
-                    b = (a*W2B(*wb++) + 127) / 255;
-                    *cp++ = PACK4(r,g,b,a);
-		}
-		SKEW4(wr, wg, wb, wa, fromskew);
-		cp += toskew;
-	}
-}
-
-/*
- * 8-bit packed CIE L*a*b 1976 samples => RGB
- */
-DECLAREContigPutFunc(putcontig8bitCIELab)
-{
-	float X, Y, Z;
-	uint32 r, g, b;
-	(void) y;
-	fromskew *= 3;
-	while (h-- > 0) {
-		for (x = w; x-- > 0;) {
-			TIFFCIELabToXYZ(img->cielab,
-					(unsigned char)pp[0],
-					(signed char)pp[1],
-					(signed char)pp[2],
-					&X, &Y, &Z);
-			TIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);
-			*cp++ = PACK(r, g, b);
-			pp += 3;
-		}
-		cp += toskew;
-		pp += fromskew;
-	}
-}
-
-/*
- * YCbCr -> RGB conversion and packing routines.
- */
-
-#define	YCbCrtoRGB(dst, Y) {						\
-	uint32 r, g, b;							\
-	TIFFYCbCrtoRGB(img->ycbcr, (Y), Cb, Cr, &r, &g, &b);		\
-	dst = PACK(r, g, b);						\
-}
-
-/*
- * 8-bit packed YCbCr samples => RGB 
- * This function is generic for different sampling sizes, 
- * and can handle blocks sizes that aren't multiples of the
- * sampling size.  However, it is substantially less optimized
- * than the specific sampling cases.  It is used as a fallback
- * for difficult blocks.
- */
-#ifdef notdef
-static void putcontig8bitYCbCrGenericTile( 
-    TIFFRGBAImage* img, 
-    uint32* cp, 
-    uint32 x, uint32 y, 
-    uint32 w, uint32 h, 
-    int32 fromskew, int32 toskew, 
-    unsigned char* pp,
-    int h_group, 
-    int v_group )
-
-{
-    uint32* cp1 = cp+w+toskew;
-    uint32* cp2 = cp1+w+toskew;
-    uint32* cp3 = cp2+w+toskew;
-    int32 incr = 3*w+4*toskew;
-    int32   Cb, Cr;
-    int     group_size = v_group * h_group + 2;
-
-    (void) y;
-    fromskew = (fromskew * group_size) / h_group;
-
-    for( yy = 0; yy < h; yy++ )
-    {
-        unsigned char *pp_line;
-        int     y_line_group = yy / v_group;
-        int     y_remainder = yy - y_line_group * v_group;
-
-        pp_line = pp + v_line_group * 
-
-        
-        for( xx = 0; xx < w; xx++ )
-        {
-            Cb = pp
-        }
-    }
-    for (; h >= 4; h -= 4) {
-	x = w>>2;
-	do {
-	    Cb = pp[16];
-	    Cr = pp[17];
-
-	    YCbCrtoRGB(cp [0], pp[ 0]);
-	    YCbCrtoRGB(cp [1], pp[ 1]);
-	    YCbCrtoRGB(cp [2], pp[ 2]);
-	    YCbCrtoRGB(cp [3], pp[ 3]);
-	    YCbCrtoRGB(cp1[0], pp[ 4]);
-	    YCbCrtoRGB(cp1[1], pp[ 5]);
-	    YCbCrtoRGB(cp1[2], pp[ 6]);
-	    YCbCrtoRGB(cp1[3], pp[ 7]);
-	    YCbCrtoRGB(cp2[0], pp[ 8]);
-	    YCbCrtoRGB(cp2[1], pp[ 9]);
-	    YCbCrtoRGB(cp2[2], pp[10]);
-	    YCbCrtoRGB(cp2[3], pp[11]);
-	    YCbCrtoRGB(cp3[0], pp[12]);
-	    YCbCrtoRGB(cp3[1], pp[13]);
-	    YCbCrtoRGB(cp3[2], pp[14]);
-	    YCbCrtoRGB(cp3[3], pp[15]);
-
-	    cp += 4, cp1 += 4, cp2 += 4, cp3 += 4;
-	    pp += 18;
-	} while (--x);
-	cp += incr, cp1 += incr, cp2 += incr, cp3 += incr;
-	pp += fromskew;
-    }
-}
-#endif
-
-/*
- * 8-bit packed YCbCr samples w/ 4,4 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr44tile)
-{
-    uint32* cp1 = cp+w+toskew;
-    uint32* cp2 = cp1+w+toskew;
-    uint32* cp3 = cp2+w+toskew;
-    int32 incr = 3*w+4*toskew;
-
-    (void) y;
-    /* adjust fromskew */
-    fromskew = (fromskew * 18) / 4;
-    if ((h & 3) == 0 && (w & 3) == 0) {				        
-        for (; h >= 4; h -= 4) {
-            x = w>>2;
-            do {
-                int32 Cb = pp[16];
-                int32 Cr = pp[17];
-
-                YCbCrtoRGB(cp [0], pp[ 0]);
-                YCbCrtoRGB(cp [1], pp[ 1]);
-                YCbCrtoRGB(cp [2], pp[ 2]);
-                YCbCrtoRGB(cp [3], pp[ 3]);
-                YCbCrtoRGB(cp1[0], pp[ 4]);
-                YCbCrtoRGB(cp1[1], pp[ 5]);
-                YCbCrtoRGB(cp1[2], pp[ 6]);
-                YCbCrtoRGB(cp1[3], pp[ 7]);
-                YCbCrtoRGB(cp2[0], pp[ 8]);
-                YCbCrtoRGB(cp2[1], pp[ 9]);
-                YCbCrtoRGB(cp2[2], pp[10]);
-                YCbCrtoRGB(cp2[3], pp[11]);
-                YCbCrtoRGB(cp3[0], pp[12]);
-                YCbCrtoRGB(cp3[1], pp[13]);
-                YCbCrtoRGB(cp3[2], pp[14]);
-                YCbCrtoRGB(cp3[3], pp[15]);
-
-                cp += 4, cp1 += 4, cp2 += 4, cp3 += 4;
-                pp += 18;
-            } while (--x);
-            cp += incr, cp1 += incr, cp2 += incr, cp3 += incr;
-            pp += fromskew;
-        }
-    } else {
-        while (h > 0) {
-            for (x = w; x > 0;) {
-                int32 Cb = pp[16];
-                int32 Cr = pp[17];
-                switch (x) {
-                default:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp3[3], pp[15]); /* FALLTHROUGH */
-                    case 3:  YCbCrtoRGB(cp2[3], pp[11]); /* FALLTHROUGH */
-                    case 2:  YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 3:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp3[2], pp[14]); /* FALLTHROUGH */
-                    case 3:  YCbCrtoRGB(cp2[2], pp[10]); /* FALLTHROUGH */
-                    case 2:  YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 2:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp3[1], pp[13]); /* FALLTHROUGH */
-                    case 3:  YCbCrtoRGB(cp2[1], pp[ 9]); /* FALLTHROUGH */
-                    case 2:  YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 1:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp3[0], pp[12]); /* FALLTHROUGH */
-                    case 3:  YCbCrtoRGB(cp2[0], pp[ 8]); /* FALLTHROUGH */
-                    case 2:  YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                }
-                if (x < 4) {
-                    cp += x; cp1 += x; cp2 += x; cp3 += x;
-                    x = 0;
-                }
-                else {
-                    cp += 4; cp1 += 4; cp2 += 4; cp3 += 4;
-                    x -= 4;
-                }
-                pp += 18;
-            }
-            if (h <= 4)
-                break;
-            h -= 4;
-            cp += incr, cp1 += incr, cp2 += incr, cp3 += incr;
-            pp += fromskew;
-        }
-    }
-}
-
-/*
- * 8-bit packed YCbCr samples w/ 4,2 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr42tile)
-{
-    uint32* cp1 = cp+w+toskew;
-    int32 incr = 2*toskew+w;
-
-    (void) y;
-    fromskew = (fromskew * 10) / 4;
-    if ((h & 3) == 0 && (w & 1) == 0) {
-        for (; h >= 2; h -= 2) {
-            x = w>>2;
-            do {
-                int32 Cb = pp[8];
-                int32 Cr = pp[9];
-                
-                YCbCrtoRGB(cp [0], pp[0]);
-                YCbCrtoRGB(cp [1], pp[1]);
-                YCbCrtoRGB(cp [2], pp[2]);
-                YCbCrtoRGB(cp [3], pp[3]);
-                YCbCrtoRGB(cp1[0], pp[4]);
-                YCbCrtoRGB(cp1[1], pp[5]);
-                YCbCrtoRGB(cp1[2], pp[6]);
-                YCbCrtoRGB(cp1[3], pp[7]);
-                
-                cp += 4, cp1 += 4;
-                pp += 10;
-            } while (--x);
-            cp += incr, cp1 += incr;
-            pp += fromskew;
-        }
-    } else {
-        while (h > 0) {
-            for (x = w; x > 0;) {
-                int32 Cb = pp[8];
-                int32 Cr = pp[9];
-                switch (x) {
-                default:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 3:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 2:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                case 1:
-                    switch (h) {
-                    default: YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */
-                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */
-                    }                                    /* FALLTHROUGH */
-                }
-                if (x < 4) {
-                    cp += x; cp1 += x;
-                    x = 0;
-                }
-                else {
-                    cp += 4; cp1 += 4;
-                    x -= 4;
-                }
-                pp += 10;
-            }
-            if (h <= 2)
-                break;
-            h -= 2;
-            cp += incr, cp1 += incr;
-            pp += fromskew;
-        }
-    }
-}
-
-/*
- * 8-bit packed YCbCr samples w/ 4,1 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr41tile)
-{
-    (void) y;
-    /* XXX adjust fromskew */
-    do {
-	x = w>>2;
-	do {
-	    int32 Cb = pp[4];
-	    int32 Cr = pp[5];
-
-	    YCbCrtoRGB(cp [0], pp[0]);
-	    YCbCrtoRGB(cp [1], pp[1]);
-	    YCbCrtoRGB(cp [2], pp[2]);
-	    YCbCrtoRGB(cp [3], pp[3]);
-
-	    cp += 4;
-	    pp += 6;
-	} while (--x);
-
-        if( (w&3) != 0 )
-        {
-	    int32 Cb = pp[4];
-	    int32 Cr = pp[5];
-
-            switch( (w&3) ) {
-              case 3: YCbCrtoRGB(cp [2], pp[2]);
-              case 2: YCbCrtoRGB(cp [1], pp[1]);
-              case 1: YCbCrtoRGB(cp [0], pp[0]);
-              case 0: break;
-            }
-
-            cp += (w&3);
-            pp += 6;
-        }
-
-	cp += toskew;
-	pp += fromskew;
-    } while (--h);
-
-}
-
-/*
- * 8-bit packed YCbCr samples w/ 2,2 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr22tile)
-{
-	uint32* cp2;
-	(void) y;
-	fromskew = (fromskew / 2) * 6;
-	cp2 = cp+w+toskew;
-	while (h>=2) {
-		x = w;
-		while (x>=2) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
-			YCbCrtoRGB(cp[0], pp[0]);
-			YCbCrtoRGB(cp[1], pp[1]);
-			YCbCrtoRGB(cp2[0], pp[2]);
-			YCbCrtoRGB(cp2[1], pp[3]);
-			cp += 2;
-			cp2 += 2;
-			pp += 6;
-			x -= 2;
-		}
-		if (x==1) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
-			YCbCrtoRGB(cp[0], pp[0]);
-			YCbCrtoRGB(cp2[0], pp[2]);
-			cp ++ ;
-			cp2 ++ ;
-			pp += 6;
-		}
-		cp += toskew*2+w;
-		cp2 += toskew*2+w;
-		pp += fromskew;
-		h-=2;
-	}
-	if (h==1) {
-		x = w;
-		while (x>=2) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
-			YCbCrtoRGB(cp[0], pp[0]);
-			YCbCrtoRGB(cp[1], pp[1]);
-			cp += 2;
-			cp2 += 2;
-			pp += 6;
-			x -= 2;
-		}
-		if (x==1) {
-			uint32 Cb = pp[4];
-			uint32 Cr = pp[5];
-			YCbCrtoRGB(cp[0], pp[0]);
-		}
-	}
-}
-
-/*
- * 8-bit packed YCbCr samples w/ 2,1 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr21tile)
-{
-	(void) y;
-	fromskew = (fromskew * 4) / 2;
-	do {
-		x = w>>1;
-		do {
-			int32 Cb = pp[2];
-			int32 Cr = pp[3];
-
-			YCbCrtoRGB(cp[0], pp[0]);
-			YCbCrtoRGB(cp[1], pp[1]);
-
-			cp += 2;
-			pp += 4;
-		} while (--x);
-
-		if( (w&1) != 0 )
-		{
-			int32 Cb = pp[2];
-			int32 Cr = pp[3];
-
-			YCbCrtoRGB(cp[0], pp[0]);
-
-			cp += 1;
-			pp += 4;
-		}
-
-		cp += toskew;
-		pp += fromskew;
-	} while (--h);
-}
-
-/*
- * 8-bit packed YCbCr samples w/ 1,2 subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr12tile)
-{
-	uint32* cp2;
-	(void) y;
-	fromskew = (fromskew / 2) * 4;
-	cp2 = cp+w+toskew;
-	while (h>=2) {
-		x = w;
-		do {
-			uint32 Cb = pp[2];
-			uint32 Cr = pp[3];
-			YCbCrtoRGB(cp[0], pp[0]);
-			YCbCrtoRGB(cp2[0], pp[1]);
-			cp ++;
-			cp2 ++;
-			pp += 4;
-		} while (--x);
-		cp += toskew*2+w;
-		cp2 += toskew*2+w;
-		pp += fromskew;
-		h-=2;
-	}
-	if (h==1) {
-		x = w;
-		do {
-			uint32 Cb = pp[2];
-			uint32 Cr = pp[3];
-			YCbCrtoRGB(cp[0], pp[0]);
-			cp ++;
-			pp += 4;
-		} while (--x);
-	}
-}
-
-/*
- * 8-bit packed YCbCr samples w/ no subsampling => RGB
- */
-DECLAREContigPutFunc(putcontig8bitYCbCr11tile)
-{
-	(void) y;
-	fromskew *= 3;
-	do {
-		x = w; /* was x = w>>1; patched 2000/09/25 warmerda@home.com */
-		do {
-			int32 Cb = pp[1];
-			int32 Cr = pp[2];
-
-			YCbCrtoRGB(*cp++, pp[0]);
-
-			pp += 3;
-		} while (--x);
-		cp += toskew;
-		pp += fromskew;
-	} while (--h);
-}
-
-/*
- * 8-bit packed YCbCr samples w/ no subsampling => RGB
- */
-DECLARESepPutFunc(putseparate8bitYCbCr11tile)
-{
-	(void) y;
-	(void) a;
-	/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */
-	while (h-- > 0) {
-		x = w;
-		do {
-			uint32 dr, dg, db;
-			TIFFYCbCrtoRGB(img->ycbcr,*r++,*g++,*b++,&dr,&dg,&db);
-			*cp++ = PACK(dr,dg,db);
-		} while (--x);
-		SKEW(r, g, b, fromskew);
-		cp += toskew;
-	}
-}
-#undef YCbCrtoRGB
-
-static int
-initYCbCrConversion(TIFFRGBAImage* img)
-{
-	static char module[] = "initYCbCrConversion";
-
-	float *luma, *refBlackWhite;
-
-	if (img->ycbcr == NULL) {
-		img->ycbcr = (TIFFYCbCrToRGB*) _TIFFmalloc(
-		    TIFFroundup(sizeof (TIFFYCbCrToRGB), sizeof (long))
-		    + 4*256*sizeof (TIFFRGBValue)
-		    + 2*256*sizeof (int)
-		    + 3*256*sizeof (int32)
-		    );
-		if (img->ycbcr == NULL) {
-			TIFFErrorExt(img->tif->tif_clientdata, module,
-			    "No space for YCbCr->RGB conversion state");
-			return (0);
-		}
-	}
-
-	TIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRCOEFFICIENTS, &luma);
-	TIFFGetFieldDefaulted(img->tif, TIFFTAG_REFERENCEBLACKWHITE,
-	    &refBlackWhite);
-	if (TIFFYCbCrToRGBInit(img->ycbcr, luma, refBlackWhite) < 0)
-		return(0);
-	return (1);
-}
-
-static tileContigRoutine
-initCIELabConversion(TIFFRGBAImage* img)
-{
-	static char module[] = "initCIELabConversion";
-
-	float   *whitePoint;
-	float   refWhite[3];
-
-	if (!img->cielab) {
-		img->cielab = (TIFFCIELabToRGB *)
-			_TIFFmalloc(sizeof(TIFFCIELabToRGB));
-		if (!img->cielab) {
-			TIFFErrorExt(img->tif->tif_clientdata, module,
-			    "No space for CIE L*a*b*->RGB conversion state.");
-			return NULL;
-		}
-	}
-
-	TIFFGetFieldDefaulted(img->tif, TIFFTAG_WHITEPOINT, &whitePoint);
-	refWhite[1] = 100.0F;
-	refWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];
-	refWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])
-		      / whitePoint[1] * refWhite[1];
-	if (TIFFCIELabToRGBInit(img->cielab, &display_sRGB, refWhite) < 0) {
-		TIFFErrorExt(img->tif->tif_clientdata, module,
-		    "Failed to initialize CIE L*a*b*->RGB conversion state.");
-		_TIFFfree(img->cielab);
-		return NULL;
-	}
-
-	return putcontig8bitCIELab;
-}
-
-/*
- * Greyscale images with less than 8 bits/sample are handled
- * with a table to avoid lots of shifts and masks.  The table
- * is setup so that put*bwtile (below) can retrieve 8/bitspersample
- * pixel values simply by indexing into the table with one
- * number.
- */
-static int
-makebwmap(TIFFRGBAImage* img)
-{
-    TIFFRGBValue* Map = img->Map;
-    int bitspersample = img->bitspersample;
-    int nsamples = 8 / bitspersample;
-    int i;
-    uint32* p;
-
-    if( nsamples == 0 )
-        nsamples = 1;
-
-    img->BWmap = (uint32**) _TIFFmalloc(
-	256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));
-    if (img->BWmap == NULL) {
-		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No space for B&W mapping table");
-		return (0);
-    }
-    p = (uint32*)(img->BWmap + 256);
-    for (i = 0; i < 256; i++) {
-	TIFFRGBValue c;
-	img->BWmap[i] = p;
-	switch (bitspersample) {
-#define	GREY(x)	c = Map[x]; *p++ = PACK(c,c,c);
-	case 1:
-	    GREY(i>>7);
-	    GREY((i>>6)&1);
-	    GREY((i>>5)&1);
-	    GREY((i>>4)&1);
-	    GREY((i>>3)&1);
-	    GREY((i>>2)&1);
-	    GREY((i>>1)&1);
-	    GREY(i&1);
-	    break;
-	case 2:
-	    GREY(i>>6);
-	    GREY((i>>4)&3);
-	    GREY((i>>2)&3);
-	    GREY(i&3);
-	    break;
-	case 4:
-	    GREY(i>>4);
-	    GREY(i&0xf);
-	    break;
-	case 8:
-        case 16:
-	    GREY(i);
-	    break;
-	}
-#undef	GREY
-    }
-    return (1);
-}
-
-/*
- * Construct a mapping table to convert from the range
- * of the data samples to [0,255] --for display.  This
- * process also handles inverting B&W images when needed.
- */ 
-static int
-setupMap(TIFFRGBAImage* img)
-{
-    int32 x, range;
-
-    range = (int32)((1L<<img->bitspersample)-1);
-    
-    /* treat 16 bit the same as eight bit */
-    if( img->bitspersample == 16 )
-        range = (int32) 255;
-
-    img->Map = (TIFFRGBValue*) _TIFFmalloc((range+1) * sizeof (TIFFRGBValue));
-    if (img->Map == NULL) {
-		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),
-			"No space for photometric conversion table");
-		return (0);
-    }
-    if (img->photometric == PHOTOMETRIC_MINISWHITE) {
-	for (x = 0; x <= range; x++)
-	    img->Map[x] = (TIFFRGBValue) (((range - x) * 255) / range);
-    } else {
-	for (x = 0; x <= range; x++)
-	    img->Map[x] = (TIFFRGBValue) ((x * 255) / range);
-    }
-    if (img->bitspersample <= 16 &&
-	(img->photometric == PHOTOMETRIC_MINISBLACK ||
-	 img->photometric == PHOTOMETRIC_MINISWHITE)) {
-	/*
-	 * Use photometric mapping table to construct
-	 * unpacking tables for samples <= 8 bits.
-	 */
-	if (!makebwmap(img))
-	    return (0);
-	/* no longer need Map, free it */
-	_TIFFfree(img->Map), img->Map = NULL;
-    }
-    return (1);
-}
-
-static int
-checkcmap(TIFFRGBAImage* img)
-{
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
-    long n = 1L<<img->bitspersample;
-
-    while (n-- > 0)
-	if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)
-	    return (16);
-    return (8);
-}
-
-static void
-cvtcmap(TIFFRGBAImage* img)
-{
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
-    long i;
-
-    for (i = (1L<<img->bitspersample)-1; i >= 0; i--) {
-#define	CVT(x)		((uint16)((x)>>8))
-	r[i] = CVT(r[i]);
-	g[i] = CVT(g[i]);
-	b[i] = CVT(b[i]);
-#undef	CVT
-    }
-}
-
-/*
- * Palette images with <= 8 bits/sample are handled
- * with a table to avoid lots of shifts and masks.  The table
- * is setup so that put*cmaptile (below) can retrieve 8/bitspersample
- * pixel values simply by indexing into the table with one
- * number.
- */
-static int
-makecmap(TIFFRGBAImage* img)
-{
-    int bitspersample = img->bitspersample;
-    int nsamples = 8 / bitspersample;
-    uint16* r = img->redcmap;
-    uint16* g = img->greencmap;
-    uint16* b = img->bluecmap;
-    uint32 *p;
-    int i;
-
-    img->PALmap = (uint32**) _TIFFmalloc(
-	256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));
-    if (img->PALmap == NULL) {
-		TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "No space for Palette mapping table");
-		return (0);
-	}
-    p = (uint32*)(img->PALmap + 256);
-    for (i = 0; i < 256; i++) {
-	TIFFRGBValue c;
-	img->PALmap[i] = p;
-#define	CMAP(x)	c = (TIFFRGBValue) x; *p++ = PACK(r[c]&0xff, g[c]&0xff, b[c]&0xff);
-	switch (bitspersample) {
-	case 1:
-	    CMAP(i>>7);
-	    CMAP((i>>6)&1);
-	    CMAP((i>>5)&1);
-	    CMAP((i>>4)&1);
-	    CMAP((i>>3)&1);
-	    CMAP((i>>2)&1);
-	    CMAP((i>>1)&1);
-	    CMAP(i&1);
-	    break;
-	case 2:
-	    CMAP(i>>6);
-	    CMAP((i>>4)&3);
-	    CMAP((i>>2)&3);
-	    CMAP(i&3);
-	    break;
-	case 4:
-	    CMAP(i>>4);
-	    CMAP(i&0xf);
-	    break;
-	case 8:
-	    CMAP(i);
-	    break;
-	}
-#undef CMAP
-    }
-    return (1);
-}
-
-/* 
- * Construct any mapping table used
- * by the associated put routine.
- */
-static int
-buildMap(TIFFRGBAImage* img)
-{
-    switch (img->photometric) {
-    case PHOTOMETRIC_RGB:
-    case PHOTOMETRIC_YCBCR:
-    case PHOTOMETRIC_SEPARATED:
-	if (img->bitspersample == 8)
-	    break;
-	/* fall thru... */
-    case PHOTOMETRIC_MINISBLACK:
-    case PHOTOMETRIC_MINISWHITE:
-	if (!setupMap(img))
-	    return (0);
-	break;
-    case PHOTOMETRIC_PALETTE:
-	/*
-	 * Convert 16-bit colormap to 8-bit (unless it looks
-	 * like an old-style 8-bit colormap).
-	 */
-	if (checkcmap(img) == 16)
-	    cvtcmap(img);
-	else
-	    TIFFWarningExt(img->tif->tif_clientdata, TIFFFileName(img->tif), "Assuming 8-bit colormap");
-	/*
-	 * Use mapping table and colormap to construct
-	 * unpacking tables for samples < 8 bits.
-	 */
-	if (img->bitspersample <= 8 && !makecmap(img))
-	    return (0);
-	break;
-    }
-    return (1);
-}
-
-/*
- * Select the appropriate conversion routine for packed data.
- */
-static int
-PickContigCase(TIFFRGBAImage* img)
-{
-	img->get = TIFFIsTiled(img->tif) ? gtTileContig : gtStripContig;
-	img->put.contig = NULL;
-	switch (img->photometric) {
-		case PHOTOMETRIC_RGB:
-			switch (img->bitspersample) {
-				case 8:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
-						img->put.contig = putRGBAAcontig8bittile;
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
-					{
-                                            img->put.contig = putRGBUAcontig8bittile;
-					}
-					else
-                                            img->put.contig = putRGBcontig8bittile;
-					break;
-				case 16:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
-					{
-                                            img->put.contig = putRGBAAcontig16bittile;
-					}
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
-					{
-                                            img->put.contig = putRGBUAcontig16bittile;
-					}
-					else
-					{
-                                            img->put.contig = putRGBcontig16bittile;
-					}
-					break;
-			}
-			break;
-		case PHOTOMETRIC_SEPARATED:
-			if (buildMap(img)) {
-				if (img->bitspersample == 8) {
-					if (!img->Map)
-						img->put.contig = putRGBcontig8bitCMYKtile;
-					else
-						img->put.contig = putRGBcontig8bitCMYKMaptile;
-				}
-			}
-			break;
-		case PHOTOMETRIC_PALETTE:
-			if (buildMap(img)) {
-				switch (img->bitspersample) {
-					case 8:
-						img->put.contig = put8bitcmaptile;
-						break;
-					case 4:
-						img->put.contig = put4bitcmaptile;
-						break;
-					case 2:
-						img->put.contig = put2bitcmaptile;
-						break;
-					case 1:
-						img->put.contig = put1bitcmaptile;
-						break;
-				}
-			}
-			break;
-		case PHOTOMETRIC_MINISWHITE:
-		case PHOTOMETRIC_MINISBLACK:
-			if (buildMap(img)) {
-				switch (img->bitspersample) {
-					case 16:
-						img->put.contig = put16bitbwtile;
-						break;
-					case 8:
-						img->put.contig = putgreytile;
-						break;
-					case 4:
-						img->put.contig = put4bitbwtile;
-						break;
-					case 2:
-						img->put.contig = put2bitbwtile;
-						break;
-					case 1:
-						img->put.contig = put1bitbwtile;
-						break;
-				}
-			}
-			break;
-		case PHOTOMETRIC_YCBCR:
-			if (img->bitspersample == 8)
-			{
-				if (initYCbCrConversion(img)!=0)
-				{
-					/*
-					 * The 6.0 spec says that subsampling must be
-					 * one of 1, 2, or 4, and that vertical subsampling
-					 * must always be <= horizontal subsampling; so
-					 * there are only a few possibilities and we just
-					 * enumerate the cases.
-					 * Joris: added support for the [1,2] case, nonetheless, to accomodate
-					 * some OJPEG files
-					 */
-					uint16 SubsamplingHor;
-					uint16 SubsamplingVer;
-					TIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &SubsamplingHor, &SubsamplingVer);
-					switch ((SubsamplingHor<<4)|SubsamplingVer) {
-						case 0x44:
-							img->put.contig = putcontig8bitYCbCr44tile;
-							break;
-						case 0x42:
-							img->put.contig = putcontig8bitYCbCr42tile;
-							break;
-						case 0x41:
-							img->put.contig = putcontig8bitYCbCr41tile;
-							break;
-						case 0x22:
-							img->put.contig = putcontig8bitYCbCr22tile;
-							break;
-						case 0x21:
-							img->put.contig = putcontig8bitYCbCr21tile;
-							break;
-						case 0x12:
-							img->put.contig = putcontig8bitYCbCr12tile;
-							break;
-						case 0x11:
-							img->put.contig = putcontig8bitYCbCr11tile;
-							break;
-					}
-				}
-			}
-			break;
-		case PHOTOMETRIC_CIELAB:
-			if (buildMap(img)) {
-				if (img->bitspersample == 8)
-					img->put.contig = initCIELabConversion(img);
-				break;
-			}
-	}
-	return ((img->get!=NULL) && (img->put.contig!=NULL));
-}
-
-/*
- * Select the appropriate conversion routine for unpacked data.
- *
- * NB: we assume that unpacked single channel data is directed
- *	 to the "packed routines.
- */
-static int
-PickSeparateCase(TIFFRGBAImage* img)
-{
-	img->get = TIFFIsTiled(img->tif) ? gtTileSeparate : gtStripSeparate;
-	img->put.separate = NULL;
-	switch (img->photometric) {
-		case PHOTOMETRIC_RGB:
-			switch (img->bitspersample) {
-				case 8:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
-						img->put.separate = putRGBAAseparate8bittile;
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
-					{
-                                            img->put.separate = putRGBUAseparate8bittile;
-					}
-					else
-						img->put.separate = putRGBseparate8bittile;
-					break;
-				case 16:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
-					{
-                                            img->put.separate = putRGBAAseparate16bittile;
-					}
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
-					{
-                                            img->put.separate = putRGBUAseparate16bittile;
-					}
-					else
-					{
-                                            img->put.separate = putRGBseparate16bittile;
-					}
-					break;
-			}
-			break;
-		case PHOTOMETRIC_YCBCR:
-			if ((img->bitspersample==8) && (img->samplesperpixel==3))
-			{
-				if (initYCbCrConversion(img)!=0)
-				{
-					uint16 hs, vs;
-					TIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &hs, &vs);
-					switch ((hs<<4)|vs) {
-						case 0x11:
-							img->put.separate = putseparate8bitYCbCr11tile;
-							break;
-						/* TODO: add other cases here */
-					}
-				}
-			}
-			break;
-	}
-	return ((img->get!=NULL) && (img->put.separate!=NULL));
-}
-
-/*
- * Read a whole strip off data from the file, and convert to RGBA form.
- * If this is the last strip, then it will only contain the portion of
- * the strip that is actually within the image space.  The result is
- * organized in bottom to top form.
- */
-
-
-int
-TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )
-
-{
-    char 	emsg[1024] = "";
-    TIFFRGBAImage img;
-    int 	ok;
-    uint32	rowsperstrip, rows_to_read;
-
-    if( TIFFIsTiled( tif ) )
-    {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),
-                  "Can't use TIFFReadRGBAStrip() with tiled file.");
-	return (0);
-    }
-    
-    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
-    if( (row % rowsperstrip) != 0 )
-    {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),
-				"Row passed to TIFFReadRGBAStrip() must be first in a strip.");
-		return (0);
-    }
-
-    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, 0, emsg)) {
-
-        img.row_offset = row;
-        img.col_offset = 0;
-
-        if( row + rowsperstrip > img.height )
-            rows_to_read = img.height - row;
-        else
-            rows_to_read = rowsperstrip;
-        
-	ok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );
-        
-	TIFFRGBAImageEnd(&img);
-    } else {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", emsg);
-		ok = 0;
-    }
-    
-    return (ok);
-}
-
-/*
- * Read a whole tile off data from the file, and convert to RGBA form.
- * The returned RGBA data is organized from bottom to top of tile,
- * and may include zeroed areas if the tile extends off the image.
- */
-
-int
-TIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)
-
-{
-    char 	emsg[1024] = "";
-    TIFFRGBAImage img;
-    int 	ok;
-    uint32	tile_xsize, tile_ysize;
-    uint32	read_xsize, read_ysize;
-    uint32	i_row;
-
-    /*
-     * Verify that our request is legal - on a tile file, and on a
-     * tile boundary.
-     */
-    
-    if( !TIFFIsTiled( tif ) )
-    {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),
-				  "Can't use TIFFReadRGBATile() with stripped file.");
-		return (0);
-    }
-    
-    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);
-    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);
-    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )
-    {
-		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),
-                  "Row/col passed to TIFFReadRGBATile() must be top"
-                  "left corner of a tile.");
-	return (0);
-    }
-
-    /*
-     * Setup the RGBA reader.
-     */
-    
-    if (!TIFFRGBAImageOK(tif, emsg) 
-	|| !TIFFRGBAImageBegin(&img, tif, 0, emsg)) {
-	    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", emsg);
-	    return( 0 );
-    }
-
-    /*
-     * The TIFFRGBAImageGet() function doesn't allow us to get off the
-     * edge of the image, even to fill an otherwise valid tile.  So we
-     * figure out how much we can read, and fix up the tile buffer to
-     * a full tile configuration afterwards.
-     */
-
-    if( row + tile_ysize > img.height )
-        read_ysize = img.height - row;
-    else
-        read_ysize = tile_ysize;
-    
-    if( col + tile_xsize > img.width )
-        read_xsize = img.width - col;
-    else
-        read_xsize = tile_xsize;
-
-    /*
-     * Read the chunk of imagery.
-     */
-    
-    img.row_offset = row;
-    img.col_offset = col;
-
-    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );
-        
-    TIFFRGBAImageEnd(&img);
-
-    /*
-     * If our read was incomplete we will need to fix up the tile by
-     * shifting the data around as if a full tile of data is being returned.
-     *
-     * This is all the more complicated because the image is organized in
-     * bottom to top format. 
-     */
-
-    if( read_xsize == tile_xsize && read_ysize == tile_ysize )
-        return( ok );
-
-    for( i_row = 0; i_row < read_ysize; i_row++ ) {
-        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,
-                 raster + (read_ysize - i_row - 1) * read_xsize,
-                 read_xsize * sizeof(uint32) );
-        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,
-                     0, sizeof(uint32) * (tile_xsize - read_xsize) );
-    }
-
-    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {
-        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,
-                     0, sizeof(uint32) * tile_xsize );
-    }
-
-    return (ok);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_jbig.c b/thirdparty/libtiff/tif_jbig.c
deleted file mode 100644
index c92ee3d..0000000
--- a/thirdparty/libtiff/tif_jbig.c
+++ /dev/null
@@ -1,385 +0,0 @@
-/* $Id: tif_jbig.c,v 1.2.2.3 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * JBIG Compression Algorithm Support.
- * Contributed by Lee Howard <faxguy@deanox.com>
- * 
- */
-
-#include "tiffiop.h"
-
-#ifdef JBIG_SUPPORT
-#include "jbig.h"
-
-typedef struct
-{
-        uint32  recvparams;     /* encoded Class 2 session params             */
-        char*   subaddress;     /* subaddress string                          */
-        uint32  recvtime;       /* time spend receiving in seconds            */
-        char*   faxdcs;         /* encoded fax parameters (DCS, Table 2/T.30) */
-
-        TIFFVGetMethod vgetparent;
-        TIFFVSetMethod vsetparent;
-} JBIGState;
-
-#define GetJBIGState(tif) ((JBIGState*)(tif)->tif_data)
-
-#define FIELD_RECVPARAMS        (FIELD_CODEC+0)
-#define FIELD_SUBADDRESS        (FIELD_CODEC+1)
-#define FIELD_RECVTIME          (FIELD_CODEC+2)
-#define FIELD_FAXDCS            (FIELD_CODEC+3)
-
-static const TIFFFieldInfo jbigFieldInfo[] = 
-{
-        {TIFFTAG_FAXRECVPARAMS,  1,  1, TIFF_LONG,  FIELD_RECVPARAMS, TRUE, FALSE, "FaxRecvParams"},
-        {TIFFTAG_FAXSUBADDRESS, -1, -1, TIFF_ASCII, FIELD_SUBADDRESS, TRUE, FALSE, "FaxSubAddress"},
-        {TIFFTAG_FAXRECVTIME,    1,  1, TIFF_LONG,  FIELD_RECVTIME,   TRUE, FALSE, "FaxRecvTime"},
-        {TIFFTAG_FAXDCS,        -1, -1, TIFF_ASCII, FIELD_FAXDCS,     TRUE, FALSE, "FaxDcs"},
-};
-
-static int JBIGSetupDecode(TIFF* tif)
-{
-        if (TIFFNumberOfStrips(tif) != 1)
-        {
-                TIFFError("JBIG", "Multistrip images not supported in decoder");
-                return 0;
-        }
-
-        return 1;
-}
-
-static int JBIGDecode(TIFF* tif, tidata_t buffer, tsize_t size, tsample_t s)
-{
-        struct jbg_dec_state decoder;
-        int decodeStatus = 0;
-        unsigned char* pImage = NULL;
-	(void) size, (void) s;
-
-        if (isFillOrder(tif, tif->tif_dir.td_fillorder))
-        {
-                TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);
-        }
-
-        jbg_dec_init(&decoder);
-
-#if defined(HAVE_JBG_NEWLEN)
-        jbg_newlen(tif->tif_rawdata, tif->tif_rawdatasize);
-        /*
-         * I do not check the return status of jbg_newlen because even if this
-         * function fails it does not necessarily mean that decoding the image
-         * will fail.  It is generally only needed for received fax images
-         * that do not contain the actual length of the image in the BIE
-         * header.  I do not log when an error occurs because that will cause
-         * problems when converting JBIG encoded TIFF's to 
-         * PostScript.  As long as the actual image length is contained in the
-         * BIE header jbg_dec_in should succeed.
-         */
-#endif /* HAVE_JBG_NEWLEN */
-
-        decodeStatus = jbg_dec_in(&decoder, tif->tif_rawdata,
-                                  tif->tif_rawdatasize, NULL);
-        if (JBG_EOK != decodeStatus)
-        {
-		/*
-		 * XXX: JBG_EN constant was defined in pre-2.0 releases of the
-		 * JBIG-KIT. Since the 2.0 the error reporting functions were
-		 * changed. We will handle both cases here.
-		 */
-                TIFFError("JBIG", "Error (%d) decoding: %s", decodeStatus,
-#if defined(JBG_EN)
-			  jbg_strerror(decodeStatus, JBG_EN)
-#else
-                          jbg_strerror(decodeStatus)
-#endif
-			 );
-                return 0;
-        }
-        
-        pImage = jbg_dec_getimage(&decoder, 0);
-        _TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));
-        jbg_dec_free(&decoder);
-        return 1;
-}
-
-static int JBIGSetupEncode(TIFF* tif)
-{
-        if (TIFFNumberOfStrips(tif) != 1)
-        {
-                TIFFError("JBIG", "Multistrip images not supported in encoder");
-                return 0;
-        }
-
-        return 1;
-}
-
-static int JBIGCopyEncodedData(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s)
-{
-        (void) s;
-        while (cc > 0) 
-        {
-                tsize_t n = cc;
-
-                if (tif->tif_rawcc + n > tif->tif_rawdatasize)
-                {
-                        n = tif->tif_rawdatasize - tif->tif_rawcc;
-                }
-
-                assert(n > 0);
-                _TIFFmemcpy(tif->tif_rawcp, pp, n);
-                tif->tif_rawcp += n;
-                tif->tif_rawcc += n;
-                pp += n;
-                cc -= n;
-                if (tif->tif_rawcc >= tif->tif_rawdatasize &&
-                    !TIFFFlushData1(tif))
-                {
-                        return (-1);
-                }
-        }
-
-        return (1);
-}
-
-static void JBIGOutputBie(unsigned char* buffer, size_t len, void *userData)
-{
-        TIFF* tif = (TIFF*)userData;
-
-        if (isFillOrder(tif, tif->tif_dir.td_fillorder))
-        {
-                TIFFReverseBits(buffer, len);
-        }
-
-        JBIGCopyEncodedData(tif, buffer, len, 0);
-}
-
-static int JBIGEncode(TIFF* tif, tidata_t buffer, tsize_t size, tsample_t s)
-{
-        TIFFDirectory* dir = &tif->tif_dir;
-        struct jbg_enc_state encoder;
-
-	(void) size, (void) s;
-
-        jbg_enc_init(&encoder, 
-                     dir->td_imagewidth, 
-                     dir->td_imagelength, 
-                     1, 
-                     &buffer,
-                     JBIGOutputBie,
-                     tif);
-        /* 
-         * jbg_enc_out does the "real" encoding.  As data is encoded,
-         * JBIGOutputBie is called, which writes the data to the directory.
-         */
-        jbg_enc_out(&encoder);
-        jbg_enc_free(&encoder);
-
-        return 1;
-}
-
-static void JBIGCleanup(TIFF* tif)
-{
-        JBIGState *sp = GetJBIGState(tif);
-
-        assert(sp != 0);
-
-        tif->tif_tagmethods.vgetfield = sp->vgetparent;
-        tif->tif_tagmethods.vsetfield = sp->vsetparent;
-
-	_TIFFfree(tif->tif_data);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-static void JBIGPrintDir(TIFF* tif, FILE* fd, long flags)
-{
-        JBIGState* codec = GetJBIGState(tif);
-        (void)flags;
-
-        if (TIFFFieldSet(tif, FIELD_RECVPARAMS))
-        {
-                fprintf(fd, 
-                        "  Fax Receive Parameters: %08lx\n",
-                        (unsigned long)codec->recvparams);
-        }
-
-        if (TIFFFieldSet(tif, FIELD_SUBADDRESS))
-        {
-                fprintf(fd, 
-                        "  Fax SubAddress: %s\n", 
-                        codec->subaddress);
-        }
-
-        if (TIFFFieldSet(tif, FIELD_RECVTIME))
-        {
-                fprintf(fd, 
-                        "  Fax Receive Time: %lu secs\n",
-                        (unsigned long)codec->recvtime);
-        }
-
-        if (TIFFFieldSet(tif, FIELD_FAXDCS))
-        {
-                fprintf(fd, 
-                        "  Fax DCS: %s\n", 
-                        codec->faxdcs);
-        }
-}
-
-static int JBIGVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-        JBIGState* codec = GetJBIGState(tif);
-
-        switch (tag)
-        {
-                case TIFFTAG_FAXRECVPARAMS:
-                        *va_arg(ap, uint32*) = codec->recvparams;
-                        break;
-                
-                case TIFFTAG_FAXSUBADDRESS:
-                        *va_arg(ap, char**) = codec->subaddress;
-                        break;
-
-                case TIFFTAG_FAXRECVTIME:
-                        *va_arg(ap, uint32*) = codec->recvtime;
-                        break;
-
-                case TIFFTAG_FAXDCS:
-                        *va_arg(ap, char**) = codec->faxdcs;
-                        break;
-
-                default:
-                        return (*codec->vgetparent)(tif, tag, ap);
-        }
-
-        return 1;
-}
-
-static int JBIGVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-        JBIGState* codec = GetJBIGState(tif);
-
-        switch (tag)
-        {
-                case TIFFTAG_FAXRECVPARAMS:
-                        codec->recvparams = va_arg(ap, uint32);
-                        break;
-
-                case TIFFTAG_FAXSUBADDRESS:
-                        _TIFFsetString(&codec->subaddress, va_arg(ap, char*));
-                        break;
-
-                case TIFFTAG_FAXRECVTIME:
-                        codec->recvtime = va_arg(ap, uint32);
-                        break;
-
-                case TIFFTAG_FAXDCS:
-                        _TIFFsetString(&codec->faxdcs, va_arg(ap, char*));
-                        break;
-
-                default:
-                        return (*codec->vsetparent)(tif, tag, ap);
-        }
-
-        TIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit);
-        tif->tif_flags |= TIFF_DIRTYDIRECT;
-        return 1;
-}
-
-int TIFFInitJBIG(TIFF* tif, int scheme)
-{
-        JBIGState* codec = NULL;
-
-	assert(scheme == COMPRESSION_JBIG);
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, jbigFieldInfo,
-				 TIFFArrayCount(jbigFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, "TIFFInitJBIG",
-			     "Merging JBIG codec-specific tags failed");
-		return 0;
-	}
-
-        /* Allocate memory for the JBIGState structure.*/
-        tif->tif_data = (tdata_t)_TIFFmalloc(sizeof(JBIGState));
-        if (tif->tif_data == NULL)
-        {
-                TIFFError("TIFFInitJBIG", "Not enough memory for JBIGState");
-                return 0;
-        }
-        _TIFFmemset(tif->tif_data, 0, sizeof(JBIGState));
-        codec = GetJBIGState(tif);
-
-        /* Initialize codec private fields */
-        codec->recvparams = 0;
-        codec->subaddress = NULL;
-        codec->faxdcs = NULL;
-        codec->recvtime = 0;
-
-	/* 
-	 * Override parent get/set field methods.
-	 */
-        codec->vgetparent = tif->tif_tagmethods.vgetfield;
-        codec->vsetparent = tif->tif_tagmethods.vsetfield;
-        tif->tif_tagmethods.vgetfield = JBIGVGetField;
-        tif->tif_tagmethods.vsetfield = JBIGVSetField;
-        tif->tif_tagmethods.printdir = JBIGPrintDir;
-
-        /*
-         * These flags are set so the JBIG Codec can control when to reverse
-         * bits and when not to and to allow the jbig decoder and bit reverser
-         * to write to memory when necessary.
-         */
-        tif->tif_flags |= TIFF_NOBITREV;
-        tif->tif_flags &= ~TIFF_MAPPED;
-
-        /* Setup the function pointers for encode, decode, and cleanup. */
-        tif->tif_setupdecode = JBIGSetupDecode;
-        tif->tif_decodestrip = JBIGDecode;
-
-        tif->tif_setupencode = JBIGSetupEncode;
-        tif->tif_encodestrip = JBIGEncode;
-        
-        tif->tif_cleanup = JBIGCleanup;
-
-        return 1;
-}
-
-#endif /* JBIG_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_jpeg.c b/thirdparty/libtiff/tif_jpeg.c
deleted file mode 100644
index a967827..0000000
--- a/thirdparty/libtiff/tif_jpeg.c
+++ /dev/null
@@ -1,2065 +0,0 @@
-/* $Id: tif_jpeg.c,v 1.50.2.9 2010-06-14 02:47:16 fwarmerdam Exp $ */
-
-/*
- * Copyright (c) 1994-1997 Sam Leffler
- * Copyright (c) 1994-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#define WIN32_LEAN_AND_MEAN
-#define VC_EXTRALEAN
-
-#include "tiffiop.h"
-#ifdef JPEG_SUPPORT
-
-/*
- * TIFF Library
- *
- * JPEG Compression support per TIFF Technical Note #2
- * (*not* per the original TIFF 6.0 spec).
- *
- * This file is simply an interface to the libjpeg library written by
- * the Independent JPEG Group.  You need release 5 or later of the IJG
- * code, which you can find on the Internet at ftp.uu.net:/graphics/jpeg/.
- *
- * Contributed by Tom Lane <tgl@sss.pgh.pa.us>.
- */
-#include <setjmp.h>
-
-int TIFFFillStrip(TIFF*, tstrip_t);
-int TIFFFillTile(TIFF*, ttile_t);
-
-/* We undefine FAR to avoid conflict with JPEG definition */
-
-#ifdef FAR
-#undef FAR
-#endif
-
-/*
-  Libjpeg's jmorecfg.h defines INT16 and INT32, but only if XMD_H is
-  not defined.  Unfortunately, the MinGW and Borland compilers include
-  a typedef for INT32, which causes a conflict.  MSVC does not include
-  a conficting typedef given the headers which are included.
-*/
-#if defined(__BORLANDC__) || defined(__MINGW32__)
-# define XMD_H 1
-#endif
-
-/*
-   The windows RPCNDR.H file defines boolean, but defines it with the
-   unsigned char size.  You should compile JPEG library using appropriate
-   definitions in jconfig.h header, but many users compile library in wrong
-   way. That causes errors of the following type:
-
-   "JPEGLib: JPEG parameter struct mismatch: library thinks size is 432,
-   caller expects 464"
-
-   For such users we wil fix the problem here. See install.doc file from
-   the JPEG library distribution for details.
-*/
-
-/* Define "boolean" as unsigned char, not int, per Windows custom. */
-#if defined(WIN32) && !defined(__MINGW32__)
-# ifndef __RPCNDR_H__            /* don't conflict if rpcndr.h already read */
-   typedef unsigned char boolean;
-# endif
-# define HAVE_BOOLEAN            /* prevent jmorecfg.h from redefining it */
-#endif
-
-#include "jpeglib.h"
-#include "jerror.h"
-
-/*
- * We are using width_in_blocks which is supposed to be private to
- * libjpeg. Unfortunately, the libjpeg delivered with Cygwin has
- * renamed this member to width_in_data_units.  Since the header has
- * also renamed a define, use that unique define name in order to
- * detect the problem header and adjust to suit.
- */
-#if defined(D_MAX_DATA_UNITS_IN_MCU)
-#define width_in_blocks width_in_data_units
-#endif
-
-/*
- * On some machines it may be worthwhile to use _setjmp or sigsetjmp
- * in place of plain setjmp.  These macros will make it easier.
- */
-#define SETJMP(jbuf)		setjmp(jbuf)
-#define LONGJMP(jbuf,code)	longjmp(jbuf,code)
-#define JMP_BUF			jmp_buf
-
-typedef struct jpeg_destination_mgr jpeg_destination_mgr;
-typedef struct jpeg_source_mgr jpeg_source_mgr;
-typedef	struct jpeg_error_mgr jpeg_error_mgr;
-
-/*
- * State block for each open TIFF file using
- * libjpeg to do JPEG compression/decompression.
- *
- * libjpeg's visible state is either a jpeg_compress_struct
- * or jpeg_decompress_struct depending on which way we
- * are going.  comm can be used to refer to the fields
- * which are common to both.
- *
- * NB: cinfo is required to be the first member of JPEGState,
- *     so we can safely cast JPEGState* -> jpeg_xxx_struct*
- *     and vice versa!
- */
-typedef	struct {
-	union {
-		struct jpeg_compress_struct c;
-		struct jpeg_decompress_struct d;
-		struct jpeg_common_struct comm;
-	} cinfo;			/* NB: must be first */
-        int             cinfo_initialized;
-
-	jpeg_error_mgr	err;		/* libjpeg error manager */
-	JMP_BUF		exit_jmpbuf;	/* for catching libjpeg failures */
-	/*
-	 * The following two members could be a union, but
-	 * they're small enough that it's not worth the effort.
-	 */
-	jpeg_destination_mgr dest;	/* data dest for compression */
-	jpeg_source_mgr	src;		/* data source for decompression */
-					/* private state */
-	TIFF*		tif;		/* back link needed by some code */
-	uint16		photometric;	/* copy of PhotometricInterpretation */
-	uint16		h_sampling;	/* luminance sampling factors */
-	uint16		v_sampling;
-	tsize_t		bytesperline;	/* decompressed bytes per scanline */
-	/* pointers to intermediate buffers when processing downsampled data */
-	JSAMPARRAY	ds_buffer[MAX_COMPONENTS];
-	int		scancount;	/* number of "scanlines" accumulated */
-	int		samplesperclump;
-
-	TIFFVGetMethod	vgetparent;	/* super-class method */
-	TIFFVSetMethod	vsetparent;	/* super-class method */
-	TIFFPrintMethod printdir;	/* super-class method */
-	TIFFStripMethod	defsparent;	/* super-class method */
-	TIFFTileMethod	deftparent;	/* super-class method */
-					/* pseudo-tag fields */
-	void*		jpegtables;	/* JPEGTables tag value, or NULL */
-	uint32		jpegtables_length; /* number of bytes in same */
-	int		jpegquality;	/* Compression quality level */
-	int		jpegcolormode;	/* Auto RGB<=>YCbCr convert? */
-	int		jpegtablesmode;	/* What to put in JPEGTables */
-
-        int             ycbcrsampling_fetched;
-	uint32		recvparams;	/* encoded Class 2 session params */
-	char*		subaddress;	/* subaddress string */
-	uint32		recvtime;	/* time spent receiving (secs) */
-	char*		faxdcs;		/* encoded fax parameters (DCS, Table 2/T.30) */
-} JPEGState;
-
-#define	JState(tif)	((JPEGState*)(tif)->tif_data)
-
-static	int JPEGDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int JPEGDecodeRaw(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int JPEGEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int JPEGEncodeRaw(TIFF*, tidata_t, tsize_t, tsample_t);
-static  int JPEGInitializeLibJPEG( TIFF * tif,
-								   int force_encode, int force_decode );
-
-#define	FIELD_JPEGTABLES	(FIELD_CODEC+0)
-#define	FIELD_RECVPARAMS	(FIELD_CODEC+1)
-#define	FIELD_SUBADDRESS	(FIELD_CODEC+2)
-#define	FIELD_RECVTIME		(FIELD_CODEC+3)
-#define	FIELD_FAXDCS		(FIELD_CODEC+4)
-
-static const TIFFFieldInfo jpegFieldInfo[] = {
-    { TIFFTAG_JPEGTABLES,	 -3,-3,	TIFF_UNDEFINED,	FIELD_JPEGTABLES,
-      FALSE,	TRUE,	"JPEGTables" },
-    { TIFFTAG_JPEGQUALITY,	 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      TRUE,	FALSE,	"" },
-    { TIFFTAG_JPEGCOLORMODE,	 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      FALSE,	FALSE,	"" },
-    { TIFFTAG_JPEGTABLESMODE,	 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      FALSE,	FALSE,	"" },
-    /* Specific for JPEG in faxes */
-    { TIFFTAG_FAXRECVPARAMS,	 1, 1, TIFF_LONG,	FIELD_RECVPARAMS,
-      TRUE,	FALSE,	"FaxRecvParams" },
-    { TIFFTAG_FAXSUBADDRESS,	-1,-1, TIFF_ASCII,	FIELD_SUBADDRESS,
-      TRUE,	FALSE,	"FaxSubAddress" },
-    { TIFFTAG_FAXRECVTIME,	 1, 1, TIFF_LONG,	FIELD_RECVTIME,
-      TRUE,	FALSE,	"FaxRecvTime" },
-    { TIFFTAG_FAXDCS,		-1, -1, TIFF_ASCII,	FIELD_FAXDCS,
-	  TRUE,	FALSE,	"FaxDcs" },
-};
-#define	N(a)	(sizeof (a) / sizeof (a[0]))
-
-/*
- * libjpeg interface layer.
- *
- * We use setjmp/longjmp to return control to libtiff
- * when a fatal error is encountered within the JPEG
- * library.  We also direct libjpeg error and warning
- * messages through the appropriate libtiff handlers.
- */
-
-/*
- * Error handling routines (these replace corresponding
- * IJG routines from jerror.c).  These are used for both
- * compression and decompression.
- */
-static void
-TIFFjpeg_error_exit(j_common_ptr cinfo)
-{
-	JPEGState *sp = (JPEGState *) cinfo;	/* NB: cinfo assumed first */
-	char buffer[JMSG_LENGTH_MAX];
-
-	(*cinfo->err->format_message) (cinfo, buffer);
-	TIFFErrorExt(sp->tif->tif_clientdata, "JPEGLib", "%s", buffer);		/* display the error message */
-	jpeg_abort(cinfo);			/* clean up libjpeg state */
-	LONGJMP(sp->exit_jmpbuf, 1);		/* return to libtiff caller */
-}
-
-/*
- * This routine is invoked only for warning messages,
- * since error_exit does its own thing and trace_level
- * is never set > 0.
- */
-static void
-TIFFjpeg_output_message(j_common_ptr cinfo)
-{
-	char buffer[JMSG_LENGTH_MAX];
-
-	(*cinfo->err->format_message) (cinfo, buffer);
-	TIFFWarningExt(((JPEGState *) cinfo)->tif->tif_clientdata, "JPEGLib", "%s", buffer);
-}
-
-/*
- * Interface routines.  This layer of routines exists
- * primarily to limit side-effects from using setjmp.
- * Also, normal/error returns are converted into return
- * values per libtiff practice.
- */
-#define	CALLJPEG(sp, fail, op)	(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))
-#define	CALLVJPEG(sp, op)	CALLJPEG(sp, 0, ((op),1))
-
-static int
-TIFFjpeg_create_compress(JPEGState* sp)
-{
-	/* initialize JPEG error handling */
-	sp->cinfo.c.err = jpeg_std_error(&sp->err);
-	sp->err.error_exit = TIFFjpeg_error_exit;
-	sp->err.output_message = TIFFjpeg_output_message;
-
-	return CALLVJPEG(sp, jpeg_create_compress(&sp->cinfo.c));
-}
-
-static int
-TIFFjpeg_create_decompress(JPEGState* sp)
-{
-	/* initialize JPEG error handling */
-	sp->cinfo.d.err = jpeg_std_error(&sp->err);
-	sp->err.error_exit = TIFFjpeg_error_exit;
-	sp->err.output_message = TIFFjpeg_output_message;
-
-	return CALLVJPEG(sp, jpeg_create_decompress(&sp->cinfo.d));
-}
-
-static int
-TIFFjpeg_set_defaults(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_set_defaults(&sp->cinfo.c));
-}
-
-static int
-TIFFjpeg_set_colorspace(JPEGState* sp, J_COLOR_SPACE colorspace)
-{
-	return CALLVJPEG(sp, jpeg_set_colorspace(&sp->cinfo.c, colorspace));
-}
-
-static int
-TIFFjpeg_set_quality(JPEGState* sp, int quality, boolean force_baseline)
-{
-	return CALLVJPEG(sp,
-	    jpeg_set_quality(&sp->cinfo.c, quality, force_baseline));
-}
-
-static int
-TIFFjpeg_suppress_tables(JPEGState* sp, boolean suppress)
-{
-	return CALLVJPEG(sp, jpeg_suppress_tables(&sp->cinfo.c, suppress));
-}
-
-static int
-TIFFjpeg_start_compress(JPEGState* sp, boolean write_all_tables)
-{
-	return CALLVJPEG(sp,
-	    jpeg_start_compress(&sp->cinfo.c, write_all_tables));
-}
-
-static int
-TIFFjpeg_write_scanlines(JPEGState* sp, JSAMPARRAY scanlines, int num_lines)
-{
-	return CALLJPEG(sp, -1, (int) jpeg_write_scanlines(&sp->cinfo.c,
-	    scanlines, (JDIMENSION) num_lines));
-}
-
-static int
-TIFFjpeg_write_raw_data(JPEGState* sp, JSAMPIMAGE data, int num_lines)
-{
-	return CALLJPEG(sp, -1, (int) jpeg_write_raw_data(&sp->cinfo.c,
-	    data, (JDIMENSION) num_lines));
-}
-
-static int
-TIFFjpeg_finish_compress(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_finish_compress(&sp->cinfo.c));
-}
-
-static int
-TIFFjpeg_write_tables(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_write_tables(&sp->cinfo.c));
-}
-
-static int
-TIFFjpeg_read_header(JPEGState* sp, boolean require_image)
-{
-	return CALLJPEG(sp, -1, jpeg_read_header(&sp->cinfo.d, require_image));
-}
-
-static int
-TIFFjpeg_start_decompress(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_start_decompress(&sp->cinfo.d));
-}
-
-static int
-TIFFjpeg_read_scanlines(JPEGState* sp, JSAMPARRAY scanlines, int max_lines)
-{
-	return CALLJPEG(sp, -1, (int) jpeg_read_scanlines(&sp->cinfo.d,
-	    scanlines, (JDIMENSION) max_lines));
-}
-
-static int
-TIFFjpeg_read_raw_data(JPEGState* sp, JSAMPIMAGE data, int max_lines)
-{
-	return CALLJPEG(sp, -1, (int) jpeg_read_raw_data(&sp->cinfo.d,
-	    data, (JDIMENSION) max_lines));
-}
-
-static int
-TIFFjpeg_finish_decompress(JPEGState* sp)
-{
-	return CALLJPEG(sp, -1, (int) jpeg_finish_decompress(&sp->cinfo.d));
-}
-
-static int
-TIFFjpeg_abort(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_abort(&sp->cinfo.comm));
-}
-
-static int
-TIFFjpeg_destroy(JPEGState* sp)
-{
-	return CALLVJPEG(sp, jpeg_destroy(&sp->cinfo.comm));
-}
-
-static JSAMPARRAY
-TIFFjpeg_alloc_sarray(JPEGState* sp, int pool_id,
-		      JDIMENSION samplesperrow, JDIMENSION numrows)
-{
-	return CALLJPEG(sp, (JSAMPARRAY) NULL,
-	    (*sp->cinfo.comm.mem->alloc_sarray)
-		(&sp->cinfo.comm, pool_id, samplesperrow, numrows));
-}
-
-/*
- * JPEG library destination data manager.
- * These routines direct compressed data from libjpeg into the
- * libtiff output buffer.
- */
-
-static void
-std_init_destination(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-	TIFF* tif = sp->tif;
-
-	sp->dest.next_output_byte = (JOCTET*) tif->tif_rawdata;
-	sp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;
-}
-
-static boolean
-std_empty_output_buffer(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-	TIFF* tif = sp->tif;
-
-	/* the entire buffer has been filled */
-	tif->tif_rawcc = tif->tif_rawdatasize;
-	TIFFFlushData1(tif);
-	sp->dest.next_output_byte = (JOCTET*) tif->tif_rawdata;
-	sp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;
-
-	return (TRUE);
-}
-
-static void
-std_term_destination(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-	TIFF* tif = sp->tif;
-
-	tif->tif_rawcp = (tidata_t) sp->dest.next_output_byte;
-	tif->tif_rawcc =
-	    tif->tif_rawdatasize - (tsize_t) sp->dest.free_in_buffer;
-	/* NB: libtiff does the final buffer flush */
-}
-
-static void
-TIFFjpeg_data_dest(JPEGState* sp, TIFF* tif)
-{
-	(void) tif;
-	sp->cinfo.c.dest = &sp->dest;
-	sp->dest.init_destination = std_init_destination;
-	sp->dest.empty_output_buffer = std_empty_output_buffer;
-	sp->dest.term_destination = std_term_destination;
-}
-
-/*
- * Alternate destination manager for outputting to JPEGTables field.
- */
-
-static void
-tables_init_destination(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-
-	/* while building, jpegtables_length is allocated buffer size */
-	sp->dest.next_output_byte = (JOCTET*) sp->jpegtables;
-	sp->dest.free_in_buffer = (size_t) sp->jpegtables_length;
-}
-
-static boolean
-tables_empty_output_buffer(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-	void* newbuf;
-
-	/* the entire buffer has been filled; enlarge it by 1000 bytes */
-	newbuf = _TIFFrealloc((tdata_t) sp->jpegtables,
-			      (tsize_t) (sp->jpegtables_length + 1000));
-	if (newbuf == NULL)
-		ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 100);
-	sp->dest.next_output_byte = (JOCTET*) newbuf + sp->jpegtables_length;
-	sp->dest.free_in_buffer = (size_t) 1000;
-	sp->jpegtables = newbuf;
-	sp->jpegtables_length += 1000;
-	return (TRUE);
-}
-
-static void
-tables_term_destination(j_compress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-
-	/* set tables length to number of bytes actually emitted */
-	sp->jpegtables_length -= sp->dest.free_in_buffer;
-}
-
-static int
-TIFFjpeg_tables_dest(JPEGState* sp, TIFF* tif)
-{
-	(void) tif;
-	/*
-	 * Allocate a working buffer for building tables.
-	 * Initial size is 1000 bytes, which is usually adequate.
-	 */
-	if (sp->jpegtables)
-		_TIFFfree(sp->jpegtables);
-	sp->jpegtables_length = 1000;
-	sp->jpegtables = (void*) _TIFFmalloc((tsize_t) sp->jpegtables_length);
-	if (sp->jpegtables == NULL) {
-		sp->jpegtables_length = 0;
-		TIFFErrorExt(sp->tif->tif_clientdata, "TIFFjpeg_tables_dest", "No space for JPEGTables");
-		return (0);
-	}
-	sp->cinfo.c.dest = &sp->dest;
-	sp->dest.init_destination = tables_init_destination;
-	sp->dest.empty_output_buffer = tables_empty_output_buffer;
-	sp->dest.term_destination = tables_term_destination;
-	return (1);
-}
-
-/*
- * JPEG library source data manager.
- * These routines supply compressed data to libjpeg.
- */
-
-static void
-std_init_source(j_decompress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-	TIFF* tif = sp->tif;
-
-	sp->src.next_input_byte = (const JOCTET*) tif->tif_rawdata;
-	sp->src.bytes_in_buffer = (size_t) tif->tif_rawcc;
-}
-
-static boolean
-std_fill_input_buffer(j_decompress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState* ) cinfo;
-	static const JOCTET dummy_EOI[2] = { 0xFF, JPEG_EOI };
-
-	/*
-	 * Should never get here since entire strip/tile is
-	 * read into memory before the decompressor is called,
-	 * and thus was supplied by init_source.
-	 */
-	WARNMS(cinfo, JWRN_JPEG_EOF);
-	/* insert a fake EOI marker */
-	sp->src.next_input_byte = dummy_EOI;
-	sp->src.bytes_in_buffer = 2;
-	return (TRUE);
-}
-
-static void
-std_skip_input_data(j_decompress_ptr cinfo, long num_bytes)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-
-	if (num_bytes > 0) {
-		if (num_bytes > (long) sp->src.bytes_in_buffer) {
-			/* oops, buffer overrun */
-			(void) std_fill_input_buffer(cinfo);
-		} else {
-			sp->src.next_input_byte += (size_t) num_bytes;
-			sp->src.bytes_in_buffer -= (size_t) num_bytes;
-		}
-	}
-}
-
-static void
-std_term_source(j_decompress_ptr cinfo)
-{
-	/* No work necessary here */
-	/* Or must we update tif->tif_rawcp, tif->tif_rawcc ??? */
-	/* (if so, need empty tables_term_source!) */
-	(void) cinfo;
-}
-
-static void
-TIFFjpeg_data_src(JPEGState* sp, TIFF* tif)
-{
-	(void) tif;
-	sp->cinfo.d.src = &sp->src;
-	sp->src.init_source = std_init_source;
-	sp->src.fill_input_buffer = std_fill_input_buffer;
-	sp->src.skip_input_data = std_skip_input_data;
-	sp->src.resync_to_restart = jpeg_resync_to_restart;
-	sp->src.term_source = std_term_source;
-	sp->src.bytes_in_buffer = 0;		/* for safety */
-	sp->src.next_input_byte = NULL;
-}
-
-/*
- * Alternate source manager for reading from JPEGTables.
- * We can share all the code except for the init routine.
- */
-
-static void
-tables_init_source(j_decompress_ptr cinfo)
-{
-	JPEGState* sp = (JPEGState*) cinfo;
-
-	sp->src.next_input_byte = (const JOCTET*) sp->jpegtables;
-	sp->src.bytes_in_buffer = (size_t) sp->jpegtables_length;
-}
-
-static void
-TIFFjpeg_tables_src(JPEGState* sp, TIFF* tif)
-{
-	TIFFjpeg_data_src(sp, tif);
-	sp->src.init_source = tables_init_source;
-}
-
-/*
- * Allocate downsampled-data buffers needed for downsampled I/O.
- * We use values computed in jpeg_start_compress or jpeg_start_decompress.
- * We use libjpeg's allocator so that buffers will be released automatically
- * when done with strip/tile.
- * This is also a handy place to compute samplesperclump, bytesperline.
- */
-static int
-alloc_downsampled_buffers(TIFF* tif, jpeg_component_info* comp_info,
-			  int num_components)
-{
-	JPEGState* sp = JState(tif);
-	int ci;
-	jpeg_component_info* compptr;
-	JSAMPARRAY buf;
-	int samples_per_clump = 0;
-
-	for (ci = 0, compptr = comp_info; ci < num_components;
-	     ci++, compptr++) {
-		samples_per_clump += compptr->h_samp_factor *
-			compptr->v_samp_factor;
-		buf = TIFFjpeg_alloc_sarray(sp, JPOOL_IMAGE,
-				compptr->width_in_blocks * DCTSIZE,
-				(JDIMENSION) (compptr->v_samp_factor*DCTSIZE));
-		if (buf == NULL)
-			return (0);
-		sp->ds_buffer[ci] = buf;
-	}
-	sp->samplesperclump = samples_per_clump;
-	return (1);
-}
-
-
-/*
- * JPEG Decoding.
- */
-
-static int
-JPEGSetupDecode(TIFF* tif)
-{
-	JPEGState* sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-
-        JPEGInitializeLibJPEG( tif, 0, 1 );
-
-	assert(sp != NULL);
-	assert(sp->cinfo.comm.is_decompressor);
-
-	/* Read JPEGTables if it is present */
-	if (TIFFFieldSet(tif,FIELD_JPEGTABLES)) {
-		TIFFjpeg_tables_src(sp, tif);
-		if(TIFFjpeg_read_header(sp,FALSE) != JPEG_HEADER_TABLES_ONLY) {
-			TIFFErrorExt(tif->tif_clientdata, "JPEGSetupDecode", "Bogus JPEGTables field");
-			return (0);
-		}
-	}
-
-	/* Grab parameters that are same for all strips/tiles */
-	sp->photometric = td->td_photometric;
-	switch (sp->photometric) {
-	case PHOTOMETRIC_YCBCR:
-		sp->h_sampling = td->td_ycbcrsubsampling[0];
-		sp->v_sampling = td->td_ycbcrsubsampling[1];
-		break;
-	default:
-		/* TIFF 6.0 forbids subsampling of all other color spaces */
-		sp->h_sampling = 1;
-		sp->v_sampling = 1;
-		break;
-	}
-
-	/* Set up for reading normal data */
-	TIFFjpeg_data_src(sp, tif);
-	tif->tif_postdecode = _TIFFNoPostDecode; /* override byte swapping */
-	return (1);
-}
-
-/*
- * Set up for decoding a strip or tile.
- */
-static int
-JPEGPreDecode(TIFF* tif, tsample_t s)
-{
-	JPEGState *sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-	static const char module[] = "JPEGPreDecode";
-	uint32 segment_width, segment_height;
-	int downsampled_output;
-	int ci;
-
-	assert(sp != NULL);
-	assert(sp->cinfo.comm.is_decompressor);
-	/*
-	 * Reset decoder state from any previous strip/tile,
-	 * in case application didn't read the whole strip.
-	 */
-	if (!TIFFjpeg_abort(sp))
-		return (0);
-	/*
-	 * Read the header for this strip/tile.
-	 */
-	if (TIFFjpeg_read_header(sp, TRUE) != JPEG_HEADER_OK)
-		return (0);
-	/*
-	 * Check image parameters and set decompression parameters.
-	 */
-	segment_width = td->td_imagewidth;
-	segment_height = td->td_imagelength - tif->tif_row;
-	if (isTiled(tif)) {
-                segment_width = td->td_tilewidth;
-                segment_height = td->td_tilelength;
-		sp->bytesperline = TIFFTileRowSize(tif);
-	} else {
-		if (segment_height > td->td_rowsperstrip)
-			segment_height = td->td_rowsperstrip;
-		sp->bytesperline = TIFFOldScanlineSize(tif);
-	}
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE && s > 0) {
-		/*
-		 * For PC 2, scale down the expected strip/tile size
-		 * to match a downsampled component
-		 */
-		segment_width = TIFFhowmany(segment_width, sp->h_sampling);
-		segment_height = TIFFhowmany(segment_height, sp->v_sampling);
-	}
-	if (sp->cinfo.d.image_width < segment_width ||
-	    sp->cinfo.d.image_height < segment_height) {
-		TIFFWarningExt(tif->tif_clientdata, module,
-			       "Improper JPEG strip/tile size, "
-			       "expected %dx%d, got %dx%d",
-			       segment_width, segment_height,
-			       sp->cinfo.d.image_width,
-			       sp->cinfo.d.image_height);
-	} 
-	if (sp->cinfo.d.image_width > segment_width ||
-	    sp->cinfo.d.image_height > segment_height) {
-		/*
-		 * This case could be dangerous, if the strip or tile size has
-		 * been reported as less than the amount of data jpeg will
-		 * return, some potential security issues arise. Catch this
-		 * case and error out.
-		 */
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "JPEG strip/tile size exceeds expected dimensions,"
-			     " expected %dx%d, got %dx%d",
-			     segment_width, segment_height,
-			     sp->cinfo.d.image_width, sp->cinfo.d.image_height);
-		return (0);
-	}
-	if (sp->cinfo.d.num_components !=
-	    (td->td_planarconfig == PLANARCONFIG_CONTIG ?
-	     td->td_samplesperpixel : 1)) {
-		TIFFErrorExt(tif->tif_clientdata, module, "Improper JPEG component count");
-		return (0);
-	}
-#ifdef JPEG_LIB_MK1
-	if (12 != td->td_bitspersample && 8 != td->td_bitspersample) {
-			TIFFErrorExt(tif->tif_clientdata, module, "Improper JPEG data precision");
-            return (0);
-	}
-        sp->cinfo.d.data_precision = td->td_bitspersample;
-        sp->cinfo.d.bits_in_jsample = td->td_bitspersample;
-#else
-	if (sp->cinfo.d.data_precision != td->td_bitspersample) {
-			TIFFErrorExt(tif->tif_clientdata, module, "Improper JPEG data precision");
-            return (0);
-	}
-#endif
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		/* Component 0 should have expected sampling factors */
-		if (sp->cinfo.d.comp_info[0].h_samp_factor != sp->h_sampling ||
-		    sp->cinfo.d.comp_info[0].v_samp_factor != sp->v_sampling) {
-				TIFFWarningExt(tif->tif_clientdata, module,
-                                    "Improper JPEG sampling factors %d,%d\n"
-                                    "Apparently should be %d,%d.",
-                                    sp->cinfo.d.comp_info[0].h_samp_factor,
-                                    sp->cinfo.d.comp_info[0].v_samp_factor,
-                                    sp->h_sampling, sp->v_sampling);
-
-				/*
-				 * There are potential security issues here
-				 * for decoders that have already allocated
-				 * buffers based on the expected sampling
-				 * factors. Lets check the sampling factors
-				 * dont exceed what we were expecting.
-				 */
-				if (sp->cinfo.d.comp_info[0].h_samp_factor
-					> sp->h_sampling
-				    || sp->cinfo.d.comp_info[0].v_samp_factor
-					> sp->v_sampling) {
-					TIFFErrorExt(tif->tif_clientdata,
-						     module,
-					"Cannot honour JPEG sampling factors"
-					" that exceed those specified.");
-					return (0);
-				}
-
-			    /*
-			     * XXX: Files written by the Intergraph software
-			     * has different sampling factors stored in the
-			     * TIFF tags and in the JPEG structures. We will
-			     * try to deduce Intergraph files by the presense
-			     * of the tag 33918.
-			     */
-			    if (!_TIFFFindFieldInfo(tif, 33918, TIFF_ANY)) {
-					TIFFWarningExt(tif->tif_clientdata, module,
-					"Decompressor will try reading with "
-					"sampling %d,%d.",
-					sp->cinfo.d.comp_info[0].h_samp_factor,
-					sp->cinfo.d.comp_info[0].v_samp_factor);
-
-				    sp->h_sampling = (uint16)
-					sp->cinfo.d.comp_info[0].h_samp_factor;
-				    sp->v_sampling = (uint16)
-					sp->cinfo.d.comp_info[0].v_samp_factor;
-			    }
-		}
-		/* Rest should have sampling factors 1,1 */
-		for (ci = 1; ci < sp->cinfo.d.num_components; ci++) {
-			if (sp->cinfo.d.comp_info[ci].h_samp_factor != 1 ||
-			    sp->cinfo.d.comp_info[ci].v_samp_factor != 1) {
-				TIFFErrorExt(tif->tif_clientdata, module, "Improper JPEG sampling factors");
-				return (0);
-			}
-		}
-	} else {
-		/* PC 2's single component should have sampling factors 1,1 */
-		if (sp->cinfo.d.comp_info[0].h_samp_factor != 1 ||
-		    sp->cinfo.d.comp_info[0].v_samp_factor != 1) {
-			TIFFErrorExt(tif->tif_clientdata, module, "Improper JPEG sampling factors");
-			return (0);
-		}
-	}
-	downsampled_output = FALSE;
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG &&
-	    sp->photometric == PHOTOMETRIC_YCBCR &&
-	    sp->jpegcolormode == JPEGCOLORMODE_RGB) {
-	/* Convert YCbCr to RGB */
-		sp->cinfo.d.jpeg_color_space = JCS_YCbCr;
-		sp->cinfo.d.out_color_space = JCS_RGB;
-	} else {
-			/* Suppress colorspace handling */
-		sp->cinfo.d.jpeg_color_space = JCS_UNKNOWN;
-		sp->cinfo.d.out_color_space = JCS_UNKNOWN;
-		if (td->td_planarconfig == PLANARCONFIG_CONTIG &&
-		    (sp->h_sampling != 1 || sp->v_sampling != 1))
-			downsampled_output = TRUE;
-		/* XXX what about up-sampling? */
-	}
-	if (downsampled_output) {
-		/* Need to use raw-data interface to libjpeg */
-		sp->cinfo.d.raw_data_out = TRUE;
-		tif->tif_decoderow = JPEGDecodeRaw;
-		tif->tif_decodestrip = JPEGDecodeRaw;
-		tif->tif_decodetile = JPEGDecodeRaw;
-	} else {
-		/* Use normal interface to libjpeg */
-		sp->cinfo.d.raw_data_out = FALSE;
-		tif->tif_decoderow = JPEGDecode;
-		tif->tif_decodestrip = JPEGDecode;
-		tif->tif_decodetile = JPEGDecode;
-	}
-	/* Start JPEG decompressor */
-	if (!TIFFjpeg_start_decompress(sp))
-		return (0);
-	/* Allocate downsampled-data buffers if needed */
-	if (downsampled_output) {
-		if (!alloc_downsampled_buffers(tif, sp->cinfo.d.comp_info,
-					       sp->cinfo.d.num_components))
-			return (0);
-		sp->scancount = DCTSIZE;	/* mark buffer empty */
-	}
-	return (1);
-}
-
-/*
- * Decode a chunk of pixels.
- * "Standard" case: returned data is not downsampled.
- */
-/*ARGSUSED*/ static int
-JPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-    JPEGState *sp = JState(tif);
-    tsize_t nrows;
-    (void) s;
-
-    nrows = cc / sp->bytesperline;
-    if (cc % sp->bytesperline)
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name, "fractional scanline not read");
-
-    if( nrows > (int) sp->cinfo.d.image_height )
-        nrows = sp->cinfo.d.image_height;
-
-    /* data is expected to be read in multiples of a scanline */
-    if (nrows)
-    {
-        JSAMPROW line_work_buf = NULL;
-
-        /*
-        ** For 6B, only use temporary buffer for 12 bit imagery. 
-        ** For Mk1 always use it. 
-        */
-#if !defined(JPEG_LIB_MK1)        
-        if( sp->cinfo.d.data_precision == 12 )
-#endif
-        {
-            line_work_buf = (JSAMPROW) 
-                _TIFFmalloc(sizeof(short) * sp->cinfo.d.output_width 
-                            * sp->cinfo.d.num_components );
-        }
-
-        do {
-            if( line_work_buf != NULL )
-            {
-                /* 
-                ** In the MK1 case, we aways read into a 16bit buffer, and then
-                ** pack down to 12bit or 8bit.  In 6B case we only read into 16
-                ** bit buffer for 12bit data, which we need to repack. 
-                */
-                if (TIFFjpeg_read_scanlines(sp, &line_work_buf, 1) != 1)
-                    return (0);
-
-                if( sp->cinfo.d.data_precision == 12 )
-                {
-                    int value_pairs = (sp->cinfo.d.output_width 
-                                       * sp->cinfo.d.num_components) / 2;
-                    int iPair;
-
-                    for( iPair = 0; iPair < value_pairs; iPair++ )
-                    {
-                        unsigned char *out_ptr = 
-                            ((unsigned char *) buf) + iPair * 3;
-                        JSAMPLE *in_ptr = line_work_buf + iPair * 2;
-
-                        out_ptr[0] = (in_ptr[0] & 0xff0) >> 4;
-                        out_ptr[1] = ((in_ptr[0] & 0xf) << 4)
-                            | ((in_ptr[1] & 0xf00) >> 8);
-                        out_ptr[2] = ((in_ptr[1] & 0xff) >> 0);
-                    }
-                }
-                else if( sp->cinfo.d.data_precision == 8 )
-                {
-                    int value_count = (sp->cinfo.d.output_width 
-                                       * sp->cinfo.d.num_components);
-                    int iValue;
-
-                    for( iValue = 0; iValue < value_count; iValue++ )
-                    {
-                        ((unsigned char *) buf)[iValue] = 
-                            line_work_buf[iValue] & 0xff;
-                    }
-                }
-            }
-            else
-            {
-                /*
-                ** In the libjpeg6b 8bit case.  We read directly into the 
-                ** TIFF buffer.
-                */
-                JSAMPROW bufptr = (JSAMPROW)buf;
-  
-                if (TIFFjpeg_read_scanlines(sp, &bufptr, 1) != 1)
-                    return (0);
-            }
-
-            ++tif->tif_row;
-            buf += sp->bytesperline;
-            cc -= sp->bytesperline;
-        } while (--nrows > 0);
-
-        if( line_work_buf != NULL )
-            _TIFFfree( line_work_buf );
-    }
-
-    /* Close down the decompressor if we've finished the strip or tile. */
-    return sp->cinfo.d.output_scanline < sp->cinfo.d.output_height
-        || TIFFjpeg_finish_decompress(sp);
-}
-
-/*
- * Decode a chunk of pixels.
- * Returned data is downsampled per sampling factors.
- */
-/*ARGSUSED*/ static int
-JPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	JPEGState *sp = JState(tif);
-	tsize_t nrows;
-	(void) s;
-
-	/* data is expected to be read in multiples of a scanline */
-	if ( (nrows = sp->cinfo.d.image_height) ) {
-		/* Cb,Cr both have sampling factors 1, so this is correct */
-		JDIMENSION clumps_per_line = sp->cinfo.d.comp_info[1].downsampled_width;            
-		int samples_per_clump = sp->samplesperclump;
-
-#ifdef JPEG_LIB_MK1
-		unsigned short* tmpbuf = _TIFFmalloc(sizeof(unsigned short) *
-		    sp->cinfo.d.output_width *
-		    sp->cinfo.d.num_components);
-#endif
-
-		do {
-			jpeg_component_info *compptr;
-			int ci, clumpoffset;
-
-			/* Reload downsampled-data buffer if needed */
-			if (sp->scancount >= DCTSIZE) {
-				int n = sp->cinfo.d.max_v_samp_factor * DCTSIZE;
-				if (TIFFjpeg_read_raw_data(sp, sp->ds_buffer, n) != n)
-					return (0);
-				sp->scancount = 0;
-			}
-			/*
-			 * Fastest way to unseparate data is to make one pass
-			 * over the scanline for each row of each component.
-			 */
-			clumpoffset = 0;    /* first sample in clump */
-			for (ci = 0, compptr = sp->cinfo.d.comp_info;
-			    ci < sp->cinfo.d.num_components;
-			    ci++, compptr++) {
-				int hsamp = compptr->h_samp_factor;
-				int vsamp = compptr->v_samp_factor;
-				int ypos;
-
-				for (ypos = 0; ypos < vsamp; ypos++) {
-					JSAMPLE *inptr = sp->ds_buffer[ci][sp->scancount*vsamp + ypos];
-#ifdef JPEG_LIB_MK1
-					JSAMPLE *outptr = (JSAMPLE*)tmpbuf + clumpoffset;
-#else
-					JSAMPLE *outptr = (JSAMPLE*)buf + clumpoffset;
-#endif
-					JDIMENSION nclump;
-
-					if (hsamp == 1) {
-						/* fast path for at least Cb and Cr */
-						for (nclump = clumps_per_line; nclump-- > 0; ) {
-							outptr[0] = *inptr++;
-							outptr += samples_per_clump;
-						}
-					} else {
-						int xpos;
-
-			/* general case */
-						for (nclump = clumps_per_line; nclump-- > 0; ) {
-							for (xpos = 0; xpos < hsamp; xpos++)
-								outptr[xpos] = *inptr++;
-							outptr += samples_per_clump;
-						}
-					}
-					clumpoffset += hsamp;
-				}
-			}
-
-#ifdef JPEG_LIB_MK1
-			{
-				if (sp->cinfo.d.data_precision == 8)
-				{
-					int i=0;
-					int len = sp->cinfo.d.output_width * sp->cinfo.d.num_components;
-					for (i=0; i<len; i++)
-					{
-						((unsigned char*)buf)[i] = tmpbuf[i] & 0xff;
-					}
-				}
-				else
-				{         // 12-bit
-					int value_pairs = (sp->cinfo.d.output_width
-					    * sp->cinfo.d.num_components) / 2;
-					int iPair;
-					for( iPair = 0; iPair < value_pairs; iPair++ )
-					{
-						unsigned char *out_ptr = ((unsigned char *) buf) + iPair * 3;
-						JSAMPLE *in_ptr = tmpbuf + iPair * 2;
-						out_ptr[0] = (in_ptr[0] & 0xff0) >> 4;
-						out_ptr[1] = ((in_ptr[0] & 0xf) << 4)
-						    | ((in_ptr[1] & 0xf00) >> 8);
-						out_ptr[2] = ((in_ptr[1] & 0xff) >> 0);
-					}
-				}
-			}
-#endif
-
-			sp->scancount ++;
-			tif->tif_row += sp->v_sampling;
-			/* increment/decrement of buf and cc is still incorrect, but should not matter
-			 * TODO: resolve this */
-			buf += sp->bytesperline;
-			cc -= sp->bytesperline;
-			nrows -= sp->v_sampling;
-		} while (nrows > 0);
-
-#ifdef JPEG_LIB_MK1
-		_TIFFfree(tmpbuf);
-#endif
-
-	}
-
-	/* Close down the decompressor if done. */
-	return sp->cinfo.d.output_scanline < sp->cinfo.d.output_height
-	    || TIFFjpeg_finish_decompress(sp);
-}
-
-
-/*
- * JPEG Encoding.
- */
-
-static void
-unsuppress_quant_table (JPEGState* sp, int tblno)
-{
-	JQUANT_TBL* qtbl;
-
-	if ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)
-		qtbl->sent_table = FALSE;
-}
-
-static void
-unsuppress_huff_table (JPEGState* sp, int tblno)
-{
-	JHUFF_TBL* htbl;
-
-	if ((htbl = sp->cinfo.c.dc_huff_tbl_ptrs[tblno]) != NULL)
-		htbl->sent_table = FALSE;
-	if ((htbl = sp->cinfo.c.ac_huff_tbl_ptrs[tblno]) != NULL)
-		htbl->sent_table = FALSE;
-}
-
-static int
-prepare_JPEGTables(TIFF* tif)
-{
-	JPEGState* sp = JState(tif);
-
-        JPEGInitializeLibJPEG( tif, 0, 0 );
-
-	/* Initialize quant tables for current quality setting */
-	if (!TIFFjpeg_set_quality(sp, sp->jpegquality, FALSE))
-		return (0);
-	/* Mark only the tables we want for output */
-	/* NB: chrominance tables are currently used only with YCbCr */
-	if (!TIFFjpeg_suppress_tables(sp, TRUE))
-		return (0);
-	if (sp->jpegtablesmode & JPEGTABLESMODE_QUANT) {
-		unsuppress_quant_table(sp, 0);
-		if (sp->photometric == PHOTOMETRIC_YCBCR)
-			unsuppress_quant_table(sp, 1);
-	}
-	if (sp->jpegtablesmode & JPEGTABLESMODE_HUFF) {
-		unsuppress_huff_table(sp, 0);
-		if (sp->photometric == PHOTOMETRIC_YCBCR)
-			unsuppress_huff_table(sp, 1);
-	}
-	/* Direct libjpeg output into jpegtables */
-	if (!TIFFjpeg_tables_dest(sp, tif))
-		return (0);
-	/* Emit tables-only datastream */
-	if (!TIFFjpeg_write_tables(sp))
-		return (0);
-
-	return (1);
-}
-
-static int
-JPEGSetupEncode(TIFF* tif)
-{
-	JPEGState* sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-	static const char module[] = "JPEGSetupEncode";
-
-        JPEGInitializeLibJPEG( tif, 1, 0 );
-
-	assert(sp != NULL);
-	assert(!sp->cinfo.comm.is_decompressor);
-
-	/*
-	 * Initialize all JPEG parameters to default values.
-	 * Note that jpeg_set_defaults needs legal values for
-	 * in_color_space and input_components.
-	 */
-	sp->cinfo.c.in_color_space = JCS_UNKNOWN;
-	sp->cinfo.c.input_components = 1;
-	if (!TIFFjpeg_set_defaults(sp))
-		return (0);
-	/* Set per-file parameters */
-	sp->photometric = td->td_photometric;
-	switch (sp->photometric) {
-	case PHOTOMETRIC_YCBCR:
-		sp->h_sampling = td->td_ycbcrsubsampling[0];
-		sp->v_sampling = td->td_ycbcrsubsampling[1];
-		/*
-		 * A ReferenceBlackWhite field *must* be present since the
-		 * default value is inappropriate for YCbCr.  Fill in the
-		 * proper value if application didn't set it.
-		 */
-		{
-			float *ref;
-			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
-				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
-				refbw[3] = refbw[1];
-				refbw[4] = refbw[2];
-				refbw[5] = refbw[1];
-				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					     refbw);
-			}
-		}
-		break;
-	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
-	case PHOTOMETRIC_MASK:
-		TIFFErrorExt(tif->tif_clientdata, module,
-			  "PhotometricInterpretation %d not allowed for JPEG",
-			  (int) sp->photometric);
-		return (0);
-	default:
-		/* TIFF 6.0 forbids subsampling of all other color spaces */
-		sp->h_sampling = 1;
-		sp->v_sampling = 1;
-		break;
-	}
-
-	/* Verify miscellaneous parameters */
-
-	/*
-	 * This would need work if libtiff ever supports different
-	 * depths for different components, or if libjpeg ever supports
-	 * run-time selection of depth.  Neither is imminent.
-	 */
-#ifdef JPEG_LIB_MK1
-        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
-	if (td->td_bitspersample != 8 && td->td_bitspersample != 12) 
-#else
-	if (td->td_bitspersample != BITS_IN_JSAMPLE )
-#endif
-	{
-		TIFFErrorExt(tif->tif_clientdata, module, "BitsPerSample %d not allowed for JPEG",
-			  (int) td->td_bitspersample);
-		return (0);
-	}
-	sp->cinfo.c.data_precision = td->td_bitspersample;
-#ifdef JPEG_LIB_MK1
-        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;
-#endif
-	if (isTiled(tif)) {
-		if ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				  "JPEG tile height must be multiple of %d",
-				  sp->v_sampling * DCTSIZE);
-			return (0);
-		}
-		if ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				  "JPEG tile width must be multiple of %d",
-				  sp->h_sampling * DCTSIZE);
-			return (0);
-		}
-	} else {
-		if (td->td_rowsperstrip < td->td_imagelength &&
-		    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				  "RowsPerStrip must be multiple of %d for JPEG",
-				  sp->v_sampling * DCTSIZE);
-			return (0);
-		}
-	}
-
-	/* Create a JPEGTables field if appropriate */
-	if (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {
-                if( sp->jpegtables == NULL
-                    || memcmp(sp->jpegtables,"\0\0\0\0\0\0\0\0\0",8) == 0 )
-                {
-                        if (!prepare_JPEGTables(tif))
-                                return (0);
-                        /* Mark the field present */
-                        /* Can't use TIFFSetField since BEENWRITING is already set! */
-                        tif->tif_flags |= TIFF_DIRTYDIRECT;
-                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);
-                }
-	} else {
-		/* We do not support application-supplied JPEGTables, */
-		/* so mark the field not present */
-		TIFFClrFieldBit(tif, FIELD_JPEGTABLES);
-	}
-
-	/* Direct libjpeg output to libtiff's output buffer */
-	TIFFjpeg_data_dest(sp, tif);
-
-	return (1);
-}
-
-/*
- * Set encoding state at the start of a strip or tile.
- */
-static int
-JPEGPreEncode(TIFF* tif, tsample_t s)
-{
-	JPEGState *sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-	static const char module[] = "JPEGPreEncode";
-	uint32 segment_width, segment_height;
-	int downsampled_input;
-
-	assert(sp != NULL);
-	assert(!sp->cinfo.comm.is_decompressor);
-	/*
-	 * Set encoding parameters for this strip/tile.
-	 */
-	if (isTiled(tif)) {
-		segment_width = td->td_tilewidth;
-		segment_height = td->td_tilelength;
-		sp->bytesperline = TIFFTileRowSize(tif);
-	} else {
-		segment_width = td->td_imagewidth;
-		segment_height = td->td_imagelength - tif->tif_row;
-		if (segment_height > td->td_rowsperstrip)
-			segment_height = td->td_rowsperstrip;
-		sp->bytesperline = TIFFOldScanlineSize(tif);
-	}
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE && s > 0) {
-		/* for PC 2, scale down the strip/tile size
-		 * to match a downsampled component
-		 */
-		segment_width = TIFFhowmany(segment_width, sp->h_sampling);
-		segment_height = TIFFhowmany(segment_height, sp->v_sampling);
-	}
-	if (segment_width > 65535 || segment_height > 65535) {
-		TIFFErrorExt(tif->tif_clientdata, module, "Strip/tile too large for JPEG");
-		return (0);
-	}
-	sp->cinfo.c.image_width = segment_width;
-	sp->cinfo.c.image_height = segment_height;
-	downsampled_input = FALSE;
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		sp->cinfo.c.input_components = td->td_samplesperpixel;
-		if (sp->photometric == PHOTOMETRIC_YCBCR) {
-			if (sp->jpegcolormode == JPEGCOLORMODE_RGB) {
-				sp->cinfo.c.in_color_space = JCS_RGB;
-			} else {
-				sp->cinfo.c.in_color_space = JCS_YCbCr;
-				if (sp->h_sampling != 1 || sp->v_sampling != 1)
-					downsampled_input = TRUE;
-			}
-			if (!TIFFjpeg_set_colorspace(sp, JCS_YCbCr))
-				return (0);
-			/*
-			 * Set Y sampling factors;
-			 * we assume jpeg_set_colorspace() set the rest to 1
-			 */
-			sp->cinfo.c.comp_info[0].h_samp_factor = sp->h_sampling;
-			sp->cinfo.c.comp_info[0].v_samp_factor = sp->v_sampling;
-		} else {
-			sp->cinfo.c.in_color_space = JCS_UNKNOWN;
-			if (!TIFFjpeg_set_colorspace(sp, JCS_UNKNOWN))
-				return (0);
-			/* jpeg_set_colorspace set all sampling factors to 1 */
-		}
-	} else {
-		sp->cinfo.c.input_components = 1;
-		sp->cinfo.c.in_color_space = JCS_UNKNOWN;
-		if (!TIFFjpeg_set_colorspace(sp, JCS_UNKNOWN))
-			return (0);
-		sp->cinfo.c.comp_info[0].component_id = s;
-		/* jpeg_set_colorspace() set sampling factors to 1 */
-		if (sp->photometric == PHOTOMETRIC_YCBCR && s > 0) {
-			sp->cinfo.c.comp_info[0].quant_tbl_no = 1;
-			sp->cinfo.c.comp_info[0].dc_tbl_no = 1;
-			sp->cinfo.c.comp_info[0].ac_tbl_no = 1;
-		}
-	}
-	/* ensure libjpeg won't write any extraneous markers */
-	sp->cinfo.c.write_JFIF_header = FALSE;
-	sp->cinfo.c.write_Adobe_marker = FALSE;
-	/* set up table handling correctly */
-        if (!TIFFjpeg_set_quality(sp, sp->jpegquality, FALSE))
-                return (0);
-	if (! (sp->jpegtablesmode & JPEGTABLESMODE_QUANT)) {
-		unsuppress_quant_table(sp, 0);
-		unsuppress_quant_table(sp, 1);
-	}
-	if (sp->jpegtablesmode & JPEGTABLESMODE_HUFF)
-		sp->cinfo.c.optimize_coding = FALSE;
-	else
-		sp->cinfo.c.optimize_coding = TRUE;
-	if (downsampled_input) {
-		/* Need to use raw-data interface to libjpeg */
-		sp->cinfo.c.raw_data_in = TRUE;
-		tif->tif_encoderow = JPEGEncodeRaw;
-		tif->tif_encodestrip = JPEGEncodeRaw;
-		tif->tif_encodetile = JPEGEncodeRaw;
-	} else {
-		/* Use normal interface to libjpeg */
-		sp->cinfo.c.raw_data_in = FALSE;
-		tif->tif_encoderow = JPEGEncode;
-		tif->tif_encodestrip = JPEGEncode;
-		tif->tif_encodetile = JPEGEncode;
-	}
-	/* Start JPEG compressor */
-	if (!TIFFjpeg_start_compress(sp, FALSE))
-		return (0);
-	/* Allocate downsampled-data buffers if needed */
-	if (downsampled_input) {
-		if (!alloc_downsampled_buffers(tif, sp->cinfo.c.comp_info,
-					       sp->cinfo.c.num_components))
-			return (0);
-	}
-	sp->scancount = 0;
-
-	return (1);
-}
-
-/*
- * Encode a chunk of pixels.
- * "Standard" case: incoming data is not downsampled.
- */
-static int
-JPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	JPEGState *sp = JState(tif);
-	tsize_t nrows;
-	JSAMPROW bufptr[1];
-
-	(void) s;
-	assert(sp != NULL);
-	/* data is expected to be supplied in multiples of a scanline */
-	nrows = cc / sp->bytesperline;
-	if (cc % sp->bytesperline)
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name, "fractional scanline discarded");
-
-        /* The last strip will be limited to image size */
-        if( !isTiled(tif) && tif->tif_row+nrows > tif->tif_dir.td_imagelength )
-            nrows = tif->tif_dir.td_imagelength - tif->tif_row;
-
-	while (nrows-- > 0) {
-		bufptr[0] = (JSAMPROW) buf;
-		if (TIFFjpeg_write_scanlines(sp, bufptr, 1) != 1)
-			return (0);
-		if (nrows > 0)
-			tif->tif_row++;
-		buf += sp->bytesperline;
-	}
-	return (1);
-}
-
-/*
- * Encode a chunk of pixels.
- * Incoming data is expected to be downsampled per sampling factors.
- */
-static int
-JPEGEncodeRaw(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	JPEGState *sp = JState(tif);
-	JSAMPLE* inptr;
-	JSAMPLE* outptr;
-	tsize_t nrows;
-	JDIMENSION clumps_per_line, nclump;
-	int clumpoffset, ci, xpos, ypos;
-	jpeg_component_info* compptr;
-	int samples_per_clump = sp->samplesperclump;
-	tsize_t bytesperclumpline;
-
-	(void) s;
-	assert(sp != NULL);
-	/* data is expected to be supplied in multiples of a clumpline */
-	/* a clumpline is equivalent to v_sampling desubsampled scanlines */
-	/* TODO: the following calculation of bytesperclumpline, should substitute calculation of sp->bytesperline, except that it is per v_sampling lines */
-	bytesperclumpline = (((sp->cinfo.c.image_width+sp->h_sampling-1)/sp->h_sampling)
-			     *(sp->h_sampling*sp->v_sampling+2)*sp->cinfo.c.data_precision+7)
-			    /8;
-
-	nrows = ( cc / bytesperclumpline ) * sp->v_sampling;
-	if (cc % bytesperclumpline)
-		TIFFWarningExt(tif->tif_clientdata, tif->tif_name, "fractional scanline discarded");
-
-	/* Cb,Cr both have sampling factors 1, so this is correct */
-	clumps_per_line = sp->cinfo.c.comp_info[1].downsampled_width;
-
-	while (nrows > 0) {
-		/*
-		 * Fastest way to separate the data is to make one pass
-		 * over the scanline for each row of each component.
-		 */
-		clumpoffset = 0;		/* first sample in clump */
-		for (ci = 0, compptr = sp->cinfo.c.comp_info;
-		     ci < sp->cinfo.c.num_components;
-		     ci++, compptr++) {
-		    int hsamp = compptr->h_samp_factor;
-		    int vsamp = compptr->v_samp_factor;
-		    int padding = (int) (compptr->width_in_blocks * DCTSIZE -
-					 clumps_per_line * hsamp);
-		    for (ypos = 0; ypos < vsamp; ypos++) {
-			inptr = ((JSAMPLE*) buf) + clumpoffset;
-			outptr = sp->ds_buffer[ci][sp->scancount*vsamp + ypos];
-			if (hsamp == 1) {
-			    /* fast path for at least Cb and Cr */
-			    for (nclump = clumps_per_line; nclump-- > 0; ) {
-				*outptr++ = inptr[0];
-				inptr += samples_per_clump;
-			    }
-			} else {
-			    /* general case */
-			    for (nclump = clumps_per_line; nclump-- > 0; ) {
-				for (xpos = 0; xpos < hsamp; xpos++)
-				    *outptr++ = inptr[xpos];
-				inptr += samples_per_clump;
-			    }
-			}
-			/* pad each scanline as needed */
-			for (xpos = 0; xpos < padding; xpos++) {
-			    *outptr = outptr[-1];
-			    outptr++;
-			}
-			clumpoffset += hsamp;
-		    }
-		}
-		sp->scancount++;
-		if (sp->scancount >= DCTSIZE) {
-			int n = sp->cinfo.c.max_v_samp_factor * DCTSIZE;
-			if (TIFFjpeg_write_raw_data(sp, sp->ds_buffer, n) != n)
-				return (0);
-			sp->scancount = 0;
-		}
-		tif->tif_row += sp->v_sampling;
-		buf += sp->bytesperline;
-		nrows -= sp->v_sampling;
-	}
-	return (1);
-}
-
-/*
- * Finish up at the end of a strip or tile.
- */
-static int
-JPEGPostEncode(TIFF* tif)
-{
-	JPEGState *sp = JState(tif);
-
-	if (sp->scancount > 0) {
-		/*
-		 * Need to emit a partial bufferload of downsampled data.
-		 * Pad the data vertically.
-		 */
-		int ci, ypos, n;
-		jpeg_component_info* compptr;
-
-		for (ci = 0, compptr = sp->cinfo.c.comp_info;
-		     ci < sp->cinfo.c.num_components;
-		     ci++, compptr++) {
-			int vsamp = compptr->v_samp_factor;
-			tsize_t row_width = compptr->width_in_blocks * DCTSIZE
-				* sizeof(JSAMPLE);
-			for (ypos = sp->scancount * vsamp;
-			     ypos < DCTSIZE * vsamp; ypos++) {
-				_TIFFmemcpy((tdata_t)sp->ds_buffer[ci][ypos],
-					    (tdata_t)sp->ds_buffer[ci][ypos-1],
-					    row_width);
-
-			}
-		}
-		n = sp->cinfo.c.max_v_samp_factor * DCTSIZE;
-		if (TIFFjpeg_write_raw_data(sp, sp->ds_buffer, n) != n)
-			return (0);
-	}
-
-	return (TIFFjpeg_finish_compress(JState(tif)));
-}
-
-static void
-JPEGCleanup(TIFF* tif)
-{
-	JPEGState *sp = JState(tif);
-	
-	assert(sp != 0);
-
-	tif->tif_tagmethods.vgetfield = sp->vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->vsetparent;
-	tif->tif_tagmethods.printdir = sp->printdir;
-
-	if( sp->cinfo_initialized )
-	    TIFFjpeg_destroy(sp);	/* release libjpeg resources */
-	if (sp->jpegtables)		/* tag value */
-		_TIFFfree(sp->jpegtables);
-	_TIFFfree(tif->tif_data);	/* release local state */
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-static void 
-JPEGResetUpsampled( TIFF* tif )
-{
-	JPEGState* sp = JState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	/*
-	 * Mark whether returned data is up-sampled or not so TIFFStripSize
-	 * and TIFFTileSize return values that reflect the true amount of
-	 * data.
-	 */
-	tif->tif_flags &= ~TIFF_UPSAMPLED;
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		if (td->td_photometric == PHOTOMETRIC_YCBCR &&
-		    sp->jpegcolormode == JPEGCOLORMODE_RGB) {
-			tif->tif_flags |= TIFF_UPSAMPLED;
-		} else {
-#ifdef notdef
-			if (td->td_ycbcrsubsampling[0] != 1 ||
-			    td->td_ycbcrsubsampling[1] != 1)
-				; /* XXX what about up-sampling? */
-#endif
-		}
-	}
-
-	/*
-	 * Must recalculate cached tile size in case sampling state changed.
-	 * Should we really be doing this now if image size isn't set? 
-	 */
-        if( tif->tif_tilesize > 0 )
-            tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
-
-        if(tif->tif_scanlinesize > 0 )
-            tif->tif_scanlinesize = TIFFScanlineSize(tif); 
-}
-
-static int
-JPEGVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	JPEGState* sp = JState(tif);
-	const TIFFFieldInfo* fip;
-	uint32 v32;
-
-	assert(sp != NULL);
-
-	switch (tag) {
-	case TIFFTAG_JPEGTABLES:
-		v32 = va_arg(ap, uint32);
-		if (v32 == 0) {
-			/* XXX */
-			return (0);
-		}
-		_TIFFsetByteArray(&sp->jpegtables, va_arg(ap, void*),
-		    (long) v32);
-		sp->jpegtables_length = v32;
-		TIFFSetFieldBit(tif, FIELD_JPEGTABLES);
-		break;
-	case TIFFTAG_JPEGQUALITY:
-		sp->jpegquality = va_arg(ap, int);
-		return (1);			/* pseudo tag */
-	case TIFFTAG_JPEGCOLORMODE:
-		sp->jpegcolormode = va_arg(ap, int);
-                JPEGResetUpsampled( tif );
-		return (1);			/* pseudo tag */
-	case TIFFTAG_PHOTOMETRIC:
-        {
-                int ret_value = (*sp->vsetparent)(tif, tag, ap);
-                JPEGResetUpsampled( tif );
-                return ret_value;
-        }
-	case TIFFTAG_JPEGTABLESMODE:
-		sp->jpegtablesmode = va_arg(ap, int);
-		return (1);			/* pseudo tag */
-	case TIFFTAG_YCBCRSUBSAMPLING:
-                /* mark the fact that we have a real ycbcrsubsampling! */
-		sp->ycbcrsampling_fetched = 1;
-                /* should we be recomputing upsampling info here? */
-		return (*sp->vsetparent)(tif, tag, ap);
-	case TIFFTAG_FAXRECVPARAMS:
-		sp->recvparams = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_FAXSUBADDRESS:
-		_TIFFsetString(&sp->subaddress, va_arg(ap, char*));
-		break;
-	case TIFFTAG_FAXRECVTIME:
-		sp->recvtime = va_arg(ap, uint32);
-		break;
-	case TIFFTAG_FAXDCS:
-		_TIFFsetString(&sp->faxdcs, va_arg(ap, char*));
-		break;
-	default:
-		return (*sp->vsetparent)(tif, tag, ap);
-	}
-
-	if ((fip = _TIFFFieldWithTag(tif, tag))) {
-		TIFFSetFieldBit(tif, fip->field_bit);
-	} else {
-		return (0);
-	}
-
-	tif->tif_flags |= TIFF_DIRTYDIRECT;
-	return (1);
-}
-
-/*
- * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in
- * the TIFF tags, but still use non-default (2,2) values within the jpeg
- * data stream itself.  In order for TIFF applications to work properly
- * - for instance to get the strip buffer size right - it is imperative
- * that the subsampling be available before we start reading the image
- * data normally.  This function will attempt to load the first strip in
- * order to get the sampling values from the jpeg data stream.  Various
- * hacks are various places are done to ensure this function gets called
- * before the td_ycbcrsubsampling values are used from the directory structure,
- * including calling TIFFGetField() for the YCBCRSUBSAMPLING field from 
- * TIFFStripSize(), and the printing code in tif_print.c. 
- *
- * Note that JPEGPreDeocode() will produce a fairly loud warning when the
- * discovered sampling does not match the default sampling (2,2) or whatever
- * was actually in the tiff tags. 
- *
- * Problems:
- *  o This code will cause one whole strip/tile of compressed data to be
- *    loaded just to get the tags right, even if the imagery is never read.
- *    It would be more efficient to just load a bit of the header, and
- *    initialize things from that. 
- *
- * See the bug in bugzilla for details:
- *
- * http://bugzilla.remotesensing.org/show_bug.cgi?id=168
- *
- * Frank Warmerdam, July 2002
- */
-
-static void 
-JPEGFixupTestSubsampling( TIFF * tif )
-{
-#ifdef CHECK_JPEG_YCBCR_SUBSAMPLING
-    JPEGState *sp = JState(tif);
-    TIFFDirectory *td = &tif->tif_dir;
-
-    JPEGInitializeLibJPEG( tif, 0, 0 );
-
-    /*
-     * Some JPEG-in-TIFF files don't provide the ycbcrsampling tags, 
-     * and use a sampling schema other than the default 2,2.  To handle
-     * this we actually have to scan the header of a strip or tile of
-     * jpeg data to get the sampling.  
-     */
-    if( !sp->cinfo.comm.is_decompressor 
-        || sp->ycbcrsampling_fetched  
-        || td->td_photometric != PHOTOMETRIC_YCBCR )
-        return;
-
-    sp->ycbcrsampling_fetched = 1;
-    if( TIFFIsTiled( tif ) )
-    {
-        if( !TIFFFillTile( tif, 0 ) )
-			return;
-    }
-    else
-    {
-        if( !TIFFFillStrip( tif, 0 ) )
-            return;
-    }
-
-    TIFFSetField( tif, TIFFTAG_YCBCRSUBSAMPLING, 
-                  (uint16) sp->h_sampling, (uint16) sp->v_sampling );
-
-    /*
-    ** We want to clear the loaded strip so the application has time
-    ** to set JPEGCOLORMODE or other behavior modifiers.  This essentially
-    ** undoes the JPEGPreDecode triggers by TIFFFileStrip().  (#1936)
-    */
-    tif->tif_curstrip = -1;
-
-#endif /* CHECK_JPEG_YCBCR_SUBSAMPLING */
-}
-
-static int
-JPEGVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	JPEGState* sp = JState(tif);
-
-	assert(sp != NULL);
-
-	switch (tag) {
-		case TIFFTAG_JPEGTABLES:
-			*va_arg(ap, uint32*) = sp->jpegtables_length;
-			*va_arg(ap, void**) = sp->jpegtables;
-			break;
-		case TIFFTAG_JPEGQUALITY:
-			*va_arg(ap, int*) = sp->jpegquality;
-			break;
-		case TIFFTAG_JPEGCOLORMODE:
-			*va_arg(ap, int*) = sp->jpegcolormode;
-			break;
-		case TIFFTAG_JPEGTABLESMODE:
-			*va_arg(ap, int*) = sp->jpegtablesmode;
-			break;
-		case TIFFTAG_YCBCRSUBSAMPLING:
-			JPEGFixupTestSubsampling( tif );
-			return (*sp->vgetparent)(tif, tag, ap);
-		case TIFFTAG_FAXRECVPARAMS:
-			*va_arg(ap, uint32*) = sp->recvparams;
-			break;
-		case TIFFTAG_FAXSUBADDRESS:
-			*va_arg(ap, char**) = sp->subaddress;
-			break;
-		case TIFFTAG_FAXRECVTIME:
-			*va_arg(ap, uint32*) = sp->recvtime;
-			break;
-		case TIFFTAG_FAXDCS:
-			*va_arg(ap, char**) = sp->faxdcs;
-			break;
-		default:
-			return (*sp->vgetparent)(tif, tag, ap);
-	}
-	return (1);
-}
-
-static void
-JPEGPrintDir(TIFF* tif, FILE* fd, long flags)
-{
-	JPEGState* sp = JState(tif);
-
-	assert(sp != NULL);
-
-	(void) flags;
-	if (TIFFFieldSet(tif,FIELD_JPEGTABLES))
-		fprintf(fd, "  JPEG Tables: (%lu bytes)\n",
-			(unsigned long) sp->jpegtables_length);
-        if (TIFFFieldSet(tif,FIELD_RECVPARAMS))
-                fprintf(fd, "  Fax Receive Parameters: %08lx\n",
-                   (unsigned long) sp->recvparams);
-        if (TIFFFieldSet(tif,FIELD_SUBADDRESS))
-                fprintf(fd, "  Fax SubAddress: %s\n", sp->subaddress);
-        if (TIFFFieldSet(tif,FIELD_RECVTIME))
-                fprintf(fd, "  Fax Receive Time: %lu secs\n",
-                    (unsigned long) sp->recvtime);
-        if (TIFFFieldSet(tif,FIELD_FAXDCS))
-                fprintf(fd, "  Fax DCS: %s\n", sp->faxdcs);
-}
-
-static uint32
-JPEGDefaultStripSize(TIFF* tif, uint32 s)
-{
-	JPEGState* sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-
-	s = (*sp->defsparent)(tif, s);
-	if (s < td->td_imagelength)
-		s = TIFFroundup(s, td->td_ycbcrsubsampling[1] * DCTSIZE);
-	return (s);
-}
-
-static void
-JPEGDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
-{
-	JPEGState* sp = JState(tif);
-	TIFFDirectory *td = &tif->tif_dir;
-
-	(*sp->deftparent)(tif, tw, th);
-	*tw = TIFFroundup(*tw, td->td_ycbcrsubsampling[0] * DCTSIZE);
-	*th = TIFFroundup(*th, td->td_ycbcrsubsampling[1] * DCTSIZE);
-}
-
-/*
- * The JPEG library initialized used to be done in TIFFInitJPEG(), but
- * now that we allow a TIFF file to be opened in update mode it is necessary
- * to have some way of deciding whether compression or decompression is
- * desired other than looking at tif->tif_mode.  We accomplish this by 
- * examining {TILE/STRIP}BYTECOUNTS to see if there is a non-zero entry.
- * If so, we assume decompression is desired. 
- *
- * This is tricky, because TIFFInitJPEG() is called while the directory is
- * being read, and generally speaking the BYTECOUNTS tag won't have been read
- * at that point.  So we try to defer jpeg library initialization till we
- * do have that tag ... basically any access that might require the compressor
- * or decompressor that occurs after the reading of the directory. 
- *
- * In an ideal world compressors or decompressors would be setup
- * at the point where a single tile or strip was accessed (for read or write)
- * so that stuff like update of missing tiles, or replacement of tiles could
- * be done. However, we aren't trying to crack that nut just yet ...
- *
- * NFW, Feb 3rd, 2003.
- */
-
-static int JPEGInitializeLibJPEG( TIFF * tif, int force_encode, int force_decode )
-{
-    JPEGState* sp = JState(tif);
-    uint32 *byte_counts = NULL;
-    int     data_is_empty = TRUE;
-    int     decompress;
-
-
-    if(sp->cinfo_initialized)
-    {
-        if( force_encode && sp->cinfo.comm.is_decompressor )
-            TIFFjpeg_destroy( sp );
-        else if( force_decode && !sp->cinfo.comm.is_decompressor )
-            TIFFjpeg_destroy( sp );
-        else
-            return 1;
-
-        sp->cinfo_initialized = 0;
-    }
-
-    /*
-     * Do we have tile data already?  Make sure we initialize the
-     * the state in decompressor mode if we have tile data, even if we
-     * are not in read-only file access mode. 
-     */
-    if( TIFFIsTiled( tif ) 
-        && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &byte_counts ) 
-        && byte_counts != NULL )
-    {
-        data_is_empty = byte_counts[0] == 0;
-    }
-    if( !TIFFIsTiled( tif ) 
-        && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &byte_counts) 
-        && byte_counts != NULL )
-    {
-        data_is_empty = byte_counts[0] == 0;
-    }
-
-    if( force_decode )
-        decompress = 1;
-    else if( force_encode )
-        decompress = 0;
-    else if( tif->tif_mode == O_RDONLY )
-        decompress = 1;
-    else if( data_is_empty )
-        decompress = 0;
-    else
-        decompress = 1;
-
-    /*
-     * Initialize libjpeg.
-     */
-    if ( decompress ) {
-        if (!TIFFjpeg_create_decompress(sp))
-            return (0);
-
-    } else {
-        if (!TIFFjpeg_create_compress(sp))
-            return (0);
-    }
-
-    sp->cinfo_initialized = TRUE;
-
-    return 1;
-}
-
-int
-TIFFInitJPEG(TIFF* tif, int scheme)
-{
-	JPEGState* sp;
-
-	assert(scheme == COMPRESSION_JPEG);
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, jpegFieldInfo, N(jpegFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata,
-			     "TIFFInitJPEG",
-			     "Merging JPEG codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (JPEGState));
-
-	if (tif->tif_data == NULL) {
-		TIFFErrorExt(tif->tif_clientdata,
-			     "TIFFInitJPEG", "No space for JPEG state block");
-		return 0;
-	}
-        _TIFFmemset(tif->tif_data, 0, sizeof(JPEGState));
-
-	sp = JState(tif);
-	sp->tif = tif;				/* back link */
-
-	/*
-	 * Override parent get/set field methods.
-	 */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield = JPEGVGetField; /* hook for codec tags */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield = JPEGVSetField; /* hook for codec tags */
-	sp->printdir = tif->tif_tagmethods.printdir;
-	tif->tif_tagmethods.printdir = JPEGPrintDir;   /* hook for codec tags */
-
-	/* Default values for codec-specific fields */
-	sp->jpegtables = NULL;
-	sp->jpegtables_length = 0;
-	sp->jpegquality = 75;			/* Default IJG quality */
-	sp->jpegcolormode = JPEGCOLORMODE_RAW;
-	sp->jpegtablesmode = JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF;
-
-        sp->recvparams = 0;
-        sp->subaddress = NULL;
-        sp->faxdcs = NULL;
-
-        sp->ycbcrsampling_fetched = 0;
-
-	/*
-	 * Install codec methods.
-	 */
-	tif->tif_setupdecode = JPEGSetupDecode;
-	tif->tif_predecode = JPEGPreDecode;
-	tif->tif_decoderow = JPEGDecode;
-	tif->tif_decodestrip = JPEGDecode;
-	tif->tif_decodetile = JPEGDecode;
-	tif->tif_setupencode = JPEGSetupEncode;
-	tif->tif_preencode = JPEGPreEncode;
-	tif->tif_postencode = JPEGPostEncode;
-	tif->tif_encoderow = JPEGEncode;
-	tif->tif_encodestrip = JPEGEncode;
-	tif->tif_encodetile = JPEGEncode;
-	tif->tif_cleanup = JPEGCleanup;
-	sp->defsparent = tif->tif_defstripsize;
-	tif->tif_defstripsize = JPEGDefaultStripSize;
-	sp->deftparent = tif->tif_deftilesize;
-	tif->tif_deftilesize = JPEGDefaultTileSize;
-	tif->tif_flags |= TIFF_NOBITREV;	/* no bit reversal, please */
-
-        sp->cinfo_initialized = FALSE;
-
-	/*
-        ** Create a JPEGTables field if no directory has yet been created. 
-        ** We do this just to ensure that sufficient space is reserved for
-        ** the JPEGTables field.  It will be properly created the right
-        ** size later. 
-        */
-        if( tif->tif_diroff == 0 )
-        {
-#define SIZE_OF_JPEGTABLES 2000
-/*
-The following line assumes incorrectly that all JPEG-in-TIFF files will have
-a JPEGTABLES tag generated and causes null-filled JPEGTABLES tags to be written
-when the JPEG data is placed with TIFFWriteRawStrip.  The field bit should be 
-set, anyway, later when actual JPEGTABLES header is generated, so removing it 
-here hopefully is harmless.
-            TIFFSetFieldBit(tif, FIELD_JPEGTABLES);
-*/
-            sp->jpegtables_length = SIZE_OF_JPEGTABLES;
-            sp->jpegtables = (void *) _TIFFmalloc(sp->jpegtables_length);
-	    _TIFFmemset(sp->jpegtables, 0, SIZE_OF_JPEGTABLES);
-#undef SIZE_OF_JPEGTABLES
-        }
-
-        /*
-         * Mark the TIFFTAG_YCBCRSAMPLES as present even if it is not
-         * see: JPEGFixupTestSubsampling().
-         */
-        TIFFSetFieldBit( tif, FIELD_YCBCRSUBSAMPLING );
-
-	return 1;
-}
-#endif /* JPEG_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_luv.c b/thirdparty/libtiff/tif_luv.c
deleted file mode 100644
index eb622b9..0000000
--- a/thirdparty/libtiff/tif_luv.c
+++ /dev/null
@@ -1,1629 +0,0 @@
-/* $Id: tif_luv.c,v 1.17.2.4 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1997 Greg Ward Larson
- * Copyright (c) 1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler, Greg Larson and Silicon Graphics may not be used in any
- * advertising or publicity relating to the software without the specific,
- * prior written permission of Sam Leffler, Greg Larson and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER, GREG LARSON OR SILICON GRAPHICS BE LIABLE
- * FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef LOGLUV_SUPPORT
-
-/*
- * TIFF Library.
- * LogLuv compression support for high dynamic range images.
- *
- * Contributed by Greg Larson.
- *
- * LogLuv image support uses the TIFF library to store 16 or 10-bit
- * log luminance values with 8 bits each of u and v or a 14-bit index.
- *
- * The codec can take as input and produce as output 32-bit IEEE float values 
- * as well as 16-bit integer values.  A 16-bit luminance is interpreted
- * as a sign bit followed by a 15-bit integer that is converted
- * to and from a linear magnitude using the transformation:
- *
- *	L = 2^( (Le+.5)/256 - 64 )		# real from 15-bit
- *
- *	Le = floor( 256*(log2(L) + 64) )	# 15-bit from real
- *
- * The actual conversion to world luminance units in candelas per sq. meter
- * requires an additional multiplier, which is stored in the TIFFTAG_STONITS.
- * This value is usually set such that a reasonable exposure comes from
- * clamping decoded luminances above 1 to 1 in the displayed image.
- *
- * The 16-bit values for u and v may be converted to real values by dividing
- * each by 32768.  (This allows for negative values, which aren't useful as
- * far as we know, but are left in case of future improvements in human
- * color vision.)
- *
- * Conversion from (u,v), which is actually the CIE (u',v') system for
- * you color scientists, is accomplished by the following transformation:
- *
- *	u = 4*x / (-2*x + 12*y + 3)
- *	v = 9*y / (-2*x + 12*y + 3)
- *
- *	x = 9*u / (6*u - 16*v + 12)
- *	y = 4*v / (6*u - 16*v + 12)
- *
- * This process is greatly simplified by passing 32-bit IEEE floats
- * for each of three CIE XYZ coordinates.  The codec then takes care
- * of conversion to and from LogLuv, though the application is still
- * responsible for interpreting the TIFFTAG_STONITS calibration factor.
- *
- * By definition, a CIE XYZ vector of [1 1 1] corresponds to a neutral white
- * point of (x,y)=(1/3,1/3).  However, most color systems assume some other
- * white point, such as D65, and an absolute color conversion to XYZ then
- * to another color space with a different white point may introduce an
- * unwanted color cast to the image.  It is often desirable, therefore, to
- * perform a white point conversion that maps the input white to [1 1 1]
- * in XYZ, then record the original white point using the TIFFTAG_WHITEPOINT
- * tag value.  A decoder that demands absolute color calibration may use
- * this white point tag to get back the original colors, but usually it
- * will be ignored and the new white point will be used instead that
- * matches the output color space.
- *
- * Pixel information is compressed into one of two basic encodings, depending
- * on the setting of the compression tag, which is one of COMPRESSION_SGILOG
- * or COMPRESSION_SGILOG24.  For COMPRESSION_SGILOG, greyscale data is
- * stored as:
- *
- *	 1       15
- *	|-+---------------|
- *
- * COMPRESSION_SGILOG color data is stored as:
- *
- *	 1       15           8        8
- *	|-+---------------|--------+--------|
- *	 S       Le           ue       ve
- *
- * For the 24-bit COMPRESSION_SGILOG24 color format, the data is stored as:
- *
- *	     10           14
- *	|----------|--------------|
- *	     Le'          Ce
- *
- * There is no sign bit in the 24-bit case, and the (u,v) chromaticity is
- * encoded as an index for optimal color resolution.  The 10 log bits are
- * defined by the following conversions:
- *
- *	L = 2^((Le'+.5)/64 - 12)		# real from 10-bit
- *
- *	Le' = floor( 64*(log2(L) + 12) )	# 10-bit from real
- *
- * The 10 bits of the smaller format may be converted into the 15 bits of
- * the larger format by multiplying by 4 and adding 13314.  Obviously,
- * a smaller range of magnitudes is covered (about 5 orders of magnitude
- * instead of 38), and the lack of a sign bit means that negative luminances
- * are not allowed.  (Well, they aren't allowed in the real world, either,
- * but they are useful for certain types of image processing.)
- *
- * The desired user format is controlled by the setting the internal
- * pseudo tag TIFFTAG_SGILOGDATAFMT to one of:
- *  SGILOGDATAFMT_FLOAT       = IEEE 32-bit float XYZ values
- *  SGILOGDATAFMT_16BIT	      = 16-bit integer encodings of logL, u and v
- * Raw data i/o is also possible using:
- *  SGILOGDATAFMT_RAW         = 32-bit unsigned integer with encoded pixel
- * In addition, the following decoding is provided for ease of display:
- *  SGILOGDATAFMT_8BIT        = 8-bit default RGB gamma-corrected values
- *
- * For grayscale images, we provide the following data formats:
- *  SGILOGDATAFMT_FLOAT       = IEEE 32-bit float Y values
- *  SGILOGDATAFMT_16BIT       = 16-bit integer w/ encoded luminance
- *  SGILOGDATAFMT_8BIT        = 8-bit gray monitor values
- *
- * Note that the COMPRESSION_SGILOG applies a simple run-length encoding
- * scheme by separating the logL, u and v bytes for each row and applying
- * a PackBits type of compression.  Since the 24-bit encoding is not
- * adaptive, the 32-bit color format takes less space in many cases.
- *
- * Further control is provided over the conversion from higher-resolution
- * formats to final encoded values through the pseudo tag
- * TIFFTAG_SGILOGENCODE:
- *  SGILOGENCODE_NODITHER     = do not dither encoded values
- *  SGILOGENCODE_RANDITHER    = apply random dithering during encoding
- *
- * The default value of this tag is SGILOGENCODE_NODITHER for
- * COMPRESSION_SGILOG to maximize run-length encoding and
- * SGILOGENCODE_RANDITHER for COMPRESSION_SGILOG24 to turn
- * quantization errors into noise.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-/*
- * State block for each open TIFF
- * file using LogLuv compression/decompression.
- */
-typedef	struct logLuvState LogLuvState;
-
-struct logLuvState {
-	int			user_datafmt;	/* user data format */
-	int			encode_meth;	/* encoding method */
-	int			pixel_size;	/* bytes per pixel */
-
-	tidata_t*		tbuf;		/* translation buffer */
-	int			tbuflen;	/* buffer length */
-	void (*tfunc)(LogLuvState*, tidata_t, int);
-
-	TIFFVSetMethod		vgetparent;	/* super-class method */
-	TIFFVSetMethod		vsetparent;	/* super-class method */
-};
-
-#define	DecoderState(tif)	((LogLuvState*) (tif)->tif_data)
-#define	EncoderState(tif)	((LogLuvState*) (tif)->tif_data)
-
-#define SGILOGDATAFMT_UNKNOWN	-1
-
-#define MINRUN		4	/* minimum run length */
-
-/*
- * Decode a string of 16-bit gray pixels.
- */
-static int
-LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	LogLuvState* sp = DecoderState(tif);
-	int shft, i, npixels;
-	unsigned char* bp;
-	int16* tp;
-	int16 b;
-	int cc, rc;
-
-	assert(s == 0);
-	assert(sp != NULL);
-
-	npixels = occ / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
-		tp = (int16*) op;
-	else {
-		assert(sp->tbuflen >= npixels);
-		tp = (int16*) sp->tbuf;
-	}
-	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
-
-	bp = (unsigned char*) tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-					/* get each byte string */
-	for (shft = 2*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
-			if (*bp >= 128) {		/* run */
-				rc = *bp++ + (2-128);
-				b = (int16)(*bp++ << shft);
-				cc -= 2;
-				while (rc-- && i < npixels)
-					tp[i++] |= b;
-			} else {			/* non-run */
-				rc = *bp++;		/* nul is noop */
-				while (--cc && rc-- && i < npixels)
-					tp[i++] |= (int16)*bp++ << shft;
-			}
-		if (i != npixels) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"LogL16Decode: Not enough data at row %d (short %d pixels)",
-			    tif->tif_row, npixels - i);
-			tif->tif_rawcp = (tidata_t) bp;
-			tif->tif_rawcc = cc;
-			return (0);
-		}
-	}
-	(*sp->tfunc)(sp, op, npixels);
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	return (1);
-}
-
-/*
- * Decode a string of 24-bit pixels.
- */
-static int
-LogLuvDecode24(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	LogLuvState* sp = DecoderState(tif);
-	int cc, i, npixels;
-	unsigned char* bp;
-	uint32* tp;
-
-	assert(s == 0);
-	assert(sp != NULL);
-
-	npixels = occ / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32 *)op;
-	else {
-		assert(sp->tbuflen >= npixels);
-		tp = (uint32 *) sp->tbuf;
-	}
-					/* copy to array of uint32 */
-	bp = (unsigned char*) tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-	for (i = 0; i < npixels && cc > 0; i++) {
-		tp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];
-		bp += 3;
-		cc -= 3;
-	}
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	if (i != npixels) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    "LogLuvDecode24: Not enough data at row %d (short %d pixels)",
-		    tif->tif_row, npixels - i);
-		return (0);
-	}
-	(*sp->tfunc)(sp, op, npixels);
-	return (1);
-}
-
-/*
- * Decode a string of 32-bit pixels.
- */
-static int
-LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	LogLuvState* sp;
-	int shft, i, npixels;
-	unsigned char* bp;
-	uint32* tp;
-	uint32 b;
-	int cc, rc;
-
-	assert(s == 0);
-	sp = DecoderState(tif);
-	assert(sp != NULL);
-
-	npixels = occ / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) op;
-	else {
-		assert(sp->tbuflen >= npixels);
-		tp = (uint32*) sp->tbuf;
-	}
-	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
-
-	bp = (unsigned char*) tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-					/* get each byte string */
-	for (shft = 4*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
-			if (*bp >= 128) {		/* run */
-				rc = *bp++ + (2-128);
-				b = (uint32)*bp++ << shft;
-				cc -= 2;
-				while (rc-- && i < npixels)
-					tp[i++] |= b;
-			} else {			/* non-run */
-				rc = *bp++;		/* nul is noop */
-				while (--cc && rc-- && i < npixels)
-					tp[i++] |= (uint32)*bp++ << shft;
-			}
-		if (i != npixels) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"LogLuvDecode32: Not enough data at row %d (short %d pixels)",
-			    tif->tif_row, npixels - i);
-			tif->tif_rawcp = (tidata_t) bp;
-			tif->tif_rawcc = cc;
-			return (0);
-		}
-	}
-	(*sp->tfunc)(sp, op, npixels);
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	return (1);
-}
-
-/*
- * Decode a strip of pixels.  We break it into rows to
- * maintain synchrony with the encode algorithm, which
- * is row by row.
- */
-static int
-LogLuvDecodeStrip(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	tsize_t rowlen = TIFFScanlineSize(tif);
-
-	assert(cc%rowlen == 0);
-	while (cc && (*tif->tif_decoderow)(tif, bp, rowlen, s))
-		bp += rowlen, cc -= rowlen;
-	return (cc == 0);
-}
-
-/*
- * Decode a tile of pixels.  We break it into rows to
- * maintain synchrony with the encode algorithm, which
- * is row by row.
- */
-static int
-LogLuvDecodeTile(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	tsize_t rowlen = TIFFTileRowSize(tif);
-
-	assert(cc%rowlen == 0);
-	while (cc && (*tif->tif_decoderow)(tif, bp, rowlen, s))
-		bp += rowlen, cc -= rowlen;
-	return (cc == 0);
-}
-
-/*
- * Encode a row of 16-bit pixels.
- */
-static int
-LogL16Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	LogLuvState* sp = EncoderState(tif);
-	int shft, i, j, npixels;
-	tidata_t op;
-	int16* tp;
-	int16 b;
-	int occ, rc=0, mask, beg;
-
-	assert(s == 0);
-	assert(sp != NULL);
-	npixels = cc / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
-		tp = (int16*) bp;
-	else {
-		tp = (int16*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
-		(*sp->tfunc)(sp, bp, npixels);
-	}
-					/* compress each byte string */
-	op = tif->tif_rawcp;
-	occ = tif->tif_rawdatasize - tif->tif_rawcc;
-	for (shft = 2*8; (shft -= 8) >= 0; )
-		for (i = 0; i < npixels; i += rc) {
-			if (occ < 4) {
-				tif->tif_rawcp = op;
-				tif->tif_rawcc = tif->tif_rawdatasize - occ;
-				if (!TIFFFlushData1(tif))
-					return (-1);
-				op = tif->tif_rawcp;
-				occ = tif->tif_rawdatasize - tif->tif_rawcc;
-			}
-			mask = 0xff << shft;		/* find next run */
-			for (beg = i; beg < npixels; beg += rc) {
-				b = (int16) (tp[beg] & mask);
-				rc = 1;
-				while (rc < 127+2 && beg+rc < npixels &&
-						(tp[beg+rc] & mask) == b)
-					rc++;
-				if (rc >= MINRUN)
-					break;		/* long enough */
-			}
-			if (beg-i > 1 && beg-i < MINRUN) {
-				b = (int16) (tp[i] & mask);/*check short run */
-				j = i+1;
-				while ((tp[j++] & mask) == b)
-                                    if (j == beg) {
-                                        *op++ = (tidataval_t)(128-2+j-i);
-                                        *op++ = (tidataval_t) (b >> shft);
-                                        occ -= 2;
-                                        i = beg;
-                                        break;
-                                    }
-			}
-			while (i < beg) {		/* write out non-run */
-				if ((j = beg-i) > 127) j = 127;
-				if (occ < j+3) {
-                                    tif->tif_rawcp = op;
-                                    tif->tif_rawcc = tif->tif_rawdatasize - occ;
-                                    if (!TIFFFlushData1(tif))
-                                        return (-1);
-                                    op = tif->tif_rawcp;
-                                    occ = tif->tif_rawdatasize - tif->tif_rawcc;
-				}
-				*op++ = (tidataval_t) j; occ--;
-				while (j--) {
-					*op++ = (tidataval_t) (tp[i++] >> shft & 0xff);
-					occ--;
-				}
-			}
-			if (rc >= MINRUN) {		/* write out run */
-				*op++ = (tidataval_t) (128-2+rc);
-				*op++ = (tidataval_t) (tp[beg] >> shft & 0xff);
-				occ -= 2;
-			} else
-				rc = 0;
-		}
-	tif->tif_rawcp = op;
-	tif->tif_rawcc = tif->tif_rawdatasize - occ;
-
-	return (1);
-}
-
-/*
- * Encode a row of 24-bit pixels.
- */
-static int
-LogLuvEncode24(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	LogLuvState* sp = EncoderState(tif);
-	int i, npixels, occ;
-	tidata_t op;
-	uint32* tp;
-
-	assert(s == 0);
-	assert(sp != NULL);
-	npixels = cc / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) bp;
-	else {
-		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
-		(*sp->tfunc)(sp, bp, npixels);
-	}
-					/* write out encoded pixels */
-	op = tif->tif_rawcp;
-	occ = tif->tif_rawdatasize - tif->tif_rawcc;
-	for (i = npixels; i--; ) {
-		if (occ < 3) {
-			tif->tif_rawcp = op;
-			tif->tif_rawcc = tif->tif_rawdatasize - occ;
-			if (!TIFFFlushData1(tif))
-				return (-1);
-			op = tif->tif_rawcp;
-			occ = tif->tif_rawdatasize - tif->tif_rawcc;
-		}
-		*op++ = (tidataval_t)(*tp >> 16);
-		*op++ = (tidataval_t)(*tp >> 8 & 0xff);
-		*op++ = (tidataval_t)(*tp++ & 0xff);
-		occ -= 3;
-	}
-	tif->tif_rawcp = op;
-	tif->tif_rawcc = tif->tif_rawdatasize - occ;
-
-	return (1);
-}
-
-/*
- * Encode a row of 32-bit pixels.
- */
-static int
-LogLuvEncode32(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	LogLuvState* sp = EncoderState(tif);
-	int shft, i, j, npixels;
-	tidata_t op;
-	uint32* tp;
-	uint32 b;
-	int occ, rc=0, mask, beg;
-
-	assert(s == 0);
-	assert(sp != NULL);
-
-	npixels = cc / sp->pixel_size;
-
-	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
-		tp = (uint32*) bp;
-	else {
-		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
-		(*sp->tfunc)(sp, bp, npixels);
-	}
-					/* compress each byte string */
-	op = tif->tif_rawcp;
-	occ = tif->tif_rawdatasize - tif->tif_rawcc;
-	for (shft = 4*8; (shft -= 8) >= 0; )
-		for (i = 0; i < npixels; i += rc) {
-			if (occ < 4) {
-				tif->tif_rawcp = op;
-				tif->tif_rawcc = tif->tif_rawdatasize - occ;
-				if (!TIFFFlushData1(tif))
-					return (-1);
-				op = tif->tif_rawcp;
-				occ = tif->tif_rawdatasize - tif->tif_rawcc;
-			}
-			mask = 0xff << shft;		/* find next run */
-			for (beg = i; beg < npixels; beg += rc) {
-				b = tp[beg] & mask;
-				rc = 1;
-				while (rc < 127+2 && beg+rc < npixels &&
-						(tp[beg+rc] & mask) == b)
-					rc++;
-				if (rc >= MINRUN)
-					break;		/* long enough */
-			}
-			if (beg-i > 1 && beg-i < MINRUN) {
-				b = tp[i] & mask;	/* check short run */
-				j = i+1;
-				while ((tp[j++] & mask) == b)
-					if (j == beg) {
-						*op++ = (tidataval_t)(128-2+j-i);
-						*op++ = (tidataval_t)(b >> shft);
-						occ -= 2;
-						i = beg;
-						break;
-					}
-			}
-			while (i < beg) {		/* write out non-run */
-				if ((j = beg-i) > 127) j = 127;
-				if (occ < j+3) {
-					tif->tif_rawcp = op;
-					tif->tif_rawcc = tif->tif_rawdatasize - occ;
-					if (!TIFFFlushData1(tif))
-						return (-1);
-					op = tif->tif_rawcp;
-					occ = tif->tif_rawdatasize - tif->tif_rawcc;
-				}
-				*op++ = (tidataval_t) j; occ--;
-				while (j--) {
-					*op++ = (tidataval_t)(tp[i++] >> shft & 0xff);
-					occ--;
-				}
-			}
-			if (rc >= MINRUN) {		/* write out run */
-				*op++ = (tidataval_t) (128-2+rc);
-				*op++ = (tidataval_t)(tp[beg] >> shft & 0xff);
-				occ -= 2;
-			} else
-				rc = 0;
-		}
-	tif->tif_rawcp = op;
-	tif->tif_rawcc = tif->tif_rawdatasize - occ;
-
-	return (1);
-}
-
-/*
- * Encode a strip of pixels.  We break it into rows to
- * avoid encoding runs across row boundaries.
- */
-static int
-LogLuvEncodeStrip(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	tsize_t rowlen = TIFFScanlineSize(tif);
-
-	assert(cc%rowlen == 0);
-	while (cc && (*tif->tif_encoderow)(tif, bp, rowlen, s) == 1)
-		bp += rowlen, cc -= rowlen;
-	return (cc == 0);
-}
-
-/*
- * Encode a tile of pixels.  We break it into rows to
- * avoid encoding runs across row boundaries.
- */
-static int
-LogLuvEncodeTile(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	tsize_t rowlen = TIFFTileRowSize(tif);
-
-	assert(cc%rowlen == 0);
-	while (cc && (*tif->tif_encoderow)(tif, bp, rowlen, s) == 1)
-		bp += rowlen, cc -= rowlen;
-	return (cc == 0);
-}
-
-/*
- * Encode/Decode functions for converting to and from user formats.
- */
-
-#include "uvcode.h"
-
-#ifndef UVSCALE
-#define U_NEU		0.210526316
-#define V_NEU		0.473684211
-#define UVSCALE		410.
-#endif
-
-#ifndef	M_LN2
-#define M_LN2		0.69314718055994530942
-#endif
-#ifndef M_PI
-#define M_PI		3.14159265358979323846
-#endif
-#define log2(x)		((1./M_LN2)*log(x))
-#define exp2(x)		exp(M_LN2*(x))
-
-#define itrunc(x,m)	((m)==SGILOGENCODE_NODITHER ? \
-				(int)(x) : \
-				(int)((x) + rand()*(1./RAND_MAX) - .5))
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-double
-LogL16toY(int p16)		/* compute luminance from 16-bit LogL */
-{
-	int	Le = p16 & 0x7fff;
-	double	Y;
-
-	if (!Le)
-		return (0.);
-	Y = exp(M_LN2/256.*(Le+.5) - M_LN2*64.);
-	return (!(p16 & 0x8000) ? Y : -Y);
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-int
-LogL16fromY(double Y, int em)	/* get 16-bit LogL from Y */
-{
-	if (Y >= 1.8371976e19)
-		return (0x7fff);
-	if (Y <= -1.8371976e19)
-		return (0xffff);
-	if (Y > 5.4136769e-20)
-		return itrunc(256.*(log2(Y) + 64.), em);
-	if (Y < -5.4136769e-20)
-		return (~0x7fff | itrunc(256.*(log2(-Y) + 64.), em));
-	return (0);
-}
-
-static void
-L16toY(LogLuvState* sp, tidata_t op, int n)
-{
-	int16* l16 = (int16*) sp->tbuf;
-	float* yp = (float*) op;
-
-	while (n-- > 0)
-		*yp++ = (float)LogL16toY(*l16++);
-}
-
-static void
-L16toGry(LogLuvState* sp, tidata_t op, int n)
-{
-	int16* l16 = (int16*) sp->tbuf;
-	uint8* gp = (uint8*) op;
-
-	while (n-- > 0) {
-		double Y = LogL16toY(*l16++);
-		*gp++ = (uint8) ((Y <= 0.) ? 0 : (Y >= 1.) ? 255 : (int)(256.*sqrt(Y)));
-	}
-}
-
-static void
-L16fromY(LogLuvState* sp, tidata_t op, int n)
-{
-	int16* l16 = (int16*) sp->tbuf;
-	float* yp = (float*) op;
-
-	while (n-- > 0)
-		*l16++ = (int16) (LogL16fromY(*yp++, sp->encode_meth));
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-void
-XYZtoRGB24(float xyz[3], uint8 rgb[3])
-{
-	double	r, g, b;
-					/* assume CCIR-709 primaries */
-	r =  2.690*xyz[0] + -1.276*xyz[1] + -0.414*xyz[2];
-	g = -1.022*xyz[0] +  1.978*xyz[1] +  0.044*xyz[2];
-	b =  0.061*xyz[0] + -0.224*xyz[1] +  1.163*xyz[2];
-					/* assume 2.0 gamma for speed */
-	/* could use integer sqrt approx., but this is probably faster */
-	rgb[0] = (uint8)((r<=0.) ? 0 : (r >= 1.) ? 255 : (int)(256.*sqrt(r)));
-	rgb[1] = (uint8)((g<=0.) ? 0 : (g >= 1.) ? 255 : (int)(256.*sqrt(g)));
-	rgb[2] = (uint8)((b<=0.) ? 0 : (b >= 1.) ? 255 : (int)(256.*sqrt(b)));
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-double
-LogL10toY(int p10)		/* compute luminance from 10-bit LogL */
-{
-	if (p10 == 0)
-		return (0.);
-	return (exp(M_LN2/64.*(p10+.5) - M_LN2*12.));
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-int
-LogL10fromY(double Y, int em)	/* get 10-bit LogL from Y */
-{
-	if (Y >= 15.742)
-		return (0x3ff);
-	else if (Y <= .00024283)
-		return (0);
-	else
-		return itrunc(64.*(log2(Y) + 12.), em);
-}
-
-#define NANGLES		100
-#define uv2ang(u, v)	( (NANGLES*.499999999/M_PI) \
-				* atan2((v)-V_NEU,(u)-U_NEU) + .5*NANGLES )
-
-static int
-oog_encode(double u, double v)		/* encode out-of-gamut chroma */
-{
-	static int	oog_table[NANGLES];
-	static int	initialized = 0;
-	register int	i;
-	
-	if (!initialized) {		/* set up perimeter table */
-		double	eps[NANGLES], ua, va, ang, epsa;
-		int	ui, vi, ustep;
-		for (i = NANGLES; i--; )
-			eps[i] = 2.;
-		for (vi = UV_NVS; vi--; ) {
-			va = UV_VSTART + (vi+.5)*UV_SQSIZ;
-			ustep = uv_row[vi].nus-1;
-			if (vi == UV_NVS-1 || vi == 0 || ustep <= 0)
-				ustep = 1;
-			for (ui = uv_row[vi].nus-1; ui >= 0; ui -= ustep) {
-				ua = uv_row[vi].ustart + (ui+.5)*UV_SQSIZ;
-				ang = uv2ang(ua, va);
-                                i = (int) ang;
-				epsa = fabs(ang - (i+.5));
-				if (epsa < eps[i]) {
-					oog_table[i] = uv_row[vi].ncum + ui;
-					eps[i] = epsa;
-				}
-			}
-		}
-		for (i = NANGLES; i--; )	/* fill any holes */
-			if (eps[i] > 1.5) {
-				int	i1, i2;
-				for (i1 = 1; i1 < NANGLES/2; i1++)
-					if (eps[(i+i1)%NANGLES] < 1.5)
-						break;
-				for (i2 = 1; i2 < NANGLES/2; i2++)
-					if (eps[(i+NANGLES-i2)%NANGLES] < 1.5)
-						break;
-				if (i1 < i2)
-					oog_table[i] =
-						oog_table[(i+i1)%NANGLES];
-				else
-					oog_table[i] =
-						oog_table[(i+NANGLES-i2)%NANGLES];
-			}
-		initialized = 1;
-	}
-	i = (int) uv2ang(u, v);		/* look up hue angle */
-	return (oog_table[i]);
-}
-
-#undef uv2ang
-#undef NANGLES
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-int
-uv_encode(double u, double v, int em)	/* encode (u',v') coordinates */
-{
-	register int	vi, ui;
-
-	if (v < UV_VSTART)
-		return oog_encode(u, v);
-	vi = itrunc((v - UV_VSTART)*(1./UV_SQSIZ), em);
-	if (vi >= UV_NVS)
-		return oog_encode(u, v);
-	if (u < uv_row[vi].ustart)
-		return oog_encode(u, v);
-	ui = itrunc((u - uv_row[vi].ustart)*(1./UV_SQSIZ), em);
-	if (ui >= uv_row[vi].nus)
-		return oog_encode(u, v);
-
-	return (uv_row[vi].ncum + ui);
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-int
-uv_decode(double *up, double *vp, int c)	/* decode (u',v') index */
-{
-	int	upper, lower;
-	register int	ui, vi;
-
-	if (c < 0 || c >= UV_NDIVS)
-		return (-1);
-	lower = 0;				/* binary search */
-	upper = UV_NVS;
-	while (upper - lower > 1) {
-		vi = (lower + upper) >> 1;
-		ui = c - uv_row[vi].ncum;
-		if (ui > 0)
-			lower = vi;
-		else if (ui < 0)
-			upper = vi;
-		else {
-			lower = vi;
-			break;
-		}
-	}
-	vi = lower;
-	ui = c - uv_row[vi].ncum;
-	*up = uv_row[vi].ustart + (ui+.5)*UV_SQSIZ;
-	*vp = UV_VSTART + (vi+.5)*UV_SQSIZ;
-	return (0);
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-void
-LogLuv24toXYZ(uint32 p, float XYZ[3])
-{
-	int	Ce;
-	double	L, u, v, s, x, y;
-					/* decode luminance */
-	L = LogL10toY(p>>14 & 0x3ff);
-	if (L <= 0.) {
-		XYZ[0] = XYZ[1] = XYZ[2] = 0.;
-		return;
-	}
-					/* decode color */
-	Ce = p & 0x3fff;
-	if (uv_decode(&u, &v, Ce) < 0) {
-		u = U_NEU; v = V_NEU;
-	}
-	s = 1./(6.*u - 16.*v + 12.);
-	x = 9.*u * s;
-	y = 4.*v * s;
-					/* convert to XYZ */
-	XYZ[0] = (float)(x/y * L);
-	XYZ[1] = (float)L;
-	XYZ[2] = (float)((1.-x-y)/y * L);
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-uint32
-LogLuv24fromXYZ(float XYZ[3], int em)
-{
-	int	Le, Ce;
-	double	u, v, s;
-					/* encode luminance */
-	Le = LogL10fromY(XYZ[1], em);
-					/* encode color */
-	s = XYZ[0] + 15.*XYZ[1] + 3.*XYZ[2];
-	if (!Le || s <= 0.) {
-		u = U_NEU;
-		v = V_NEU;
-	} else {
-		u = 4.*XYZ[0] / s;
-		v = 9.*XYZ[1] / s;
-	}
-	Ce = uv_encode(u, v, em);
-	if (Ce < 0)			/* never happens */
-		Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);
-					/* combine encodings */
-	return (Le << 14 | Ce);
-}
-
-static void
-Luv24toXYZ(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	float* xyz = (float*) op;
-
-	while (n-- > 0) {
-		LogLuv24toXYZ(*luv, xyz);
-		xyz += 3;
-		luv++;
-	}
-}
-
-static void
-Luv24toLuv48(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	int16* luv3 = (int16*) op;
-
-	while (n-- > 0) {
-		double u, v;
-
-		*luv3++ = (int16)((*luv >> 12 & 0xffd) + 13314);
-		if (uv_decode(&u, &v, *luv&0x3fff) < 0) {
-			u = U_NEU;
-			v = V_NEU;
-		}
-		*luv3++ = (int16)(u * (1L<<15));
-		*luv3++ = (int16)(v * (1L<<15));
-		luv++;
-	}
-}
-
-static void
-Luv24toRGB(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	uint8* rgb = (uint8*) op;
-
-	while (n-- > 0) {
-		float xyz[3];
-
-		LogLuv24toXYZ(*luv++, xyz);
-		XYZtoRGB24(xyz, rgb);
-		rgb += 3;
-	}
-}
-
-static void
-Luv24fromXYZ(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	float* xyz = (float*) op;
-
-	while (n-- > 0) {
-		*luv++ = LogLuv24fromXYZ(xyz, sp->encode_meth);
-		xyz += 3;
-	}
-}
-
-static void
-Luv24fromLuv48(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	int16* luv3 = (int16*) op;
-
-	while (n-- > 0) {
-		int Le, Ce;
-
-		if (luv3[0] <= 0)
-			Le = 0;
-		else if (luv3[0] >= (1<<12)+3314)
-			Le = (1<<10) - 1;
-		else if (sp->encode_meth == SGILOGENCODE_NODITHER)
-			Le = (luv3[0]-3314) >> 2;
-		else
-			Le = itrunc(.25*(luv3[0]-3314.), sp->encode_meth);
-
-		Ce = uv_encode((luv3[1]+.5)/(1<<15), (luv3[2]+.5)/(1<<15),
-					sp->encode_meth);
-		if (Ce < 0)	/* never happens */
-			Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);
-		*luv++ = (uint32)Le << 14 | Ce;
-		luv3 += 3;
-	}
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-void
-LogLuv32toXYZ(uint32 p, float XYZ[3])
-{
-	double	L, u, v, s, x, y;
-					/* decode luminance */
-	L = LogL16toY((int)p >> 16);
-	if (L <= 0.) {
-		XYZ[0] = XYZ[1] = XYZ[2] = 0.;
-		return;
-	}
-					/* decode color */
-	u = 1./UVSCALE * ((p>>8 & 0xff) + .5);
-	v = 1./UVSCALE * ((p & 0xff) + .5);
-	s = 1./(6.*u - 16.*v + 12.);
-	x = 9.*u * s;
-	y = 4.*v * s;
-					/* convert to XYZ */
-	XYZ[0] = (float)(x/y * L);
-	XYZ[1] = (float)L;
-	XYZ[2] = (float)((1.-x-y)/y * L);
-}
-
-#if !LOGLUV_PUBLIC
-static
-#endif
-uint32
-LogLuv32fromXYZ(float XYZ[3], int em)
-{
-	unsigned int	Le, ue, ve;
-	double	u, v, s;
-					/* encode luminance */
-	Le = (unsigned int)LogL16fromY(XYZ[1], em);
-					/* encode color */
-	s = XYZ[0] + 15.*XYZ[1] + 3.*XYZ[2];
-	if (!Le || s <= 0.) {
-		u = U_NEU;
-		v = V_NEU;
-	} else {
-		u = 4.*XYZ[0] / s;
-		v = 9.*XYZ[1] / s;
-	}
-	if (u <= 0.) ue = 0;
-	else ue = itrunc(UVSCALE*u, em);
-	if (ue > 255) ue = 255;
-	if (v <= 0.) ve = 0;
-	else ve = itrunc(UVSCALE*v, em);
-	if (ve > 255) ve = 255;
-					/* combine encodings */
-	return (Le << 16 | ue << 8 | ve);
-}
-
-static void
-Luv32toXYZ(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	float* xyz = (float*) op;
-
-	while (n-- > 0) {
-		LogLuv32toXYZ(*luv++, xyz);
-		xyz += 3;
-	}
-}
-
-static void
-Luv32toLuv48(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	int16* luv3 = (int16*) op;
-
-	while (n-- > 0) {
-		double u, v;
-
-		*luv3++ = (int16)(*luv >> 16);
-		u = 1./UVSCALE * ((*luv>>8 & 0xff) + .5);
-		v = 1./UVSCALE * ((*luv & 0xff) + .5);
-		*luv3++ = (int16)(u * (1L<<15));
-		*luv3++ = (int16)(v * (1L<<15));
-		luv++;
-	}
-}
-
-static void
-Luv32toRGB(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	uint8* rgb = (uint8*) op;
-
-	while (n-- > 0) {
-		float xyz[3];
-
-		LogLuv32toXYZ(*luv++, xyz);
-		XYZtoRGB24(xyz, rgb);
-		rgb += 3;
-	}
-}
-
-static void
-Luv32fromXYZ(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	float* xyz = (float*) op;
-
-	while (n-- > 0) {
-		*luv++ = LogLuv32fromXYZ(xyz, sp->encode_meth);
-		xyz += 3;
-	}
-}
-
-static void
-Luv32fromLuv48(LogLuvState* sp, tidata_t op, int n)
-{
-	uint32* luv = (uint32*) sp->tbuf;
-	int16* luv3 = (int16*) op;
-
-	if (sp->encode_meth == SGILOGENCODE_NODITHER) {
-		while (n-- > 0) {
-			*luv++ = (uint32)luv3[0] << 16 |
-				(luv3[1]*(uint32)(UVSCALE+.5) >> 7 & 0xff00) |
-				(luv3[2]*(uint32)(UVSCALE+.5) >> 15 & 0xff);
-			luv3 += 3;
-		}
-		return;
-	}
-	while (n-- > 0) {
-		*luv++ = (uint32)luv3[0] << 16 |
-	(itrunc(luv3[1]*(UVSCALE/(1<<15)), sp->encode_meth) << 8 & 0xff00) |
-		(itrunc(luv3[2]*(UVSCALE/(1<<15)), sp->encode_meth) & 0xff);
-		luv3 += 3;
-	}
-}
-
-static void
-_logLuvNop(LogLuvState* sp, tidata_t op, int n)
-{
-	(void) sp; (void) op; (void) n;
-}
-
-static int
-LogL16GuessDataFmt(TIFFDirectory *td)
-{
-#define	PACK(s,b,f)	(((b)<<6)|((s)<<3)|(f))
-	switch (PACK(td->td_samplesperpixel, td->td_bitspersample, td->td_sampleformat)) {
-	case PACK(1, 32, SAMPLEFORMAT_IEEEFP):
-		return (SGILOGDATAFMT_FLOAT);
-	case PACK(1, 16, SAMPLEFORMAT_VOID):
-	case PACK(1, 16, SAMPLEFORMAT_INT):
-	case PACK(1, 16, SAMPLEFORMAT_UINT):
-		return (SGILOGDATAFMT_16BIT);
-	case PACK(1,  8, SAMPLEFORMAT_VOID):
-	case PACK(1,  8, SAMPLEFORMAT_UINT):
-		return (SGILOGDATAFMT_8BIT);
-	}
-#undef PACK
-	return (SGILOGDATAFMT_UNKNOWN);
-}
-
-static uint32
-multiply(size_t m1, size_t m2)
-{
-	uint32	bytes = m1 * m2;
-
-	if (m1 && bytes / m1 != m2)
-		bytes = 0;
-
-	return bytes;
-}
-
-static int
-LogL16InitState(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	LogLuvState* sp = DecoderState(tif);
-	static const char module[] = "LogL16InitState";
-
-	assert(sp != NULL);
-	assert(td->td_photometric == PHOTOMETRIC_LOGL);
-
-	/* for some reason, we can't do this in TIFFInitLogL16 */
-	if (sp->user_datafmt == SGILOGDATAFMT_UNKNOWN)
-		sp->user_datafmt = LogL16GuessDataFmt(td);
-	switch (sp->user_datafmt) {
-	case SGILOGDATAFMT_FLOAT:
-		sp->pixel_size = sizeof (float);
-		break;
-	case SGILOGDATAFMT_16BIT:
-		sp->pixel_size = sizeof (int16);
-		break;
-	case SGILOGDATAFMT_8BIT:
-		sp->pixel_size = sizeof (uint8);
-		break;
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "No support for converting user data format to LogL");
-		return (0);
-	}
-        if( isTiled(tif) )
-            sp->tbuflen = multiply(td->td_tilewidth, td->td_tilelength);
-        else
-            sp->tbuflen = multiply(td->td_imagewidth, td->td_rowsperstrip);
-	if (multiply(sp->tbuflen, sizeof (int16)) == 0 ||
-	    (sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (int16))) == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: No space for SGILog translation buffer",
-		    tif->tif_name);
-		return (0);
-	}
-	return (1);
-}
-
-static int
-LogLuvGuessDataFmt(TIFFDirectory *td)
-{
-	int guess;
-
-	/*
-	 * If the user didn't tell us their datafmt,
-	 * take our best guess from the bitspersample.
-	 */
-#define	PACK(a,b)	(((a)<<3)|(b))
-	switch (PACK(td->td_bitspersample, td->td_sampleformat)) {
-	case PACK(32, SAMPLEFORMAT_IEEEFP):
-		guess = SGILOGDATAFMT_FLOAT;
-		break;
-	case PACK(32, SAMPLEFORMAT_VOID):
-	case PACK(32, SAMPLEFORMAT_UINT):
-	case PACK(32, SAMPLEFORMAT_INT):
-		guess = SGILOGDATAFMT_RAW;
-		break;
-	case PACK(16, SAMPLEFORMAT_VOID):
-	case PACK(16, SAMPLEFORMAT_INT):
-	case PACK(16, SAMPLEFORMAT_UINT):
-		guess = SGILOGDATAFMT_16BIT;
-		break;
-	case PACK( 8, SAMPLEFORMAT_VOID):
-	case PACK( 8, SAMPLEFORMAT_UINT):
-		guess = SGILOGDATAFMT_8BIT;
-		break;
-	default:
-		guess = SGILOGDATAFMT_UNKNOWN;
-		break;
-#undef PACK
-	}
-	/*
-	 * Double-check samples per pixel.
-	 */
-	switch (td->td_samplesperpixel) {
-	case 1:
-		if (guess != SGILOGDATAFMT_RAW)
-			guess = SGILOGDATAFMT_UNKNOWN;
-		break;
-	case 3:
-		if (guess == SGILOGDATAFMT_RAW)
-			guess = SGILOGDATAFMT_UNKNOWN;
-		break;
-	default:
-		guess = SGILOGDATAFMT_UNKNOWN;
-		break;
-	}
-	return (guess);
-}
-
-static int
-LogLuvInitState(TIFF* tif)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	LogLuvState* sp = DecoderState(tif);
-	static const char module[] = "LogLuvInitState";
-
-	assert(sp != NULL);
-	assert(td->td_photometric == PHOTOMETRIC_LOGLUV);
-
-	/* for some reason, we can't do this in TIFFInitLogLuv */
-	if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-		    "SGILog compression cannot handle non-contiguous data");
-		return (0);
-	}
-	if (sp->user_datafmt == SGILOGDATAFMT_UNKNOWN)
-		sp->user_datafmt = LogLuvGuessDataFmt(td);
-	switch (sp->user_datafmt) {
-	case SGILOGDATAFMT_FLOAT:
-		sp->pixel_size = 3*sizeof (float);
-		break;
-	case SGILOGDATAFMT_16BIT:
-		sp->pixel_size = 3*sizeof (int16);
-		break;
-	case SGILOGDATAFMT_RAW:
-		sp->pixel_size = sizeof (uint32);
-		break;
-	case SGILOGDATAFMT_8BIT:
-		sp->pixel_size = 3*sizeof (uint8);
-		break;
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "No support for converting user data format to LogLuv");
-		return (0);
-	}
-        if( isTiled(tif) )
-            sp->tbuflen = multiply(td->td_tilewidth, td->td_tilelength);
-        else
-            sp->tbuflen = multiply(td->td_imagewidth, td->td_rowsperstrip);
-	if (multiply(sp->tbuflen, sizeof (uint32)) == 0 ||
-	    (sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (uint32))) == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: No space for SGILog translation buffer",
-		    tif->tif_name);
-		return (0);
-	}
-	return (1);
-}
-
-static int
-LogLuvSetupDecode(TIFF* tif)
-{
-	LogLuvState* sp = DecoderState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	tif->tif_postdecode = _TIFFNoPostDecode;
-	switch (td->td_photometric) {
-	case PHOTOMETRIC_LOGLUV:
-		if (!LogLuvInitState(tif))
-			break;
-		if (td->td_compression == COMPRESSION_SGILOG24) {
-			tif->tif_decoderow = LogLuvDecode24;
-			switch (sp->user_datafmt) {
-			case SGILOGDATAFMT_FLOAT:
-				sp->tfunc = Luv24toXYZ;
-				break;
-			case SGILOGDATAFMT_16BIT:
-				sp->tfunc = Luv24toLuv48;
-				break;
-			case SGILOGDATAFMT_8BIT:
-				sp->tfunc = Luv24toRGB;
-				break;
-			}
-		} else {
-			tif->tif_decoderow = LogLuvDecode32;
-			switch (sp->user_datafmt) {
-			case SGILOGDATAFMT_FLOAT:
-				sp->tfunc = Luv32toXYZ;
-				break;
-			case SGILOGDATAFMT_16BIT:
-				sp->tfunc = Luv32toLuv48;
-				break;
-			case SGILOGDATAFMT_8BIT:
-				sp->tfunc = Luv32toRGB;
-				break;
-			}
-		}
-		return (1);
-	case PHOTOMETRIC_LOGL:
-		if (!LogL16InitState(tif))
-			break;
-		tif->tif_decoderow = LogL16Decode;
-		switch (sp->user_datafmt) {
-		case SGILOGDATAFMT_FLOAT:
-			sp->tfunc = L16toY;
-			break;
-		case SGILOGDATAFMT_8BIT:
-			sp->tfunc = L16toGry;
-			break;
-		}
-		return (1);
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-    "Inappropriate photometric interpretation %d for SGILog compression; %s",
-		    td->td_photometric, "must be either LogLUV or LogL");
-		break;
-	}
-	return (0);
-}
-
-static int
-LogLuvSetupEncode(TIFF* tif)
-{
-	LogLuvState* sp = EncoderState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	switch (td->td_photometric) {
-	case PHOTOMETRIC_LOGLUV:
-		if (!LogLuvInitState(tif))
-			break;
-		if (td->td_compression == COMPRESSION_SGILOG24) {
-			tif->tif_encoderow = LogLuvEncode24;
-			switch (sp->user_datafmt) {
-			case SGILOGDATAFMT_FLOAT:
-				sp->tfunc = Luv24fromXYZ;
-				break;
-			case SGILOGDATAFMT_16BIT:
-				sp->tfunc = Luv24fromLuv48;
-				break;
-			case SGILOGDATAFMT_RAW:
-				break;
-			default:
-				goto notsupported;
-			}
-		} else {
-			tif->tif_encoderow = LogLuvEncode32;
-			switch (sp->user_datafmt) {
-			case SGILOGDATAFMT_FLOAT:
-				sp->tfunc = Luv32fromXYZ;
-				break;
-			case SGILOGDATAFMT_16BIT:
-				sp->tfunc = Luv32fromLuv48;
-				break;
-			case SGILOGDATAFMT_RAW:
-				break;
-			default:
-				goto notsupported;
-			}
-		}
-		break;
-	case PHOTOMETRIC_LOGL:
-		if (!LogL16InitState(tif))
-			break;
-		tif->tif_encoderow = LogL16Encode;
-		switch (sp->user_datafmt) {
-		case SGILOGDATAFMT_FLOAT:
-			sp->tfunc = L16fromY;
-			break;
-		case SGILOGDATAFMT_16BIT:
-			break;
-		default:
-			goto notsupported;
-		}
-		break;
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-    "Inappropriate photometric interpretation %d for SGILog compression; %s",
-    		    td->td_photometric, "must be either LogLUV or LogL");
-		break;
-	}
-	return (1);
-notsupported:
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    "SGILog compression supported only for %s, or raw data",
-	    td->td_photometric == PHOTOMETRIC_LOGL ? "Y, L" : "XYZ, Luv");
-	return (0);
-}
-
-static void
-LogLuvClose(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	/*
-	 * For consistency, we always want to write out the same
-	 * bitspersample and sampleformat for our TIFF file,
-	 * regardless of the data format being used by the application.
-	 * Since this routine is called after tags have been set but
-	 * before they have been recorded in the file, we reset them here.
-	 */
-	td->td_samplesperpixel =
-	    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;
-	td->td_bitspersample = 16;
-	td->td_sampleformat = SAMPLEFORMAT_INT;
-}
-
-static void
-LogLuvCleanup(TIFF* tif)
-{
-	LogLuvState* sp = (LogLuvState *)tif->tif_data;
-
-	assert(sp != 0);
-
-	tif->tif_tagmethods.vgetfield = sp->vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->vsetparent;
-
-	if (sp->tbuf)
-		_TIFFfree(sp->tbuf);
-	_TIFFfree(sp);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-static int
-LogLuvVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	LogLuvState* sp = DecoderState(tif);
-	int bps, fmt;
-
-	switch (tag) {
-	case TIFFTAG_SGILOGDATAFMT:
-		sp->user_datafmt = va_arg(ap, int);
-		/*
-		 * Tweak the TIFF header so that the rest of libtiff knows what
-		 * size of data will be passed between app and library, and
-		 * assume that the app knows what it is doing and is not
-		 * confused by these header manipulations...
-		 */
-		switch (sp->user_datafmt) {
-		case SGILOGDATAFMT_FLOAT:
-			bps = 32, fmt = SAMPLEFORMAT_IEEEFP;
-			break;
-		case SGILOGDATAFMT_16BIT:
-			bps = 16, fmt = SAMPLEFORMAT_INT;
-			break;
-		case SGILOGDATAFMT_RAW:
-			bps = 32, fmt = SAMPLEFORMAT_UINT;
-			TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);
-			break;
-		case SGILOGDATAFMT_8BIT:
-			bps = 8, fmt = SAMPLEFORMAT_UINT;
-			break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "Unknown data format %d for LogLuv compression",
-			    sp->user_datafmt);
-			return (0);
-		}
-		TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);
-		TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, fmt);
-		/*
-		 * Must recalculate sizes should bits/sample change.
-		 */
-		tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
-		tif->tif_scanlinesize = TIFFScanlineSize(tif);
-		return (1);
-	case TIFFTAG_SGILOGENCODE:
-		sp->encode_meth = va_arg(ap, int);
-		if (sp->encode_meth != SGILOGENCODE_NODITHER &&
-				sp->encode_meth != SGILOGENCODE_RANDITHER) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"Unknown encoding %d for LogLuv compression",
-				sp->encode_meth);
-			return (0);
-		}
-		return (1);
-	default:
-		return (*sp->vsetparent)(tif, tag, ap);
-	}
-}
-
-static int
-LogLuvVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	LogLuvState *sp = (LogLuvState *)tif->tif_data;
-
-	switch (tag) {
-	case TIFFTAG_SGILOGDATAFMT:
-		*va_arg(ap, int*) = sp->user_datafmt;
-		return (1);
-	default:
-		return (*sp->vgetparent)(tif, tag, ap);
-	}
-}
-
-static const TIFFFieldInfo LogLuvFieldInfo[] = {
-    { TIFFTAG_SGILOGDATAFMT,	  0, 0,	TIFF_SHORT,	FIELD_PSEUDO,
-      TRUE,	FALSE,	"SGILogDataFmt"},
-    { TIFFTAG_SGILOGENCODE,	  0, 0, TIFF_SHORT,	FIELD_PSEUDO,
-      TRUE,	FALSE,	"SGILogEncode"}
-};
-
-int
-TIFFInitSGILog(TIFF* tif, int scheme)
-{
-	static const char module[] = "TIFFInitSGILog";
-	LogLuvState* sp;
-
-	assert(scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG);
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, LogLuvFieldInfo,
-				 TIFFArrayCount(LogLuvFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Merging SGILog codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (LogLuvState));
-	if (tif->tif_data == NULL)
-		goto bad;
-	sp = (LogLuvState*) tif->tif_data;
-	_TIFFmemset((tdata_t)sp, 0, sizeof (*sp));
-	sp->user_datafmt = SGILOGDATAFMT_UNKNOWN;
-	sp->encode_meth = (scheme == COMPRESSION_SGILOG24) ?
-				SGILOGENCODE_RANDITHER : SGILOGENCODE_NODITHER;
-	sp->tfunc = _logLuvNop;
-
-	/*
-	 * Install codec methods.
-	 * NB: tif_decoderow & tif_encoderow are filled
-	 *     in at setup time.
-	 */
-	tif->tif_setupdecode = LogLuvSetupDecode;
-	tif->tif_decodestrip = LogLuvDecodeStrip;
-	tif->tif_decodetile = LogLuvDecodeTile;
-	tif->tif_setupencode = LogLuvSetupEncode;
-	tif->tif_encodestrip = LogLuvEncodeStrip;
-	tif->tif_encodetile = LogLuvEncodeTile;
-	tif->tif_close = LogLuvClose;
-	tif->tif_cleanup = LogLuvCleanup;
-
-	/* 
-	 * Override parent get/set field methods.
-	 */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield = LogLuvVGetField;   /* hook for codec tags */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield = LogLuvVSetField;   /* hook for codec tags */
-
-	return (1);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "%s: No space for LogLuv state block", tif->tif_name);
-	return (0);
-}
-#endif /* LOGLUV_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_lzw.c b/thirdparty/libtiff/tif_lzw.c
deleted file mode 100644
index d423866..0000000
--- a/thirdparty/libtiff/tif_lzw.c
+++ /dev/null
@@ -1,1129 +0,0 @@
-/* $Id: tif_lzw.c,v 1.29.2.6 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef LZW_SUPPORT
-/*
- * TIFF Library.
- * Rev 5.0 Lempel-Ziv & Welch Compression Support
- *
- * This code is derived from the compress program whose code is
- * derived from software contributed to Berkeley by James A. Woods,
- * derived from original work by Spencer Thomas and Joseph Orost.
- *
- * The original Berkeley copyright notice appears below in its entirety.
- */
-#include "tif_predict.h"
-
-#include <stdio.h>
-
-/*
- * NB: The 5.0 spec describes a different algorithm than Aldus
- *     implements.  Specifically, Aldus does code length transitions
- *     one code earlier than should be done (for real LZW).
- *     Earlier versions of this library implemented the correct
- *     LZW algorithm, but emitted codes in a bit order opposite
- *     to the TIFF spec.  Thus, to maintain compatibility w/ Aldus
- *     we interpret MSB-LSB ordered codes to be images written w/
- *     old versions of this library, but otherwise adhere to the
- *     Aldus "off by one" algorithm.
- *
- * Future revisions to the TIFF spec are expected to "clarify this issue".
- */
-#define	LZW_COMPAT		/* include backwards compatibility code */
-/*
- * Each strip of data is supposed to be terminated by a CODE_EOI.
- * If the following #define is included, the decoder will also
- * check for end-of-strip w/o seeing this code.  This makes the
- * library more robust, but also slower.
- */
-#define	LZW_CHECKEOS		/* include checks for strips w/o EOI code */
-
-#define MAXCODE(n)	((1L<<(n))-1)
-/*
- * The TIFF spec specifies that encoded bit
- * strings range from 9 to 12 bits.
- */
-#define	BITS_MIN	9		/* start with 9 bits */
-#define	BITS_MAX	12		/* max of 12 bit strings */
-/* predefined codes */
-#define	CODE_CLEAR	256		/* code to clear string table */
-#define	CODE_EOI	257		/* end-of-information code */
-#define CODE_FIRST	258		/* first free code entry */
-#define	CODE_MAX	MAXCODE(BITS_MAX)
-#define	HSIZE		9001L		/* 91% occupancy */
-#define	HSHIFT		(13-8)
-#ifdef LZW_COMPAT
-/* NB: +1024 is for compatibility with old files */
-#define	CSIZE		(MAXCODE(BITS_MAX)+1024L)
-#else
-#define	CSIZE		(MAXCODE(BITS_MAX)+1L)
-#endif
-
-/*
- * State block for each open TIFF file using LZW
- * compression/decompression.  Note that the predictor
- * state block must be first in this data structure.
- */
-typedef	struct {
-	TIFFPredictorState predict;	/* predictor super class */
-
-	unsigned short	nbits;		/* # of bits/code */
-	unsigned short	maxcode;	/* maximum code for lzw_nbits */
-	unsigned short	free_ent;	/* next free entry in hash table */
-	long		nextdata;	/* next bits of i/o */
-	long		nextbits;	/* # of valid bits in lzw_nextdata */
-
-        int             rw_mode;        /* preserve rw_mode from init */
-} LZWBaseState;
-
-#define	lzw_nbits	base.nbits
-#define	lzw_maxcode	base.maxcode
-#define	lzw_free_ent	base.free_ent
-#define	lzw_nextdata	base.nextdata
-#define	lzw_nextbits	base.nextbits
-
-/*
- * Encoding-specific state.
- */
-typedef uint16 hcode_t;			/* codes fit in 16 bits */
-typedef struct {
-	long	hash;
-	hcode_t	code;
-} hash_t;
-
-/*
- * Decoding-specific state.
- */
-typedef struct code_ent {
-	struct code_ent *next;
-	unsigned short	length;		/* string len, including this token */
-	unsigned char	value;		/* data value */
-	unsigned char	firstchar;	/* first token of string */
-} code_t;
-
-typedef	int (*decodeFunc)(TIFF*, tidata_t, tsize_t, tsample_t);
-
-typedef struct {
-	LZWBaseState base;
-
-	/* Decoding specific data */
-	long	dec_nbitsmask;		/* lzw_nbits 1 bits, right adjusted */
-	long	dec_restart;		/* restart count */
-#ifdef LZW_CHECKEOS
-	long	dec_bitsleft;		/* available bits in raw data */
-#endif
-	decodeFunc dec_decode;		/* regular or backwards compatible */
-	code_t*	dec_codep;		/* current recognized code */
-	code_t*	dec_oldcodep;		/* previously recognized code */
-	code_t*	dec_free_entp;		/* next free entry */
-	code_t*	dec_maxcodep;		/* max available entry */
-	code_t*	dec_codetab;		/* kept separate for small machines */
-
-	/* Encoding specific data */
-	int	enc_oldcode;		/* last code encountered */
-	long	enc_checkpoint;		/* point at which to clear table */
-#define CHECK_GAP	10000		/* enc_ratio check interval */
-	long	enc_ratio;		/* current compression ratio */
-	long	enc_incount;		/* (input) data bytes encoded */
-	long	enc_outcount;		/* encoded (output) bytes */
-	tidata_t enc_rawlimit;		/* bound on tif_rawdata buffer */
-	hash_t*	enc_hashtab;		/* kept separate for small machines */
-} LZWCodecState;
-
-#define	LZWState(tif)		((LZWBaseState*) (tif)->tif_data)
-#define	DecoderState(tif)	((LZWCodecState*) LZWState(tif))
-#define	EncoderState(tif)	((LZWCodecState*) LZWState(tif))
-
-static	int LZWDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-#ifdef LZW_COMPAT
-static	int LZWDecodeCompat(TIFF*, tidata_t, tsize_t, tsample_t);
-#endif
-static  void cl_hash(LZWCodecState*);
-
-/*
- * LZW Decoder.
- */
-
-#ifdef LZW_CHECKEOS
-/*
- * This check shouldn't be necessary because each
- * strip is suppose to be terminated with CODE_EOI.
- */
-#define	NextCode(_tif, _sp, _bp, _code, _get) {				\
-	if ((_sp)->dec_bitsleft < nbits) {				\
-		TIFFWarningExt(_tif->tif_clientdata, _tif->tif_name,				\
-		    "LZWDecode: Strip %d not terminated with EOI code", \
-		    _tif->tif_curstrip);				\
-		_code = CODE_EOI;					\
-	} else {							\
-		_get(_sp,_bp,_code);					\
-		(_sp)->dec_bitsleft -= nbits;				\
-	}								\
-}
-#else
-#define	NextCode(tif, sp, bp, code, get) get(sp, bp, code)
-#endif
-
-static int
-LZWSetupDecode(TIFF* tif)
-{
-	LZWCodecState* sp = DecoderState(tif);
-	static const char module[] = " LZWSetupDecode";
-	int code;
-
-        if( sp == NULL )
-        {
-            /*
-             * Allocate state block so tag methods have storage to record 
-			 * values.
-             */
-            tif->tif_data = (tidata_t) _TIFFmalloc(sizeof(LZWCodecState));
-            if (tif->tif_data == NULL)
-            {
-				TIFFErrorExt(tif->tif_clientdata, "LZWPreDecode", "No space for LZW state block");
-                return (0);
-            }
-
-            DecoderState(tif)->dec_codetab = NULL;
-            DecoderState(tif)->dec_decode = NULL;
-            
-            /*
-             * Setup predictor setup.
-             */
-            (void) TIFFPredictorInit(tif);
-
-            sp = DecoderState(tif);
-        }
-            
-	assert(sp != NULL);
-
-	if (sp->dec_codetab == NULL) {
-		sp->dec_codetab = (code_t*)_TIFFmalloc(CSIZE*sizeof (code_t));
-		if (sp->dec_codetab == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-				     "No space for LZW code table");
-			return (0);
-		}
-		/*
-		 * Pre-load the table.
-		 */
-                code = 255;
-                do {
-                    sp->dec_codetab[code].value = code;
-                    sp->dec_codetab[code].firstchar = code;
-                    sp->dec_codetab[code].length = 1;
-                    sp->dec_codetab[code].next = NULL;
-                } while (code--);
-		/*
-		 * Zero-out the unused entries
-                 */
-                 _TIFFmemset(&sp->dec_codetab[CODE_CLEAR], 0,
-			     (CODE_FIRST - CODE_CLEAR) * sizeof (code_t));
-	}
-	return (1);
-}
-
-/*
- * Setup state for decoding a strip.
- */
-static int
-LZWPreDecode(TIFF* tif, tsample_t s)
-{
-	LZWCodecState *sp = DecoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-        if( sp->dec_codetab == NULL )
-        {
-            tif->tif_setupdecode( tif );
-        }
-
-	/*
-	 * Check for old bit-reversed codes.
-	 */
-	if (tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) {
-#ifdef LZW_COMPAT
-		if (!sp->dec_decode) {
-			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-			    "Old-style LZW codes, convert file");
-			/*
-			 * Override default decoding methods with
-			 * ones that deal with the old coding.
-			 * Otherwise the predictor versions set
-			 * above will call the compatibility routines
-			 * through the dec_decode method.
-			 */
-			tif->tif_decoderow = LZWDecodeCompat;
-			tif->tif_decodestrip = LZWDecodeCompat;
-			tif->tif_decodetile = LZWDecodeCompat;
-			/*
-			 * If doing horizontal differencing, must
-			 * re-setup the predictor logic since we
-			 * switched the basic decoder methods...
-			 */
-			(*tif->tif_setupdecode)(tif);
-			sp->dec_decode = LZWDecodeCompat;
-		}
-		sp->lzw_maxcode = MAXCODE(BITS_MIN);
-#else /* !LZW_COMPAT */
-		if (!sp->dec_decode) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "Old-style LZW codes not supported");
-			sp->dec_decode = LZWDecode;
-		}
-		return (0);
-#endif/* !LZW_COMPAT */
-	} else {
-		sp->lzw_maxcode = MAXCODE(BITS_MIN)-1;
-		sp->dec_decode = LZWDecode;
-	}
-	sp->lzw_nbits = BITS_MIN;
-	sp->lzw_nextbits = 0;
-	sp->lzw_nextdata = 0;
-
-	sp->dec_restart = 0;
-	sp->dec_nbitsmask = MAXCODE(BITS_MIN);
-#ifdef LZW_CHECKEOS
-	sp->dec_bitsleft = tif->tif_rawcc << 3;
-#endif
-	sp->dec_free_entp = sp->dec_codetab + CODE_FIRST;
-	/*
-	 * Zero entries that are not yet filled in.  We do
-	 * this to guard against bogus input data that causes
-	 * us to index into undefined entries.  If you can
-	 * come up with a way to safely bounds-check input codes
-	 * while decoding then you can remove this operation.
-	 */
-	_TIFFmemset(sp->dec_free_entp, 0, (CSIZE-CODE_FIRST)*sizeof (code_t));
-	sp->dec_oldcodep = &sp->dec_codetab[-1];
-	sp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];
-	return (1);
-}
-
-/*
- * Decode a "hunk of data".
- */
-#define	GetNextCode(sp, bp, code) {				\
-	nextdata = (nextdata<<8) | *(bp)++;			\
-	nextbits += 8;						\
-	if (nextbits < nbits) {					\
-		nextdata = (nextdata<<8) | *(bp)++;		\
-		nextbits += 8;					\
-	}							\
-	code = (hcode_t)((nextdata >> (nextbits-nbits)) & nbitsmask);	\
-	nextbits -= nbits;					\
-}
-
-static void
-codeLoop(TIFF* tif)
-{
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    "LZWDecode: Bogus encoding, loop in the code table; scanline %d",
-	    tif->tif_row);
-}
-
-static int
-LZWDecode(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s)
-{
-	LZWCodecState *sp = DecoderState(tif);
-	char *op = (char*) op0;
-	long occ = (long) occ0;
-	char *tp;
-	unsigned char *bp;
-	hcode_t code;
-	int len;
-	long nbits, nextbits, nextdata, nbitsmask;
-	code_t *codep, *free_entp, *maxcodep, *oldcodep;
-
-	(void) s;
-	assert(sp != NULL);
-        assert(sp->dec_codetab != NULL);
-	/*
-	 * Restart interrupted output operation.
-	 */
-	if (sp->dec_restart) {
-		long residue;
-
-		codep = sp->dec_codep;
-		residue = codep->length - sp->dec_restart;
-		if (residue > occ) {
-			/*
-			 * Residue from previous decode is sufficient
-			 * to satisfy decode request.  Skip to the
-			 * start of the decoded string, place decoded
-			 * values in the output buffer, and return.
-			 */
-			sp->dec_restart += occ;
-			do {
-				codep = codep->next;
-			} while (--residue > occ && codep);
-			if (codep) {
-				tp = op + occ;
-				do {
-					*--tp = codep->value;
-					codep = codep->next;
-				} while (--occ && codep);
-			}
-			return (1);
-		}
-		/*
-		 * Residue satisfies only part of the decode request.
-		 */
-		op += residue, occ -= residue;
-		tp = op;
-		do {
-			int t;
-			--tp;
-			t = codep->value;
-			codep = codep->next;
-			*tp = t;
-		} while (--residue && codep);
-		sp->dec_restart = 0;
-	}
-
-	bp = (unsigned char *)tif->tif_rawcp;
-	nbits = sp->lzw_nbits;
-	nextdata = sp->lzw_nextdata;
-	nextbits = sp->lzw_nextbits;
-	nbitsmask = sp->dec_nbitsmask;
-	oldcodep = sp->dec_oldcodep;
-	free_entp = sp->dec_free_entp;
-	maxcodep = sp->dec_maxcodep;
-
-	while (occ > 0) {
-		NextCode(tif, sp, bp, code, GetNextCode);
-		if (code == CODE_EOI)
-			break;
-		if (code == CODE_CLEAR) {
-			free_entp = sp->dec_codetab + CODE_FIRST;
-			_TIFFmemset(free_entp, 0,
-				    (CSIZE - CODE_FIRST) * sizeof (code_t));
-			nbits = BITS_MIN;
-			nbitsmask = MAXCODE(BITS_MIN);
-			maxcodep = sp->dec_codetab + nbitsmask-1;
-			NextCode(tif, sp, bp, code, GetNextCode);
-			if (code == CODE_EOI)
-				break;
-			if (code == CODE_CLEAR) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"LZWDecode: Corrupted LZW table at scanline %d",
-					     tif->tif_row);
-				return (0);
-			}
-			*op++ = (char)code, occ--;
-			oldcodep = sp->dec_codetab + code;
-			continue;
-		}
-		codep = sp->dec_codetab + code;
-
-		/*
-	 	 * Add the new entry to the code table.
-	 	 */
-		if (free_entp < &sp->dec_codetab[0] ||
-			free_entp >= &sp->dec_codetab[CSIZE]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"LZWDecode: Corrupted LZW table at scanline %d",
-			tif->tif_row);
-			return (0);
-		}
-
-		free_entp->next = oldcodep;
-		if (free_entp->next < &sp->dec_codetab[0] ||
-			free_entp->next >= &sp->dec_codetab[CSIZE]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"LZWDecode: Corrupted LZW table at scanline %d",
-			tif->tif_row);
-			return (0);
-		}
-		free_entp->firstchar = free_entp->next->firstchar;
-		free_entp->length = free_entp->next->length+1;
-		free_entp->value = (codep < free_entp) ?
-		    codep->firstchar : free_entp->firstchar;
-		if (++free_entp > maxcodep) {
-			if (++nbits > BITS_MAX)		/* should not happen */
-				nbits = BITS_MAX;
-			nbitsmask = MAXCODE(nbits);
-			maxcodep = sp->dec_codetab + nbitsmask-1;
-		}
-		oldcodep = codep;
-		if (code >= 256) {
-			/*
-		 	 * Code maps to a string, copy string
-			 * value to output (written in reverse).
-		 	 */
-			if(codep->length == 0) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    		    "LZWDecode: Wrong length of decoded string: "
-			    "data probably corrupted at scanline %d",
-			    tif->tif_row);	
-			    return (0);
-			}
-			if (codep->length > occ) {
-				/*
-				 * String is too long for decode buffer,
-				 * locate portion that will fit, copy to
-				 * the decode buffer, and setup restart
-				 * logic for the next decoding call.
-				 */
-				sp->dec_codep = codep;
-				do {
-					codep = codep->next;
-				} while (codep && codep->length > occ);
-				if (codep) {
-					sp->dec_restart = occ;
-					tp = op + occ;
-					do  {
-						*--tp = codep->value;
-						codep = codep->next;
-					}  while (--occ && codep);
-					if (codep)
-						codeLoop(tif);
-				}
-				break;
-			}
-			len = codep->length;
-			tp = op + len;
-			do {
-				int t;
-				--tp;
-				t = codep->value;
-				codep = codep->next;
-				*tp = t;
-			} while (codep && tp > op);
-			if (codep) {
-			    codeLoop(tif);
-			    break;
-			}
-			op += len, occ -= len;
-		} else
-			*op++ = (char)code, occ--;
-	}
-
-	tif->tif_rawcp = (tidata_t) bp;
-	sp->lzw_nbits = (unsigned short) nbits;
-	sp->lzw_nextdata = nextdata;
-	sp->lzw_nextbits = nextbits;
-	sp->dec_nbitsmask = nbitsmask;
-	sp->dec_oldcodep = oldcodep;
-	sp->dec_free_entp = free_entp;
-	sp->dec_maxcodep = maxcodep;
-
-	if (occ > 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"LZWDecode: Not enough data at scanline %d (short %ld bytes)",
-		    tif->tif_row, occ);
-		return (0);
-	}
-	return (1);
-}
-
-#ifdef LZW_COMPAT
-/*
- * Decode a "hunk of data" for old images.
- */
-#define	GetNextCodeCompat(sp, bp, code) {			\
-	nextdata |= (unsigned long) *(bp)++ << nextbits;	\
-	nextbits += 8;						\
-	if (nextbits < nbits) {					\
-		nextdata |= (unsigned long) *(bp)++ << nextbits;\
-		nextbits += 8;					\
-	}							\
-	code = (hcode_t)(nextdata & nbitsmask);			\
-	nextdata >>= nbits;					\
-	nextbits -= nbits;					\
-}
-
-static int
-LZWDecodeCompat(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s)
-{
-	LZWCodecState *sp = DecoderState(tif);
-	char *op = (char*) op0;
-	long occ = (long) occ0;
-	char *tp;
-	unsigned char *bp;
-	int code, nbits;
-	long nextbits, nextdata, nbitsmask;
-	code_t *codep, *free_entp, *maxcodep, *oldcodep;
-
-	(void) s;
-	assert(sp != NULL);
-	/*
-	 * Restart interrupted output operation.
-	 */
-	if (sp->dec_restart) {
-		long residue;
-
-		codep = sp->dec_codep;
-		residue = codep->length - sp->dec_restart;
-		if (residue > occ) {
-			/*
-			 * Residue from previous decode is sufficient
-			 * to satisfy decode request.  Skip to the
-			 * start of the decoded string, place decoded
-			 * values in the output buffer, and return.
-			 */
-			sp->dec_restart += occ;
-			do {
-				codep = codep->next;
-			} while (--residue > occ);
-			tp = op + occ;
-			do {
-				*--tp = codep->value;
-				codep = codep->next;
-			} while (--occ);
-			return (1);
-		}
-		/*
-		 * Residue satisfies only part of the decode request.
-		 */
-		op += residue, occ -= residue;
-		tp = op;
-		do {
-			*--tp = codep->value;
-			codep = codep->next;
-		} while (--residue);
-		sp->dec_restart = 0;
-	}
-
-	bp = (unsigned char *)tif->tif_rawcp;
-	nbits = sp->lzw_nbits;
-	nextdata = sp->lzw_nextdata;
-	nextbits = sp->lzw_nextbits;
-	nbitsmask = sp->dec_nbitsmask;
-	oldcodep = sp->dec_oldcodep;
-	free_entp = sp->dec_free_entp;
-	maxcodep = sp->dec_maxcodep;
-
-	while (occ > 0) {
-		NextCode(tif, sp, bp, code, GetNextCodeCompat);
-		if (code == CODE_EOI)
-			break;
-		if (code == CODE_CLEAR) {
-			free_entp = sp->dec_codetab + CODE_FIRST;
-			_TIFFmemset(free_entp, 0,
-				    (CSIZE - CODE_FIRST) * sizeof (code_t));
-			nbits = BITS_MIN;
-			nbitsmask = MAXCODE(BITS_MIN);
-			maxcodep = sp->dec_codetab + nbitsmask;
-			NextCode(tif, sp, bp, code, GetNextCodeCompat);
-			if (code == CODE_EOI)
-				break;
-			if (code == CODE_CLEAR) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"LZWDecode: Corrupted LZW table at scanline %d",
-					     tif->tif_row);
-				return (0);
-			}
-			*op++ = code, occ--;
-			oldcodep = sp->dec_codetab + code;
-			continue;
-		}
-		codep = sp->dec_codetab + code;
-
-		/*
-	 	 * Add the new entry to the code table.
-	 	 */
-		if (free_entp < &sp->dec_codetab[0] ||
-			free_entp >= &sp->dec_codetab[CSIZE]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"LZWDecodeCompat: Corrupted LZW table at scanline %d",
-			tif->tif_row);
-			return (0);
-		}
-
-		free_entp->next = oldcodep;
-		if (free_entp->next < &sp->dec_codetab[0] ||
-			free_entp->next >= &sp->dec_codetab[CSIZE]) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"LZWDecodeCompat: Corrupted LZW table at scanline %d",
-			tif->tif_row);
-			return (0);
-		}
-		free_entp->firstchar = free_entp->next->firstchar;
-		free_entp->length = free_entp->next->length+1;
-		free_entp->value = (codep < free_entp) ?
-		    codep->firstchar : free_entp->firstchar;
-		if (++free_entp > maxcodep) {
-			if (++nbits > BITS_MAX)		/* should not happen */
-				nbits = BITS_MAX;
-			nbitsmask = MAXCODE(nbits);
-			maxcodep = sp->dec_codetab + nbitsmask;
-		}
-		oldcodep = codep;
-		if (code >= 256) {
-			char *op_orig = op;
-			/*
-		 	 * Code maps to a string, copy string
-			 * value to output (written in reverse).
-		 	 */
-			if(codep->length == 0) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    		    "LZWDecodeCompat: Wrong length of decoded "
-			    "string: data probably corrupted at scanline %d",
-			    tif->tif_row);	
-			    return (0);
-			}
-			if (codep->length > occ) {
-				/*
-				 * String is too long for decode buffer,
-				 * locate portion that will fit, copy to
-				 * the decode buffer, and setup restart
-				 * logic for the next decoding call.
-				 */
-				sp->dec_codep = codep;
-				do {
-					codep = codep->next;
-				} while (codep->length > occ);
-				sp->dec_restart = occ;
-				tp = op + occ;
-				do  {
-					*--tp = codep->value;
-					codep = codep->next;
-				}  while (--occ);
-				break;
-			}
-			op += codep->length, occ -= codep->length;
-			tp = op;
-			do {
-				*--tp = codep->value;
-			} while( (codep = codep->next) != NULL && tp > op_orig);
-		} else
-			*op++ = code, occ--;
-	}
-
-	tif->tif_rawcp = (tidata_t) bp;
-	sp->lzw_nbits = nbits;
-	sp->lzw_nextdata = nextdata;
-	sp->lzw_nextbits = nextbits;
-	sp->dec_nbitsmask = nbitsmask;
-	sp->dec_oldcodep = oldcodep;
-	sp->dec_free_entp = free_entp;
-	sp->dec_maxcodep = maxcodep;
-
-	if (occ > 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	    "LZWDecodeCompat: Not enough data at scanline %d (short %ld bytes)",
-		    tif->tif_row, occ);
-		return (0);
-	}
-	return (1);
-}
-#endif /* LZW_COMPAT */
-
-/*
- * LZW Encoding.
- */
-
-static int
-LZWSetupEncode(TIFF* tif)
-{
-	LZWCodecState* sp = EncoderState(tif);
-	static const char module[] = "LZWSetupEncode";
-
-	assert(sp != NULL);
-	sp->enc_hashtab = (hash_t*) _TIFFmalloc(HSIZE*sizeof (hash_t));
-	if (sp->enc_hashtab == NULL) {
-		TIFFErrorExt(tif->tif_clientdata, module, "No space for LZW hash table");
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * Reset encoding state at the start of a strip.
- */
-static int
-LZWPreEncode(TIFF* tif, tsample_t s)
-{
-	LZWCodecState *sp = EncoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-        
-        if( sp->enc_hashtab == NULL )
-        {
-            tif->tif_setupencode( tif );
-        }
-
-	sp->lzw_nbits = BITS_MIN;
-	sp->lzw_maxcode = MAXCODE(BITS_MIN);
-	sp->lzw_free_ent = CODE_FIRST;
-	sp->lzw_nextbits = 0;
-	sp->lzw_nextdata = 0;
-	sp->enc_checkpoint = CHECK_GAP;
-	sp->enc_ratio = 0;
-	sp->enc_incount = 0;
-	sp->enc_outcount = 0;
-	/*
-	 * The 4 here insures there is space for 2 max-sized
-	 * codes in LZWEncode and LZWPostDecode.
-	 */
-	sp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize-1 - 4;
-	cl_hash(sp);		/* clear hash table */
-	sp->enc_oldcode = (hcode_t) -1;	/* generates CODE_CLEAR in LZWEncode */
-	return (1);
-}
-
-#define	CALCRATIO(sp, rat) {					\
-	if (incount > 0x007fffff) { /* NB: shift will overflow */\
-		rat = outcount >> 8;				\
-		rat = (rat == 0 ? 0x7fffffff : incount/rat);	\
-	} else							\
-		rat = (incount<<8) / outcount;			\
-}
-#define	PutNextCode(op, c) {					\
-	nextdata = (nextdata << nbits) | c;			\
-	nextbits += nbits;					\
-	*op++ = (unsigned char)(nextdata >> (nextbits-8));		\
-	nextbits -= 8;						\
-	if (nextbits >= 8) {					\
-		*op++ = (unsigned char)(nextdata >> (nextbits-8));	\
-		nextbits -= 8;					\
-	}							\
-	outcount += nbits;					\
-}
-
-/*
- * Encode a chunk of pixels.
- *
- * Uses an open addressing double hashing (no chaining) on the 
- * prefix code/next character combination.  We do a variant of
- * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's
- * relatively-prime secondary probe.  Here, the modular division
- * first probe is gives way to a faster exclusive-or manipulation. 
- * Also do block compression with an adaptive reset, whereby the
- * code table is cleared when the compression ratio decreases,
- * but after the table fills.  The variable-length output codes
- * are re-sized at this point, and a CODE_CLEAR is generated
- * for the decoder. 
- */
-static int
-LZWEncode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	register LZWCodecState *sp = EncoderState(tif);
-	register long fcode;
-	register hash_t *hp;
-	register int h, c;
-	hcode_t ent;
-	long disp;
-	long incount, outcount, checkpoint;
-	long nextdata, nextbits;
-	int free_ent, maxcode, nbits;
-	tidata_t op, limit;
-
-	(void) s;
-	if (sp == NULL)
-		return (0);
-
-        assert(sp->enc_hashtab != NULL);
-
-	/*
-	 * Load local state.
-	 */
-	incount = sp->enc_incount;
-	outcount = sp->enc_outcount;
-	checkpoint = sp->enc_checkpoint;
-	nextdata = sp->lzw_nextdata;
-	nextbits = sp->lzw_nextbits;
-	free_ent = sp->lzw_free_ent;
-	maxcode = sp->lzw_maxcode;
-	nbits = sp->lzw_nbits;
-	op = tif->tif_rawcp;
-	limit = sp->enc_rawlimit;
-	ent = sp->enc_oldcode;
-
-	if (ent == (hcode_t) -1 && cc > 0) {
-		/*
-		 * NB: This is safe because it can only happen
-		 *     at the start of a strip where we know there
-		 *     is space in the data buffer.
-		 */
-		PutNextCode(op, CODE_CLEAR);
-		ent = *bp++; cc--; incount++;
-	}
-	while (cc > 0) {
-		c = *bp++; cc--; incount++;
-		fcode = ((long)c << BITS_MAX) + ent;
-		h = (c << HSHIFT) ^ ent;	/* xor hashing */
-#ifdef _WINDOWS
-		/*
-		 * Check hash index for an overflow.
-		 */
-		if (h >= HSIZE)
-			h -= HSIZE;
-#endif
-		hp = &sp->enc_hashtab[h];
-		if (hp->hash == fcode) {
-			ent = hp->code;
-			continue;
-		}
-		if (hp->hash >= 0) {
-			/*
-			 * Primary hash failed, check secondary hash.
-			 */
-			disp = HSIZE - h;
-			if (h == 0)
-				disp = 1;
-			do {
-				/*
-				 * Avoid pointer arithmetic 'cuz of
-				 * wraparound problems with segments.
-				 */
-				if ((h -= disp) < 0)
-					h += HSIZE;
-				hp = &sp->enc_hashtab[h];
-				if (hp->hash == fcode) {
-					ent = hp->code;
-					goto hit;
-				}
-			} while (hp->hash >= 0);
-		}
-		/*
-		 * New entry, emit code and add to table.
-		 */
-		/*
-		 * Verify there is space in the buffer for the code
-		 * and any potential Clear code that might be emitted
-		 * below.  The value of limit is setup so that there
-		 * are at least 4 bytes free--room for 2 codes.
-		 */
-		if (op > limit) {
-			tif->tif_rawcc = (tsize_t)(op - tif->tif_rawdata);
-			TIFFFlushData1(tif);
-			op = tif->tif_rawdata;
-		}
-		PutNextCode(op, ent);
-		ent = c;
-		hp->code = free_ent++;
-		hp->hash = fcode;
-		if (free_ent == CODE_MAX-1) {
-			/* table is full, emit clear code and reset */
-			cl_hash(sp);
-			sp->enc_ratio = 0;
-			incount = 0;
-			outcount = 0;
-			free_ent = CODE_FIRST;
-			PutNextCode(op, CODE_CLEAR);
-			nbits = BITS_MIN;
-			maxcode = MAXCODE(BITS_MIN);
-		} else {
-			/*
-			 * If the next entry is going to be too big for
-			 * the code size, then increase it, if possible.
-			 */
-			if (free_ent > maxcode) {
-				nbits++;
-				assert(nbits <= BITS_MAX);
-				maxcode = (int) MAXCODE(nbits);
-			} else if (incount >= checkpoint) {
-				long rat;
-				/*
-				 * Check compression ratio and, if things seem
-				 * to be slipping, clear the hash table and
-				 * reset state.  The compression ratio is a
-				 * 24+8-bit fractional number.
-				 */
-				checkpoint = incount+CHECK_GAP;
-				CALCRATIO(sp, rat);
-				if (rat <= sp->enc_ratio) {
-					cl_hash(sp);
-					sp->enc_ratio = 0;
-					incount = 0;
-					outcount = 0;
-					free_ent = CODE_FIRST;
-					PutNextCode(op, CODE_CLEAR);
-					nbits = BITS_MIN;
-					maxcode = MAXCODE(BITS_MIN);
-				} else
-					sp->enc_ratio = rat;
-			}
-		}
-	hit:
-		;
-	}
-
-	/*
-	 * Restore global state.
-	 */
-	sp->enc_incount = incount;
-	sp->enc_outcount = outcount;
-	sp->enc_checkpoint = checkpoint;
-	sp->enc_oldcode = ent;
-	sp->lzw_nextdata = nextdata;
-	sp->lzw_nextbits = nextbits;
-	sp->lzw_free_ent = free_ent;
-	sp->lzw_maxcode = maxcode;
-	sp->lzw_nbits = nbits;
-	tif->tif_rawcp = op;
-	return (1);
-}
-
-/*
- * Finish off an encoded strip by flushing the last
- * string and tacking on an End Of Information code.
- */
-static int
-LZWPostEncode(TIFF* tif)
-{
-	register LZWCodecState *sp = EncoderState(tif);
-	tidata_t op = tif->tif_rawcp;
-	long nextbits = sp->lzw_nextbits;
-	long nextdata = sp->lzw_nextdata;
-	long outcount = sp->enc_outcount;
-	int nbits = sp->lzw_nbits;
-
-	if (op > sp->enc_rawlimit) {
-		tif->tif_rawcc = (tsize_t)(op - tif->tif_rawdata);
-		TIFFFlushData1(tif);
-		op = tif->tif_rawdata;
-	}
-	if (sp->enc_oldcode != (hcode_t) -1) {
-		PutNextCode(op, sp->enc_oldcode);
-		sp->enc_oldcode = (hcode_t) -1;
-	}
-	PutNextCode(op, CODE_EOI);
-	if (nextbits > 0) 
-		*op++ = (unsigned char)(nextdata << (8-nextbits));
-	tif->tif_rawcc = (tsize_t)(op - tif->tif_rawdata);
-	return (1);
-}
-
-/*
- * Reset encoding hash table.
- */
-static void
-cl_hash(LZWCodecState* sp)
-{
-	register hash_t *hp = &sp->enc_hashtab[HSIZE-1];
-	register long i = HSIZE-8;
-
- 	do {
-		i -= 8;
-		hp[-7].hash = -1;
-		hp[-6].hash = -1;
-		hp[-5].hash = -1;
-		hp[-4].hash = -1;
-		hp[-3].hash = -1;
-		hp[-2].hash = -1;
-		hp[-1].hash = -1;
-		hp[ 0].hash = -1;
-		hp -= 8;
-	} while (i >= 0);
-    	for (i += 8; i > 0; i--, hp--)
-		hp->hash = -1;
-}
-
-static void
-LZWCleanup(TIFF* tif)
-{
-	(void)TIFFPredictorCleanup(tif);
-
-	assert(tif->tif_data != 0);
-
-	if (DecoderState(tif)->dec_codetab)
-		_TIFFfree(DecoderState(tif)->dec_codetab);
-
-	if (EncoderState(tif)->enc_hashtab)
-		_TIFFfree(EncoderState(tif)->enc_hashtab);
-
-	_TIFFfree(tif->tif_data);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-int
-TIFFInitLZW(TIFF* tif, int scheme)
-{
-	assert(scheme == COMPRESSION_LZW);
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (LZWCodecState));
-	if (tif->tif_data == NULL)
-		goto bad;
-	DecoderState(tif)->dec_codetab = NULL;
-	DecoderState(tif)->dec_decode = NULL;
-	EncoderState(tif)->enc_hashtab = NULL;
-        LZWState(tif)->rw_mode = tif->tif_mode;
-
-	/*
-	 * Install codec methods.
-	 */
-	tif->tif_setupdecode = LZWSetupDecode;
-	tif->tif_predecode = LZWPreDecode;
-	tif->tif_decoderow = LZWDecode;
-	tif->tif_decodestrip = LZWDecode;
-	tif->tif_decodetile = LZWDecode;
-	tif->tif_setupencode = LZWSetupEncode;
-	tif->tif_preencode = LZWPreEncode;
-	tif->tif_postencode = LZWPostEncode;
-	tif->tif_encoderow = LZWEncode;
-	tif->tif_encodestrip = LZWEncode;
-	tif->tif_encodetile = LZWEncode;
-	tif->tif_cleanup = LZWCleanup;
-	/*
-	 * Setup predictor setup.
-	 */
-	(void) TIFFPredictorInit(tif);
-	return (1);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, "TIFFInitLZW", 
-		     "No space for LZW state block");
-	return (0);
-}
-
-/*
- * Copyright (c) 1985, 1986 The Regents of the University of California.
- * All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * James A. Woods, derived from original work by Spencer Thomas
- * and Joseph Orost.
- *
- * Redistribution and use in source and binary forms are permitted
- * provided that the above copyright notice and this paragraph are
- * duplicated in all such forms and that any documentation,
- * advertising materials, and other materials related to such
- * distribution and use acknowledge that the software was developed
- * by the University of California, Berkeley.  The name of the
- * University may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-#endif /* LZW_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_next.c b/thirdparty/libtiff/tif_next.c
deleted file mode 100644
index d7652bb..0000000
--- a/thirdparty/libtiff/tif_next.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/* $Id: tif_next.c,v 1.8.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef NEXT_SUPPORT
-/*
- * TIFF Library.
- *
- * NeXT 2-bit Grey Scale Compression Algorithm Support
- */
-
-#define SETPIXEL(op, v) {			\
-	switch (npixels++ & 3) {		\
-	case 0:	op[0]  = (unsigned char) ((v) << 6); break;	\
-	case 1:	op[0] |= (v) << 4; break;	\
-	case 2:	op[0] |= (v) << 2; break;	\
-	case 3:	*op++ |= (v);	   break;	\
-	}					\
-}
-
-#define LITERALROW	0x00
-#define LITERALSPAN	0x40
-#define WHITE   	((1<<2)-1)
-
-static int
-NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	unsigned char *bp, *op;
-	tsize_t cc;
-	tidata_t row;
-	tsize_t scanline, n;
-
-	(void) s;
-	/*
-	 * Each scanline is assumed to start off as all
-	 * white (we assume a PhotometricInterpretation
-	 * of ``min-is-black'').
-	 */
-	for (op = buf, cc = occ; cc-- > 0;)
-		*op++ = 0xff;
-
-	bp = (unsigned char *)tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-	scanline = tif->tif_scanlinesize;
-	for (row = buf; occ > 0; occ -= scanline, row += scanline) {
-		n = *bp++, cc--;
-		switch (n) {
-		case LITERALROW:
-			/*
-			 * The entire scanline is given as literal values.
-			 */
-			if (cc < scanline)
-				goto bad;
-			_TIFFmemcpy(row, bp, scanline);
-			bp += scanline;
-			cc -= scanline;
-			break;
-		case LITERALSPAN: {
-			tsize_t off;
-			/*
-			 * The scanline has a literal span that begins at some
-			 * offset.
-			 */
-			off = (bp[0] * 256) + bp[1];
-			n = (bp[2] * 256) + bp[3];
-			if (cc < 4+n || off+n > scanline)
-				goto bad;
-			_TIFFmemcpy(row+off, bp+4, n);
-			bp += 4+n;
-			cc -= 4+n;
-			break;
-		}
-		default: {
-			uint32 npixels = 0, grey;
-			uint32 imagewidth = tif->tif_dir.td_imagewidth;
-
-			/*
-			 * The scanline is composed of a sequence of constant
-			 * color ``runs''.  We shift into ``run mode'' and
-			 * interpret bytes as codes of the form
-			 * <color><npixels> until we've filled the scanline.
-			 */
-			op = row;
-			for (;;) {
-				grey = (n>>6) & 0x3;
-				n &= 0x3f;
-				/*
-				 * Ensure the run does not exceed the scanline
-				 * bounds, potentially resulting in a security
-				 * issue.
-				 */
-				while (n-- > 0 && npixels < imagewidth)
-					SETPIXEL(op, grey);
-				if (npixels >= imagewidth)
-					break;
-				if (cc == 0)
-					goto bad;
-				n = *bp++, cc--;
-			}
-			break;
-		}
-		}
-	}
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	return (1);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "NeXTDecode: Not enough data for scanline %ld",
-	    (long) tif->tif_row);
-	return (0);
-}
-
-int
-TIFFInitNeXT(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	tif->tif_decoderow = NeXTDecode;
-	tif->tif_decodestrip = NeXTDecode;
-	tif->tif_decodetile = NeXTDecode;
-	return (1);
-}
-#endif /* NEXT_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_ojpeg.c b/thirdparty/libtiff/tif_ojpeg.c
deleted file mode 100644
index 9ae856c..0000000
--- a/thirdparty/libtiff/tif_ojpeg.c
+++ /dev/null
@@ -1,2438 +0,0 @@
-/* $Id: tif_ojpeg.c,v 1.24.2.6 2010-06-08 23:29:51 bfriesen Exp $ */
-
-/* WARNING: The type of JPEG encapsulation defined by the TIFF Version 6.0
-   specification is now totally obsolete and deprecated for new applications and
-   images. This file was was created solely in order to read unconverted images
-   still present on some users' computer systems. It will never be extended
-   to write such files. Writing new-style JPEG compressed TIFFs is implemented
-   in tif_jpeg.c.
-
-   The code is carefully crafted to robustly read all gathered JPEG-in-TIFF
-   testfiles, and anticipate as much as possible all other... But still, it may
-   fail on some. If you encounter problems, please report them on the TIFF
-   mailing list and/or to Joris Van Damme <info@awaresystems.be>.
-
-   Please read the file called "TIFF Technical Note #2" if you need to be
-   convinced this compression scheme is bad and breaks TIFF. That document
-   is linked to from the LibTiff site <http://www.remotesensing.org/libtiff/>
-   and from AWare Systems' TIFF section
-   <http://www.awaresystems.be/imaging/tiff.html>. It is also absorbed
-   in Adobe's specification supplements, marked "draft" up to this day, but
-   supported by the TIFF community.
-
-   This file interfaces with Release 6B of the JPEG Library written by the
-   Independent JPEG Group. Previous versions of this file required a hack inside
-   the LibJpeg library. This version no longer requires that. Remember to
-   remove the hack if you update from the old version.
-
-   Copyright (c) Joris Van Damme <info@awaresystems.be>
-   Copyright (c) AWare Systems <http://www.awaresystems.be/>
-
-   The licence agreement for this file is the same as the rest of the LibTiff
-   library.
-
-   IN NO EVENT SHALL JORIS VAN DAMME OR AWARE SYSTEMS BE LIABLE FOR
-   ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
-   OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-   WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
-   LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
-   OF THIS SOFTWARE.
-
-   Joris Van Damme and/or AWare Systems may be available for custom
-   developement. If you like what you see, and need anything similar or related,
-   contact <info@awaresystems.be>.
-*/
-
-/* What is what, and what is not?
-
-   This decoder starts with an input stream, that is essentially the JpegInterchangeFormat
-   stream, if any, followed by the strile data, if any. This stream is read in
-   OJPEGReadByte and related functions.
-
-   It analyzes the start of this stream, until it encounters non-marker data, i.e.
-   compressed image data. Some of the header markers it sees have no actual content,
-   like the SOI marker, and APP/COM markers that really shouldn't even be there. Some
-   other markers do have content, and the valuable bits and pieces of information
-   in these markers are saved, checking all to verify that the stream is more or
-   less within expected bounds. This happens inside the OJPEGReadHeaderInfoSecStreamXxx
-   functions.
-
-   Some OJPEG imagery contains no valid JPEG header markers. This situation is picked
-   up on if we've seen no SOF marker when we're at the start of the compressed image
-   data. In this case, the tables are read from JpegXxxTables tags, and the other
-   bits and pieces of information is initialized to its most basic value. This is
-   implemented in the OJPEGReadHeaderInfoSecTablesXxx functions.
-
-   When this is complete, a good and valid JPEG header can be assembled, and this is
-   passed through to LibJpeg. When that's done, the remainder of the input stream, i.e.
-   the compressed image data, can be passed through unchanged. This is done in
-   OJPEGWriteStream functions.
-
-   LibTiff rightly expects to know the subsampling values before decompression. Just like
-   in new-style JPEG-in-TIFF, though, or even more so, actually, the YCbCrsubsampling
-   tag is notoriously unreliable. To correct these tag values with the ones inside
-   the JPEG stream, the first part of the input stream is pre-scanned in
-   OJPEGSubsamplingCorrect, making no note of any other data, reporting no warnings
-   or errors, up to the point where either these values are read, or it's clear they
-   aren't there. This means that some of the data is read twice, but we feel speed
-   in correcting these values is important enough to warrant this sacrifice. Allthough
-   there is currently no define or other configuration mechanism to disable this behaviour,
-   the actual header scanning is build to robustly respond with error report if it
-   should encounter an uncorrected mismatch of subsampling values. See
-   OJPEGReadHeaderInfoSecStreamSof.
-
-   The restart interval and restart markers are the most tricky part... The restart
-   interval can be specified in a tag. It can also be set inside the input JPEG stream.
-   It can be used inside the input JPEG stream. If reading from strile data, we've
-   consistenly discovered the need to insert restart markers in between the different
-   striles, as is also probably the most likely interpretation of the original TIFF 6.0
-   specification. With all this setting of interval, and actual use of markers that is not
-   predictable at the time of valid JPEG header assembly, the restart thing may turn
-   out the Achilles heel of this implementation. Fortunately, most OJPEG writer vendors
-   succeed in reading back what they write, which may be the reason why we've been able
-   to discover ways that seem to work.
-
-   Some special provision is made for planarconfig separate OJPEG files. These seem
-   to consistently contain header info, a SOS marker, a plane, SOS marker, plane, SOS,
-   and plane. This may or may not be a valid JPEG configuration, we don't know and don't
-   care. We want LibTiff to be able to access the planes individually, without huge
-   buffering inside LibJpeg, anyway. So we compose headers to feed to LibJpeg, in this
-   case, that allow us to pass a single plane such that LibJpeg sees a valid
-   single-channel JPEG stream. Locating subsequent SOS markers, and thus subsequent
-   planes, is done inside OJPEGReadSecondarySos.
-
-   The benefit of the scheme is... that it works, basically. We know of no other that
-   does. It works without checking software tag, or otherwise going about things in an
-   OJPEG flavor specific manner. Instead, it is a single scheme, that covers the cases
-   with and without JpegInterchangeFormat, with and without striles, with part of
-   the header in JpegInterchangeFormat and remainder in first strile, etc. It is forgiving
-   and robust, may likely work with OJPEG flavors we've not seen yet, and makes most out
-   of the data.
-
-   Another nice side-effect is that a complete JPEG single valid stream is build if
-   planarconfig is not separate (vast majority). We may one day use that to build
-   converters to JPEG, and/or to new-style JPEG compression inside TIFF.
-
-   A dissadvantage is the lack of random access to the individual striles. This is the
-   reason for much of the complicated restart-and-position stuff inside OJPEGPreDecode.
-   Applications would do well accessing all striles in order, as this will result in
-   a single sequential scan of the input stream, and no restarting of LibJpeg decoding
-   session.
-*/
-
-
-#include "tiffiop.h"
-#ifdef OJPEG_SUPPORT
-
-/* Configuration defines here are:
- * JPEG_ENCAP_EXTERNAL: The normal way to call libjpeg, uses longjump. In some environments,
- * 	like eg LibTiffDelphi, this is not possible. For this reason, the actual calls to
- * 	libjpeg, with longjump stuff, are encapsulated in dedicated functions. When
- * 	JPEG_ENCAP_EXTERNAL is defined, these encapsulating functions are declared external
- * 	to this unit, and can be defined elsewhere to use stuff other then longjump.
- * 	The default mode, without JPEG_ENCAP_EXTERNAL, implements the call encapsulators
- * 	here, internally, with normal longjump.
- * SETJMP, LONGJMP, JMP_BUF: On some machines/environments a longjump equivalent is
- * 	conviniently available, but still it may be worthwhile to use _setjmp or sigsetjmp
- * 	in place of plain setjmp. These macros will make it easier. It is useless
- * 	to fiddle with these if you define JPEG_ENCAP_EXTERNAL.
- * OJPEG_BUFFER: Define the size of the desired buffer here. Should be small enough so as to guarantee
- * 	instant processing, optimal streaming and optimal use of processor cache, but also big
- * 	enough so as to not result in significant call overhead. It should be at least a few
- * 	bytes to accomodate some structures (this is verified in asserts), but it would not be
- * 	sensible to make it this small anyway, and it should be at most 64K since it is indexed
- * 	with uint16. We recommend 2K.
- * EGYPTIANWALK: You could also define EGYPTIANWALK here, but it is not used anywhere and has
- * 	absolutely no effect. That is why most people insist the EGYPTIANWALK is a bit silly.
- */
-
-/* #define LIBJPEG_ENCAP_EXTERNAL */
-#define SETJMP(jbuf) setjmp(jbuf)
-#define LONGJMP(jbuf,code) longjmp(jbuf,code)
-#define JMP_BUF jmp_buf
-#define OJPEG_BUFFER 2048
-/* define EGYPTIANWALK */
-
-#define JPEG_MARKER_SOF0 0xC0
-#define JPEG_MARKER_SOF1 0xC1
-#define JPEG_MARKER_SOF3 0xC3
-#define JPEG_MARKER_DHT 0xC4
-#define JPEG_MARKER_RST0 0XD0
-#define JPEG_MARKER_SOI 0xD8
-#define JPEG_MARKER_EOI 0xD9
-#define JPEG_MARKER_SOS 0xDA
-#define JPEG_MARKER_DQT 0xDB
-#define JPEG_MARKER_DRI 0xDD
-#define JPEG_MARKER_APP0 0xE0
-#define JPEG_MARKER_COM 0xFE
-
-#define FIELD_OJPEG_JPEGINTERCHANGEFORMAT (FIELD_CODEC+0)
-#define FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH (FIELD_CODEC+1)
-#define FIELD_OJPEG_JPEGQTABLES (FIELD_CODEC+2)
-#define FIELD_OJPEG_JPEGDCTABLES (FIELD_CODEC+3)
-#define FIELD_OJPEG_JPEGACTABLES (FIELD_CODEC+4)
-#define FIELD_OJPEG_JPEGPROC (FIELD_CODEC+5)
-#define FIELD_OJPEG_JPEGRESTARTINTERVAL (FIELD_CODEC+6)
-#define FIELD_OJPEG_COUNT 7
-
-static const TIFFFieldInfo ojpeg_field_info[] = {
-	{TIFFTAG_JPEGIFOFFSET,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMAT,TRUE,FALSE,"JpegInterchangeFormat"},
-	{TIFFTAG_JPEGIFBYTECOUNT,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH,TRUE,FALSE,"JpegInterchangeFormatLength"},
-	{TIFFTAG_JPEGQTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGQTABLES,FALSE,TRUE,"JpegQTables"},
-	{TIFFTAG_JPEGDCTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGDCTABLES,FALSE,TRUE,"JpegDcTables"},
-	{TIFFTAG_JPEGACTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGACTABLES,FALSE,TRUE,"JpegAcTables"},
-	{TIFFTAG_JPEGPROC,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGPROC,FALSE,FALSE,"JpegProc"},
-	{TIFFTAG_JPEGRESTARTINTERVAL,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGRESTARTINTERVAL,FALSE,FALSE,"JpegRestartInterval"},
-};
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-#include <setjmp.h>
-#endif
-
-#include "jpeglib.h"
-#include "jerror.h"
-
-typedef struct jpeg_error_mgr jpeg_error_mgr;
-typedef struct jpeg_common_struct jpeg_common_struct;
-typedef struct jpeg_decompress_struct jpeg_decompress_struct;
-typedef struct jpeg_source_mgr jpeg_source_mgr;
-
-typedef enum {
-	osibsNotSetYet,
-	osibsJpegInterchangeFormat,
-	osibsStrile,
-	osibsEof
-} OJPEGStateInBufferSource;
-
-typedef enum {
-	ososSoi,
-	ososQTable0,ososQTable1,ososQTable2,ososQTable3,
-	ososDcTable0,ososDcTable1,ososDcTable2,ososDcTable3,
-	ososAcTable0,ososAcTable1,ososAcTable2,ososAcTable3,
-	ososDri,
-	ososSof,
-	ososSos,
-	ososCompressed,
-	ososRst,
-	ososEoi
-} OJPEGStateOutState;
-
-typedef struct {
-	TIFF* tif;
-	#ifndef LIBJPEG_ENCAP_EXTERNAL
-	JMP_BUF exit_jmpbuf;
-	#endif
-	TIFFVGetMethod vgetparent;
-	TIFFVSetMethod vsetparent;
-	toff_t file_size;
-	uint32 image_width;
-	uint32 image_length;
-	uint32 strile_width;
-	uint32 strile_length;
-	uint32 strile_length_total;
-	uint8 samples_per_pixel;
-	uint8 plane_sample_offset;
-	uint8 samples_per_pixel_per_plane;
-	toff_t jpeg_interchange_format;
-	toff_t jpeg_interchange_format_length;
-	uint8 jpeg_proc;
-	uint8 subsamplingcorrect;
-	uint8 subsamplingcorrect_done;
-	uint8 subsampling_tag;
-	uint8 subsampling_hor;
-	uint8 subsampling_ver;
-	uint8 subsampling_force_desubsampling_inside_decompression;
-	uint8 qtable_offset_count;
-	uint8 dctable_offset_count;
-	uint8 actable_offset_count;
-	toff_t qtable_offset[3];
-	toff_t dctable_offset[3];
-	toff_t actable_offset[3];
-	uint8* qtable[4];
-	uint8* dctable[4];
-	uint8* actable[4];
-	uint16 restart_interval;
-	uint8 restart_index;
-	uint8 sof_log;
-	uint8 sof_marker_id;
-	uint32 sof_x;
-	uint32 sof_y;
-	uint8 sof_c[3];
-	uint8 sof_hv[3];
-	uint8 sof_tq[3];
-	uint8 sos_cs[3];
-	uint8 sos_tda[3];
-	struct {
-		uint8 log;
-		OJPEGStateInBufferSource in_buffer_source;
-		tstrile_t in_buffer_next_strile;
-		toff_t in_buffer_file_pos;
-		toff_t in_buffer_file_togo;
-	} sos_end[3];
-	uint8 readheader_done;
-	uint8 writeheader_done;
-	tsample_t write_cursample;
-	tstrile_t write_curstrile;
-	uint8 libjpeg_session_active;
-	uint8 libjpeg_jpeg_query_style;
-	jpeg_error_mgr libjpeg_jpeg_error_mgr;
-	jpeg_decompress_struct libjpeg_jpeg_decompress_struct;
-	jpeg_source_mgr libjpeg_jpeg_source_mgr;
-	uint8 subsampling_convert_log;
-	uint32 subsampling_convert_ylinelen;
-	uint32 subsampling_convert_ylines;
-	uint32 subsampling_convert_clinelen;
-	uint32 subsampling_convert_clines;
-	uint32 subsampling_convert_ybuflen;
-	uint32 subsampling_convert_cbuflen;
-	uint32 subsampling_convert_ycbcrbuflen;
-	uint8* subsampling_convert_ycbcrbuf;
-	uint8* subsampling_convert_ybuf;
-	uint8* subsampling_convert_cbbuf;
-	uint8* subsampling_convert_crbuf;
-	uint32 subsampling_convert_ycbcrimagelen;
-	uint8** subsampling_convert_ycbcrimage;
-	uint32 subsampling_convert_clinelenout;
-	uint32 subsampling_convert_state;
-	uint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */
-	uint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */
-	OJPEGStateInBufferSource in_buffer_source;
-	tstrile_t in_buffer_next_strile;
-	tstrile_t in_buffer_strile_count;
-	toff_t in_buffer_file_pos;
-	uint8 in_buffer_file_pos_log;
-	toff_t in_buffer_file_togo;
-	uint16 in_buffer_togo;
-	uint8* in_buffer_cur;
-	uint8 in_buffer[OJPEG_BUFFER];
-	OJPEGStateOutState out_state;
-	uint8 out_buffer[OJPEG_BUFFER];
-	uint8* skip_buffer;
-} OJPEGState;
-
-static int OJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap);
-static int OJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap);
-static void OJPEGPrintDir(TIFF* tif, FILE* fd, long flags);
-
-static int OJPEGSetupDecode(TIFF* tif);
-static int OJPEGPreDecode(TIFF* tif, tsample_t s);
-static int OJPEGPreDecodeSkipRaw(TIFF* tif);
-static int OJPEGPreDecodeSkipScanlines(TIFF* tif);
-static int OJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);
-static int OJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc);
-static int OJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc);
-static void OJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc);
-static int OJPEGSetupEncode(TIFF* tif);
-static int OJPEGPreEncode(TIFF* tif, tsample_t s);
-static int OJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);
-static int OJPEGPostEncode(TIFF* tif);
-static void OJPEGCleanup(TIFF* tif);
-
-static void OJPEGSubsamplingCorrect(TIFF* tif);
-static int OJPEGReadHeaderInfo(TIFF* tif);
-static int OJPEGReadSecondarySos(TIFF* tif, tsample_t s);
-static int OJPEGWriteHeaderInfo(TIFF* tif);
-static void OJPEGLibjpegSessionAbort(TIFF* tif);
-
-static int OJPEGReadHeaderInfoSec(TIFF* tif);
-static int OJPEGReadHeaderInfoSecStreamDri(TIFF* tif);
-static int OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif);
-static int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif);
-static int OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id);
-static int OJPEGReadHeaderInfoSecStreamSos(TIFF* tif);
-static int OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif);
-static int OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif);
-static int OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif);
-
-static int OJPEGReadBufferFill(OJPEGState* sp);
-static int OJPEGReadByte(OJPEGState* sp, uint8* byte);
-static int OJPEGReadBytePeek(OJPEGState* sp, uint8* byte);
-static void OJPEGReadByteAdvance(OJPEGState* sp);
-static int OJPEGReadWord(OJPEGState* sp, uint16* word);
-static int OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem);
-static void OJPEGReadSkip(OJPEGState* sp, uint16 len);
-
-static int OJPEGWriteStream(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);
-static void OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len);
-static int OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len);
-static void OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len);
-
-#ifdef LIBJPEG_ENCAP_EXTERNAL
-extern int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-extern int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);
-extern int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-extern int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);
-extern int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);
-extern void jpeg_encap_unwind(TIFF* tif);
-#else
-static int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* j);
-static int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);
-static int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);
-static int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);
-static int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);
-static void jpeg_encap_unwind(TIFF* tif);
-#endif
-
-static void OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo);
-static void OJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo);
-static void OJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo);
-static boolean OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo);
-static void OJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes);
-static boolean OJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired);
-static void OJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo);
-
-int
-TIFFInitOJPEG(TIFF* tif, int scheme)
-{
-	static const char module[]="TIFFInitOJPEG";
-	OJPEGState* sp;
-
-	assert(scheme==COMPRESSION_OJPEG);
-
-        /*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif,ojpeg_field_info,FIELD_OJPEG_COUNT)) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Merging Old JPEG codec-specific tags failed");
-		return 0;
-	}
-
-	/* state block */
-	sp=_TIFFmalloc(sizeof(OJPEGState));
-	if (sp==NULL)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"No space for OJPEG state block");
-		return(0);
-	}
-	_TIFFmemset(sp,0,sizeof(OJPEGState));
-	sp->tif=tif;
-	sp->jpeg_proc=1;
-	sp->subsampling_hor=2;
-	sp->subsampling_ver=2;
-	TIFFSetField(tif,TIFFTAG_YCBCRSUBSAMPLING,2,2);
-	/* tif codec methods */
-	tif->tif_setupdecode=OJPEGSetupDecode;
-	tif->tif_predecode=OJPEGPreDecode;
-	tif->tif_postdecode=OJPEGPostDecode;
-	tif->tif_decoderow=OJPEGDecode;
-	tif->tif_decodestrip=OJPEGDecode;
-	tif->tif_decodetile=OJPEGDecode;
-	tif->tif_setupencode=OJPEGSetupEncode;
-	tif->tif_preencode=OJPEGPreEncode;
-	tif->tif_postencode=OJPEGPostEncode;
-	tif->tif_encoderow=OJPEGEncode;
-	tif->tif_encodestrip=OJPEGEncode;
-	tif->tif_encodetile=OJPEGEncode;
-	tif->tif_cleanup=OJPEGCleanup;
-	tif->tif_data=(tidata_t)sp;
-	/* tif tag methods */
-	sp->vgetparent=tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield=OJPEGVGetField;
-	sp->vsetparent=tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield=OJPEGVSetField;
-	tif->tif_tagmethods.printdir=OJPEGPrintDir;
-	/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.
-	   Some others do, but have totally meaningless or corrupt values
-	   in these tags. In these cases, the JpegInterchangeFormat stream is
-	   reliable. In any case, this decoder reads the compressed data itself,
-	   from the most reliable locations, and we need to notify encapsulating
-	   LibTiff not to read raw strips or tiles for us. */
-	tif->tif_flags|=TIFF_NOREADRAW;
-	return(1);
-}
-
-static int
-OJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	switch(tag)
-	{
-		case TIFFTAG_JPEGIFOFFSET:
-			*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format;
-			break;
-		case TIFFTAG_JPEGIFBYTECOUNT:
-			*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format_length;
-			break;
-		case TIFFTAG_YCBCRSUBSAMPLING:
-			if (sp->subsamplingcorrect_done==0)
-				OJPEGSubsamplingCorrect(tif);
-			*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;
-			*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;
-			break;
-		case TIFFTAG_JPEGQTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->qtable_offset;
-			break;
-		case TIFFTAG_JPEGDCTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->dctable_offset;
-			break;
-		case TIFFTAG_JPEGACTABLES:
-			*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;
-			*va_arg(ap,void**)=(void*)sp->actable_offset;
-			break;
-		case TIFFTAG_JPEGPROC:
-			*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;
-			break;
-		case TIFFTAG_JPEGRESTARTINTERVAL:
-			*va_arg(ap,uint16*)=sp->restart_interval;
-			break;
-		default:
-			return (*sp->vgetparent)(tif,tag,ap);
-	}
-	return (1);
-}
-
-static int
-OJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	static const char module[]="OJPEGVSetField";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 ma;
-	uint32* mb;
-	uint32 n;
-	switch(tag)
-	{
-		case TIFFTAG_JPEGIFOFFSET:
-			sp->jpeg_interchange_format=(toff_t)va_arg(ap,uint32);  
-			break;
-		case TIFFTAG_JPEGIFBYTECOUNT:
-			sp->jpeg_interchange_format_length=(toff_t)va_arg(ap,uint32);  
-			break;
-		case TIFFTAG_YCBCRSUBSAMPLING:
-			sp->subsampling_tag=1;
-			sp->subsampling_hor=(uint8)va_arg(ap,int);
-			sp->subsampling_ver=(uint8)va_arg(ap,int);
-			tif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;
-			tif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;
-			break;
-		case TIFFTAG_JPEGQTABLES:
-			ma=va_arg(ap,uint32);
-			if (ma!=0)
-			{
-				if (ma>3)
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"JpegQTables tag has incorrect count");
-					return(0);
-				}
-				sp->qtable_offset_count=(uint8)ma;
-				mb=va_arg(ap,uint32*);
-				for (n=0; n<ma; n++)
-					sp->qtable_offset[n]=(toff_t)mb[n];
-			}
-			break;
-		case TIFFTAG_JPEGDCTABLES:
-			ma=va_arg(ap,uint32);
-			if (ma!=0)
-			{
-				if (ma>3)
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"JpegDcTables tag has incorrect count");
-					return(0);
-				}
-				sp->dctable_offset_count=(uint8)ma;
-				mb=va_arg(ap,uint32*);
-				for (n=0; n<ma; n++)
-					sp->dctable_offset[n]=(toff_t)mb[n];
-			}
-			break;
-		case TIFFTAG_JPEGACTABLES:
-			ma=va_arg(ap,uint32);
-			if (ma!=0)
-			{
-				if (ma>3)
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"JpegAcTables tag has incorrect count");
-					return(0);
-				}
-				sp->actable_offset_count=(uint8)ma;
-				mb=va_arg(ap,uint32*);
-				for (n=0; n<ma; n++)
-					sp->actable_offset[n]=(toff_t)mb[n];
-			}
-			break;
-		case TIFFTAG_JPEGPROC:
-			sp->jpeg_proc=(uint8)va_arg(ap,uint32);
-			break;
-		case TIFFTAG_JPEGRESTARTINTERVAL:
-			sp->restart_interval=(uint16)va_arg(ap,uint32);
-			break;
-		default:
-			return (*sp->vsetparent)(tif,tag,ap);
-	}
-	TIFFSetFieldBit(tif,_TIFFFieldWithTag(tif,tag)->field_bit);
-	tif->tif_flags|=TIFF_DIRTYDIRECT;
-	return(1);
-}
-
-static void
-OJPEGPrintDir(TIFF* tif, FILE* fd, long flags)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	(void)flags;
-	assert(sp!=NULL);
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMAT))
-		fprintf(fd,"  JpegInterchangeFormat: %lu\n",(unsigned long)sp->jpeg_interchange_format);
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH))
-		fprintf(fd,"  JpegInterchangeFormatLength: %lu\n",(unsigned long)sp->jpeg_interchange_format_length);
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGQTABLES))
-	{
-		fprintf(fd,"  JpegQTables:");
-		for (m=0; m<sp->qtable_offset_count; m++)
-			fprintf(fd," %lu",(unsigned long)sp->qtable_offset[m]);
-		fprintf(fd,"\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGDCTABLES))
-	{
-		fprintf(fd,"  JpegDcTables:");
-		for (m=0; m<sp->dctable_offset_count; m++)
-			fprintf(fd," %lu",(unsigned long)sp->dctable_offset[m]);
-		fprintf(fd,"\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGACTABLES))
-	{
-		fprintf(fd,"  JpegAcTables:");
-		for (m=0; m<sp->actable_offset_count; m++)
-			fprintf(fd," %lu",(unsigned long)sp->actable_offset[m]);
-		fprintf(fd,"\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGPROC))
-		fprintf(fd,"  JpegProc: %u\n",(unsigned int)sp->jpeg_proc);
-	if (TIFFFieldSet(tif,FIELD_OJPEG_JPEGRESTARTINTERVAL))
-		fprintf(fd,"  JpegRestartInterval: %u\n",(unsigned int)sp->restart_interval);
-}
-
-static int
-OJPEGSetupDecode(TIFF* tif)
-{
-	static const char module[]="OJPEGSetupDecode";
-	TIFFWarningExt(tif->tif_clientdata,module,"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software");
-	return(1);
-}
-
-static int
-OJPEGPreDecode(TIFF* tif, tsample_t s)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	tstrile_t m;
-	if (sp->subsamplingcorrect_done==0)
-		OJPEGSubsamplingCorrect(tif);
-	if (sp->readheader_done==0)
-	{
-		if (OJPEGReadHeaderInfo(tif)==0)
-			return(0);
-	}
-	if (sp->sos_end[s].log==0)
-	{
-		if (OJPEGReadSecondarySos(tif,s)==0)
-			return(0);
-	}
-	if isTiled(tif)
-		m=(tstrile_t)tif->tif_curtile;
-	else
-		m=(tstrile_t)tif->tif_curstrip;
-	if ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m)))
-	{
-		if (sp->libjpeg_session_active!=0)
-			OJPEGLibjpegSessionAbort(tif);
-		sp->writeheader_done=0;
-	}
-	if (sp->writeheader_done==0)
-	{
-		sp->plane_sample_offset=s;
-		sp->write_cursample=s;
-		sp->write_curstrile=s*tif->tif_dir.td_stripsperimage;
-		if ((sp->in_buffer_file_pos_log==0) ||
-		    (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos))
-		{
-			sp->in_buffer_source=sp->sos_end[s].in_buffer_source;
-			sp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile;
-			sp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos;
-			sp->in_buffer_file_pos_log=0;
-			sp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo;
-			sp->in_buffer_togo=0;
-			sp->in_buffer_cur=0;
-		}
-		if (OJPEGWriteHeaderInfo(tif)==0)
-			return(0);
-	}
-	while (sp->write_curstrile<m)          
-	{
-		if (sp->libjpeg_jpeg_query_style==0)
-		{
-			if (OJPEGPreDecodeSkipRaw(tif)==0)
-				return(0);
-		}
-		else
-		{
-			if (OJPEGPreDecodeSkipScanlines(tif)==0)
-				return(0);
-		}
-		sp->write_curstrile++;
-	}
-	return(1);
-}
-
-static int
-OJPEGPreDecodeSkipRaw(TIFF* tif)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 m;
-	m=sp->lines_per_strile;
-	if (sp->subsampling_convert_state!=0)
-	{
-		if (sp->subsampling_convert_clines-sp->subsampling_convert_state>=m)
-		{
-			sp->subsampling_convert_state+=m;
-			if (sp->subsampling_convert_state==sp->subsampling_convert_clines)
-				sp->subsampling_convert_state=0;
-			return(1);
-		}
-		m-=sp->subsampling_convert_clines-sp->subsampling_convert_state;
-		sp->subsampling_convert_state=0;
-	}
-	while (m>=sp->subsampling_convert_clines)
-	{
-		if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)
-			return(0);
-		m-=sp->subsampling_convert_clines;
-	}
-	if (m>0)
-	{
-		if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)
-			return(0);
-		sp->subsampling_convert_state=m;
-	}
-	return(1);
-}
-
-static int
-OJPEGPreDecodeSkipScanlines(TIFF* tif)
-{
-	static const char module[]="OJPEGPreDecodeSkipScanlines";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint32 m;
-	if (sp->skip_buffer==NULL)
-	{
-		sp->skip_buffer=_TIFFmalloc(sp->bytes_per_line);
-		if (sp->skip_buffer==NULL)
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-			return(0);
-		}
-	}
-	for (m=0; m<sp->lines_per_strile; m++)
-	{
-		if (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&sp->skip_buffer,1)==0)
-			return(0);
-	}
-	return(1);
-}
-
-static int
-OJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	(void)s;
-	if (sp->libjpeg_jpeg_query_style==0)
-	{
-		if (OJPEGDecodeRaw(tif,buf,cc)==0)
-			return(0);
-	}
-	else
-	{
-		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
-			return(0);
-	}
-	return(1);
-}
-
-static int
-OJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-	static const char module[]="OJPEGDecodeRaw";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8* m;
-	uint32 n;
-	uint8* oy;
-	uint8* ocb;
-	uint8* ocr;
-	uint8* p;
-	uint32 q;
-	uint8* r;
-	uint8 sx,sy;
-	if (cc%sp->bytes_per_line!=0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Fractional scanline not read");
-		return(0);
-	}
-	assert(cc>0);
-	m=buf;
-	n=cc;
-	do
-	{
-		if (sp->subsampling_convert_state==0)
-		{
-			if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)
-				return(0);
-		}
-		oy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;
-		ocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;
-		ocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;
-		p=m;
-		for (q=0; q<sp->subsampling_convert_clinelenout; q++)
-		{
-			r=oy;
-			for (sy=0; sy<sp->subsampling_ver; sy++)
-			{
-				for (sx=0; sx<sp->subsampling_hor; sx++)
-					*p++=*r++;
-				r+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;
-			}
-			oy+=sp->subsampling_hor;
-			*p++=*ocb++;
-			*p++=*ocr++;
-		}
-		sp->subsampling_convert_state++;
-		if (sp->subsampling_convert_state==sp->subsampling_convert_clines)
-			sp->subsampling_convert_state=0;
-		m+=sp->bytes_per_line;
-		n-=sp->bytes_per_line;
-	} while(n>0);
-	return(1);
-}
-
-static int
-OJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-	static const char module[]="OJPEGDecodeScanlines";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8* m;
-	uint32 n;
-	if (cc%sp->bytes_per_line!=0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Fractional scanline not read");
-		return(0);
-	}
-	assert(cc>0);
-	m=buf;
-	n=cc;
-	do
-	{
-		if (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&m,1)==0)
-			return(0);
-		m+=sp->bytes_per_line;
-		n-=sp->bytes_per_line;
-	} while(n>0);
-	return(1);
-}
-
-static void
-OJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	(void)buf;
-	(void)cc;
-	sp->write_curstrile++;
-	if (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0)
-	{
-		assert(sp->libjpeg_session_active!=0);
-		OJPEGLibjpegSessionAbort(tif);
-		sp->writeheader_done=0;
-	}
-}
-
-static int
-OJPEGSetupEncode(TIFF* tif)
-{
-	static const char module[]="OJPEGSetupEncode";
-	TIFFErrorExt(tif->tif_clientdata,module,"OJPEG encoding not supported; use new-style JPEG compression instead");
-	return(0);
-}
-
-static int
-OJPEGPreEncode(TIFF* tif, tsample_t s)
-{
-	static const char module[]="OJPEGPreEncode";
-	(void)s;
-	TIFFErrorExt(tif->tif_clientdata,module,"OJPEG encoding not supported; use new-style JPEG compression instead");
-	return(0);
-}
-
-static int
-OJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	static const char module[]="OJPEGEncode";
-	(void)buf;
-	(void)cc;
-	(void)s;
-	TIFFErrorExt(tif->tif_clientdata,module,"OJPEG encoding not supported; use new-style JPEG compression instead");
-	return(0);
-}
-
-static int
-OJPEGPostEncode(TIFF* tif)
-{
-	static const char module[]="OJPEGPostEncode";
-	TIFFErrorExt(tif->tif_clientdata,module,"OJPEG encoding not supported; use new-style JPEG compression instead");
-	return(0);
-}
-
-static void
-OJPEGCleanup(TIFF* tif)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	if (sp!=0)
-	{
-		tif->tif_tagmethods.vgetfield=sp->vgetparent;
-		tif->tif_tagmethods.vsetfield=sp->vsetparent;
-		if (sp->qtable[0]!=0)
-			_TIFFfree(sp->qtable[0]);
-		if (sp->qtable[1]!=0)
-			_TIFFfree(sp->qtable[1]);
-		if (sp->qtable[2]!=0)
-			_TIFFfree(sp->qtable[2]);
-		if (sp->qtable[3]!=0)
-			_TIFFfree(sp->qtable[3]);
-		if (sp->dctable[0]!=0)
-			_TIFFfree(sp->dctable[0]);
-		if (sp->dctable[1]!=0)
-			_TIFFfree(sp->dctable[1]);
-		if (sp->dctable[2]!=0)
-			_TIFFfree(sp->dctable[2]);
-		if (sp->dctable[3]!=0)
-			_TIFFfree(sp->dctable[3]);
-		if (sp->actable[0]!=0)
-			_TIFFfree(sp->actable[0]);
-		if (sp->actable[1]!=0)
-			_TIFFfree(sp->actable[1]);
-		if (sp->actable[2]!=0)
-			_TIFFfree(sp->actable[2]);
-		if (sp->actable[3]!=0)
-			_TIFFfree(sp->actable[3]);
-		if (sp->libjpeg_session_active!=0)
-			OJPEGLibjpegSessionAbort(tif);
-		if (sp->subsampling_convert_ycbcrbuf!=0)
-			_TIFFfree(sp->subsampling_convert_ycbcrbuf);
-		if (sp->subsampling_convert_ycbcrimage!=0)
-			_TIFFfree(sp->subsampling_convert_ycbcrimage);
-		if (sp->skip_buffer!=0)
-			_TIFFfree(sp->skip_buffer);
-		_TIFFfree(sp);
-		tif->tif_data=NULL;
-		_TIFFSetDefaultCompressionState(tif);
-	}
-}
-
-static void
-OJPEGSubsamplingCorrect(TIFF* tif)
-{
-	static const char module[]="OJPEGSubsamplingCorrect";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 mh;
-	uint8 mv;
-	assert(sp->subsamplingcorrect_done==0);
-	if ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&
-	    (tif->tif_dir.td_photometric!=PHOTOMETRIC_ITULAB)))
-	{
-		if (sp->subsampling_tag!=0)
-			TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel");
-		sp->subsampling_hor=1;
-		sp->subsampling_ver=1;
-		sp->subsampling_force_desubsampling_inside_decompression=0;
-	}
-	else
-	{
-		sp->subsamplingcorrect_done=1;
-		mh=sp->subsampling_hor;
-		mv=sp->subsampling_ver;
-		sp->subsamplingcorrect=1;
-		OJPEGReadHeaderInfoSec(tif);
-		if (sp->subsampling_force_desubsampling_inside_decompression!=0)
-		{
-			sp->subsampling_hor=1;
-			sp->subsampling_ver=1;
-		}
-		sp->subsamplingcorrect=0;
-		if (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))
-		{
-			if (sp->subsampling_tag==0)
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver);
-			else
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct",sp->subsampling_hor,sp->subsampling_ver,mh,mv);
-		}
-		if (sp->subsampling_force_desubsampling_inside_decompression!=0)
-		{
-			if (sp->subsampling_tag==0)
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression");
-			else
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression",mh,mv);
-		}
-		if (sp->subsampling_force_desubsampling_inside_decompression==0)
-		{
-			if (sp->subsampling_hor<sp->subsampling_ver)
-				TIFFWarningExt(tif->tif_clientdata,module,"Subsampling values [%d,%d] are not allowed in TIFF",sp->subsampling_hor,sp->subsampling_ver);
-		}
-	}
-	sp->subsamplingcorrect_done=1;
-}
-
-static int
-OJPEGReadHeaderInfo(TIFF* tif)
-{
-	static const char module[]="OJPEGReadHeaderInfo";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(sp->readheader_done==0);
-	sp->image_width=tif->tif_dir.td_imagewidth;
-	sp->image_length=tif->tif_dir.td_imagelength;
-	if isTiled(tif)
-	{
-		sp->strile_width=tif->tif_dir.td_tilewidth;
-		sp->strile_length=tif->tif_dir.td_tilelength;
-		sp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;
-	}
-	else
-	{
-		sp->strile_width=sp->image_width;
-		sp->strile_length=tif->tif_dir.td_rowsperstrip;
-		sp->strile_length_total=sp->image_length;
-	}
-	sp->samples_per_pixel=tif->tif_dir.td_samplesperpixel;
-	if (sp->samples_per_pixel==1)
-	{
-		sp->plane_sample_offset=0;
-		sp->samples_per_pixel_per_plane=sp->samples_per_pixel;
-		sp->subsampling_hor=1;
-		sp->subsampling_ver=1;
-	}
-	else
-	{
-		if (sp->samples_per_pixel!=3)
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"SamplesPerPixel %d not supported for this compression scheme",sp->samples_per_pixel);
-			return(0);
-		}
-		sp->plane_sample_offset=0;
-		if (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)
-			sp->samples_per_pixel_per_plane=3;
-		else
-			sp->samples_per_pixel_per_plane=1;
-	}
-	if (sp->strile_length<sp->image_length)
-	{
-		if (sp->strile_length%(sp->subsampling_ver*8)!=0)
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"Incompatible vertical subsampling and image strip/tile length");
-			return(0);
-		}
-		sp->restart_interval=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8))*(sp->strile_length/(sp->subsampling_ver*8));
-	}
-	if (OJPEGReadHeaderInfoSec(tif)==0)
-		return(0);
-	sp->sos_end[0].log=1;
-	sp->sos_end[0].in_buffer_source=sp->in_buffer_source;
-	sp->sos_end[0].in_buffer_next_strile=sp->in_buffer_next_strile;
-	sp->sos_end[0].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;
-	sp->sos_end[0].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;
-	sp->readheader_done=1;
-	return(1);
-}
-
-static int
-OJPEGReadSecondarySos(TIFF* tif, tsample_t s)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	assert(s>0);
-	assert(s<3);
-	assert(sp->sos_end[0].log!=0);
-	assert(sp->sos_end[s].log==0);
-	sp->plane_sample_offset=s-1;
-	while(sp->sos_end[sp->plane_sample_offset].log==0)
-		sp->plane_sample_offset--;
-	sp->in_buffer_source=sp->sos_end[sp->plane_sample_offset].in_buffer_source;
-	sp->in_buffer_next_strile=sp->sos_end[sp->plane_sample_offset].in_buffer_next_strile;
-	sp->in_buffer_file_pos=sp->sos_end[sp->plane_sample_offset].in_buffer_file_pos;  
-	sp->in_buffer_file_pos_log=0;
-	sp->in_buffer_file_togo=sp->sos_end[sp->plane_sample_offset].in_buffer_file_togo;
-	sp->in_buffer_togo=0;
-	sp->in_buffer_cur=0;
-	while(sp->plane_sample_offset<s)
-	{
-		do
-		{
-			if (OJPEGReadByte(sp,&m)==0)
-				return(0);
-			if (m==255)
-			{
-				do
-				{
-					if (OJPEGReadByte(sp,&m)==0)
-						return(0);
-					if (m!=255)
-						break;
-				} while(1);
-				if (m==JPEG_MARKER_SOS)
-					break;
-			}
-		} while(1);
-		sp->plane_sample_offset++;
-		if (OJPEGReadHeaderInfoSecStreamSos(tif)==0)
-			return(0);
-		sp->sos_end[sp->plane_sample_offset].log=1;
-		sp->sos_end[sp->plane_sample_offset].in_buffer_source=sp->in_buffer_source;
-		sp->sos_end[sp->plane_sample_offset].in_buffer_next_strile=sp->in_buffer_next_strile;
-		sp->sos_end[sp->plane_sample_offset].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;
-		sp->sos_end[sp->plane_sample_offset].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;
-	}
-	return(1);
-}
-
-static int
-OJPEGWriteHeaderInfo(TIFF* tif)
-{
-	static const char module[]="OJPEGWriteHeaderInfo";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8** m;
-	uint32 n;
-	assert(sp->libjpeg_session_active==0);
-	sp->out_state=ososSoi;
-	sp->restart_index=0;
-	jpeg_std_error(&(sp->libjpeg_jpeg_error_mgr));
-	sp->libjpeg_jpeg_error_mgr.output_message=OJPEGLibjpegJpegErrorMgrOutputMessage;
-	sp->libjpeg_jpeg_error_mgr.error_exit=OJPEGLibjpegJpegErrorMgrErrorExit;
-	sp->libjpeg_jpeg_decompress_struct.err=&(sp->libjpeg_jpeg_error_mgr);
-	sp->libjpeg_jpeg_decompress_struct.client_data=(void*)tif;
-	if (jpeg_create_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)
-		return(0);
-	sp->libjpeg_session_active=1;
-	sp->libjpeg_jpeg_source_mgr.bytes_in_buffer=0;
-	sp->libjpeg_jpeg_source_mgr.init_source=OJPEGLibjpegJpegSourceMgrInitSource;
-	sp->libjpeg_jpeg_source_mgr.fill_input_buffer=OJPEGLibjpegJpegSourceMgrFillInputBuffer;
-	sp->libjpeg_jpeg_source_mgr.skip_input_data=OJPEGLibjpegJpegSourceMgrSkipInputData;
-	sp->libjpeg_jpeg_source_mgr.resync_to_restart=OJPEGLibjpegJpegSourceMgrResyncToRestart;
-	sp->libjpeg_jpeg_source_mgr.term_source=OJPEGLibjpegJpegSourceMgrTermSource;
-	sp->libjpeg_jpeg_decompress_struct.src=&(sp->libjpeg_jpeg_source_mgr);
-	if (jpeg_read_header_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),1)==0)
-		return(0);
-	if ((sp->subsampling_force_desubsampling_inside_decompression==0) && (sp->samples_per_pixel_per_plane>1))
-	{
-		sp->libjpeg_jpeg_decompress_struct.raw_data_out=1;
-#if JPEG_LIB_VERSION >= 70
-		sp->libjpeg_jpeg_decompress_struct.do_fancy_upsampling=FALSE;
-#endif
-		sp->libjpeg_jpeg_query_style=0;
-		if (sp->subsampling_convert_log==0)
-		{
-			assert(sp->subsampling_convert_ycbcrbuf==0);
-			assert(sp->subsampling_convert_ycbcrimage==0);
-			sp->subsampling_convert_ylinelen=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8)*sp->subsampling_hor*8);
-			sp->subsampling_convert_ylines=sp->subsampling_ver*8;
-			sp->subsampling_convert_clinelen=sp->subsampling_convert_ylinelen/sp->subsampling_hor;
-			sp->subsampling_convert_clines=8;
-			sp->subsampling_convert_ybuflen=sp->subsampling_convert_ylinelen*sp->subsampling_convert_ylines;
-			sp->subsampling_convert_cbuflen=sp->subsampling_convert_clinelen*sp->subsampling_convert_clines;
-			sp->subsampling_convert_ycbcrbuflen=sp->subsampling_convert_ybuflen+2*sp->subsampling_convert_cbuflen;
-			sp->subsampling_convert_ycbcrbuf=_TIFFmalloc(sp->subsampling_convert_ycbcrbuflen);
-			if (sp->subsampling_convert_ycbcrbuf==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			sp->subsampling_convert_ybuf=sp->subsampling_convert_ycbcrbuf;
-			sp->subsampling_convert_cbbuf=sp->subsampling_convert_ybuf+sp->subsampling_convert_ybuflen;
-			sp->subsampling_convert_crbuf=sp->subsampling_convert_cbbuf+sp->subsampling_convert_cbuflen;
-			sp->subsampling_convert_ycbcrimagelen=3+sp->subsampling_convert_ylines+2*sp->subsampling_convert_clines;
-			sp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8*));
-			if (sp->subsampling_convert_ycbcrimage==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			m=sp->subsampling_convert_ycbcrimage;
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3);
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines);
-			*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines+sp->subsampling_convert_clines);
-			for (n=0; n<sp->subsampling_convert_ylines; n++)
-				*m++=sp->subsampling_convert_ybuf+n*sp->subsampling_convert_ylinelen;
-			for (n=0; n<sp->subsampling_convert_clines; n++)
-				*m++=sp->subsampling_convert_cbbuf+n*sp->subsampling_convert_clinelen;
-			for (n=0; n<sp->subsampling_convert_clines; n++)
-				*m++=sp->subsampling_convert_crbuf+n*sp->subsampling_convert_clinelen;
-			sp->subsampling_convert_clinelenout=((sp->strile_width+sp->subsampling_hor-1)/sp->subsampling_hor);
-			sp->subsampling_convert_state=0;
-			sp->bytes_per_line=sp->subsampling_convert_clinelenout*(sp->subsampling_ver*sp->subsampling_hor+2);
-			sp->lines_per_strile=((sp->strile_length+sp->subsampling_ver-1)/sp->subsampling_ver);
-			sp->subsampling_convert_log=1;
-		}
-	}
-	else
-	{
-		sp->libjpeg_jpeg_decompress_struct.jpeg_color_space=JCS_UNKNOWN;
-		sp->libjpeg_jpeg_decompress_struct.out_color_space=JCS_UNKNOWN;
-		sp->libjpeg_jpeg_query_style=1;
-		sp->bytes_per_line=sp->samples_per_pixel_per_plane*sp->strile_width;
-		sp->lines_per_strile=sp->strile_length;
-	}
-	if (jpeg_start_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)
-		return(0);
-	sp->writeheader_done=1;
-	return(1);
-}
-
-static void
-OJPEGLibjpegSessionAbort(TIFF* tif)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(sp->libjpeg_session_active!=0);
-	jpeg_destroy((jpeg_common_struct*)(&(sp->libjpeg_jpeg_decompress_struct)));
-	sp->libjpeg_session_active=0;
-}
-
-static int
-OJPEGReadHeaderInfoSec(TIFF* tif)
-{
-	static const char module[]="OJPEGReadHeaderInfoSec";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint16 n;
-	uint8 o;
-	if (sp->file_size==0)
-		sp->file_size=TIFFGetFileSize(tif);
-	if (sp->jpeg_interchange_format!=0)
-	{
-		if (sp->jpeg_interchange_format>=sp->file_size)
-		{
-			sp->jpeg_interchange_format=0;
-			sp->jpeg_interchange_format_length=0;
-		}
-		else
-		{
-			if ((sp->jpeg_interchange_format_length==0) || (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))
-				sp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;
-		}
-	}
-	sp->in_buffer_source=osibsNotSetYet;
-	sp->in_buffer_next_strile=0;
-	sp->in_buffer_strile_count=tif->tif_dir.td_nstrips;   
-	sp->in_buffer_file_togo=0;
-	sp->in_buffer_togo=0;
-	do
-	{
-		if (OJPEGReadBytePeek(sp,&m)==0)
-			return(0);
-		if (m!=255)
-			break;
-		OJPEGReadByteAdvance(sp);
-		do
-		{
-			if (OJPEGReadByte(sp,&m)==0)
-				return(0);
-		} while(m==255);
-		switch(m)
-		{
-			case JPEG_MARKER_SOI:
-				/* this type of marker has no data, and should be skipped */
-				break;
-			case JPEG_MARKER_COM:
-			case JPEG_MARKER_APP0:
-			case JPEG_MARKER_APP0+1:
-			case JPEG_MARKER_APP0+2:
-			case JPEG_MARKER_APP0+3:
-			case JPEG_MARKER_APP0+4:
-			case JPEG_MARKER_APP0+5:
-			case JPEG_MARKER_APP0+6:
-			case JPEG_MARKER_APP0+7:
-			case JPEG_MARKER_APP0+8:
-			case JPEG_MARKER_APP0+9:
-			case JPEG_MARKER_APP0+10:
-			case JPEG_MARKER_APP0+11:
-			case JPEG_MARKER_APP0+12:
-			case JPEG_MARKER_APP0+13:
-			case JPEG_MARKER_APP0+14:
-			case JPEG_MARKER_APP0+15:
-				/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */
-				if (OJPEGReadWord(sp,&n)==0)
-					return(0);
-				if (n<2)
-				{
-					if (sp->subsamplingcorrect==0)
-						TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JPEG data");
-					return(0);
-				}
-				if (n>2)
-					OJPEGReadSkip(sp,n-2);
-				break;
-			case JPEG_MARKER_DRI:
-				if (OJPEGReadHeaderInfoSecStreamDri(tif)==0)
-					return(0);
-				break;
-			case JPEG_MARKER_DQT:
-				if (OJPEGReadHeaderInfoSecStreamDqt(tif)==0)
-					return(0);
-				break;
-			case JPEG_MARKER_DHT:
-				if (OJPEGReadHeaderInfoSecStreamDht(tif)==0)
-					return(0);
-				break;
-			case JPEG_MARKER_SOF0:
-			case JPEG_MARKER_SOF1:
-			case JPEG_MARKER_SOF3:
-				if (OJPEGReadHeaderInfoSecStreamSof(tif,m)==0)
-					return(0);
-				if (sp->subsamplingcorrect!=0)
-					return(1);
-				break;
-			case JPEG_MARKER_SOS:
-				if (sp->subsamplingcorrect!=0)
-					return(1);
-				assert(sp->plane_sample_offset==0);
-				if (OJPEGReadHeaderInfoSecStreamSos(tif)==0)
-					return(0);
-				break;
-			default:
-				TIFFErrorExt(tif->tif_clientdata,module,"Unknown marker type %d in JPEG data",m);
-				return(0);
-		}
-	} while(m!=JPEG_MARKER_SOS);
-	if (sp->subsamplingcorrect)
-		return(1);
-	if (sp->sof_log==0)
-	{
-		if (OJPEGReadHeaderInfoSecTablesQTable(tif)==0)
-			return(0);
-		sp->sof_marker_id=JPEG_MARKER_SOF0;
-		for (o=0; o<sp->samples_per_pixel; o++)
-			sp->sof_c[o]=o;
-		sp->sof_hv[0]=((sp->subsampling_hor<<4)|sp->subsampling_ver);
-		for (o=1; o<sp->samples_per_pixel; o++)
-			sp->sof_hv[o]=17;
-		sp->sof_x=sp->strile_width;
-		sp->sof_y=sp->strile_length_total;
-		sp->sof_log=1;
-		if (OJPEGReadHeaderInfoSecTablesDcTable(tif)==0)
-			return(0);
-		if (OJPEGReadHeaderInfoSecTablesAcTable(tif)==0)
-			return(0);
-		for (o=1; o<sp->samples_per_pixel; o++)
-			sp->sos_cs[o]=o;
-	}
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecStreamDri(TIFF* tif)
-{
-	/* this could easilly cause trouble in some cases... but no such cases have occured sofar */
-	static const char module[]="OJPEGReadHeaderInfoSecStreamDri";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	if (m!=4)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DRI marker in JPEG data");
-		return(0);
-	}
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	sp->restart_interval=m;
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)
-{
-	/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */
-	static const char module[]="OJPEGReadHeaderInfoSecStreamDqt";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint32 na;
-	uint8* nb;
-	uint8 o;
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	if (m<=2)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DQT marker in JPEG data");
-		return(0);
-	}
-	if (sp->subsamplingcorrect!=0)
-		OJPEGReadSkip(sp,m-2);
-	else
-	{
-		m-=2;
-		do
-		{
-			if (m<65)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DQT marker in JPEG data");
-				return(0);
-			}
-			na=sizeof(uint32)+69;
-			nb=_TIFFmalloc(na);
-			if (nb==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			*(uint32*)nb=na;
-			nb[sizeof(uint32)]=255;
-			nb[sizeof(uint32)+1]=JPEG_MARKER_DQT;
-			nb[sizeof(uint32)+2]=0;
-			nb[sizeof(uint32)+3]=67;
-			if (OJPEGReadBlock(sp,65,&nb[sizeof(uint32)+4])==0)
-				return(0);
-			o=nb[sizeof(uint32)+4]&15;
-			if (3<o)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DQT marker in JPEG data");
-				return(0);
-			}
-			if (sp->qtable[o]!=0)
-				_TIFFfree(sp->qtable[o]);
-			sp->qtable[o]=nb;
-			m-=65;
-		} while(m>0);
-	}
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecStreamDht(TIFF* tif)
-{
-	/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */
-	/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */
-	static const char module[]="OJPEGReadHeaderInfoSecStreamDht";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint32 na;
-	uint8* nb;
-	uint8 o;
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	if (m<=2)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DHT marker in JPEG data");
-		return(0);
-	}
-	if (sp->subsamplingcorrect!=0)
-	{
-		OJPEGReadSkip(sp,m-2);
-	}
-	else
-	{
-		na=sizeof(uint32)+2+m;
-		nb=_TIFFmalloc(na);
-		if (nb==0)
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-			return(0);
-		}
-		*(uint32*)nb=na;
-		nb[sizeof(uint32)]=255;
-		nb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-		nb[sizeof(uint32)+2]=(m>>8);
-		nb[sizeof(uint32)+3]=(m&255);
-		if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0)
-			return(0);
-		o=nb[sizeof(uint32)+4];
-		if ((o&240)==0)
-		{
-			if (3<o)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DHT marker in JPEG data");
-				return(0);
-			}
-			if (sp->dctable[o]!=0)
-				_TIFFfree(sp->dctable[o]);
-			sp->dctable[o]=nb;
-		}
-		else
-		{
-			if ((o&240)!=16)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DHT marker in JPEG data");
-				return(0);
-			}
-			o&=15;
-			if (3<o)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Corrupt DHT marker in JPEG data");
-				return(0);
-			}
-			if (sp->actable[o]!=0)
-				_TIFFfree(sp->actable[o]);
-			sp->actable[o]=nb;
-		}
-	}
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)
-{
-	/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
-	static const char module[]="OJPEGReadHeaderInfoSecStreamSof";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint16 n;
-	uint8 o;
-	uint16 p;
-	uint16 q;
-	if (sp->sof_log!=0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JPEG data");
-		return(0);
-	}
-	if (sp->subsamplingcorrect==0)
-		sp->sof_marker_id=marker_id;
-	/* Lf: data length */
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	if (m<11)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOF marker in JPEG data");
-		return(0);
-	}
-	m-=8;
-	if (m%3!=0)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOF marker in JPEG data");
-		return(0);
-	}
-	n=m/3;
-	if (sp->subsamplingcorrect==0)
-	{
-		if (n!=sp->samples_per_pixel)
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected number of samples");
-			return(0);
-		}
-	}
-	/* P: Sample precision */
-	if (OJPEGReadByte(sp,&o)==0)
-		return(0);
-	if (o!=8)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected number of bits per sample");
-		return(0);
-	}
-	/* Y: Number of lines, X: Number of samples per line */
-	if (sp->subsamplingcorrect)
-		OJPEGReadSkip(sp,4);
-	else
-	{
-		/* TODO: probably best to also add check on allowed upper bound, especially x, may cause buffer overflow otherwise i think */
-		/* Y: Number of lines */
-		if (OJPEGReadWord(sp,&p)==0)
-			return(0);
-		if ((p<sp->image_length) && (p<sp->strile_length_total))
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected height");
-			return(0);
-		}
-		sp->sof_y=p;
-		/* X: Number of samples per line */
-		if (OJPEGReadWord(sp,&p)==0)
-			return(0);
-		if ((p<sp->image_width) && (p<sp->strile_width))
-		{
-			TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected width");
-			return(0);
-		}
-		sp->sof_x=p;
-	}
-	/* Nf: Number of image components in frame */
-	if (OJPEGReadByte(sp,&o)==0)
-		return(0);
-	if (o!=n)
-	{
-		if (sp->subsamplingcorrect==0)
-			TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOF marker in JPEG data");
-		return(0);
-	}
-	/* per component stuff */
-	/* TODO: double-check that flow implies that n cannot be as big as to make us overflow sof_c, sof_hv and sof_tq arrays */
-	for (q=0; q<n; q++)
-	{
-		/* C: Component identifier */
-		if (OJPEGReadByte(sp,&o)==0)
-			return(0);
-		if (sp->subsamplingcorrect==0)
-			sp->sof_c[q]=o;
-		/* H: Horizontal sampling factor, and V: Vertical sampling factor */
-		if (OJPEGReadByte(sp,&o)==0)
-			return(0);
-		if (sp->subsamplingcorrect!=0)
-		{
-			if (q==0)
-			{
-				sp->subsampling_hor=(o>>4);
-				sp->subsampling_ver=(o&15);
-				if (((sp->subsampling_hor!=1) && (sp->subsampling_hor!=2) && (sp->subsampling_hor!=4)) ||
-					((sp->subsampling_ver!=1) && (sp->subsampling_ver!=2) && (sp->subsampling_ver!=4)))
-					sp->subsampling_force_desubsampling_inside_decompression=1;
-			}
-			else
-			{
-				if (o!=17)
-					sp->subsampling_force_desubsampling_inside_decompression=1;
-			}
-		}
-		else
-		{
-			sp->sof_hv[q]=o;
-			if (sp->subsampling_force_desubsampling_inside_decompression==0)
-			{
-				if (q==0)
-				{
-					if (o!=((sp->subsampling_hor<<4)|sp->subsampling_ver))
-					{
-						TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected subsampling values");
-						return(0);
-					}
-				}
-				else
-				{
-					if (o!=17)
-					{
-						TIFFErrorExt(tif->tif_clientdata,module,"JPEG compressed data indicates unexpected subsampling values");
-						return(0);
-					}
-				}
-			}
-		}
-		/* Tq: Quantization table destination selector */
-		if (OJPEGReadByte(sp,&o)==0)
-			return(0);
-		if (sp->subsamplingcorrect==0)
-			sp->sof_tq[q]=o;
-	}
-	if (sp->subsamplingcorrect==0)
-		sp->sof_log=1;
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecStreamSos(TIFF* tif)
-{
-	/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
-	static const char module[]="OJPEGReadHeaderInfoSecStreamSos";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint16 m;
-	uint8 n;
-	uint8 o;
-	assert(sp->subsamplingcorrect==0);
-	if (sp->sof_log==0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOS marker in JPEG data");
-		return(0);
-	}
-	/* Ls */
-	if (OJPEGReadWord(sp,&m)==0)
-		return(0);
-	if (m!=6+sp->samples_per_pixel_per_plane*2)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOS marker in JPEG data");
-		return(0);
-	}
-	/* Ns */
-	if (OJPEGReadByte(sp,&n)==0)
-		return(0);
-	if (n!=sp->samples_per_pixel_per_plane)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Corrupt SOS marker in JPEG data");
-		return(0);
-	}
-	/* Cs, Td, and Ta */
-	for (o=0; o<sp->samples_per_pixel_per_plane; o++)
-	{
-		/* Cs */
-		if (OJPEGReadByte(sp,&n)==0)
-			return(0);
-		sp->sos_cs[sp->plane_sample_offset+o]=n;
-		/* Td and Ta */
-		if (OJPEGReadByte(sp,&n)==0)
-			return(0);
-		sp->sos_tda[sp->plane_sample_offset+o]=n;
-	}
-	/* skip Ss, Se, Ah, en Al -> no check, as per Tom Lane recommendation, as per LibJpeg source */
-	OJPEGReadSkip(sp,3);
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)
-{
-	static const char module[]="OJPEGReadHeaderInfoSecTablesQTable";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint32 oa;
-	uint8* ob;
-	uint32 p;
-	if (sp->qtable_offset[0]==0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
-		return(0);
-	}
-	sp->in_buffer_file_pos_log=0;
-	for (m=0; m<sp->samples_per_pixel; m++)
-	{
-		if ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1])))
-		{
-			for (n=0; n<m-1; n++)
-			{
-				if (sp->qtable_offset[m]==sp->qtable_offset[n])
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JpegQTables tag value");
-					return(0);
-				}
-			}
-			oa=sizeof(uint32)+69;
-			ob=_TIFFmalloc(oa);
-			if (ob==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			*(uint32*)ob=oa;
-			ob[sizeof(uint32)]=255;
-			ob[sizeof(uint32)+1]=JPEG_MARKER_DQT;
-			ob[sizeof(uint32)+2]=0;
-			ob[sizeof(uint32)+3]=67;
-			ob[sizeof(uint32)+4]=m;
-			TIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET);
-			p=TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);
-			if (p!=64)
-				return(0);
-			sp->qtable[m]=ob;
-			sp->sof_tq[m]=m;
-		}
-		else
-			sp->sof_tq[m]=sp->sof_tq[m-1];
-	}
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)
-{
-	static const char module[]="OJPEGReadHeaderInfoSecTablesDcTable";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint8 o[16];
-	uint32 p;
-	uint32 q;
-	uint32 ra;
-	uint8* rb;
-	if (sp->dctable_offset[0]==0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
-		return(0);
-	}
-	sp->in_buffer_file_pos_log=0;
-	for (m=0; m<sp->samples_per_pixel; m++)
-	{
-		if ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))
-		{
-			for (n=0; n<m-1; n++)
-			{
-				if (sp->dctable_offset[m]==sp->dctable_offset[n])
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JpegDcTables tag value");
-					return(0);
-				}
-			}
-			TIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);
-			p=TIFFReadFile(tif,o,16);
-			if (p!=16)
-				return(0);
-			q=0;
-			for (n=0; n<16; n++)
-				q+=o[n];
-			ra=sizeof(uint32)+21+q;
-			rb=_TIFFmalloc(ra);
-			if (rb==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			*(uint32*)rb=ra;
-			rb[sizeof(uint32)]=255;
-			rb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-			rb[sizeof(uint32)+2]=((19+q)>>8);
-			rb[sizeof(uint32)+3]=((19+q)&255);
-			rb[sizeof(uint32)+4]=m;
-			for (n=0; n<16; n++)
-				rb[sizeof(uint32)+5+n]=o[n];
-			p=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);
-			if (p!=q)
-				return(0);
-			sp->dctable[m]=rb;
-			sp->sos_tda[m]=(m<<4);
-		}
-		else
-			sp->sos_tda[m]=sp->sos_tda[m-1];
-	}
-	return(1);
-}
-
-static int
-OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)
-{
-	static const char module[]="OJPEGReadHeaderInfoSecTablesAcTable";
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	uint8 n;
-	uint8 o[16];
-	uint32 p;
-	uint32 q;
-	uint32 ra;
-	uint8* rb;
-	if (sp->actable_offset[0]==0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,module,"Missing JPEG tables");
-		return(0);
-	}
-	sp->in_buffer_file_pos_log=0;
-	for (m=0; m<sp->samples_per_pixel; m++)
-	{
-		if ((sp->actable_offset[m]!=0) && ((m==0) || (sp->actable_offset[m]!=sp->actable_offset[m-1])))
-		{
-			for (n=0; n<m-1; n++)
-			{
-				if (sp->actable_offset[m]==sp->actable_offset[n])
-				{
-					TIFFErrorExt(tif->tif_clientdata,module,"Corrupt JpegAcTables tag value");
-					return(0);
-				}
-			}
-			TIFFSeekFile(tif,sp->actable_offset[m],SEEK_SET);
-			p=TIFFReadFile(tif,o,16);
-			if (p!=16)
-				return(0);
-			q=0;
-			for (n=0; n<16; n++)
-				q+=o[n];
-			ra=sizeof(uint32)+21+q;
-			rb=_TIFFmalloc(ra);
-			if (rb==0)
-			{
-				TIFFErrorExt(tif->tif_clientdata,module,"Out of memory");
-				return(0);
-			}
-			*(uint32*)rb=ra;
-			rb[sizeof(uint32)]=255;
-			rb[sizeof(uint32)+1]=JPEG_MARKER_DHT;
-			rb[sizeof(uint32)+2]=((19+q)>>8);
-			rb[sizeof(uint32)+3]=((19+q)&255);
-			rb[sizeof(uint32)+4]=(16|m);
-			for (n=0; n<16; n++)
-				rb[sizeof(uint32)+5+n]=o[n];
-			p=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);
-			if (p!=q)
-				return(0);
-			sp->actable[m]=rb;
-			sp->sos_tda[m]=(sp->sos_tda[m]|m);
-		}
-		else
-			sp->sos_tda[m]=(sp->sos_tda[m]|(sp->sos_tda[m-1]&15));
-	}
-	return(1);
-}
-
-static int
-OJPEGReadBufferFill(OJPEGState* sp)
-{
-	uint16 m;
-	tsize_t n;
-	/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made
-	 * in any other case, seek or read errors should be passed through */
-	do
-	{
-		if (sp->in_buffer_file_togo!=0)
-		{
-			if (sp->in_buffer_file_pos_log==0)
-			{
-				TIFFSeekFile(sp->tif,sp->in_buffer_file_pos,SEEK_SET);
-				sp->in_buffer_file_pos_log=1;
-			}
-			m=OJPEG_BUFFER;
-			if (m>sp->in_buffer_file_togo)
-				m=(uint16)sp->in_buffer_file_togo;
-			n=TIFFReadFile(sp->tif,sp->in_buffer,(tsize_t)m);
-			if (n==0)
-				return(0);
-			assert(n>0);
-			assert(n<=OJPEG_BUFFER);
-			assert(n<65536);
-			assert((uint16)n<=sp->in_buffer_file_togo);
-			m=(uint16)n;
-			sp->in_buffer_togo=m;
-			sp->in_buffer_cur=sp->in_buffer;
-			sp->in_buffer_file_togo-=m;
-			sp->in_buffer_file_pos+=m;
-			break;
-		}
-		sp->in_buffer_file_pos_log=0;
-		switch(sp->in_buffer_source)
-		{
-			case osibsNotSetYet:
-				if (sp->jpeg_interchange_format!=0)
-				{
-					sp->in_buffer_file_pos=sp->jpeg_interchange_format;
-					sp->in_buffer_file_togo=sp->jpeg_interchange_format_length;
-				}
-				sp->in_buffer_source=osibsJpegInterchangeFormat;
-				break;
-			case osibsJpegInterchangeFormat:
-				sp->in_buffer_source=osibsStrile;
-			case osibsStrile:
-				if (sp->in_buffer_next_strile==sp->in_buffer_strile_count)  
-					sp->in_buffer_source=osibsEof;
-				else
-				{
-					if (sp->tif->tif_dir.td_stripoffset == 0) {
-						TIFFErrorExt(sp->tif->tif_clientdata,sp->tif->tif_name,"Strip offsets are missing");
-						return(0);
-					}
-					sp->in_buffer_file_pos=sp->tif->tif_dir.td_stripoffset[sp->in_buffer_next_strile];  
-					if (sp->in_buffer_file_pos!=0)
-					{
-						if (sp->in_buffer_file_pos>=sp->file_size)
-							sp->in_buffer_file_pos=0;
-						else
-						{
-							sp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];  
-							if (sp->in_buffer_file_togo==0)
-								sp->in_buffer_file_pos=0;
-							else if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)
-								sp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;
-						}
-					}
-					sp->in_buffer_next_strile++;
-				}
-				break;
-			default:
-				return(0);
-		}
-	} while (1);
-	return(1);
-}
-
-static int
-OJPEGReadByte(OJPEGState* sp, uint8* byte)
-{
-	if (sp->in_buffer_togo==0)
-	{
-		if (OJPEGReadBufferFill(sp)==0)
-			return(0);
-		assert(sp->in_buffer_togo>0);
-	}
-	*byte=*(sp->in_buffer_cur);
-	sp->in_buffer_cur++;
-	sp->in_buffer_togo--;
-	return(1);
-}
-
-static int
-OJPEGReadBytePeek(OJPEGState* sp, uint8* byte)
-{
-	if (sp->in_buffer_togo==0)
-	{
-		if (OJPEGReadBufferFill(sp)==0)
-			return(0);
-		assert(sp->in_buffer_togo>0);
-	}
-	*byte=*(sp->in_buffer_cur);
-	return(1);
-}
-
-static void
-OJPEGReadByteAdvance(OJPEGState* sp)
-{
-	assert(sp->in_buffer_togo>0);
-	sp->in_buffer_cur++;
-	sp->in_buffer_togo--;
-}
-
-static int
-OJPEGReadWord(OJPEGState* sp, uint16* word)
-{
-	uint8 m;
-	if (OJPEGReadByte(sp,&m)==0)
-		return(0);
-	*word=(m<<8);
-	if (OJPEGReadByte(sp,&m)==0)
-		return(0);
-	*word|=m;
-	return(1);
-}
-
-static int
-OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)
-{
-	uint16 mlen;
-	uint8* mmem;
-	uint16 n;
-	assert(len>0);
-	mlen=len;
-	mmem=mem;
-	do
-	{
-		if (sp->in_buffer_togo==0)
-		{
-			if (OJPEGReadBufferFill(sp)==0)
-				return(0);
-			assert(sp->in_buffer_togo>0);
-		}
-		n=mlen;
-		if (n>sp->in_buffer_togo)
-			n=sp->in_buffer_togo;
-		_TIFFmemcpy(mmem,sp->in_buffer_cur,n);
-		sp->in_buffer_cur+=n;
-		sp->in_buffer_togo-=n;
-		mlen-=n;
-		mmem+=n;
-	} while(mlen>0);
-	return(1);
-}
-
-static void
-OJPEGReadSkip(OJPEGState* sp, uint16 len)
-{
-	uint16 m;
-	uint16 n;
-	m=len;
-	n=m;
-	if (n>sp->in_buffer_togo)
-		n=sp->in_buffer_togo;
-	sp->in_buffer_cur+=n;
-	sp->in_buffer_togo-=n;
-	m-=n;
-	if (m>0)
-	{
-		assert(sp->in_buffer_togo==0);
-		n=m;
-		if (n>sp->in_buffer_file_togo)
-			n=sp->in_buffer_file_togo;
-		sp->in_buffer_file_pos+=n;
-		sp->in_buffer_file_togo-=n;
-		sp->in_buffer_file_pos_log=0;
-		/* we don't skip past jpeginterchangeformat/strile block...
-		 * if that is asked from us, we're dealing with totally bazurk
-		 * data anyway, and we've not seen this happening on any
-		 * testfile, so we might as well likely cause some other
-		 * meaningless error to be passed at some later time
-		 */
-	}
-}
-
-static int
-OJPEGWriteStream(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	*len=0;
-	do
-	{
-		assert(sp->out_state<=ososEoi);
-		switch(sp->out_state)
-		{
-			case ososSoi:
-				OJPEGWriteStreamSoi(tif,mem,len);
-				break;
-			case ososQTable0:
-				OJPEGWriteStreamQTable(tif,0,mem,len);
-				break;
-			case ososQTable1:
-				OJPEGWriteStreamQTable(tif,1,mem,len);
-				break;
-			case ososQTable2:
-				OJPEGWriteStreamQTable(tif,2,mem,len);
-				break;
-			case ososQTable3:
-				OJPEGWriteStreamQTable(tif,3,mem,len);
-				break;
-			case ososDcTable0:
-				OJPEGWriteStreamDcTable(tif,0,mem,len);
-				break;
-			case ososDcTable1:
-				OJPEGWriteStreamDcTable(tif,1,mem,len);
-				break;
-			case ososDcTable2:
-				OJPEGWriteStreamDcTable(tif,2,mem,len);
-				break;
-			case ososDcTable3:
-				OJPEGWriteStreamDcTable(tif,3,mem,len);
-				break;
-			case ososAcTable0:
-				OJPEGWriteStreamAcTable(tif,0,mem,len);
-				break;
-			case ososAcTable1:
-				OJPEGWriteStreamAcTable(tif,1,mem,len);
-				break;
-			case ososAcTable2:
-				OJPEGWriteStreamAcTable(tif,2,mem,len);
-				break;
-			case ososAcTable3:
-				OJPEGWriteStreamAcTable(tif,3,mem,len);
-				break;
-			case ososDri:
-				OJPEGWriteStreamDri(tif,mem,len);
-				break;
-			case ososSof:
-				OJPEGWriteStreamSof(tif,mem,len);
-				break;
-			case ososSos:
-				OJPEGWriteStreamSos(tif,mem,len);
-				break;
-			case ososCompressed:
-				if (OJPEGWriteStreamCompressed(tif,mem,len)==0)
-					return(0);
-				break;
-			case ososRst:
-				OJPEGWriteStreamRst(tif,mem,len);
-				break;
-			case ososEoi:
-				OJPEGWriteStreamEoi(tif,mem,len);
-				break;
-		}
-	} while (*len==0);
-	return(1);
-}
-
-static void
-OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(OJPEG_BUFFER>=2);
-	sp->out_buffer[0]=255;
-	sp->out_buffer[1]=JPEG_MARKER_SOI;
-	*len=2;
-	*mem=(void*)sp->out_buffer;
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	if (sp->qtable[table_index]!=0)
-	{
-		*mem=(void*)(sp->qtable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->qtable[table_index])-sizeof(uint32);
-	}
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	if (sp->dctable[table_index]!=0)
-	{
-		*mem=(void*)(sp->dctable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->dctable[table_index])-sizeof(uint32);
-	}
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	if (sp->actable[table_index]!=0)
-	{
-		*mem=(void*)(sp->actable[table_index]+sizeof(uint32));
-		*len=*((uint32*)sp->actable[table_index])-sizeof(uint32);
-	}
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(OJPEG_BUFFER>=6);
-	if (sp->restart_interval!=0)
-	{
-		sp->out_buffer[0]=255;
-		sp->out_buffer[1]=JPEG_MARKER_DRI;
-		sp->out_buffer[2]=0;
-		sp->out_buffer[3]=4;
-		sp->out_buffer[4]=(sp->restart_interval>>8);
-		sp->out_buffer[5]=(sp->restart_interval&255);
-		*len=6;
-		*mem=(void*)sp->out_buffer;
-	}
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	assert(OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3);
-	assert(255>=8+sp->samples_per_pixel_per_plane*3);
-	sp->out_buffer[0]=255;
-	sp->out_buffer[1]=sp->sof_marker_id;
-	/* Lf */
-	sp->out_buffer[2]=0;
-	sp->out_buffer[3]=8+sp->samples_per_pixel_per_plane*3;
-	/* P */
-	sp->out_buffer[4]=8;
-	/* Y */
-	sp->out_buffer[5]=(sp->sof_y>>8);
-	sp->out_buffer[6]=(sp->sof_y&255);
-	/* X */
-	sp->out_buffer[7]=(sp->sof_x>>8);
-	sp->out_buffer[8]=(sp->sof_x&255);
-	/* Nf */
-	sp->out_buffer[9]=sp->samples_per_pixel_per_plane;
-	for (m=0; m<sp->samples_per_pixel_per_plane; m++)
-	{
-		/* C */
-		sp->out_buffer[10+m*3]=sp->sof_c[sp->plane_sample_offset+m];
-		/* H and V */
-		sp->out_buffer[10+m*3+1]=sp->sof_hv[sp->plane_sample_offset+m];
-		/* Tq */
-		sp->out_buffer[10+m*3+2]=sp->sof_tq[sp->plane_sample_offset+m];
-	}
-	*len=10+sp->samples_per_pixel_per_plane*3;
-	*mem=(void*)sp->out_buffer;
-	sp->out_state++;
-}
-
-static void
-OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	uint8 m;
-	assert(OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2);
-	assert(255>=6+sp->samples_per_pixel_per_plane*2);
-	sp->out_buffer[0]=255;
-	sp->out_buffer[1]=JPEG_MARKER_SOS;
-	/* Ls */
-	sp->out_buffer[2]=0;
-	sp->out_buffer[3]=6+sp->samples_per_pixel_per_plane*2;
-	/* Ns */
-	sp->out_buffer[4]=sp->samples_per_pixel_per_plane;
-	for (m=0; m<sp->samples_per_pixel_per_plane; m++)
-	{
-		/* Cs */
-		sp->out_buffer[5+m*2]=sp->sos_cs[sp->plane_sample_offset+m];
-		/* Td and Ta */
-		sp->out_buffer[5+m*2+1]=sp->sos_tda[sp->plane_sample_offset+m];
-	}
-	/* Ss */
-	sp->out_buffer[5+sp->samples_per_pixel_per_plane*2]=0;
-	/* Se */
-	sp->out_buffer[5+sp->samples_per_pixel_per_plane*2+1]=63;
-	/* Ah and Al */
-	sp->out_buffer[5+sp->samples_per_pixel_per_plane*2+2]=0;
-	*len=8+sp->samples_per_pixel_per_plane*2;
-	*mem=(void*)sp->out_buffer;
-	sp->out_state++;
-}
-
-static int
-OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	if (sp->in_buffer_togo==0)
-	{
-		if (OJPEGReadBufferFill(sp)==0)
-			return(0);
-		assert(sp->in_buffer_togo>0);
-	}
-	*len=sp->in_buffer_togo;
-	*mem=(void*)sp->in_buffer_cur;
-	sp->in_buffer_togo=0;
-	if (sp->in_buffer_file_togo==0)
-	{
-		switch(sp->in_buffer_source)
-		{
-			case osibsStrile:
-				if (sp->in_buffer_next_strile<sp->in_buffer_strile_count)  
-					sp->out_state=ososRst;
-				else
-					sp->out_state=ososEoi;
-				break;
-			case osibsEof:
-				sp->out_state=ososEoi;
-				break;
-			default:
-				break;
-		}
-	}
-	return(1);
-}
-
-static void
-OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(OJPEG_BUFFER>=2);
-	sp->out_buffer[0]=255;
-	sp->out_buffer[1]=JPEG_MARKER_RST0+sp->restart_index;
-	sp->restart_index++;
-	if (sp->restart_index==8)
-		sp->restart_index=0;
-	*len=2;
-	*mem=(void*)sp->out_buffer;
-	sp->out_state=ososCompressed;
-}
-
-static void
-OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	assert(OJPEG_BUFFER>=2);
-	sp->out_buffer[0]=255;
-	sp->out_buffer[1]=JPEG_MARKER_EOI;
-	*len=2;
-	*mem=(void*)sp->out_buffer;
-}
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static int
-jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)
-{
-	return(SETJMP(sp->exit_jmpbuf)?0:(jpeg_create_decompress(cinfo),1));
-}
-#endif
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static int
-jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)
-{
-	return(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_header(cinfo,require_image),1));
-}
-#endif
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static int
-jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)
-{
-	return(SETJMP(sp->exit_jmpbuf)?0:(jpeg_start_decompress(cinfo),1));
-}
-#endif
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static int
-jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)
-{
-	return(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_scanlines(cinfo,scanlines,max_lines),1));
-}
-#endif
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static int
-jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)
-{
-	return(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_raw_data(cinfo,data,max_lines),1));
-}
-#endif
-
-#ifndef LIBJPEG_ENCAP_EXTERNAL
-static void
-jpeg_encap_unwind(TIFF* tif)
-{
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	LONGJMP(sp->exit_jmpbuf,1);
-}
-#endif
-
-static void
-OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)
-{
-	char buffer[JMSG_LENGTH_MAX];
-	(*cinfo->err->format_message)(cinfo,buffer);
-	TIFFWarningExt(((TIFF*)(cinfo->client_data))->tif_clientdata,"LibJpeg", "%s", buffer);
-}
-
-static void
-OJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo)
-{
-	char buffer[JMSG_LENGTH_MAX];
-	(*cinfo->err->format_message)(cinfo,buffer);
-	TIFFErrorExt(((TIFF*)(cinfo->client_data))->tif_clientdata,"LibJpeg", "%s", buffer);
-	jpeg_encap_unwind((TIFF*)(cinfo->client_data));
-}
-
-static void
-OJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo)
-{
-	(void)cinfo;
-}
-
-static boolean
-OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)
-{
-	TIFF* tif=(TIFF*)cinfo->client_data;
-	OJPEGState* sp=(OJPEGState*)tif->tif_data;
-	void* mem=0;
-	uint32 len=0;
-	if (OJPEGWriteStream(tif,&mem,&len)==0)
-	{
-		TIFFErrorExt(tif->tif_clientdata,"LibJpeg","Premature end of JPEG data");
-		jpeg_encap_unwind(tif);
-	}
-	sp->libjpeg_jpeg_source_mgr.bytes_in_buffer=len;
-	sp->libjpeg_jpeg_source_mgr.next_input_byte=mem;
-	return(1);
-}
-
-static void
-OJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes)
-{
-	TIFF* tif=(TIFF*)cinfo->client_data;
-	(void)num_bytes;
-	TIFFErrorExt(tif->tif_clientdata,"LibJpeg","Unexpected error");
-	jpeg_encap_unwind(tif);
-}
-
-static boolean
-OJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired)
-{
-	TIFF* tif=(TIFF*)cinfo->client_data;
-	(void)desired;
-	TIFFErrorExt(tif->tif_clientdata,"LibJpeg","Unexpected error");
-	jpeg_encap_unwind(tif);
-	return(0);
-}
-
-static void
-OJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo)
-{
-	(void)cinfo;
-}
-
-#endif
-
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_open.c b/thirdparty/libtiff/tif_open.c
deleted file mode 100644
index 3b3b2ce..0000000
--- a/thirdparty/libtiff/tif_open.c
+++ /dev/null
@@ -1,695 +0,0 @@
-/* $Id: tif_open.c,v 1.33.2.1 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- */
-#include "tiffiop.h"
-
-static const long typemask[13] = {
-	(long)0L,		/* TIFF_NOTYPE */
-	(long)0x000000ffL,	/* TIFF_BYTE */
-	(long)0xffffffffL,	/* TIFF_ASCII */
-	(long)0x0000ffffL,	/* TIFF_SHORT */
-	(long)0xffffffffL,	/* TIFF_LONG */
-	(long)0xffffffffL,	/* TIFF_RATIONAL */
-	(long)0x000000ffL,	/* TIFF_SBYTE */
-	(long)0x000000ffL,	/* TIFF_UNDEFINED */
-	(long)0x0000ffffL,	/* TIFF_SSHORT */
-	(long)0xffffffffL,	/* TIFF_SLONG */
-	(long)0xffffffffL,	/* TIFF_SRATIONAL */
-	(long)0xffffffffL,	/* TIFF_FLOAT */
-	(long)0xffffffffL,	/* TIFF_DOUBLE */
-};
-static const int bigTypeshift[13] = {
-	0,		/* TIFF_NOTYPE */
-	24,		/* TIFF_BYTE */
-	0,		/* TIFF_ASCII */
-	16,		/* TIFF_SHORT */
-	0,		/* TIFF_LONG */
-	0,		/* TIFF_RATIONAL */
-	24,		/* TIFF_SBYTE */
-	24,		/* TIFF_UNDEFINED */
-	16,		/* TIFF_SSHORT */
-	0,		/* TIFF_SLONG */
-	0,		/* TIFF_SRATIONAL */
-	0,		/* TIFF_FLOAT */
-	0,		/* TIFF_DOUBLE */
-};
-static const int litTypeshift[13] = {
-	0,		/* TIFF_NOTYPE */
-	0,		/* TIFF_BYTE */
-	0,		/* TIFF_ASCII */
-	0,		/* TIFF_SHORT */
-	0,		/* TIFF_LONG */
-	0,		/* TIFF_RATIONAL */
-	0,		/* TIFF_SBYTE */
-	0,		/* TIFF_UNDEFINED */
-	0,		/* TIFF_SSHORT */
-	0,		/* TIFF_SLONG */
-	0,		/* TIFF_SRATIONAL */
-	0,		/* TIFF_FLOAT */
-	0,		/* TIFF_DOUBLE */
-};
-
-/*
- * Dummy functions to fill the omitted client procedures.
- */
-static int
-_tiffDummyMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	(void) fd; (void) pbase; (void) psize;
-	return (0);
-}
-
-static void
-_tiffDummyUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-	(void) fd; (void) base; (void) size;
-}
-
-/*
- * Initialize the shift & mask tables, and the
- * byte swapping state according to the file
- * contents and the machine architecture.
- */
-static void
-TIFFInitOrder(TIFF* tif, int magic)
-{
-	tif->tif_typemask = typemask;
-	if (magic == TIFF_BIGENDIAN) {
-		tif->tif_typeshift = bigTypeshift;
-#ifndef WORDS_BIGENDIAN
-		tif->tif_flags |= TIFF_SWAB;
-#endif
-	} else {
-		tif->tif_typeshift = litTypeshift;
-#ifdef WORDS_BIGENDIAN
-		tif->tif_flags |= TIFF_SWAB;
-#endif
-	}
-}
-
-int
-_TIFFgetMode(const char* mode, const char* module)
-{
-	int m = -1;
-
-	switch (mode[0]) {
-	case 'r':
-		m = O_RDONLY;
-		if (mode[1] == '+')
-			m = O_RDWR;
-		break;
-	case 'w':
-	case 'a':
-		m = O_RDWR|O_CREAT;
-		if (mode[0] == 'w')
-			m |= O_TRUNC;
-		break;
-	default:
-		TIFFErrorExt(0, module, "\"%s\": Bad mode", mode);
-		break;
-	}
-	return (m);
-}
-
-TIFF*
-TIFFClientOpen(
-	const char* name, const char* mode,
-	thandle_t clientdata,
-	TIFFReadWriteProc readproc,
-	TIFFReadWriteProc writeproc,
-	TIFFSeekProc seekproc,
-	TIFFCloseProc closeproc,
-	TIFFSizeProc sizeproc,
-	TIFFMapFileProc mapproc,
-	TIFFUnmapFileProc unmapproc
-)
-{
-	static const char module[] = "TIFFClientOpen";
-	TIFF *tif;
-	int m;
-	const char* cp;
-
-	m = _TIFFgetMode(mode, module);
-	if (m == -1)
-		goto bad2;
-	tif = (TIFF *)_TIFFmalloc(sizeof (TIFF) + strlen(name) + 1);
-	if (tif == NULL) {
-		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);
-		goto bad2;
-	}
-	_TIFFmemset(tif, 0, sizeof (*tif));
-	tif->tif_name = (char *)tif + sizeof (TIFF);
-	strcpy(tif->tif_name, name);
-	tif->tif_mode = m &~ (O_CREAT|O_TRUNC);
-	tif->tif_curdir = (tdir_t) -1;		/* non-existent directory */
-	tif->tif_curoff = 0;
-	tif->tif_curstrip = (tstrip_t) -1;	/* invalid strip */
-	tif->tif_row = (uint32) -1;		/* read/write pre-increment */
-	tif->tif_clientdata = clientdata;
-	if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {
-		TIFFErrorExt(clientdata, module,
-			  "One of the client procedures is NULL pointer.");
-		goto bad2;
-	}
-	tif->tif_readproc = readproc;
-	tif->tif_writeproc = writeproc;
-	tif->tif_seekproc = seekproc;
-	tif->tif_closeproc = closeproc;
-	tif->tif_sizeproc = sizeproc;
-        if (mapproc)
-		tif->tif_mapproc = mapproc;
-	else
-		tif->tif_mapproc = _tiffDummyMapProc;
-	if (unmapproc)
-		tif->tif_unmapproc = unmapproc;
-	else
-		tif->tif_unmapproc = _tiffDummyUnmapProc;
-	_TIFFSetDefaultCompressionState(tif);	/* setup default state */
-	/*
-	 * Default is to return data MSB2LSB and enable the
-	 * use of memory-mapped files and strip chopping when
-	 * a file is opened read-only.
-	 */
-	tif->tif_flags = FILLORDER_MSB2LSB;
-	if (m == O_RDONLY )
-		tif->tif_flags |= TIFF_MAPPED;
-
-#ifdef STRIPCHOP_DEFAULT
-	if (m == O_RDONLY || m == O_RDWR)
-		tif->tif_flags |= STRIPCHOP_DEFAULT;
-#endif
-
-	/*
-	 * Process library-specific flags in the open mode string.
-	 * The following flags may be used to control intrinsic library
-	 * behaviour that may or may not be desirable (usually for
-	 * compatibility with some application that claims to support
-	 * TIFF but only supports some braindead idea of what the
-	 * vendor thinks TIFF is):
-	 *
-	 * 'l'		use little-endian byte order for creating a file
-	 * 'b'		use big-endian byte order for creating a file
-	 * 'L'		read/write information using LSB2MSB bit order
-	 * 'B'		read/write information using MSB2LSB bit order
-	 * 'H'		read/write information using host bit order
-	 * 'M'		enable use of memory-mapped files when supported
-	 * 'm'		disable use of memory-mapped files
-	 * 'C'		enable strip chopping support when reading
-	 * 'c'		disable strip chopping support
-	 * 'h'		read TIFF header only, do not load the first IFD
-	 *
-	 * The use of the 'l' and 'b' flags is strongly discouraged.
-	 * These flags are provided solely because numerous vendors,
-	 * typically on the PC, do not correctly support TIFF; they
-	 * only support the Intel little-endian byte order.  This
-	 * support is not configured by default because it supports
-	 * the violation of the TIFF spec that says that readers *MUST*
-	 * support both byte orders.  It is strongly recommended that
-	 * you not use this feature except to deal with busted apps
-	 * that write invalid TIFF.  And even in those cases you should
-	 * bang on the vendors to fix their software.
-	 *
-	 * The 'L', 'B', and 'H' flags are intended for applications
-	 * that can optimize operations on data by using a particular
-	 * bit order.  By default the library returns data in MSB2LSB
-	 * bit order for compatibiltiy with older versions of this
-	 * library.  Returning data in the bit order of the native cpu
-	 * makes the most sense but also requires applications to check
-	 * the value of the FillOrder tag; something they probably do
-	 * not do right now.
-	 *
-	 * The 'M' and 'm' flags are provided because some virtual memory
-	 * systems exhibit poor behaviour when large images are mapped.
-	 * These options permit clients to control the use of memory-mapped
-	 * files on a per-file basis.
-	 *
-	 * The 'C' and 'c' flags are provided because the library support
-	 * for chopping up large strips into multiple smaller strips is not
-	 * application-transparent and as such can cause problems.  The 'c'
-	 * option permits applications that only want to look at the tags,
-	 * for example, to get the unadulterated TIFF tag information.
-	 */
-	for (cp = mode; *cp; cp++)
-		switch (*cp) {
-		case 'b':
-#ifndef WORDS_BIGENDIAN
-		    if (m&O_CREAT)
-				tif->tif_flags |= TIFF_SWAB;
-#endif
-			break;
-		case 'l':
-#ifdef WORDS_BIGENDIAN
-			if ((m&O_CREAT))
-				tif->tif_flags |= TIFF_SWAB;
-#endif
-			break;
-		case 'B':
-			tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
-			    FILLORDER_MSB2LSB;
-			break;
-		case 'L':
-			tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
-			    FILLORDER_LSB2MSB;
-			break;
-		case 'H':
-			tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
-			    HOST_FILLORDER;
-			break;
-		case 'M':
-			if (m == O_RDONLY)
-				tif->tif_flags |= TIFF_MAPPED;
-			break;
-		case 'm':
-			if (m == O_RDONLY)
-				tif->tif_flags &= ~TIFF_MAPPED;
-			break;
-		case 'C':
-			if (m == O_RDONLY)
-				tif->tif_flags |= TIFF_STRIPCHOP;
-			break;
-		case 'c':
-			if (m == O_RDONLY)
-				tif->tif_flags &= ~TIFF_STRIPCHOP;
-			break;
-		case 'h':
-			tif->tif_flags |= TIFF_HEADERONLY;
-			break;
-		}
-	/*
-	 * Read in TIFF header.
-	 */
-	if (tif->tif_mode & O_TRUNC ||
-	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeader))) {
-		if (tif->tif_mode == O_RDONLY) {
-			TIFFErrorExt(tif->tif_clientdata, name,
-				     "Cannot read TIFF header");
-			goto bad;
-		}
-		/*
-		 * Setup header and write.
-		 */
-#ifdef WORDS_BIGENDIAN
-		tif->tif_header.tiff_magic = tif->tif_flags & TIFF_SWAB
-		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;
-#else
-		tif->tif_header.tiff_magic = tif->tif_flags & TIFF_SWAB
-		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;
-#endif
-		tif->tif_header.tiff_version = TIFF_VERSION;
-		if (tif->tif_flags & TIFF_SWAB)
-			TIFFSwabShort(&tif->tif_header.tiff_version);
-		tif->tif_header.tiff_diroff = 0;	/* filled in later */
-
-
-                /*
-                 * The doc for "fopen" for some STD_C_LIBs says that if you 
-                 * open a file for modify ("+"), then you must fseek (or 
-                 * fflush?) between any freads and fwrites.  This is not
-                 * necessary on most systems, but has been shown to be needed
-                 * on Solaris. 
-                 */
-                TIFFSeekFile( tif, 0, SEEK_SET );
-               
-		if (!WriteOK(tif, &tif->tif_header, sizeof (TIFFHeader))) {
-			TIFFErrorExt(tif->tif_clientdata, name,
-				     "Error writing TIFF header");
-			goto bad;
-		}
-		/*
-		 * Setup the byte order handling.
-		 */
-		TIFFInitOrder(tif, tif->tif_header.tiff_magic);
-		/*
-		 * Setup default directory.
-		 */
-		if (!TIFFDefaultDirectory(tif))
-			goto bad;
-		tif->tif_diroff = 0;
-		tif->tif_dirlist = NULL;
-		tif->tif_dirlistsize = 0;
-		tif->tif_dirnumber = 0;
-		return (tif);
-	}
-	/*
-	 * Setup the byte order handling.
-	 */
-	if (tif->tif_header.tiff_magic != TIFF_BIGENDIAN &&
-	    tif->tif_header.tiff_magic != TIFF_LITTLEENDIAN
-#if MDI_SUPPORT
-	    &&
-#if HOST_BIGENDIAN
-	    tif->tif_header.tiff_magic != MDI_BIGENDIAN
-#else
-	    tif->tif_header.tiff_magic != MDI_LITTLEENDIAN
-#endif
-	    ) {
-		TIFFErrorExt(tif->tif_clientdata, name,
-			"Not a TIFF or MDI file, bad magic number %d (0x%x)",
-#else
-	    ) {
-		TIFFErrorExt(tif->tif_clientdata, name,
-			     "Not a TIFF file, bad magic number %d (0x%x)",
-#endif
-		    tif->tif_header.tiff_magic,
-		    tif->tif_header.tiff_magic);
-		goto bad;
-	}
-	TIFFInitOrder(tif, tif->tif_header.tiff_magic);
-	/*
-	 * Swap header if required.
-	 */
-	if (tif->tif_flags & TIFF_SWAB) {
-		TIFFSwabShort(&tif->tif_header.tiff_version);
-		TIFFSwabLong(&tif->tif_header.tiff_diroff);
-	}
-	/*
-	 * Now check version (if needed, it's been byte-swapped).
-	 * Note that this isn't actually a version number, it's a
-	 * magic number that doesn't change (stupid).
-	 */
-	if (tif->tif_header.tiff_version == TIFF_BIGTIFF_VERSION) {
-		TIFFErrorExt(tif->tif_clientdata, name,
-                          "This is a BigTIFF file.  This format not supported\n"
-                          "by this version of libtiff." );
-		goto bad;
-	}
-	if (tif->tif_header.tiff_version != TIFF_VERSION) {
-		TIFFErrorExt(tif->tif_clientdata, name,
-		    "Not a TIFF file, bad version number %d (0x%x)",
-		    tif->tif_header.tiff_version,
-		    tif->tif_header.tiff_version);
-		goto bad;
-	}
-	tif->tif_flags |= TIFF_MYBUFFER;
-	tif->tif_rawcp = tif->tif_rawdata = 0;
-	tif->tif_rawdatasize = 0;
-
-	/*
-	 * Sometimes we do not want to read the first directory (for example,
-	 * it may be broken) and want to proceed to other directories. I this
-	 * case we use the TIFF_HEADERONLY flag to open file and return
-	 * immediately after reading TIFF header.
-	 */
-	if (tif->tif_flags & TIFF_HEADERONLY)
-		return (tif);
-
-	/*
-	 * Setup initial directory.
-	 */
-	switch (mode[0]) {
-	case 'r':
-		tif->tif_nextdiroff = tif->tif_header.tiff_diroff;
-		/*
-		 * Try to use a memory-mapped file if the client
-		 * has not explicitly suppressed usage with the
-		 * 'm' flag in the open mode (see above).
-		 */
-		if ((tif->tif_flags & TIFF_MAPPED) &&
-	!TIFFMapFileContents(tif, (tdata_t*) &tif->tif_base, &tif->tif_size))
-			tif->tif_flags &= ~TIFF_MAPPED;
-		if (TIFFReadDirectory(tif)) {
-			tif->tif_rawcc = -1;
-			tif->tif_flags |= TIFF_BUFFERSETUP;
-			return (tif);
-		}
-		break;
-	case 'a':
-		/*
-		 * New directories are automatically append
-		 * to the end of the directory chain when they
-		 * are written out (see TIFFWriteDirectory).
-		 */
-		if (!TIFFDefaultDirectory(tif))
-			goto bad;
-		return (tif);
-	}
-bad:
-	tif->tif_mode = O_RDONLY;	/* XXX avoid flush */
-        TIFFCleanup(tif);
-bad2:
-	return ((TIFF*)0);
-}
-
-/*
- * Query functions to access private data.
- */
-
-/*
- * Return open file's name.
- */
-const char *
-TIFFFileName(TIFF* tif)
-{
-	return (tif->tif_name);
-}
-
-/*
- * Set the file name.
- */
-const char *
-TIFFSetFileName(TIFF* tif, const char *name)
-{
-	const char* old_name = tif->tif_name;
-	tif->tif_name = (char *)name;
-	return (old_name);
-}
-
-/*
- * Return open file's I/O descriptor.
- */
-int
-TIFFFileno(TIFF* tif)
-{
-	return (tif->tif_fd);
-}
-
-/*
- * Set open file's I/O descriptor, and return previous value.
- */
-int
-TIFFSetFileno(TIFF* tif, int fd)
-{
-        int old_fd = tif->tif_fd;
-	tif->tif_fd = fd;
-	return old_fd;
-}
-
-/*
- * Return open file's clientdata.
- */
-thandle_t
-TIFFClientdata(TIFF* tif)
-{
-	return (tif->tif_clientdata);
-}
-
-/*
- * Set open file's clientdata, and return previous value.
- */
-thandle_t
-TIFFSetClientdata(TIFF* tif, thandle_t newvalue)
-{
-	thandle_t m = tif->tif_clientdata;
-	tif->tif_clientdata = newvalue;
-	return m;
-}
-
-/*
- * Return read/write mode.
- */
-int
-TIFFGetMode(TIFF* tif)
-{
-	return (tif->tif_mode);
-}
-
-/*
- * Return read/write mode.
- */
-int
-TIFFSetMode(TIFF* tif, int mode)
-{
-	int old_mode = tif->tif_mode;
-	tif->tif_mode = mode;
-	return (old_mode);
-}
-
-/*
- * Return nonzero if file is organized in
- * tiles; zero if organized as strips.
- */
-int
-TIFFIsTiled(TIFF* tif)
-{
-	return (isTiled(tif));
-}
-
-/*
- * Return current row being read/written.
- */
-uint32
-TIFFCurrentRow(TIFF* tif)
-{
-	return (tif->tif_row);
-}
-
-/*
- * Return index of the current directory.
- */
-tdir_t
-TIFFCurrentDirectory(TIFF* tif)
-{
-	return (tif->tif_curdir);
-}
-
-/*
- * Return current strip.
- */
-tstrip_t
-TIFFCurrentStrip(TIFF* tif)
-{
-	return (tif->tif_curstrip);
-}
-
-/*
- * Return current tile.
- */
-ttile_t
-TIFFCurrentTile(TIFF* tif)
-{
-	return (tif->tif_curtile);
-}
-
-/*
- * Return nonzero if the file has byte-swapped data.
- */
-int
-TIFFIsByteSwapped(TIFF* tif)
-{
-	return ((tif->tif_flags & TIFF_SWAB) != 0);
-}
-
-/*
- * Return nonzero if the data is returned up-sampled.
- */
-int
-TIFFIsUpSampled(TIFF* tif)
-{
-	return (isUpSampled(tif));
-}
-
-/*
- * Return nonzero if the data is returned in MSB-to-LSB bit order.
- */
-int
-TIFFIsMSB2LSB(TIFF* tif)
-{
-	return (isFillOrder(tif, FILLORDER_MSB2LSB));
-}
-
-/*
- * Return nonzero if given file was written in big-endian order.
- */
-int
-TIFFIsBigEndian(TIFF* tif)
-{
-	return (tif->tif_header.tiff_magic == TIFF_BIGENDIAN);
-}
-
-/*
- * Return pointer to file read method.
- */
-TIFFReadWriteProc
-TIFFGetReadProc(TIFF* tif)
-{
-	return (tif->tif_readproc);
-}
-
-/*
- * Return pointer to file write method.
- */
-TIFFReadWriteProc
-TIFFGetWriteProc(TIFF* tif)
-{
-	return (tif->tif_writeproc);
-}
-
-/*
- * Return pointer to file seek method.
- */
-TIFFSeekProc
-TIFFGetSeekProc(TIFF* tif)
-{
-	return (tif->tif_seekproc);
-}
-
-/*
- * Return pointer to file close method.
- */
-TIFFCloseProc
-TIFFGetCloseProc(TIFF* tif)
-{
-	return (tif->tif_closeproc);
-}
-
-/*
- * Return pointer to file size requesting method.
- */
-TIFFSizeProc
-TIFFGetSizeProc(TIFF* tif)
-{
-	return (tif->tif_sizeproc);
-}
-
-/*
- * Return pointer to memory mapping method.
- */
-TIFFMapFileProc
-TIFFGetMapFileProc(TIFF* tif)
-{
-	return (tif->tif_mapproc);
-}
-
-/*
- * Return pointer to memory unmapping method.
- */
-TIFFUnmapFileProc
-TIFFGetUnmapFileProc(TIFF* tif)
-{
-	return (tif->tif_unmapproc);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_packbits.c b/thirdparty/libtiff/tif_packbits.c
deleted file mode 100644
index ee095f5..0000000
--- a/thirdparty/libtiff/tif_packbits.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/* $Id: tif_packbits.c,v 1.13.2.2 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef PACKBITS_SUPPORT
-/*
- * TIFF Library.
- *
- * PackBits Compression Algorithm Support
- */
-#include <stdio.h>
-
-static int
-PackBitsPreEncode(TIFF* tif, tsample_t s)
-{
-	(void) s;
-
-        if (!(tif->tif_data = (tidata_t)_TIFFmalloc(sizeof(tsize_t))))
-		return (0);
-	/*
-	 * Calculate the scanline/tile-width size in bytes.
-	 */
-	if (isTiled(tif))
-		*(tsize_t*)tif->tif_data = TIFFTileRowSize(tif);
-	else
-		*(tsize_t*)tif->tif_data = TIFFScanlineSize(tif);
-	return (1);
-}
-
-static int
-PackBitsPostEncode(TIFF* tif)
-{
-        if (tif->tif_data)
-            _TIFFfree(tif->tif_data);
-	return (1);
-}
-
-/*
- * NB: tidata is the type representing *(tidata_t);
- *     if tidata_t is made signed then this type must
- *     be adjusted accordingly.
- */
-typedef unsigned char tidata;
-
-/*
- * Encode a run of pixels.
- */
-static int
-PackBitsEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)
-{
-	unsigned char* bp = (unsigned char*) buf;
-	tidata_t op, ep, lastliteral;
-	long n, slop;
-	int b;
-	enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
-
-	(void) s;
-	op = tif->tif_rawcp;
-	ep = tif->tif_rawdata + tif->tif_rawdatasize;
-	state = BASE;
-	lastliteral = 0;
-	while (cc > 0) {
-		/*
-		 * Find the longest string of identical bytes.
-		 */
-		b = *bp++, cc--, n = 1;
-		for (; cc > 0 && b == *bp; cc--, bp++)
-			n++;
-	again:
-		if (op + 2 >= ep) {		/* insure space for new data */
-			/*
-			 * Be careful about writing the last
-			 * literal.  Must write up to that point
-			 * and then copy the remainder to the
-			 * front of the buffer.
-			 */
-			if (state == LITERAL || state == LITERAL_RUN) {
-				slop = op - lastliteral;
-				tif->tif_rawcc += lastliteral - tif->tif_rawcp;
-				if (!TIFFFlushData1(tif))
-					return (-1);
-				op = tif->tif_rawcp;
-				while (slop-- > 0)
-					*op++ = *lastliteral++;
-				lastliteral = tif->tif_rawcp;
-			} else {
-				tif->tif_rawcc += op - tif->tif_rawcp;
-				if (!TIFFFlushData1(tif))
-					return (-1);
-				op = tif->tif_rawcp;
-			}
-		}
-		switch (state) {
-		case BASE:		/* initial state, set run/literal */
-			if (n > 1) {
-				state = RUN;
-				if (n > 128) {
-					*op++ = (tidata) -127;
-					*op++ = (tidataval_t) b;
-					n -= 128;
-					goto again;
-				}
-				*op++ = (tidataval_t)(-(n-1));
-				*op++ = (tidataval_t) b;
-			} else {
-				lastliteral = op;
-				*op++ = 0;
-				*op++ = (tidataval_t) b;
-				state = LITERAL;
-			}
-			break;
-		case LITERAL:		/* last object was literal string */
-			if (n > 1) {
-				state = LITERAL_RUN;
-				if (n > 128) {
-					*op++ = (tidata) -127;
-					*op++ = (tidataval_t) b;
-					n -= 128;
-					goto again;
-				}
-				*op++ = (tidataval_t)(-(n-1));	/* encode run */
-				*op++ = (tidataval_t) b;
-			} else {			/* extend literal */
-				if (++(*lastliteral) == 127)
-					state = BASE;
-				*op++ = (tidataval_t) b;
-			}
-			break;
-		case RUN:		/* last object was run */
-			if (n > 1) {
-				if (n > 128) {
-					*op++ = (tidata) -127;
-					*op++ = (tidataval_t) b;
-					n -= 128;
-					goto again;
-				}
-				*op++ = (tidataval_t)(-(n-1));
-				*op++ = (tidataval_t) b;
-			} else {
-				lastliteral = op;
-				*op++ = 0;
-				*op++ = (tidataval_t) b;
-				state = LITERAL;
-			}
-			break;
-		case LITERAL_RUN:	/* literal followed by a run */
-			/*
-			 * Check to see if previous run should
-			 * be converted to a literal, in which
-			 * case we convert literal-run-literal
-			 * to a single literal.
-			 */
-			if (n == 1 && op[-2] == (tidata) -1 &&
-			    *lastliteral < 126) {
-				state = (((*lastliteral) += 2) == 127 ?
-				    BASE : LITERAL);
-				op[-2] = op[-1];	/* replicate */
-			} else
-				state = RUN;
-			goto again;
-		}
-	}
-	tif->tif_rawcc += op - tif->tif_rawcp;
-	tif->tif_rawcp = op;
-	return (1);
-}
-
-/*
- * Encode a rectangular chunk of pixels.  We break it up
- * into row-sized pieces to insure that encoded runs do
- * not span rows.  Otherwise, there can be problems with
- * the decoder if data is read, for example, by scanlines
- * when it was encoded by strips.
- */
-static int
-PackBitsEncodeChunk(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	tsize_t rowsize = *(tsize_t*)tif->tif_data;
-
-	while ((long)cc > 0) {
-		int	chunk = rowsize;
-		
-		if( cc < chunk )
-		    chunk = cc;
-
-		if (PackBitsEncode(tif, bp, chunk, s) < 0)
-		    return (-1);
-		bp += chunk;
-		cc -= chunk;
-	}
-	return (1);
-}
-
-static int
-PackBitsDecode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	char *bp;
-	tsize_t cc;
-	long n;
-	int b;
-
-	(void) s;
-	bp = (char*) tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-	while (cc > 0 && (long)occ > 0) {
-		n = (long) *bp++, cc--;
-		/*
-		 * Watch out for compilers that
-		 * don't sign extend chars...
-		 */
-		if (n >= 128)
-			n -= 256;
-		if (n < 0) {		/* replicate next byte -n+1 times */
-			if (n == -128)	/* nop */
-				continue;
-                        n = -n + 1;
-                        if( occ < n )
-                        {
-							TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-                                        "PackBitsDecode: discarding %ld bytes "
-                                        "to avoid buffer overrun",
-                                        n - occ);
-                            n = occ;
-                        }
-			occ -= n;
-			b = *bp++, cc--;
-			while (n-- > 0)
-				*op++ = (tidataval_t) b;
-		} else {		/* copy next n+1 bytes literally */
-			if (occ < n + 1)
-                        {
-                            TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
-                                        "PackBitsDecode: discarding %ld bytes "
-                                        "to avoid buffer overrun",
-                                        n - occ + 1);
-                            n = occ - 1;
-                        }
-                        _TIFFmemcpy(op, bp, ++n);
-			op += n; occ -= n;
-			bp += n; cc -= n;
-		}
-	}
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	if (occ > 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "PackBitsDecode: Not enough data for scanline %ld",
-		    (long) tif->tif_row);
-		return (0);
-	}
-	return (1);
-}
-
-int
-TIFFInitPackBits(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	tif->tif_decoderow = PackBitsDecode;
-	tif->tif_decodestrip = PackBitsDecode;
-	tif->tif_decodetile = PackBitsDecode;
-	tif->tif_preencode = PackBitsPreEncode;
-        tif->tif_postencode = PackBitsPostEncode;
-	tif->tif_encoderow = PackBitsEncode;
-	tif->tif_encodestrip = PackBitsEncodeChunk;
-	tif->tif_encodetile = PackBitsEncodeChunk;
-	return (1);
-}
-#endif /* PACKBITS_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_pixarlog.c b/thirdparty/libtiff/tif_pixarlog.c
deleted file mode 100644
index ed8eb40..0000000
--- a/thirdparty/libtiff/tif_pixarlog.c
+++ /dev/null
@@ -1,1371 +0,0 @@
-/* $Id: tif_pixarlog.c,v 1.15.2.4 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1996-1997 Sam Leffler
- * Copyright (c) 1996 Pixar
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Pixar, Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Pixar, Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL PIXAR, SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef PIXARLOG_SUPPORT
-
-/*
- * TIFF Library.
- * PixarLog Compression Support
- *
- * Contributed by Dan McCoy.
- *
- * PixarLog film support uses the TIFF library to store companded
- * 11 bit values into a tiff file, which are compressed using the 
- * zip compressor.  
- *
- * The codec can take as input and produce as output 32-bit IEEE float values 
- * as well as 16-bit or 8-bit unsigned integer values.
- *
- * On writing any of the above are converted into the internal
- * 11-bit log format.   In the case of  8 and 16 bit values, the
- * input is assumed to be unsigned linear color values that represent
- * the range 0-1.  In the case of IEEE values, the 0-1 range is assumed to
- * be the normal linear color range, in addition over 1 values are
- * accepted up to a value of about 25.0 to encode "hot" hightlights and such.
- * The encoding is lossless for 8-bit values, slightly lossy for the
- * other bit depths.  The actual color precision should be better
- * than the human eye can perceive with extra room to allow for
- * error introduced by further image computation.  As with any quantized
- * color format, it is possible to perform image calculations which
- * expose the quantization error. This format should certainly be less 
- * susceptable to such errors than standard 8-bit encodings, but more
- * susceptable than straight 16-bit or 32-bit encodings.
- *
- * On reading the internal format is converted to the desired output format.
- * The program can request which format it desires by setting the internal
- * pseudo tag TIFFTAG_PIXARLOGDATAFMT to one of these possible values:
- *  PIXARLOGDATAFMT_FLOAT     = provide IEEE float values.
- *  PIXARLOGDATAFMT_16BIT     = provide unsigned 16-bit integer values
- *  PIXARLOGDATAFMT_8BIT      = provide unsigned 8-bit integer values
- *
- * alternately PIXARLOGDATAFMT_8BITABGR provides unsigned 8-bit integer
- * values with the difference that if there are exactly three or four channels
- * (rgb or rgba) it swaps the channel order (bgr or abgr).
- *
- * PIXARLOGDATAFMT_11BITLOG provides the internal encoding directly
- * packed in 16-bit values.   However no tools are supplied for interpreting
- * these values.
- *
- * "hot" (over 1.0) areas written in floating point get clamped to
- * 1.0 in the integer data types.
- *
- * When the file is closed after writing, the bit depth and sample format
- * are set always to appear as if 8-bit data has been written into it.
- * That way a naive program unaware of the particulars of the encoding
- * gets the format it is most likely able to handle.
- *
- * The codec does it's own horizontal differencing step on the coded
- * values so the libraries predictor stuff should be turned off.
- * The codec also handle byte swapping the encoded values as necessary
- * since the library does not have the information necessary
- * to know the bit depth of the raw unencoded buffer.
- * 
- */
-
-#include "tif_predict.h"
-#include "zlib.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-/* Tables for converting to/from 11 bit coded values */
-
-#define  TSIZE	 2048		/* decode table size (11-bit tokens) */
-#define  TSIZEP1 2049		/* Plus one for slop */
-#define  ONE	 1250		/* token value of 1.0 exactly */
-#define  RATIO	 1.004		/* nominal ratio for log part */
-
-#define CODE_MASK 0x7ff         /* 11 bits. */
-
-static float  Fltsize;
-static float  LogK1, LogK2;
-
-#define REPEAT(n, op)   { int i; i=n; do { i--; op; } while (i>0); }
-
-static void
-horizontalAccumulateF(uint16 *wp, int n, int stride, float *op, 
-	float *ToLinearF)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-    register float  t0, t1, t2, t3;
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    t0 = ToLinearF[cr = wp[0]];
-	    t1 = ToLinearF[cg = wp[1]];
-	    t2 = ToLinearF[cb = wp[2]];
-	    op[0] = t0;
-	    op[1] = t1;
-	    op[2] = t2;
-	    n -= 3;
-	    while (n > 0) {
-		wp += 3;
-		op += 3;
-		n -= 3;
-		t0 = ToLinearF[(cr += wp[0]) & mask];
-		t1 = ToLinearF[(cg += wp[1]) & mask];
-		t2 = ToLinearF[(cb += wp[2]) & mask];
-		op[0] = t0;
-		op[1] = t1;
-		op[2] = t2;
-	    }
-	} else if (stride == 4) {
-	    t0 = ToLinearF[cr = wp[0]];
-	    t1 = ToLinearF[cg = wp[1]];
-	    t2 = ToLinearF[cb = wp[2]];
-	    t3 = ToLinearF[ca = wp[3]];
-	    op[0] = t0;
-	    op[1] = t1;
-	    op[2] = t2;
-	    op[3] = t3;
-	    n -= 4;
-	    while (n > 0) {
-		wp += 4;
-		op += 4;
-		n -= 4;
-		t0 = ToLinearF[(cr += wp[0]) & mask];
-		t1 = ToLinearF[(cg += wp[1]) & mask];
-		t2 = ToLinearF[(cb += wp[2]) & mask];
-		t3 = ToLinearF[(ca += wp[3]) & mask];
-		op[0] = t0;
-		op[1] = t1;
-		op[2] = t2;
-		op[3] = t3;
-	    }
-	} else {
-	    REPEAT(stride, *op = ToLinearF[*wp&mask]; wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-static void
-horizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,
-	float *ToLinearF)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-    register float  t0, t1, t2, t3;
-
-#define SCALE12 2048.0F
-#define CLAMP12(t) (((t) < 3071) ? (uint16) (t) : 3071)
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    t0 = ToLinearF[cr = wp[0]] * SCALE12;
-	    t1 = ToLinearF[cg = wp[1]] * SCALE12;
-	    t2 = ToLinearF[cb = wp[2]] * SCALE12;
-	    op[0] = CLAMP12(t0);
-	    op[1] = CLAMP12(t1);
-	    op[2] = CLAMP12(t2);
-	    n -= 3;
-	    while (n > 0) {
-		wp += 3;
-		op += 3;
-		n -= 3;
-		t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;
-		t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;
-		t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;
-		op[0] = CLAMP12(t0);
-		op[1] = CLAMP12(t1);
-		op[2] = CLAMP12(t2);
-	    }
-	} else if (stride == 4) {
-	    t0 = ToLinearF[cr = wp[0]] * SCALE12;
-	    t1 = ToLinearF[cg = wp[1]] * SCALE12;
-	    t2 = ToLinearF[cb = wp[2]] * SCALE12;
-	    t3 = ToLinearF[ca = wp[3]] * SCALE12;
-	    op[0] = CLAMP12(t0);
-	    op[1] = CLAMP12(t1);
-	    op[2] = CLAMP12(t2);
-	    op[3] = CLAMP12(t3);
-	    n -= 4;
-	    while (n > 0) {
-		wp += 4;
-		op += 4;
-		n -= 4;
-		t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;
-		t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;
-		t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;
-		t3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12;
-		op[0] = CLAMP12(t0);
-		op[1] = CLAMP12(t1);
-		op[2] = CLAMP12(t2);
-		op[3] = CLAMP12(t3);
-	    }
-	} else {
-	    REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;
-                           *op = CLAMP12(t0); wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12;
-		    *op = CLAMP12(t0);  wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-static void
-horizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,
-	uint16 *ToLinear16)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    op[0] = ToLinear16[cr = wp[0]];
-	    op[1] = ToLinear16[cg = wp[1]];
-	    op[2] = ToLinear16[cb = wp[2]];
-	    n -= 3;
-	    while (n > 0) {
-		wp += 3;
-		op += 3;
-		n -= 3;
-		op[0] = ToLinear16[(cr += wp[0]) & mask];
-		op[1] = ToLinear16[(cg += wp[1]) & mask];
-		op[2] = ToLinear16[(cb += wp[2]) & mask];
-	    }
-	} else if (stride == 4) {
-	    op[0] = ToLinear16[cr = wp[0]];
-	    op[1] = ToLinear16[cg = wp[1]];
-	    op[2] = ToLinear16[cb = wp[2]];
-	    op[3] = ToLinear16[ca = wp[3]];
-	    n -= 4;
-	    while (n > 0) {
-		wp += 4;
-		op += 4;
-		n -= 4;
-		op[0] = ToLinear16[(cr += wp[0]) & mask];
-		op[1] = ToLinear16[(cg += wp[1]) & mask];
-		op[2] = ToLinear16[(cb += wp[2]) & mask];
-		op[3] = ToLinear16[(ca += wp[3]) & mask];
-	    }
-	} else {
-	    REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-/* 
- * Returns the log encoded 11-bit values with the horizontal
- * differencing undone.
- */
-static void
-horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    op[0] = cr = wp[0];  op[1] = cg = wp[1];  op[2] = cb = wp[2];
-	    n -= 3;
-	    while (n > 0) {
-		wp += 3;
-		op += 3;
-		n -= 3;
-		op[0] = (cr += wp[0]) & mask;
-		op[1] = (cg += wp[1]) & mask;
-		op[2] = (cb += wp[2]) & mask;
-	    }
-	} else if (stride == 4) {
-	    op[0] = cr = wp[0];  op[1] = cg = wp[1];
-	    op[2] = cb = wp[2];  op[3] = ca = wp[3];
-	    n -= 4;
-	    while (n > 0) {
-		wp += 4;
-		op += 4;
-		n -= 4;
-		op[0] = (cr += wp[0]) & mask;
-		op[1] = (cg += wp[1]) & mask;
-		op[2] = (cb += wp[2]) & mask;
-		op[3] = (ca += wp[3]) & mask;
-	    } 
-	} else {
-	    REPEAT(stride, *op = *wp&mask; wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; *op = *wp&mask; wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-static void
-horizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,
-	unsigned char *ToLinear8)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    op[0] = ToLinear8[cr = wp[0]];
-	    op[1] = ToLinear8[cg = wp[1]];
-	    op[2] = ToLinear8[cb = wp[2]];
-	    n -= 3;
-	    while (n > 0) {
-		n -= 3;
-		wp += 3;
-		op += 3;
-		op[0] = ToLinear8[(cr += wp[0]) & mask];
-		op[1] = ToLinear8[(cg += wp[1]) & mask];
-		op[2] = ToLinear8[(cb += wp[2]) & mask];
-	    }
-	} else if (stride == 4) {
-	    op[0] = ToLinear8[cr = wp[0]];
-	    op[1] = ToLinear8[cg = wp[1]];
-	    op[2] = ToLinear8[cb = wp[2]];
-	    op[3] = ToLinear8[ca = wp[3]];
-	    n -= 4;
-	    while (n > 0) {
-		n -= 4;
-		wp += 4;
-		op += 4;
-		op[0] = ToLinear8[(cr += wp[0]) & mask];
-		op[1] = ToLinear8[(cg += wp[1]) & mask];
-		op[2] = ToLinear8[(cb += wp[2]) & mask];
-		op[3] = ToLinear8[(ca += wp[3]) & mask];
-	    }
-	} else {
-	    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-
-static void
-horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,
-	unsigned char *ToLinear8)
-{
-    register unsigned int  cr, cg, cb, ca, mask;
-    register unsigned char  t0, t1, t2, t3;
-
-    if (n >= stride) {
-	mask = CODE_MASK;
-	if (stride == 3) {
-	    op[0] = 0;
-	    t1 = ToLinear8[cb = wp[2]];
-	    t2 = ToLinear8[cg = wp[1]];
-	    t3 = ToLinear8[cr = wp[0]];
-	    op[1] = t1;
-	    op[2] = t2;
-	    op[3] = t3;
-	    n -= 3;
-	    while (n > 0) {
-		n -= 3;
-		wp += 3;
-		op += 4;
-		op[0] = 0;
-		t1 = ToLinear8[(cb += wp[2]) & mask];
-		t2 = ToLinear8[(cg += wp[1]) & mask];
-		t3 = ToLinear8[(cr += wp[0]) & mask];
-		op[1] = t1;
-		op[2] = t2;
-		op[3] = t3;
-	    }
-	} else if (stride == 4) {
-	    t0 = ToLinear8[ca = wp[3]];
-	    t1 = ToLinear8[cb = wp[2]];
-	    t2 = ToLinear8[cg = wp[1]];
-	    t3 = ToLinear8[cr = wp[0]];
-	    op[0] = t0;
-	    op[1] = t1;
-	    op[2] = t2;
-	    op[3] = t3;
-	    n -= 4;
-	    while (n > 0) {
-		n -= 4;
-		wp += 4;
-		op += 4;
-		t0 = ToLinear8[(ca += wp[3]) & mask];
-		t1 = ToLinear8[(cb += wp[2]) & mask];
-		t2 = ToLinear8[(cg += wp[1]) & mask];
-		t3 = ToLinear8[(cr += wp[0]) & mask];
-		op[0] = t0;
-		op[1] = t1;
-		op[2] = t2;
-		op[3] = t3;
-	    }
-	} else {
-	    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride,
-		    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)
-		n -= stride;
-	    }
-	}
-    }
-}
-
-/*
- * State block for each open TIFF
- * file using PixarLog compression/decompression.
- */
-typedef	struct {
-	TIFFPredictorState	predict;
-	z_stream		stream;
-	uint16			*tbuf; 
-	uint16			stride;
-	int			state;
-	int			user_datafmt;
-	int			quality;
-#define PLSTATE_INIT 1
-
-	TIFFVSetMethod		vgetparent;	/* super-class method */
-	TIFFVSetMethod		vsetparent;	/* super-class method */
-
-	float *ToLinearF;
-	uint16 *ToLinear16;
-	unsigned char *ToLinear8;
-	uint16  *FromLT2;
-	uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
-	uint16  *From8;
-	
-} PixarLogState;
-
-static int
-PixarLogMakeTables(PixarLogState *sp)
-{
-
-/*
- *    We make several tables here to convert between various external
- *    representations (float, 16-bit, and 8-bit) and the internal
- *    11-bit companded representation.  The 11-bit representation has two
- *    distinct regions.  A linear bottom end up through .018316 in steps
- *    of about .000073, and a region of constant ratio up to about 25.
- *    These floating point numbers are stored in the main table ToLinearF. 
- *    All other tables are derived from this one.  The tables (and the
- *    ratios) are continuous at the internal seam.
- */
-
-    int  nlin, lt2size;
-    int  i, j;
-    double  b, c, linstep, v;
-    float *ToLinearF;
-    uint16 *ToLinear16;
-    unsigned char *ToLinear8;
-    uint16  *FromLT2;
-    uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
-    uint16  *From8;
-
-    c = log(RATIO);	
-    nlin = (int)(1./c);	/* nlin must be an integer */
-    c = 1./nlin;
-    b = exp(-c*ONE);	/* multiplicative scale factor [b*exp(c*ONE) = 1] */
-    linstep = b*c*exp(1.);
-
-    LogK1 = (float)(1./c);	/* if (v >= 2)  token = k1*log(v*k2) */
-    LogK2 = (float)(1./b);
-    lt2size = (int)(2./linstep) + 1;
-    FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16));
-    From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16));
-    From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16));
-    ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float));
-    ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16));
-    ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char));
-    if (FromLT2 == NULL || From14  == NULL || From8   == NULL ||
-	 ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) {
-	if (FromLT2) _TIFFfree(FromLT2);
-	if (From14) _TIFFfree(From14);
-	if (From8) _TIFFfree(From8);
-	if (ToLinearF) _TIFFfree(ToLinearF);
-	if (ToLinear16) _TIFFfree(ToLinear16);
-	if (ToLinear8) _TIFFfree(ToLinear8);
-	sp->FromLT2 = NULL;
-	sp->From14 = NULL;
-	sp->From8 = NULL;
-	sp->ToLinearF = NULL;
-	sp->ToLinear16 = NULL;
-	sp->ToLinear8 = NULL;
-	return 0;
-    }
-
-    j = 0;
-
-    for (i = 0; i < nlin; i++)  {
-	v = i * linstep;
-	ToLinearF[j++] = (float)v;
-    }
-
-    for (i = nlin; i < TSIZE; i++)
-	ToLinearF[j++] = (float)(b*exp(c*i));
-
-    ToLinearF[2048] = ToLinearF[2047];
-
-    for (i = 0; i < TSIZEP1; i++)  {
-	v = ToLinearF[i]*65535.0 + 0.5;
-	ToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v;
-	v = ToLinearF[i]*255.0  + 0.5;
-	ToLinear8[i]  = (v > 255.0) ? 255 : (unsigned char)v;
-    }
-
-    j = 0;
-    for (i = 0; i < lt2size; i++)  {
-	if ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1])
-	    j++;
-	FromLT2[i] = j;
-    }
-
-    /*
-     * Since we lose info anyway on 16-bit data, we set up a 14-bit
-     * table and shift 16-bit values down two bits on input.
-     * saves a little table space.
-     */
-    j = 0;
-    for (i = 0; i < 16384; i++)  {
-	while ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1])
-	    j++;
-	From14[i] = j;
-    }
-
-    j = 0;
-    for (i = 0; i < 256; i++)  {
-	while ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1])
-	    j++;
-	From8[i] = j;
-    }
-
-    Fltsize = (float)(lt2size/2);
-
-    sp->ToLinearF = ToLinearF;
-    sp->ToLinear16 = ToLinear16;
-    sp->ToLinear8 = ToLinear8;
-    sp->FromLT2 = FromLT2;
-    sp->From14 = From14;
-    sp->From8 = From8;
-
-    return 1;
-}
-
-#define	DecoderState(tif)	((PixarLogState*) (tif)->tif_data)
-#define	EncoderState(tif)	((PixarLogState*) (tif)->tif_data)
-
-static	int PixarLogEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int PixarLogDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-
-#define PIXARLOGDATAFMT_UNKNOWN	-1
-
-static int
-PixarLogGuessDataFmt(TIFFDirectory *td)
-{
-	int guess = PIXARLOGDATAFMT_UNKNOWN;
-	int format = td->td_sampleformat;
-
-	/* If the user didn't tell us his datafmt,
-	 * take our best guess from the bitspersample.
-	 */
-	switch (td->td_bitspersample) {
-	 case 32:
-		if (format == SAMPLEFORMAT_IEEEFP)
-			guess = PIXARLOGDATAFMT_FLOAT;
-		break;
-	 case 16:
-		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
-			guess = PIXARLOGDATAFMT_16BIT;
-		break;
-	 case 12:
-		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_INT)
-			guess = PIXARLOGDATAFMT_12BITPICIO;
-		break;
-	 case 11:
-		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
-			guess = PIXARLOGDATAFMT_11BITLOG;
-		break;
-	 case 8:
-		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
-			guess = PIXARLOGDATAFMT_8BIT;
-		break;
-	}
-
-	return guess;
-}
-
-static uint32
-multiply(size_t m1, size_t m2)
-{
-	uint32	bytes = m1 * m2;
-
-	if (m1 && bytes / m1 != m2)
-		bytes = 0;
-
-	return bytes;
-}
-
-static int
-PixarLogSetupDecode(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	PixarLogState* sp = DecoderState(tif);
-	tsize_t tbuf_size;
-	static const char module[] = "PixarLogSetupDecode";
-
-	assert(sp != NULL);
-
-	/* Make sure no byte swapping happens on the data
-	 * after decompression. */
-	tif->tif_postdecode = _TIFFNoPostDecode;
-
-	/* for some reason, we can't do this in TIFFInitPixarLog */
-
-	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
-	    td->td_samplesperpixel : 1);
-	tbuf_size = multiply(multiply(multiply(sp->stride, td->td_imagewidth),
-				      td->td_rowsperstrip), sizeof(uint16));
-	if (tbuf_size == 0)
-		return (0);
-	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
-	if (sp->tbuf == NULL)
-		return (0);
-	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
-		sp->user_datafmt = PixarLogGuessDataFmt(td);
-	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			"PixarLog compression can't handle bits depth/data format combination (depth: %d)", 
-			td->td_bitspersample);
-		return (0);
-	}
-
-	if (inflateInit(&sp->stream) != Z_OK) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: %s", tif->tif_name, sp->stream.msg);
-		return (0);
-	} else {
-		sp->state |= PLSTATE_INIT;
-		return (1);
-	}
-}
-
-/*
- * Setup state for decoding a strip.
- */
-static int
-PixarLogPreDecode(TIFF* tif, tsample_t s)
-{
-	PixarLogState* sp = DecoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-	sp->stream.next_in = tif->tif_rawdata;
-	sp->stream.avail_in = tif->tif_rawcc;
-	return (inflateReset(&sp->stream) == Z_OK);
-}
-
-static int
-PixarLogDecode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	PixarLogState* sp = DecoderState(tif);
-	static const char module[] = "PixarLogDecode";
-	int i, nsamples, llen;
-	uint16 *up;
-
-	switch (sp->user_datafmt) {
-	case PIXARLOGDATAFMT_FLOAT:
-		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
-		break;
-	case PIXARLOGDATAFMT_16BIT:
-	case PIXARLOGDATAFMT_12BITPICIO:
-	case PIXARLOGDATAFMT_11BITLOG:
-		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
-		break;
-	case PIXARLOGDATAFMT_8BIT:
-	case PIXARLOGDATAFMT_8BITABGR:
-		nsamples = occ;
-		break;
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"%d bit input not supported in PixarLog",
-			td->td_bitspersample);
-		return 0;
-	}
-
-	llen = sp->stride * td->td_imagewidth;
-
-	(void) s;
-	assert(sp != NULL);
-	sp->stream.next_out = (unsigned char *) sp->tbuf;
-	sp->stream.avail_out = nsamples * sizeof(uint16);
-	do {
-		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
-		if (state == Z_STREAM_END) {
-			break;			/* XXX */
-		}
-		if (state == Z_DATA_ERROR) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Decoding error at scanline %d, %s",
-			    tif->tif_name, tif->tif_row, sp->stream.msg);
-			if (inflateSync(&sp->stream) != Z_OK)
-				return (0);
-			continue;
-		}
-		if (state != Z_OK) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-			    tif->tif_name, sp->stream.msg);
-			return (0);
-		}
-	} while (sp->stream.avail_out > 0);
-
-	/* hopefully, we got all the bytes we needed */
-	if (sp->stream.avail_out != 0) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%s: Not enough data at scanline %d (short %d bytes)",
-		    tif->tif_name, tif->tif_row, sp->stream.avail_out);
-		return (0);
-	}
-
-	up = sp->tbuf;
-	/* Swap bytes in the data if from a different endian machine. */
-	if (tif->tif_flags & TIFF_SWAB)
-		TIFFSwabArrayOfShort(up, nsamples);
-
-	/* 
-	 * if llen is not an exact multiple of nsamples, the decode operation
-	 * may overflow the output buffer, so truncate it enough to prevent
-	 * that but still salvage as much data as possible.
-	 */
-	if (nsamples % llen) { 
-		TIFFWarningExt(tif->tif_clientdata, module,
-			"%s: stride %d is not a multiple of sample count, "
-			"%d, data truncated.", tif->tif_name, llen, nsamples);
-		nsamples -= nsamples % llen;
-	}
-
-	for (i = 0; i < nsamples; i += llen, up += llen) {
-		switch (sp->user_datafmt)  {
-		case PIXARLOGDATAFMT_FLOAT:
-			horizontalAccumulateF(up, llen, sp->stride,
-					(float *)op, sp->ToLinearF);
-			op += llen * sizeof(float);
-			break;
-		case PIXARLOGDATAFMT_16BIT:
-			horizontalAccumulate16(up, llen, sp->stride,
-					(uint16 *)op, sp->ToLinear16);
-			op += llen * sizeof(uint16);
-			break;
-		case PIXARLOGDATAFMT_12BITPICIO:
-			horizontalAccumulate12(up, llen, sp->stride,
-					(int16 *)op, sp->ToLinearF);
-			op += llen * sizeof(int16);
-			break;
-		case PIXARLOGDATAFMT_11BITLOG:
-			horizontalAccumulate11(up, llen, sp->stride,
-					(uint16 *)op);
-			op += llen * sizeof(uint16);
-			break;
-		case PIXARLOGDATAFMT_8BIT:
-			horizontalAccumulate8(up, llen, sp->stride,
-					(unsigned char *)op, sp->ToLinear8);
-			op += llen * sizeof(unsigned char);
-			break;
-		case PIXARLOGDATAFMT_8BITABGR:
-			horizontalAccumulate8abgr(up, llen, sp->stride,
-					(unsigned char *)op, sp->ToLinear8);
-			op += llen * sizeof(unsigned char);
-			break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				  "PixarLogDecode: unsupported bits/sample: %d", 
-				  td->td_bitspersample);
-			return (0);
-		}
-	}
-
-	return (1);
-}
-
-static int
-PixarLogSetupEncode(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	PixarLogState* sp = EncoderState(tif);
-	tsize_t tbuf_size;
-	static const char module[] = "PixarLogSetupEncode";
-
-	assert(sp != NULL);
-
-	/* for some reason, we can't do this in TIFFInitPixarLog */
-
-	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
-	    td->td_samplesperpixel : 1);
-	tbuf_size = multiply(multiply(multiply(sp->stride, td->td_imagewidth),
-				      td->td_rowsperstrip), sizeof(uint16));
-	if (tbuf_size == 0)
-		return (0);
-	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
-	if (sp->tbuf == NULL)
-		return (0);
-	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
-		sp->user_datafmt = PixarLogGuessDataFmt(td);
-	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
-		TIFFErrorExt(tif->tif_clientdata, module, "PixarLog compression can't handle %d bit linear encodings", td->td_bitspersample);
-		return (0);
-	}
-
-	if (deflateInit(&sp->stream, sp->quality) != Z_OK) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: %s", tif->tif_name, sp->stream.msg);
-		return (0);
-	} else {
-		sp->state |= PLSTATE_INIT;
-		return (1);
-	}
-}
-
-/*
- * Reset encoding state at the start of a strip.
- */
-static int
-PixarLogPreEncode(TIFF* tif, tsample_t s)
-{
-	PixarLogState *sp = EncoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-	sp->stream.next_out = tif->tif_rawdata;
-	sp->stream.avail_out = tif->tif_rawdatasize;
-	return (deflateReset(&sp->stream) == Z_OK);
-}
-
-static void
-horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
-{
-
-    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;
-    float fltsize = Fltsize;
-
-#define  CLAMP(v) ( (v<(float)0.)   ? 0				\
-		  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]	\
-		  : (v>(float)24.2) ? 2047			\
-		  : LogK1*log(v*LogK2) + 0.5 )
-
-    mask = CODE_MASK;
-    if (n >= stride) {
-	if (stride == 3) {
-	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
-	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
-	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
-	    n -= 3;
-	    while (n > 0) {
-		n -= 3;
-		wp += 3;
-		ip += 3;
-		r1 = (int32) CLAMP(ip[0]); wp[0] = (r1-r2) & mask; r2 = r1;
-		g1 = (int32) CLAMP(ip[1]); wp[1] = (g1-g2) & mask; g2 = g1;
-		b1 = (int32) CLAMP(ip[2]); wp[2] = (b1-b2) & mask; b2 = b1;
-	    }
-	} else if (stride == 4) {
-	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
-	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
-	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
-	    a2 = wp[3] = (uint16) CLAMP(ip[3]);
-	    n -= 4;
-	    while (n > 0) {
-		n -= 4;
-		wp += 4;
-		ip += 4;
-		r1 = (int32) CLAMP(ip[0]); wp[0] = (r1-r2) & mask; r2 = r1;
-		g1 = (int32) CLAMP(ip[1]); wp[1] = (g1-g2) & mask; g2 = g1;
-		b1 = (int32) CLAMP(ip[2]); wp[2] = (b1-b2) & mask; b2 = b1;
-		a1 = (int32) CLAMP(ip[3]); wp[3] = (a1-a2) & mask; a2 = a1;
-	    }
-	} else {
-	    ip += n - 1;	/* point to last one */
-	    wp += n - 1;	/* point to last one */
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);
-				wp[stride] -= wp[0];
-				wp[stride] &= mask;
-				wp--; ip--)
-		n -= stride;
-	    }
-	    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)
-	}
-    }
-}
-
-static void
-horizontalDifference16(unsigned short *ip, int n, int stride, 
-	unsigned short *wp, uint16 *From14)
-{
-    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;
-
-/* assumption is unsigned pixel values */
-#undef   CLAMP
-#define  CLAMP(v) From14[(v) >> 2]
-
-    mask = CODE_MASK;
-    if (n >= stride) {
-	if (stride == 3) {
-	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
-	    b2 = wp[2] = CLAMP(ip[2]);
-	    n -= 3;
-	    while (n > 0) {
-		n -= 3;
-		wp += 3;
-		ip += 3;
-		r1 = CLAMP(ip[0]); wp[0] = (r1-r2) & mask; r2 = r1;
-		g1 = CLAMP(ip[1]); wp[1] = (g1-g2) & mask; g2 = g1;
-		b1 = CLAMP(ip[2]); wp[2] = (b1-b2) & mask; b2 = b1;
-	    }
-	} else if (stride == 4) {
-	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
-	    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);
-	    n -= 4;
-	    while (n > 0) {
-		n -= 4;
-		wp += 4;
-		ip += 4;
-		r1 = CLAMP(ip[0]); wp[0] = (r1-r2) & mask; r2 = r1;
-		g1 = CLAMP(ip[1]); wp[1] = (g1-g2) & mask; g2 = g1;
-		b1 = CLAMP(ip[2]); wp[2] = (b1-b2) & mask; b2 = b1;
-		a1 = CLAMP(ip[3]); wp[3] = (a1-a2) & mask; a2 = a1;
-	    }
-	} else {
-	    ip += n - 1;	/* point to last one */
-	    wp += n - 1;	/* point to last one */
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride, wp[0] = CLAMP(ip[0]);
-				wp[stride] -= wp[0];
-				wp[stride] &= mask;
-				wp--; ip--)
-		n -= stride;
-	    }
-	    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)
-	}
-    }
-}
-
-
-static void
-horizontalDifference8(unsigned char *ip, int n, int stride, 
-	unsigned short *wp, uint16 *From8)
-{
-    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;
-
-#undef	 CLAMP
-#define  CLAMP(v) (From8[(v)])
-
-    mask = CODE_MASK;
-    if (n >= stride) {
-	if (stride == 3) {
-	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
-	    b2 = wp[2] = CLAMP(ip[2]);
-	    n -= 3;
-	    while (n > 0) {
-		n -= 3;
-		r1 = CLAMP(ip[3]); wp[3] = (r1-r2) & mask; r2 = r1;
-		g1 = CLAMP(ip[4]); wp[4] = (g1-g2) & mask; g2 = g1;
-		b1 = CLAMP(ip[5]); wp[5] = (b1-b2) & mask; b2 = b1;
-		wp += 3;
-		ip += 3;
-	    }
-	} else if (stride == 4) {
-	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
-	    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);
-	    n -= 4;
-	    while (n > 0) {
-		n -= 4;
-		r1 = CLAMP(ip[4]); wp[4] = (r1-r2) & mask; r2 = r1;
-		g1 = CLAMP(ip[5]); wp[5] = (g1-g2) & mask; g2 = g1;
-		b1 = CLAMP(ip[6]); wp[6] = (b1-b2) & mask; b2 = b1;
-		a1 = CLAMP(ip[7]); wp[7] = (a1-a2) & mask; a2 = a1;
-		wp += 4;
-		ip += 4;
-	    }
-	} else {
-	    wp += n + stride - 1;	/* point to last one */
-	    ip += n + stride - 1;	/* point to last one */
-	    n -= stride;
-	    while (n > 0) {
-		REPEAT(stride, wp[0] = CLAMP(ip[0]);
-				wp[stride] -= wp[0];
-				wp[stride] &= mask;
-				wp--; ip--)
-		n -= stride;
-	    }
-	    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)
-	}
-    }
-}
-
-/*
- * Encode a chunk of pixels.
- */
-static int
-PixarLogEncode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	PixarLogState *sp = EncoderState(tif);
-	static const char module[] = "PixarLogEncode";
-	int	i, n, llen;
-	unsigned short * up;
-
-	(void) s;
-
-	switch (sp->user_datafmt) {
-	case PIXARLOGDATAFMT_FLOAT:
-		n = cc / sizeof(float);		/* XXX float == 32 bits */
-		break;
-	case PIXARLOGDATAFMT_16BIT:
-	case PIXARLOGDATAFMT_12BITPICIO:
-	case PIXARLOGDATAFMT_11BITLOG:
-		n = cc / sizeof(uint16);	/* XXX uint16 == 16 bits */
-		break;
-	case PIXARLOGDATAFMT_8BIT:
-	case PIXARLOGDATAFMT_8BITABGR:
-		n = cc;
-		break;
-	default:
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			"%d bit input not supported in PixarLog",
-			td->td_bitspersample);
-		return 0;
-	}
-
-	llen = sp->stride * td->td_imagewidth;
-
-	for (i = 0, up = sp->tbuf; i < n; i += llen, up += llen) {
-		switch (sp->user_datafmt)  {
-		case PIXARLOGDATAFMT_FLOAT:
-			horizontalDifferenceF((float *)bp, llen, 
-				sp->stride, up, sp->FromLT2);
-			bp += llen * sizeof(float);
-			break;
-		case PIXARLOGDATAFMT_16BIT:
-			horizontalDifference16((uint16 *)bp, llen, 
-				sp->stride, up, sp->From14);
-			bp += llen * sizeof(uint16);
-			break;
-		case PIXARLOGDATAFMT_8BIT:
-			horizontalDifference8((unsigned char *)bp, llen, 
-				sp->stride, up, sp->From8);
-			bp += llen * sizeof(unsigned char);
-			break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				"%d bit input not supported in PixarLog",
-				td->td_bitspersample);
-			return 0;
-		}
-	}
- 
-	sp->stream.next_in = (unsigned char *) sp->tbuf;
-	sp->stream.avail_in = n * sizeof(uint16);
-
-	do {
-		if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Encoder error: %s",
-			    tif->tif_name, sp->stream.msg);
-			return (0);
-		}
-		if (sp->stream.avail_out == 0) {
-			tif->tif_rawcc = tif->tif_rawdatasize;
-			TIFFFlushData1(tif);
-			sp->stream.next_out = tif->tif_rawdata;
-			sp->stream.avail_out = tif->tif_rawdatasize;
-		}
-	} while (sp->stream.avail_in > 0);
-	return (1);
-}
-
-/*
- * Finish off an encoded strip by flushing the last
- * string and tacking on an End Of Information code.
- */
-
-static int
-PixarLogPostEncode(TIFF* tif)
-{
-	PixarLogState *sp = EncoderState(tif);
-	static const char module[] = "PixarLogPostEncode";
-	int state;
-
-	sp->stream.avail_in = 0;
-
-	do {
-		state = deflate(&sp->stream, Z_FINISH);
-		switch (state) {
-		case Z_STREAM_END:
-		case Z_OK:
-		    if (sp->stream.avail_out != (uint32)tif->tif_rawdatasize) {
-			    tif->tif_rawcc =
-				tif->tif_rawdatasize - sp->stream.avail_out;
-			    TIFFFlushData1(tif);
-			    sp->stream.next_out = tif->tif_rawdata;
-			    sp->stream.avail_out = tif->tif_rawdatasize;
-		    }
-		    break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-			tif->tif_name, sp->stream.msg);
-		    return (0);
-		}
-	} while (state != Z_STREAM_END);
-	return (1);
-}
-
-static void
-PixarLogClose(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	/* In a really sneaky maneuver, on close, we covertly modify both
-	 * bitspersample and sampleformat in the directory to indicate
-	 * 8-bit linear.  This way, the decode "just works" even for
-	 * readers that don't know about PixarLog, or how to set
-	 * the PIXARLOGDATFMT pseudo-tag.
-	 */
-	td->td_bitspersample = 8;
-	td->td_sampleformat = SAMPLEFORMAT_UINT;
-}
-
-static void
-PixarLogCleanup(TIFF* tif)
-{
-	PixarLogState* sp = (PixarLogState*) tif->tif_data;
-
-	assert(sp != 0);
-
-	(void)TIFFPredictorCleanup(tif);
-
-	tif->tif_tagmethods.vgetfield = sp->vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->vsetparent;
-
-	if (sp->FromLT2) _TIFFfree(sp->FromLT2);
-	if (sp->From14) _TIFFfree(sp->From14);
-	if (sp->From8) _TIFFfree(sp->From8);
-	if (sp->ToLinearF) _TIFFfree(sp->ToLinearF);
-	if (sp->ToLinear16) _TIFFfree(sp->ToLinear16);
-	if (sp->ToLinear8) _TIFFfree(sp->ToLinear8);
-	if (sp->state&PLSTATE_INIT) {
-		if (tif->tif_mode == O_RDONLY)
-			inflateEnd(&sp->stream);
-		else
-			deflateEnd(&sp->stream);
-	}
-	if (sp->tbuf)
-		_TIFFfree(sp->tbuf);
-	_TIFFfree(sp);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-static int
-PixarLogVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-    PixarLogState *sp = (PixarLogState *)tif->tif_data;
-    int result;
-    static const char module[] = "PixarLogVSetField";
-
-    switch (tag) {
-     case TIFFTAG_PIXARLOGQUALITY:
-		sp->quality = va_arg(ap, int);
-		if (tif->tif_mode != O_RDONLY && (sp->state&PLSTATE_INIT)) {
-			if (deflateParams(&sp->stream,
-			    sp->quality, Z_DEFAULT_STRATEGY) != Z_OK) {
-				TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-					tif->tif_name, sp->stream.msg);
-				return (0);
-			}
-		}
-		return (1);
-     case TIFFTAG_PIXARLOGDATAFMT:
-	sp->user_datafmt = va_arg(ap, int);
-	/* Tweak the TIFF header so that the rest of libtiff knows what
-	 * size of data will be passed between app and library, and
-	 * assume that the app knows what it is doing and is not
-	 * confused by these header manipulations...
-	 */
-	switch (sp->user_datafmt) {
-	 case PIXARLOGDATAFMT_8BIT:
-	 case PIXARLOGDATAFMT_8BITABGR:
-	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
-	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
-	    break;
-	 case PIXARLOGDATAFMT_11BITLOG:
-	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
-	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
-	    break;
-	 case PIXARLOGDATAFMT_12BITPICIO:
-	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
-	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);
-	    break;
-	 case PIXARLOGDATAFMT_16BIT:
-	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
-	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
-	    break;
-	 case PIXARLOGDATAFMT_FLOAT:
-	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);
-	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);
-	    break;
-	}
-	/*
-	 * Must recalculate sizes should bits/sample change.
-	 */
-	tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
-	tif->tif_scanlinesize = TIFFScanlineSize(tif);
-	result = 1;		/* NB: pseudo tag */
-	break;
-     default:
-	result = (*sp->vsetparent)(tif, tag, ap);
-    }
-    return (result);
-}
-
-static int
-PixarLogVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-    PixarLogState *sp = (PixarLogState *)tif->tif_data;
-
-    switch (tag) {
-     case TIFFTAG_PIXARLOGQUALITY:
-	*va_arg(ap, int*) = sp->quality;
-	break;
-     case TIFFTAG_PIXARLOGDATAFMT:
-	*va_arg(ap, int*) = sp->user_datafmt;
-	break;
-     default:
-	return (*sp->vgetparent)(tif, tag, ap);
-    }
-    return (1);
-}
-
-static const TIFFFieldInfo pixarlogFieldInfo[] = {
-    {TIFFTAG_PIXARLOGDATAFMT,0,0,TIFF_ANY,  FIELD_PSEUDO,FALSE,FALSE,""},
-    {TIFFTAG_PIXARLOGQUALITY,0,0,TIFF_ANY,  FIELD_PSEUDO,FALSE,FALSE,""}
-};
-
-int
-TIFFInitPixarLog(TIFF* tif, int scheme)
-{
-	static const char module[] = "TIFFInitPixarLog";
-
-	PixarLogState* sp;
-
-	assert(scheme == COMPRESSION_PIXARLOG);
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, pixarlogFieldInfo,
-				 TIFFArrayCount(pixarlogFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Merging PixarLog codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (PixarLogState));
-	if (tif->tif_data == NULL)
-		goto bad;
-	sp = (PixarLogState*) tif->tif_data;
-	_TIFFmemset(sp, 0, sizeof (*sp));
-	sp->stream.data_type = Z_BINARY;
-	sp->user_datafmt = PIXARLOGDATAFMT_UNKNOWN;
-
-	/*
-	 * Install codec methods.
-	 */
-	tif->tif_setupdecode = PixarLogSetupDecode;
-	tif->tif_predecode = PixarLogPreDecode;
-	tif->tif_decoderow = PixarLogDecode;
-	tif->tif_decodestrip = PixarLogDecode;
-	tif->tif_decodetile = PixarLogDecode;
-	tif->tif_setupencode = PixarLogSetupEncode;
-	tif->tif_preencode = PixarLogPreEncode;
-	tif->tif_postencode = PixarLogPostEncode;
-	tif->tif_encoderow = PixarLogEncode;
-	tif->tif_encodestrip = PixarLogEncode;
-	tif->tif_encodetile = PixarLogEncode;
-	tif->tif_close = PixarLogClose;
-	tif->tif_cleanup = PixarLogCleanup;
-
-	/* Override SetField so we can handle our private pseudo-tag */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield = PixarLogVGetField;   /* hook for codec tags */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield = PixarLogVSetField;   /* hook for codec tags */
-
-	/* Default values for codec-specific fields */
-	sp->quality = Z_DEFAULT_COMPRESSION; /* default comp. level */
-	sp->state = 0;
-
-	/* we don't wish to use the predictor, 
-	 * the default is none, which predictor value 1
-	 */
-	(void) TIFFPredictorInit(tif);
-
-	/*
-	 * build the companding tables 
-	 */
-	PixarLogMakeTables(sp);
-
-	return (1);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "No space for PixarLog state block");
-	return (0);
-}
-#endif /* PIXARLOG_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_predict.c b/thirdparty/libtiff/tif_predict.c
deleted file mode 100644
index bbc221f..0000000
--- a/thirdparty/libtiff/tif_predict.c
+++ /dev/null
@@ -1,736 +0,0 @@
-/* $Id: tif_predict.c,v 1.11.2.4 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Predictor Tag Support (used by multiple codecs).
- */
-#include "tiffiop.h"
-#include "tif_predict.h"
-
-#define	PredictorState(tif)	((TIFFPredictorState*) (tif)->tif_data)
-
-static	void horAcc8(TIFF*, tidata_t, tsize_t);
-static	void horAcc16(TIFF*, tidata_t, tsize_t);
-static	void horAcc32(TIFF*, tidata_t, tsize_t);
-static	void swabHorAcc16(TIFF*, tidata_t, tsize_t);
-static	void swabHorAcc32(TIFF*, tidata_t, tsize_t);
-static	void horDiff8(TIFF*, tidata_t, tsize_t);
-static	void horDiff16(TIFF*, tidata_t, tsize_t);
-static	void horDiff32(TIFF*, tidata_t, tsize_t);
-static	void fpAcc(TIFF*, tidata_t, tsize_t);
-static	void fpDiff(TIFF*, tidata_t, tsize_t);
-static	int PredictorDecodeRow(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int PredictorDecodeTile(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int PredictorEncodeRow(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int PredictorEncodeTile(TIFF*, tidata_t, tsize_t, tsample_t);
-
-static int
-PredictorSetup(TIFF* tif)
-{
-	static const char module[] = "PredictorSetup";
-
-	TIFFPredictorState* sp = PredictorState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	switch (sp->predictor)		/* no differencing */
-	{
-		case PREDICTOR_NONE:
-			return 1;
-		case PREDICTOR_HORIZONTAL:
-			if (td->td_bitspersample != 8
-			    && td->td_bitspersample != 16
-			    && td->td_bitspersample != 32) {
-				TIFFErrorExt(tif->tif_clientdata, module,
-    "Horizontal differencing \"Predictor\" not supported with %d-bit samples",
-					  td->td_bitspersample);
-				return 0;
-			}
-			break;
-		case PREDICTOR_FLOATINGPOINT:
-			if (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) {
-				TIFFErrorExt(tif->tif_clientdata, module,
-	"Floating point \"Predictor\" not supported with %d data format",
-					  td->td_sampleformat);
-				return 0;
-			}
-			break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, module,
-				  "\"Predictor\" value %d not supported",
-				  sp->predictor);
-			return 0;
-	}
-	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
-	    td->td_samplesperpixel : 1);
-	/*
-	 * Calculate the scanline/tile-width size in bytes.
-	 */
-	if (isTiled(tif))
-		sp->rowsize = TIFFTileRowSize(tif);
-	else
-		sp->rowsize = TIFFScanlineSize(tif);
-
-	return 1;
-}
-
-static int
-PredictorSetupDecode(TIFF* tif)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	if (!(*sp->setupdecode)(tif) || !PredictorSetup(tif))
-		return 0;
-
-	if (sp->predictor == 2) {
-		switch (td->td_bitspersample) {
-			case 8:  sp->decodepfunc = horAcc8; break;
-			case 16: sp->decodepfunc = horAcc16; break;
-			case 32: sp->decodepfunc = horAcc32; break;
-		}
-		/*
-		 * Override default decoding method with one that does the
-		 * predictor stuff.
-		 */
-                if( tif->tif_decoderow != PredictorDecodeRow )
-                {
-                    sp->decoderow = tif->tif_decoderow;
-                    tif->tif_decoderow = PredictorDecodeRow;
-                    sp->decodestrip = tif->tif_decodestrip;
-                    tif->tif_decodestrip = PredictorDecodeTile;
-                    sp->decodetile = tif->tif_decodetile;
-                    tif->tif_decodetile = PredictorDecodeTile;
-                }
-		/*
-		 * If the data is horizontally differenced 16-bit data that
-		 * requires byte-swapping, then it must be byte swapped before
-		 * the accumulation step.  We do this with a special-purpose
-		 * routine and override the normal post decoding logic that
-		 * the library setup when the directory was read.
-		 */
-		if (tif->tif_flags & TIFF_SWAB) {
-			if (sp->decodepfunc == horAcc16) {
-				sp->decodepfunc = swabHorAcc16;
-				tif->tif_postdecode = _TIFFNoPostDecode;
-			} else if (sp->decodepfunc == horAcc32) {
-				sp->decodepfunc = swabHorAcc32;
-				tif->tif_postdecode = _TIFFNoPostDecode;
-			}
-		}
-	}
-
-	else if (sp->predictor == 3) {
-		sp->decodepfunc = fpAcc;
-		/*
-		 * Override default decoding method with one that does the
-		 * predictor stuff.
-		 */
-                if( tif->tif_decoderow != PredictorDecodeRow )
-                {
-                    sp->decoderow = tif->tif_decoderow;
-                    tif->tif_decoderow = PredictorDecodeRow;
-                    sp->decodestrip = tif->tif_decodestrip;
-                    tif->tif_decodestrip = PredictorDecodeTile;
-                    sp->decodetile = tif->tif_decodetile;
-                    tif->tif_decodetile = PredictorDecodeTile;
-                }
-		/*
-		 * The data should not be swapped outside of the floating
-		 * point predictor, the accumulation routine should return
-		 * byres in the native order.
-		 */
-		if (tif->tif_flags & TIFF_SWAB) {
-			tif->tif_postdecode = _TIFFNoPostDecode;
-		}
-		/*
-		 * Allocate buffer to keep the decoded bytes before
-		 * rearranging in the ight order
-		 */
-	}
-
-	return 1;
-}
-
-static int
-PredictorSetupEncode(TIFF* tif)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-	TIFFDirectory* td = &tif->tif_dir;
-
-	if (!(*sp->setupencode)(tif) || !PredictorSetup(tif))
-		return 0;
-
-	if (sp->predictor == 2) {
-		switch (td->td_bitspersample) {
-			case 8:  sp->encodepfunc = horDiff8; break;
-			case 16: sp->encodepfunc = horDiff16; break;
-			case 32: sp->encodepfunc = horDiff32; break;
-		}
-		/*
-		 * Override default encoding method with one that does the
-		 * predictor stuff.
-		 */
-                if( tif->tif_encoderow != PredictorEncodeRow )
-                {
-                    sp->encoderow = tif->tif_encoderow;
-                    tif->tif_encoderow = PredictorEncodeRow;
-                    sp->encodestrip = tif->tif_encodestrip;
-                    tif->tif_encodestrip = PredictorEncodeTile;
-                    sp->encodetile = tif->tif_encodetile;
-                    tif->tif_encodetile = PredictorEncodeTile;
-                }
-	}
-	
-	else if (sp->predictor == 3) {
-		sp->encodepfunc = fpDiff;
-		/*
-		 * Override default encoding method with one that does the
-		 * predictor stuff.
-		 */
-                if( tif->tif_encoderow != PredictorEncodeRow )
-                {
-                    sp->encoderow = tif->tif_encoderow;
-                    tif->tif_encoderow = PredictorEncodeRow;
-                    sp->encodestrip = tif->tif_encodestrip;
-                    tif->tif_encodestrip = PredictorEncodeTile;
-                    sp->encodetile = tif->tif_encodetile;
-                    tif->tif_encodetile = PredictorEncodeTile;
-                }
-	}
-
-	return 1;
-}
-
-#define REPEAT4(n, op)		\
-    switch (n) {		\
-    default: { int i; for (i = n-4; i > 0; i--) { op; } } \
-    case 4:  op;		\
-    case 3:  op;		\
-    case 2:  op;		\
-    case 1:  op;		\
-    case 0:  ;			\
-    }
-
-static void
-horAcc8(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-
-	char* cp = (char*) cp0;
-	if (cc > stride) {
-		cc -= stride;
-		/*
-		 * Pipeline the most common cases.
-		 */
-		if (stride == 3)  {
-			unsigned int cr = cp[0];
-			unsigned int cg = cp[1];
-			unsigned int cb = cp[2];
-			do {
-				cc -= 3, cp += 3;
-				cp[0] = (char) (cr += cp[0]);
-				cp[1] = (char) (cg += cp[1]);
-				cp[2] = (char) (cb += cp[2]);
-			} while ((int32) cc > 0);
-		} else if (stride == 4)  {
-			unsigned int cr = cp[0];
-			unsigned int cg = cp[1];
-			unsigned int cb = cp[2];
-			unsigned int ca = cp[3];
-			do {
-				cc -= 4, cp += 4;
-				cp[0] = (char) (cr += cp[0]);
-				cp[1] = (char) (cg += cp[1]);
-				cp[2] = (char) (cb += cp[2]);
-				cp[3] = (char) (ca += cp[3]);
-			} while ((int32) cc > 0);
-		} else  {
-			do {
-				REPEAT4(stride, cp[stride] =
-					(char) (cp[stride] + *cp); cp++)
-				cc -= stride;
-			} while ((int32) cc > 0);
-		}
-	}
-}
-
-static void
-swabHorAcc16(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint16* wp = (uint16*) cp0;
-	tsize_t wc = cc / 2;
-
-	if (wc > stride) {
-		TIFFSwabArrayOfShort(wp, wc);
-		wc -= stride;
-		do {
-			REPEAT4(stride, wp[stride] += wp[0]; wp++)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-static void
-horAcc16(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint16* wp = (uint16*) cp0;
-	tsize_t wc = cc / 2;
-
-	if (wc > stride) {
-		wc -= stride;
-		do {
-			REPEAT4(stride, wp[stride] += wp[0]; wp++)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-static void
-swabHorAcc32(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint32* wp = (uint32*) cp0;
-	tsize_t wc = cc / 4;
-
-	if (wc > stride) {
-		TIFFSwabArrayOfLong(wp, wc);
-		wc -= stride;
-		do {
-			REPEAT4(stride, wp[stride] += wp[0]; wp++)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-static void
-horAcc32(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint32* wp = (uint32*) cp0;
-	tsize_t wc = cc / 4;
-
-	if (wc > stride) {
-		wc -= stride;
-		do {
-			REPEAT4(stride, wp[stride] += wp[0]; wp++)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-/*
- * Floating point predictor accumulation routine.
- */
-static void
-fpAcc(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint32 bps = tif->tif_dir.td_bitspersample / 8;
-	tsize_t wc = cc / bps;
-	tsize_t count = cc;
-	uint8 *cp = (uint8 *) cp0;
-	uint8 *tmp = (uint8 *)_TIFFmalloc(cc);
-
-	if (!tmp)
-		return;
-
-	while (count > stride) {
-		REPEAT4(stride, cp[stride] += cp[0]; cp++)
-		count -= stride;
-	}
-
-	_TIFFmemcpy(tmp, cp0, cc);
-	cp = (uint8 *) cp0;
-	for (count = 0; count < wc; count++) {
-		uint32 byte;
-		for (byte = 0; byte < bps; byte++) {
-#if WORDS_BIGENDIAN
-			cp[bps * count + byte] = tmp[byte * wc + count];
-#else
-			cp[bps * count + byte] =
-				tmp[(bps - byte - 1) * wc + count];
-#endif
-		}
-	}
-	_TIFFfree(tmp);
-}
-
-/*
- * Decode a scanline and apply the predictor routine.
- */
-static int
-PredictorDecodeRow(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s)
-{
-	TIFFPredictorState *sp = PredictorState(tif);
-
-	assert(sp != NULL);
-	assert(sp->decoderow != NULL);
-	assert(sp->decodepfunc != NULL);
-
-	if ((*sp->decoderow)(tif, op0, occ0, s)) {
-		(*sp->decodepfunc)(tif, op0, occ0);
-		return 1;
-	} else
-		return 0;
-}
-
-/*
- * Decode a tile/strip and apply the predictor routine.
- * Note that horizontal differencing must be done on a
- * row-by-row basis.  The width of a "row" has already
- * been calculated at pre-decode time according to the
- * strip/tile dimensions.
- */
-static int
-PredictorDecodeTile(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s)
-{
-	TIFFPredictorState *sp = PredictorState(tif);
-
-	assert(sp != NULL);
-	assert(sp->decodetile != NULL);
-
-	if ((*sp->decodetile)(tif, op0, occ0, s)) {
-		tsize_t rowsize = sp->rowsize;
-		assert(rowsize > 0);
-		assert(sp->decodepfunc != NULL);
-		while ((long)occ0 > 0) {
-			(*sp->decodepfunc)(tif, op0, (tsize_t) rowsize);
-			occ0 -= rowsize;
-			op0 += rowsize;
-		}
-		return 1;
-	} else
-		return 0;
-}
-
-static void
-horDiff8(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-	tsize_t stride = sp->stride;
-	char* cp = (char*) cp0;
-
-	if (cc > stride) {
-		cc -= stride;
-		/*
-		 * Pipeline the most common cases.
-		 */
-		if (stride == 3) {
-			int r1, g1, b1;
-			int r2 = cp[0];
-			int g2 = cp[1];
-			int b2 = cp[2];
-			do {
-				r1 = cp[3]; cp[3] = r1-r2; r2 = r1;
-				g1 = cp[4]; cp[4] = g1-g2; g2 = g1;
-				b1 = cp[5]; cp[5] = b1-b2; b2 = b1;
-				cp += 3;
-			} while ((int32)(cc -= 3) > 0);
-		} else if (stride == 4) {
-			int r1, g1, b1, a1;
-			int r2 = cp[0];
-			int g2 = cp[1];
-			int b2 = cp[2];
-			int a2 = cp[3];
-			do {
-				r1 = cp[4]; cp[4] = r1-r2; r2 = r1;
-				g1 = cp[5]; cp[5] = g1-g2; g2 = g1;
-				b1 = cp[6]; cp[6] = b1-b2; b2 = b1;
-				a1 = cp[7]; cp[7] = a1-a2; a2 = a1;
-				cp += 4;
-			} while ((int32)(cc -= 4) > 0);
-		} else {
-			cp += cc - 1;
-			do {
-				REPEAT4(stride, cp[stride] -= cp[0]; cp--)
-			} while ((int32)(cc -= stride) > 0);
-		}
-	}
-}
-
-static void
-horDiff16(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-	tsize_t stride = sp->stride;
-	int16 *wp = (int16*) cp0;
-	tsize_t wc = cc/2;
-
-	if (wc > stride) {
-		wc -= stride;
-		wp += wc - 1;
-		do {
-			REPEAT4(stride, wp[stride] -= wp[0]; wp--)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-static void
-horDiff32(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-	tsize_t stride = sp->stride;
-	int32 *wp = (int32*) cp0;
-	tsize_t wc = cc/4;
-
-	if (wc > stride) {
-		wc -= stride;
-		wp += wc - 1;
-		do {
-			REPEAT4(stride, wp[stride] -= wp[0]; wp--)
-			wc -= stride;
-		} while ((int32) wc > 0);
-	}
-}
-
-/*
- * Floating point predictor differencing routine.
- */
-static void
-fpDiff(TIFF* tif, tidata_t cp0, tsize_t cc)
-{
-	tsize_t stride = PredictorState(tif)->stride;
-	uint32 bps = tif->tif_dir.td_bitspersample / 8;
-	tsize_t wc = cc / bps;
-	tsize_t count;
-	uint8 *cp = (uint8 *) cp0;
-	uint8 *tmp = (uint8 *)_TIFFmalloc(cc);
-
-	if (!tmp)
-		return;
-
-	_TIFFmemcpy(tmp, cp0, cc);
-	for (count = 0; count < wc; count++) {
-		uint32 byte;
-		for (byte = 0; byte < bps; byte++) {
-#if WORDS_BIGENDIAN
-			cp[byte * wc + count] =	tmp[bps * count + byte];
-#else
-			cp[(bps - byte - 1) * wc + count] =
-				tmp[bps * count + byte];
-#endif
-		}
-	}
-	_TIFFfree(tmp);
-
-	cp = (uint8 *) cp0;
-	cp += cc - stride - 1;
-	for (count = cc; count > stride; count -= stride)
-		REPEAT4(stride, cp[stride] -= cp[0]; cp--)
-}
-
-static int
-PredictorEncodeRow(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	TIFFPredictorState *sp = PredictorState(tif);
-
-	assert(sp != NULL);
-	assert(sp->encodepfunc != NULL);
-	assert(sp->encoderow != NULL);
-
-	/* XXX horizontal differencing alters user's data XXX */
-	(*sp->encodepfunc)(tif, bp, cc);
-	return (*sp->encoderow)(tif, bp, cc, s);
-}
-
-static int
-PredictorEncodeTile(TIFF* tif, tidata_t bp0, tsize_t cc0, tsample_t s)
-{
-	static const char module[] = "PredictorEncodeTile";
-	TIFFPredictorState *sp = PredictorState(tif);
-        uint8 *working_copy;
-	tsize_t cc = cc0, rowsize;
-	unsigned char* bp;
-        int result_code;
-
-	assert(sp != NULL);
-	assert(sp->encodepfunc != NULL);
-	assert(sp->encodetile != NULL);
-
-        /* 
-         * Do predictor manipulation in a working buffer to avoid altering
-         * the callers buffer. http://trac.osgeo.org/gdal/ticket/1965
-         */
-        working_copy = (uint8*) _TIFFmalloc(cc0);
-        if( working_copy == NULL )
-        {
-            TIFFErrorExt(tif->tif_clientdata, module, 
-                         "Out of memory allocating %d byte temp buffer.",
-                         cc0 );
-            return 0;
-        }
-        memcpy( working_copy, bp0, cc0 );
-        bp = working_copy;
-
-	rowsize = sp->rowsize;
-	assert(rowsize > 0);
-	assert((cc0%rowsize)==0);
-	while (cc > 0) {
-		(*sp->encodepfunc)(tif, bp, rowsize);
-		cc -= rowsize;
-		bp += rowsize;
-	}
-	result_code = (*sp->encodetile)(tif, working_copy, cc0, s);
-
-        _TIFFfree( working_copy );
-
-        return result_code;
-}
-
-#define	FIELD_PREDICTOR	(FIELD_CODEC+0)		/* XXX */
-
-static const TIFFFieldInfo predictFieldInfo[] = {
-    { TIFFTAG_PREDICTOR,	 1, 1, TIFF_SHORT,	FIELD_PREDICTOR,
-      FALSE,	FALSE,	"Predictor" },
-};
-
-static int
-PredictorVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	TIFFPredictorState *sp = PredictorState(tif);
-
-	assert(sp != NULL);
-	assert(sp->vsetparent != NULL);
-
-	switch (tag) {
-	case TIFFTAG_PREDICTOR:
-		sp->predictor = (uint16) va_arg(ap, int);
-		TIFFSetFieldBit(tif, FIELD_PREDICTOR);
-		break;
-	default:
-		return (*sp->vsetparent)(tif, tag, ap);
-	}
-	tif->tif_flags |= TIFF_DIRTYDIRECT;
-	return 1;
-}
-
-static int
-PredictorVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	TIFFPredictorState *sp = PredictorState(tif);
-
-	assert(sp != NULL);
-	assert(sp->vgetparent != NULL);
-
-	switch (tag) {
-	case TIFFTAG_PREDICTOR:
-		*va_arg(ap, uint16*) = sp->predictor;
-		break;
-	default:
-		return (*sp->vgetparent)(tif, tag, ap);
-	}
-	return 1;
-}
-
-static void
-PredictorPrintDir(TIFF* tif, FILE* fd, long flags)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-
-	(void) flags;
-	if (TIFFFieldSet(tif,FIELD_PREDICTOR)) {
-		fprintf(fd, "  Predictor: ");
-		switch (sp->predictor) {
-		case 1: fprintf(fd, "none "); break;
-		case 2: fprintf(fd, "horizontal differencing "); break;
-		case 3: fprintf(fd, "floating point predictor "); break;
-		}
-		fprintf(fd, "%u (0x%x)\n", sp->predictor, sp->predictor);
-	}
-	if (sp->printdir)
-		(*sp->printdir)(tif, fd, flags);
-}
-
-int
-TIFFPredictorInit(TIFF* tif)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-
-	assert(sp != 0);
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, predictFieldInfo,
-				 TIFFArrayCount(predictFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, "TIFFPredictorInit",
-			     "Merging Predictor codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Override parent get/set field methods.
-	 */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield =
-            PredictorVGetField;/* hook for predictor tag */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield =
-            PredictorVSetField;/* hook for predictor tag */
-	sp->printdir = tif->tif_tagmethods.printdir;
-	tif->tif_tagmethods.printdir =
-            PredictorPrintDir;	/* hook for predictor tag */
-
-	sp->setupdecode = tif->tif_setupdecode;
-	tif->tif_setupdecode = PredictorSetupDecode;
-	sp->setupencode = tif->tif_setupencode;
-	tif->tif_setupencode = PredictorSetupEncode;
-
-	sp->predictor = 1;			/* default value */
-	sp->encodepfunc = NULL;			/* no predictor routine */
-	sp->decodepfunc = NULL;			/* no predictor routine */
-	return 1;
-}
-
-int
-TIFFPredictorCleanup(TIFF* tif)
-{
-	TIFFPredictorState* sp = PredictorState(tif);
-
-	assert(sp != 0);
-
-	tif->tif_tagmethods.vgetfield = sp->vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->vsetparent;
-	tif->tif_tagmethods.printdir = sp->printdir;
-	tif->tif_setupdecode = sp->setupdecode;
-	tif->tif_setupencode = sp->setupencode;
-
-	return 1;
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_predict.h b/thirdparty/libtiff/tif_predict.h
deleted file mode 100644
index da0ad98..0000000
--- a/thirdparty/libtiff/tif_predict.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/* $Id: tif_predict.h,v 1.3.2.2 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1995-1997 Sam Leffler
- * Copyright (c) 1995-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFPREDICT_
-#define	_TIFFPREDICT_
-/*
- * ``Library-private'' Support for the Predictor Tag
- */
-
-/*
- * Codecs that want to support the Predictor tag must place
- * this structure first in their private state block so that
- * the predictor code can cast tif_data to find its state.
- */
-typedef struct {
-	int		predictor;	/* predictor tag value */
-	int		stride;		/* sample stride over data */
-	tsize_t		rowsize;	/* tile/strip row size */
-
- 	TIFFCodeMethod  encoderow;	/* parent codec encode/decode row */
- 	TIFFCodeMethod  encodestrip;	/* parent codec encode/decode strip */
- 	TIFFCodeMethod  encodetile;	/* parent codec encode/decode tile */ 
- 	TIFFPostMethod  encodepfunc;	/* horizontal differencer */
- 
- 	TIFFCodeMethod  decoderow;	/* parent codec encode/decode row */
- 	TIFFCodeMethod  decodestrip;	/* parent codec encode/decode strip */
- 	TIFFCodeMethod  decodetile;	/* parent codec encode/decode tile */ 
- 	TIFFPostMethod  decodepfunc;	/* horizontal accumulator */
-
-	TIFFVGetMethod	vgetparent;	/* super-class method */
-	TIFFVSetMethod	vsetparent;	/* super-class method */
-	TIFFPrintMethod	printdir;	/* super-class method */
-	TIFFBoolMethod	setupdecode;	/* super-class method */
-	TIFFBoolMethod	setupencode;	/* super-class method */
-} TIFFPredictorState;
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	int TIFFPredictorInit(TIFF*);
-extern	int TIFFPredictorCleanup(TIFF*);
-#if defined(__cplusplus)
-}
-#endif
-#endif /* _TIFFPREDICT_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_print.c b/thirdparty/libtiff/tif_print.c
deleted file mode 100644
index d9e4435..0000000
--- a/thirdparty/libtiff/tif_print.c
+++ /dev/null
@@ -1,646 +0,0 @@
-/* $Id: tif_print.c,v 1.36.2.4 2010-06-08 18:50:42 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Directory Printing Support
- */
-#include "tiffiop.h"
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-
-static const char *photoNames[] = {
-    "min-is-white",				/* PHOTOMETRIC_MINISWHITE */
-    "min-is-black",				/* PHOTOMETRIC_MINISBLACK */
-    "RGB color",				/* PHOTOMETRIC_RGB */
-    "palette color (RGB from colormap)",	/* PHOTOMETRIC_PALETTE */
-    "transparency mask",			/* PHOTOMETRIC_MASK */
-    "separated",				/* PHOTOMETRIC_SEPARATED */
-    "YCbCr",					/* PHOTOMETRIC_YCBCR */
-    "7 (0x7)",
-    "CIE L*a*b*",				/* PHOTOMETRIC_CIELAB */
-};
-#define	NPHOTONAMES	(sizeof (photoNames) / sizeof (photoNames[0]))
-
-static const char *orientNames[] = {
-    "0 (0x0)",
-    "row 0 top, col 0 lhs",			/* ORIENTATION_TOPLEFT */
-    "row 0 top, col 0 rhs",			/* ORIENTATION_TOPRIGHT */
-    "row 0 bottom, col 0 rhs",			/* ORIENTATION_BOTRIGHT */
-    "row 0 bottom, col 0 lhs",			/* ORIENTATION_BOTLEFT */
-    "row 0 lhs, col 0 top",			/* ORIENTATION_LEFTTOP */
-    "row 0 rhs, col 0 top",			/* ORIENTATION_RIGHTTOP */
-    "row 0 rhs, col 0 bottom",			/* ORIENTATION_RIGHTBOT */
-    "row 0 lhs, col 0 bottom",			/* ORIENTATION_LEFTBOT */
-};
-#define	NORIENTNAMES	(sizeof (orientNames) / sizeof (orientNames[0]))
-
-static void
-_TIFFPrintField(FILE* fd, const TIFFFieldInfo *fip,
-		uint32 value_count, void *raw_data)
-{
-	uint32 j;
-		
-	fprintf(fd, "  %s: ", fip->field_name);
-
-	for(j = 0; j < value_count; j++) {
-		if(fip->field_type == TIFF_BYTE)
-			fprintf(fd, "%u", ((uint8 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_UNDEFINED)
-			fprintf(fd, "0x%x",
-				(unsigned int) ((unsigned char *) raw_data)[j]);
-		else if(fip->field_type == TIFF_SBYTE)
-			fprintf(fd, "%d", ((int8 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_SHORT)
-			fprintf(fd, "%u", ((uint16 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_SSHORT)
-			fprintf(fd, "%d", ((int16 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_LONG)
-			fprintf(fd, "%lu",
-				(unsigned long)((uint32 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_SLONG)
-			fprintf(fd, "%ld", (long)((int32 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_RATIONAL
-			|| fip->field_type == TIFF_SRATIONAL
-			|| fip->field_type == TIFF_FLOAT)
-			fprintf(fd, "%f", ((float *) raw_data)[j]);
-		else if(fip->field_type == TIFF_IFD)
-			fprintf(fd, "0x%ulx", ((uint32 *) raw_data)[j]);
-		else if(fip->field_type == TIFF_ASCII) {
-			fprintf(fd, "%s", (char *) raw_data);
-			break;
-		}
-		else if(fip->field_type == TIFF_DOUBLE)
-			fprintf(fd, "%f", ((double *) raw_data)[j]);
-		else if(fip->field_type == TIFF_FLOAT)
-			fprintf(fd, "%f", ((float *)raw_data)[j]);
-		else {
-			fprintf(fd, "<unsupported data type in TIFFPrint>");
-			break;
-		}
-
-		if(j < value_count - 1)
-			fprintf(fd, ",");
-	}
-
-	fprintf(fd, "\n");
-}
-
-static int
-_TIFFPrettyPrintField(TIFF* tif, FILE* fd, ttag_t tag,
-		      uint32 value_count, void *raw_data)
-{
-	//TIFFDirectory *td = &tif->tif_dir;
-
-	switch (tag)
-	{
-		case TIFFTAG_INKSET:
-			fprintf(fd, "  Ink Set: ");
-			switch (*((uint16*)raw_data)) {
-				case INKSET_CMYK:
-					fprintf(fd, "CMYK\n");
-					break;
-				default:
-					fprintf(fd, "%u (0x%x)\n",
-						*((uint16*)raw_data),
-						*((uint16*)raw_data));
-					break;
-			}
-			return 1;
-		case TIFFTAG_DOTRANGE:
-			fprintf(fd, "  Dot Range: %u-%u\n",
-				((uint16*)raw_data)[0], ((uint16*)raw_data)[1]);
-			return 1;
-		case TIFFTAG_WHITEPOINT:
-			fprintf(fd, "  White Point: %g-%g\n",
-				((float *)raw_data)[0], ((float *)raw_data)[1]);			return 1;
-		case TIFFTAG_REFERENCEBLACKWHITE:
-		{
-			uint16 i;
-
-			fprintf(fd, "  Reference Black/White:\n");
-			for (i = 0; i < 3; i++)
-			fprintf(fd, "    %2d: %5g %5g\n", i,
-				((float *)raw_data)[2*i+0],
-				((float *)raw_data)[2*i+1]);
-			return 1;
-		}
-		case TIFFTAG_XMLPACKET:
-		{
-			uint32 i;
-			
-			fprintf(fd, "  XMLPacket (XMP Metadata):\n" );
-			for(i = 0; i < value_count; i++)
-				fputc(((char *)raw_data)[i], fd);
-			fprintf( fd, "\n" );
-			return 1;
-		}
-		case TIFFTAG_RICHTIFFIPTC:
-			/*
-			 * XXX: for some weird reason RichTIFFIPTC tag
-			 * defined as array of LONG values.
-			 */
-			fprintf(fd,
-				"  RichTIFFIPTC Data: <present>, %lu bytes\n",
-				(unsigned long) value_count * 4);
-			return 1;
-		case TIFFTAG_PHOTOSHOP:
-			fprintf(fd, "  Photoshop Data: <present>, %lu bytes\n",
-				(unsigned long) value_count);
-			return 1;
-		case TIFFTAG_ICCPROFILE:
-			fprintf(fd, "  ICC Profile: <present>, %lu bytes\n",
-				(unsigned long) value_count);
-			return 1;
-		case TIFFTAG_STONITS:
-			fprintf(fd,
-				"  Sample to Nits conversion factor: %.4e\n",
-				*((double*)raw_data));
-			return 1;
-        }
-
-	return 0;
-}
-
-/*
- * Print the contents of the current directory
- * to the specified stdio file stream.
- */
-void
-TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	char *sep;
-	uint16 i;
-	long l, n;
-
-	fprintf(fd, "TIFF Directory at offset 0x%lx (%lu)\n",
-		(unsigned long)tif->tif_diroff, (unsigned long)tif->tif_diroff);
-	if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {
-		fprintf(fd, "  Subfile Type:");
-		sep = " ";
-		if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {
-			fprintf(fd, "%sreduced-resolution image", sep);
-			sep = "/";
-		}
-		if (td->td_subfiletype & FILETYPE_PAGE) {
-			fprintf(fd, "%smulti-page document", sep);
-			sep = "/";
-		}
-		if (td->td_subfiletype & FILETYPE_MASK)
-			fprintf(fd, "%stransparency mask", sep);
-		fprintf(fd, " (%lu = 0x%lx)\n",
-		    (long) td->td_subfiletype, (long) td->td_subfiletype);
-	}
-	if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {
-		fprintf(fd, "  Image Width: %lu Image Length: %lu",
-		    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);
-		if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
-			fprintf(fd, " Image Depth: %lu",
-			    (unsigned long) td->td_imagedepth);
-		fprintf(fd, "\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {
-		fprintf(fd, "  Tile Width: %lu Tile Length: %lu",
-		    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);
-		if (TIFFFieldSet(tif,FIELD_TILEDEPTH))
-			fprintf(fd, " Tile Depth: %lu",
-			    (unsigned long) td->td_tiledepth);
-		fprintf(fd, "\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_RESOLUTION)) {
-		fprintf(fd, "  Resolution: %g, %g",
-		    td->td_xresolution, td->td_yresolution);
-		if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {
-			switch (td->td_resolutionunit) {
-			case RESUNIT_NONE:
-				fprintf(fd, " (unitless)");
-				break;
-			case RESUNIT_INCH:
-				fprintf(fd, " pixels/inch");
-				break;
-			case RESUNIT_CENTIMETER:
-				fprintf(fd, " pixels/cm");
-				break;
-			default:
-				fprintf(fd, " (unit %u = 0x%x)",
-				    td->td_resolutionunit,
-				    td->td_resolutionunit);
-				break;
-			}
-		}
-		fprintf(fd, "\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_POSITION))
-		fprintf(fd, "  Position: %g, %g\n",
-		    td->td_xposition, td->td_yposition);
-	if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
-		fprintf(fd, "  Bits/Sample: %u\n", td->td_bitspersample);
-	if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {
-		fprintf(fd, "  Sample Format: ");
-		switch (td->td_sampleformat) {
-		case SAMPLEFORMAT_VOID:
-			fprintf(fd, "void\n");
-			break;
-		case SAMPLEFORMAT_INT:
-			fprintf(fd, "signed integer\n");
-			break;
-		case SAMPLEFORMAT_UINT:
-			fprintf(fd, "unsigned integer\n");
-			break;
-		case SAMPLEFORMAT_IEEEFP:
-			fprintf(fd, "IEEE floating point\n");
-			break;
-		case SAMPLEFORMAT_COMPLEXINT:
-			fprintf(fd, "complex signed integer\n");
-			break;
-		case SAMPLEFORMAT_COMPLEXIEEEFP:
-			fprintf(fd, "complex IEEE floating point\n");
-			break;
-		default:
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_sampleformat, td->td_sampleformat);
-			break;
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_COMPRESSION)) {
-		const TIFFCodec* c = TIFFFindCODEC(td->td_compression);
-		fprintf(fd, "  Compression Scheme: ");
-		if (c)
-			fprintf(fd, "%s\n", c->name);
-		else
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_compression, td->td_compression);
-	}
-	if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {
-		fprintf(fd, "  Photometric Interpretation: ");
-		if (td->td_photometric < NPHOTONAMES)
-			fprintf(fd, "%s\n", photoNames[td->td_photometric]);
-		else {
-			switch (td->td_photometric) {
-			case PHOTOMETRIC_LOGL:
-				fprintf(fd, "CIE Log2(L)\n");
-				break;
-			case PHOTOMETRIC_LOGLUV:
-				fprintf(fd, "CIE Log2(L) (u',v')\n");
-				break;
-			default:
-				fprintf(fd, "%u (0x%x)\n",
-				    td->td_photometric, td->td_photometric);
-				break;
-			}
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {
-		fprintf(fd, "  Extra Samples: %u<", td->td_extrasamples);
-		sep = "";
-		for (i = 0; i < td->td_extrasamples; i++) {
-			switch (td->td_sampleinfo[i]) {
-			case EXTRASAMPLE_UNSPECIFIED:
-				fprintf(fd, "%sunspecified", sep);
-				break;
-			case EXTRASAMPLE_ASSOCALPHA:
-				fprintf(fd, "%sassoc-alpha", sep);
-				break;
-			case EXTRASAMPLE_UNASSALPHA:
-				fprintf(fd, "%sunassoc-alpha", sep);
-				break;
-			default:
-				fprintf(fd, "%s%u (0x%x)", sep,
-				    td->td_sampleinfo[i], td->td_sampleinfo[i]);
-				break;
-			}
-			sep = ", ";
-		}
-		fprintf(fd, ">\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_INKNAMES)) {
-		char* cp;
-		fprintf(fd, "  Ink Names: ");
-		i = td->td_samplesperpixel;
-		sep = "";
-		for (cp = td->td_inknames; i > 0; cp = strchr(cp,'\0')+1, i--) {
-			fputs(sep, fd);
-			_TIFFprintAscii(fd, cp);
-			sep = ", ";
-		}
-                fputs("\n", fd);
-	}
-	if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {
-		fprintf(fd, "  Thresholding: ");
-		switch (td->td_threshholding) {
-		case THRESHHOLD_BILEVEL:
-			fprintf(fd, "bilevel art scan\n");
-			break;
-		case THRESHHOLD_HALFTONE:
-			fprintf(fd, "halftone or dithered scan\n");
-			break;
-		case THRESHHOLD_ERRORDIFFUSE:
-			fprintf(fd, "error diffused\n");
-			break;
-		default:
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_threshholding, td->td_threshholding);
-			break;
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_FILLORDER)) {
-		fprintf(fd, "  FillOrder: ");
-		switch (td->td_fillorder) {
-		case FILLORDER_MSB2LSB:
-			fprintf(fd, "msb-to-lsb\n");
-			break;
-		case FILLORDER_LSB2MSB:
-			fprintf(fd, "lsb-to-msb\n");
-			break;
-		default:
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_fillorder, td->td_fillorder);
-			break;
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))
-        {
-            /*
-             * For hacky reasons (see tif_jpeg.c - JPEGFixupTestSubsampling),
-             * we need to fetch this rather than trust what is in our
-             * structures.
-             */
-            uint16 subsampling[2];
-
-            TIFFGetField( tif, TIFFTAG_YCBCRSUBSAMPLING, 
-                          subsampling + 0, subsampling + 1 );
-		fprintf(fd, "  YCbCr Subsampling: %u, %u\n",
-                        subsampling[0], subsampling[1] );
-        }
-	if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {
-		fprintf(fd, "  YCbCr Positioning: ");
-		switch (td->td_ycbcrpositioning) {
-		case YCBCRPOSITION_CENTERED:
-			fprintf(fd, "centered\n");
-			break;
-		case YCBCRPOSITION_COSITED:
-			fprintf(fd, "cosited\n");
-			break;
-		default:
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_ycbcrpositioning, td->td_ycbcrpositioning);
-			break;
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))
-		fprintf(fd, "  Halftone Hints: light %u dark %u\n",
-		    td->td_halftonehints[0], td->td_halftonehints[1]);
-	if (TIFFFieldSet(tif,FIELD_ORIENTATION)) {
-		fprintf(fd, "  Orientation: ");
-		if (td->td_orientation < NORIENTNAMES)
-			fprintf(fd, "%s\n", orientNames[td->td_orientation]);
-		else
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_orientation, td->td_orientation);
-	}
-	if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
-		fprintf(fd, "  Samples/Pixel: %u\n", td->td_samplesperpixel);
-	if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {
-		fprintf(fd, "  Rows/Strip: ");
-		if (td->td_rowsperstrip == (uint32) -1)
-			fprintf(fd, "(infinite)\n");
-		else
-			fprintf(fd, "%lu\n", (unsigned long) td->td_rowsperstrip);
-	}
-	if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))
-		fprintf(fd, "  Min Sample Value: %u\n", td->td_minsamplevalue);
-	if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))
-		fprintf(fd, "  Max Sample Value: %u\n", td->td_maxsamplevalue);
-	if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))
-		fprintf(fd, "  SMin Sample Value: %g\n",
-		    td->td_sminsamplevalue);
-	if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))
-		fprintf(fd, "  SMax Sample Value: %g\n",
-		    td->td_smaxsamplevalue);
-	if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {
-		fprintf(fd, "  Planar Configuration: ");
-		switch (td->td_planarconfig) {
-		case PLANARCONFIG_CONTIG:
-			fprintf(fd, "single image plane\n");
-			break;
-		case PLANARCONFIG_SEPARATE:
-			fprintf(fd, "separate image planes\n");
-			break;
-		default:
-			fprintf(fd, "%u (0x%x)\n",
-			    td->td_planarconfig, td->td_planarconfig);
-			break;
-		}
-	}
-	if (TIFFFieldSet(tif,FIELD_PAGENUMBER))
-		fprintf(fd, "  Page Number: %u-%u\n",
-		    td->td_pagenumber[0], td->td_pagenumber[1]);
-	if (TIFFFieldSet(tif,FIELD_COLORMAP)) {
-		fprintf(fd, "  Color Map: ");
-		if (flags & TIFFPRINT_COLORMAP) {
-			fprintf(fd, "\n");
-			n = 1L<<td->td_bitspersample;
-			for (l = 0; l < n; l++)
-				fprintf(fd, "   %5lu: %5u %5u %5u\n",
-				    l,
-				    td->td_colormap[0][l],
-				    td->td_colormap[1][l],
-				    td->td_colormap[2][l]);
-		} else
-			fprintf(fd, "(present)\n");
-	}
-	if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {
-		fprintf(fd, "  Transfer Function: ");
-		if (flags & TIFFPRINT_CURVES) {
-			fprintf(fd, "\n");
-			n = 1L<<td->td_bitspersample;
-			for (l = 0; l < n; l++) {
-				fprintf(fd, "    %2lu: %5u",
-				    l, td->td_transferfunction[0][l]);
-				for (i = 1; i < td->td_samplesperpixel; i++)
-					fprintf(fd, " %5u",
-					    td->td_transferfunction[i][l]);
-				fputc('\n', fd);
-			}
-		} else
-			fprintf(fd, "(present)\n");
-	}
-	if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {
-		fprintf(fd, "  SubIFD Offsets:");
-		for (i = 0; i < td->td_nsubifd; i++)
-			fprintf(fd, " %5lu", (long) td->td_subifd[i]);
-		fputc('\n', fd);
-	}
-
-        /*
-        ** Custom tag support.
-        */
-        {
-            int  i;
-            short count;
-
-            count = (short) TIFFGetTagListCount(tif);
-            for(i = 0; i < count; i++) {
-                ttag_t  tag = TIFFGetTagListEntry(tif, i);
-                const TIFFFieldInfo *fip;
-                uint32 value_count;
-                int mem_alloc = 0;
-                void *raw_data;
-
-                fip = TIFFFieldWithTag(tif, tag);
-                if(fip == NULL)
-			continue;
-
-		if(fip->field_passcount) {
-			if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)
-				continue;
-		} else {
-			if (fip->field_readcount == TIFF_VARIABLE
-			    || fip->field_readcount == TIFF_VARIABLE2)
-				value_count = 1;
-			else if (fip->field_readcount == TIFF_SPP)
-				value_count = td->td_samplesperpixel;
-			else
-				value_count = fip->field_readcount;
-			if ((fip->field_type == TIFF_ASCII
-			     || fip->field_readcount == TIFF_VARIABLE
-			     || fip->field_readcount == TIFF_VARIABLE2
-			     || fip->field_readcount == TIFF_SPP
-			     || value_count > 1)
-			    && fip->field_tag != TIFFTAG_PAGENUMBER
-			    && fip->field_tag != TIFFTAG_HALFTONEHINTS
-			    && fip->field_tag != TIFFTAG_YCBCRSUBSAMPLING
-			    && fip->field_tag != TIFFTAG_DOTRANGE) {
-				if(TIFFGetField(tif, tag, &raw_data) != 1)
-					continue;
-			} else if (fip->field_tag != TIFFTAG_PAGENUMBER
-				   && fip->field_tag != TIFFTAG_HALFTONEHINTS
-				   && fip->field_tag != TIFFTAG_YCBCRSUBSAMPLING
-				   && fip->field_tag != TIFFTAG_DOTRANGE) {
-				raw_data = _TIFFmalloc(
-					_TIFFDataSize(fip->field_type)
-					* value_count);
-				mem_alloc = 1;
-				if(TIFFGetField(tif, tag, raw_data) != 1) {
-					_TIFFfree(raw_data);
-					continue;
-				}
-			} else {
-				/* 
-				 * XXX: Should be fixed and removed, see the
-				 * notes related to TIFFTAG_PAGENUMBER,
-				 * TIFFTAG_HALFTONEHINTS,
-				 * TIFFTAG_YCBCRSUBSAMPLING and
-				 * TIFFTAG_DOTRANGE tags in tif_dir.c. */
-				char *tmp;
-				raw_data = _TIFFmalloc(
-					_TIFFDataSize(fip->field_type)
-					* value_count);
-				tmp = raw_data;
-				mem_alloc = 1;
-				if(TIFFGetField(tif, tag, tmp,
-				tmp + _TIFFDataSize(fip->field_type)) != 1) {
-					_TIFFfree(raw_data);
-					continue;
-				}
-			}
-		}
-
-		/*
-		 * Catch the tags which needs to be specially handled and
-		 * pretty print them. If tag not handled in
-		 * _TIFFPrettyPrintField() fall down and print it as any other
-		 * tag.
-		 */
-		if (_TIFFPrettyPrintField(tif, fd, tag, value_count, raw_data)) {
-			if(mem_alloc)
-				_TIFFfree(raw_data);
-			continue;
-		}
-		else
-			_TIFFPrintField(fd, fip, value_count, raw_data);
-
-		if(mem_alloc)
-			_TIFFfree(raw_data);
-            }
-        }
-        
-	if (tif->tif_tagmethods.printdir)
-		(*tif->tif_tagmethods.printdir)(tif, fd, flags);
-	if ((flags & TIFFPRINT_STRIPS) &&
-	    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {
-		tstrip_t s;
-
-		fprintf(fd, "  %lu %s:\n",
-		    (long) td->td_nstrips,
-		    isTiled(tif) ? "Tiles" : "Strips");
-		for (s = 0; s < td->td_nstrips; s++)
-			fprintf(fd, "    %3lu: [%8lu, %8lu]\n",
-			    (unsigned long) s,
-			    (unsigned long) td->td_stripoffset[s],
-			    (unsigned long) td->td_stripbytecount[s]);
-	}
-}
-
-void
-_TIFFprintAscii(FILE* fd, const char* cp)
-{
-	for (; *cp != '\0'; cp++) {
-		const char* tp;
-
-		if (isprint((int)*cp)) {
-			fputc(*cp, fd);
-			continue;
-		}
-		for (tp = "\tt\bb\rr\nn\vv"; *tp; tp++)
-			if (*tp++ == *cp)
-				break;
-		if (*tp)
-			fprintf(fd, "\\%c", *tp);
-		else
-			fprintf(fd, "\\%03o", *cp & 0xff);
-	}
-}
-
-void
-_TIFFprintAsciiTag(FILE* fd, const char* name, const char* value)
-{
-	fprintf(fd, "  %s: \"", name);
-	_TIFFprintAscii(fd, value);
-	fprintf(fd, "\"\n");
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_read.c b/thirdparty/libtiff/tif_read.c
deleted file mode 100644
index 8ac0ae6..0000000
--- a/thirdparty/libtiff/tif_read.c
+++ /dev/null
@@ -1,750 +0,0 @@
-/* $Id: tif_read.c,v 1.16.2.3 2010-06-09 14:32:47 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- * Scanline-oriented Read Support
- */
-#include "tiffiop.h"
-#include <stdio.h>
-
-	int TIFFFillStrip(TIFF*, tstrip_t);
-	int TIFFFillTile(TIFF*, ttile_t);
-static	int TIFFStartStrip(TIFF*, tstrip_t);
-static	int TIFFStartTile(TIFF*, ttile_t);
-static	int TIFFCheckRead(TIFF*, int);
-
-#define	NOSTRIP	((tstrip_t) -1)			/* undefined state */
-#define	NOTILE	((ttile_t) -1)			/* undefined state */
-
-/*
- * Seek to a random row+sample in a file.
- */
-static int
-TIFFSeek(TIFF* tif, uint32 row, tsample_t sample)
-{
-	register TIFFDirectory *td = &tif->tif_dir;
-	tstrip_t strip;
-
-	if (row >= td->td_imagelength) {	/* out of range */
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Row out of range, max %lu",
-			     (unsigned long) row,
-			     (unsigned long) td->td_imagelength);
-		return (0);
-	}
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-		if (sample >= td->td_samplesperpixel) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "%lu: Sample out of range, max %lu",
-			    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);
-			return (0);
-		}
-		strip = sample*td->td_stripsperimage + row/td->td_rowsperstrip;
-	} else
-		strip = row / td->td_rowsperstrip;
-	if (strip != tif->tif_curstrip) {	/* different strip, refill */
-		if (!TIFFFillStrip(tif, strip))
-			return (0);
-	} else if (row < tif->tif_row) {
-		/*
-		 * Moving backwards within the same strip: backup
-		 * to the start and then decode forward (below).
-		 *
-		 * NB: If you're planning on lots of random access within a
-		 * strip, it's better to just read and decode the entire
-		 * strip, and then access the decoded data in a random fashion.
-		 */
-		if (!TIFFStartStrip(tif, strip))
-			return (0);
-	}
-	if (row != tif->tif_row) {
-		/*
-		 * Seek forward to the desired row.
-		 */
-		if (!(*tif->tif_seek)(tif, row - tif->tif_row))
-			return (0);
-		tif->tif_row = row;
-	}
-	return (1);
-}
-
-int
-TIFFReadScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample)
-{
-	int e;
-
-	if (!TIFFCheckRead(tif, 0))
-		return (-1);
-	if( (e = TIFFSeek(tif, row, sample)) != 0) {
-		/*
-		 * Decompress desired row into user buffer.
-		 */
-		e = (*tif->tif_decoderow)
-		    (tif, (tidata_t) buf, tif->tif_scanlinesize, sample);
-
-		/* we are now poised at the beginning of the next row */
-		tif->tif_row = row + 1;
-
-		if (e)
-			(*tif->tif_postdecode)(tif, (tidata_t) buf,
-			    tif->tif_scanlinesize);
-	}
-	return (e > 0 ? 1 : -1);
-}
-
-/*
- * Read a strip of data and decompress the specified
- * amount into the user-supplied buffer.
- */
-tsize_t
-TIFFReadEncodedStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	uint32 nrows;
-	tsize_t stripsize;
-        tstrip_t sep_strip, strips_per_sep;
-
-	if (!TIFFCheckRead(tif, 0))
-		return (-1);
-	if (strip >= td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%ld: Strip out of range, max %ld",
-			     (long) strip, (long) td->td_nstrips);
-		return (-1);
-	}
-	/*
-	 * Calculate the strip size according to the number of
-	 * rows in the strip (check for truncated last strip on any
-	 * of the separations).
-	 */
-	if( td->td_rowsperstrip >= td->td_imagelength )
-		strips_per_sep = 1;
-	else
-		strips_per_sep = (td->td_imagelength+td->td_rowsperstrip-1)
-		    / td->td_rowsperstrip;
-
-	sep_strip = strip % strips_per_sep;
-
-	if (sep_strip != strips_per_sep-1 ||
-	    (nrows = td->td_imagelength % td->td_rowsperstrip) == 0)
-		nrows = td->td_rowsperstrip;
-
-	stripsize = TIFFVStripSize(tif, nrows);
-	if (size == (tsize_t) -1)
-		size = stripsize;
-	else if (size > stripsize)
-		size = stripsize;
-	if (TIFFFillStrip(tif, strip)
-	    && (*tif->tif_decodestrip)(tif, (tidata_t) buf, size,   
-	    (tsample_t)(strip / td->td_stripsperimage)) > 0 ) {
-		(*tif->tif_postdecode)(tif, (tidata_t) buf, size);
-		return (size);
-	} else
-		return ((tsize_t) -1);
-}
-
-static tsize_t
-TIFFReadRawStrip1(TIFF* tif,
-    tstrip_t strip, tdata_t buf, tsize_t size, const char* module)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	assert((tif->tif_flags&TIFF_NOREADRAW)==0);
-	if (!isMapped(tif)) {
-		tsize_t cc;
-
-		if (!SeekOK(tif, td->td_stripoffset[strip])) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Seek error at scanline %lu, strip %lu",
-			    tif->tif_name,
-			    (unsigned long) tif->tif_row, (unsigned long) strip);
-			return (-1);
-		}
-		cc = TIFFReadFile(tif, buf, size);
-		if (cc != size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-		"%s: Read error at scanline %lu; got %lu bytes, expected %lu",
-			    tif->tif_name,
-			    (unsigned long) tif->tif_row,
-			    (unsigned long) cc,
-			    (unsigned long) size);
-			return (-1);
-		}
-	} else {
-		if (td->td_stripoffset[strip] + size > tif->tif_size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-    "%s: Read error at scanline %lu, strip %lu; got %lu bytes, expected %lu",
-			    tif->tif_name,
-			    (unsigned long) tif->tif_row,
-			    (unsigned long) strip,
-			    (unsigned long) tif->tif_size - td->td_stripoffset[strip],
-			    (unsigned long) size);
-			return (-1);
-		}
-		_TIFFmemcpy(buf, tif->tif_base + td->td_stripoffset[strip],
-                            size);
-	}
-	return (size);
-}
-
-/*
- * Read a strip of data from the file.
- */
-tsize_t
-TIFFReadRawStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)
-{
-	static const char module[] = "TIFFReadRawStrip";
-	TIFFDirectory *td = &tif->tif_dir;
-	/*
-	 * FIXME: butecount should have tsize_t type, but for now libtiff
-	 * defines tsize_t as a signed 32-bit integer and we are losing
-	 * ability to read arrays larger than 2^31 bytes. So we are using
-	 * uint32 instead of tsize_t here.
-	 */
-	uint32 bytecount;
-
-	if (!TIFFCheckRead(tif, 0))
-		return ((tsize_t) -1);
-	if (strip >= td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Strip out of range, max %lu",
-			     (unsigned long) strip,
-			     (unsigned long) td->td_nstrips);
-		return ((tsize_t) -1);
-	}
-	if (tif->tif_flags&TIFF_NOREADRAW)
-	{
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	"Compression scheme does not support access to raw uncompressed data");
-		return ((tsize_t) -1);
-	}
-	bytecount = td->td_stripbytecount[strip];
-	if (bytecount <= 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "%lu: Invalid strip byte count, strip %lu",
-		    (unsigned long) bytecount, (unsigned long) strip);
-		return ((tsize_t) -1);
-	}
-	if (size != (tsize_t)-1 && (uint32)size < bytecount)
-		bytecount = size;
-	return (TIFFReadRawStrip1(tif, strip, buf, bytecount, module));
-}
-
-/*
- * Read the specified strip and setup for decoding. The data buffer is
- * expanded, as necessary, to hold the strip's data.
- */
-int
-TIFFFillStrip(TIFF* tif, tstrip_t strip)
-{
-	static const char module[] = "TIFFFillStrip";
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if ((tif->tif_flags&TIFF_NOREADRAW)==0)
-	{
-		/*
-		 * FIXME: butecount should have tsize_t type, but for now
-		 * libtiff defines tsize_t as a signed 32-bit integer and we
-		 * are losing ability to read arrays larger than 2^31 bytes.
-		 * So we are using uint32 instead of tsize_t here.
-		 */
-		uint32 bytecount = td->td_stripbytecount[strip];
-		if (bytecount <= 0) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Invalid strip byte count %lu, strip %lu",
-			    tif->tif_name, (unsigned long) bytecount,
-			    (unsigned long) strip);
-			return (0);
-		}
-		if (isMapped(tif) &&
-		    (isFillOrder(tif, td->td_fillorder)
-		    || (tif->tif_flags & TIFF_NOBITREV))) {
-			/*
-			 * The image is mapped into memory and we either don't
-			 * need to flip bits or the compression routine is
-			 * going to handle this operation itself.  In this
-			 * case, avoid copying the raw data and instead just
-			 * reference the data from the memory mapped file
-			 * image.  This assumes that the decompression
-			 * routines do not modify the contents of the raw data
-			 * buffer (if they try to, the application will get a
-			 * fault since the file is mapped read-only).
-			 */
-			if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)
-				_TIFFfree(tif->tif_rawdata);
-			tif->tif_flags &= ~TIFF_MYBUFFER;
-			/*
-			 * We must check for overflow, potentially causing
-			 * an OOB read. Instead of simple
-			 *
-			 *  td->td_stripoffset[strip]+bytecount > tif->tif_size
-			 *
-			 * comparison (which can overflow) we do the following
-			 * two comparisons:
-			 */
-			if (bytecount > tif->tif_size ||
-			    td->td_stripoffset[strip] > tif->tif_size - bytecount) {
-				/*
-				 * This error message might seem strange, but
-				 * it's what would happen if a read were done
-				 * instead.
-				 */
-				TIFFErrorExt(tif->tif_clientdata, module,
-
-					"%s: Read error on strip %lu; "
-					"got %lu bytes, expected %lu",
-					tif->tif_name, (unsigned long) strip,
-					(unsigned long) tif->tif_size - td->td_stripoffset[strip],
-					(unsigned long) bytecount);
-				tif->tif_curstrip = NOSTRIP;
-				return (0);
-			}
-			tif->tif_rawdatasize = bytecount;
-			tif->tif_rawdata = tif->tif_base + td->td_stripoffset[strip];
-		} else {
-			/*
-			 * Expand raw data buffer, if needed, to hold data
-			 * strip coming from file (perhaps should set upper
-			 * bound on the size of a buffer we'll use?).
-			 */
-			if (bytecount > (uint32)tif->tif_rawdatasize) {
-				tif->tif_curstrip = NOSTRIP;
-				if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {
-					TIFFErrorExt(tif->tif_clientdata,
-						     module,
-				"%s: Data buffer too small to hold strip %lu",
-						     tif->tif_name,
-						     (unsigned long) strip);
-					return (0);
-				}
-				if (!TIFFReadBufferSetup(tif, 0,
-				    TIFFroundup(bytecount, 1024)))
-					return (0);
-			}
-			if ((uint32)TIFFReadRawStrip1(tif, strip,
-				(unsigned char *)tif->tif_rawdata,
-				bytecount, module) != bytecount)
-				return (0);
-			if (!isFillOrder(tif, td->td_fillorder) &&
-			    (tif->tif_flags & TIFF_NOBITREV) == 0)
-				TIFFReverseBits(tif->tif_rawdata, bytecount);
-		}
-	}
-	return (TIFFStartStrip(tif, strip));
-}
-
-/*
- * Tile-oriented Read Support
- * Contributed by Nancy Cam (Silicon Graphics).
- */
-
-/*
- * Read and decompress a tile of data.  The
- * tile is selected by the (x,y,z,s) coordinates.
- */
-tsize_t
-TIFFReadTile(TIFF* tif,
-    tdata_t buf, uint32 x, uint32 y, uint32 z, tsample_t s)
-{
-	if (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))
-		return (-1);
-	return (TIFFReadEncodedTile(tif,
-	    TIFFComputeTile(tif, x, y, z, s), buf, (tsize_t) -1));
-}
-
-/*
- * Read a tile of data and decompress the specified
- * amount into the user-supplied buffer.
- */
-tsize_t
-TIFFReadEncodedTile(TIFF* tif, ttile_t tile, tdata_t buf, tsize_t size)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t tilesize = tif->tif_tilesize;
-
-	if (!TIFFCheckRead(tif, 1))
-		return (-1);
-	if (tile >= td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%ld: Tile out of range, max %ld",
-			     (long) tile, (unsigned long) td->td_nstrips);
-		return (-1);
-	}
-	if (size == (tsize_t) -1)
-		size = tilesize;
-	else if (size > tilesize)
-		size = tilesize;
-	if (TIFFFillTile(tif, tile) && (*tif->tif_decodetile)(tif,
-	    (tidata_t) buf, size, (tsample_t)(tile/td->td_stripsperimage))) {
-		(*tif->tif_postdecode)(tif, (tidata_t) buf, size);
-		return (size);
-	} else
-		return (-1);
-}
-
-static tsize_t
-TIFFReadRawTile1(TIFF* tif,
-    ttile_t tile, tdata_t buf, tsize_t size, const char* module)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	assert((tif->tif_flags&TIFF_NOREADRAW)==0);
-	if (!isMapped(tif)) {
-		tsize_t cc;
-
-		if (!SeekOK(tif, td->td_stripoffset[tile])) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Seek error at row %ld, col %ld, tile %ld",
-			    tif->tif_name,
-			    (long) tif->tif_row,
-			    (long) tif->tif_col,
-			    (long) tile);
-			return ((tsize_t) -1);
-		}
-		cc = TIFFReadFile(tif, buf, size);
-		if (cc != size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-	    "%s: Read error at row %ld, col %ld; got %lu bytes, expected %lu",
-			    tif->tif_name,
-			    (long) tif->tif_row,
-			    (long) tif->tif_col,
-			    (unsigned long) cc,
-			    (unsigned long) size);
-			return ((tsize_t) -1);
-		}
-	} else {
-		if (td->td_stripoffset[tile] + size > tif->tif_size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-    "%s: Read error at row %ld, col %ld, tile %ld; got %lu bytes, expected %lu",
-			    tif->tif_name,
-			    (long) tif->tif_row,
-			    (long) tif->tif_col,
-			    (long) tile,
-			    (unsigned long) tif->tif_size - td->td_stripoffset[tile],
-			    (unsigned long) size);
-			return ((tsize_t) -1);
-		}
-		_TIFFmemcpy(buf, tif->tif_base + td->td_stripoffset[tile], size);
-	}
-	return (size);
-}
-
-/*
- * Read a tile of data from the file.
- */
-tsize_t
-TIFFReadRawTile(TIFF* tif, ttile_t tile, tdata_t buf, tsize_t size)
-{
-	static const char module[] = "TIFFReadRawTile";
-	TIFFDirectory *td = &tif->tif_dir;
-	/*
-	 * FIXME: butecount should have tsize_t type, but for now libtiff
-	 * defines tsize_t as a signed 32-bit integer and we are losing
-	 * ability to read arrays larger than 2^31 bytes. So we are using
-	 * uint32 instead of tsize_t here.
-	 */
-	uint32 bytecount;
-
-	if (!TIFFCheckRead(tif, 1))
-		return ((tsize_t) -1);
-	if (tile >= td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Tile out of range, max %lu",
-		    (unsigned long) tile, (unsigned long) td->td_nstrips);
-		return ((tsize_t) -1);
-	}
-	if (tif->tif_flags&TIFF_NOREADRAW)
-	{
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-	"Compression scheme does not support access to raw uncompressed data");
-		return ((tsize_t) -1);
-	}
-	bytecount = td->td_stripbytecount[tile];
-	if (size != (tsize_t) -1 && (uint32)size < bytecount)
-		bytecount = size;
-	return (TIFFReadRawTile1(tif, tile, buf, bytecount, module));
-}
-
-/*
- * Read the specified tile and setup for decoding. The data buffer is
- * expanded, as necessary, to hold the tile's data.
- */
-int
-TIFFFillTile(TIFF* tif, ttile_t tile)
-{
-	static const char module[] = "TIFFFillTile";
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if ((tif->tif_flags&TIFF_NOREADRAW)==0)
-	{
-		/*
-		 * FIXME: butecount should have tsize_t type, but for now
-		 * libtiff defines tsize_t as a signed 32-bit integer and we
-		 * are losing ability to read arrays larger than 2^31 bytes.
-		 * So we are using uint32 instead of tsize_t here.
-		 */
-		uint32 bytecount = td->td_stripbytecount[tile];
-		if (bytecount <= 0) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "%lu: Invalid tile byte count, tile %lu",
-			    (unsigned long) bytecount, (unsigned long) tile);
-			return (0);
-		}
-		if (isMapped(tif) &&
-		    (isFillOrder(tif, td->td_fillorder)
-		     || (tif->tif_flags & TIFF_NOBITREV))) {
-			/*
-			 * The image is mapped into memory and we either don't
-			 * need to flip bits or the compression routine is
-			 * going to handle this operation itself.  In this
-			 * case, avoid copying the raw data and instead just
-			 * reference the data from the memory mapped file
-			 * image.  This assumes that the decompression
-			 * routines do not modify the contents of the raw data
-			 * buffer (if they try to, the application will get a
-			 * fault since the file is mapped read-only).
-			 */
-			if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)
-				_TIFFfree(tif->tif_rawdata);
-			tif->tif_flags &= ~TIFF_MYBUFFER;
-			/*
-			 * We must check for overflow, potentially causing
-			 * an OOB read. Instead of simple
-			 *
-			 *  td->td_stripoffset[tile]+bytecount > tif->tif_size
-			 *
-			 * comparison (which can overflow) we do the following
-			 * two comparisons:
-			 */
-			if (bytecount > tif->tif_size ||
-			    td->td_stripoffset[tile] > tif->tif_size - bytecount) {
-				tif->tif_curtile = NOTILE;
-				return (0);
-			}
-			tif->tif_rawdatasize = bytecount;
-			tif->tif_rawdata =
-				tif->tif_base + td->td_stripoffset[tile];
-		} else {
-			/*
-			 * Expand raw data buffer, if needed, to hold data
-			 * tile coming from file (perhaps should set upper
-			 * bound on the size of a buffer we'll use?).
-			 */
-			if (bytecount > (uint32)tif->tif_rawdatasize) {
-				tif->tif_curtile = NOTILE;
-				if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {
-					TIFFErrorExt(tif->tif_clientdata,
-						     module,
-				"%s: Data buffer too small to hold tile %ld",
-						     tif->tif_name,
-						     (long) tile);
-					return (0);
-				}
-				if (!TIFFReadBufferSetup(tif, 0,
-				    TIFFroundup(bytecount, 1024)))
-					return (0);
-			}
-			if ((uint32)TIFFReadRawTile1(tif, tile,
-				(unsigned char *)tif->tif_rawdata,
-				bytecount, module) != bytecount)
-				return (0);
-			if (!isFillOrder(tif, td->td_fillorder) &&
-			    (tif->tif_flags & TIFF_NOBITREV) == 0)
-				TIFFReverseBits(tif->tif_rawdata, bytecount);
-		}
-	}
-	return (TIFFStartTile(tif, tile));
-}
-
-/*
- * Setup the raw data buffer in preparation for
- * reading a strip of raw data.  If the buffer
- * is specified as zero, then a buffer of appropriate
- * size is allocated by the library.  Otherwise,
- * the client must guarantee that the buffer is
- * large enough to hold any individual strip of
- * raw data.
- */
-int
-TIFFReadBufferSetup(TIFF* tif, tdata_t bp, tsize_t size)
-{
-	static const char module[] = "TIFFReadBufferSetup";
-
-	assert((tif->tif_flags&TIFF_NOREADRAW)==0);
-	if (tif->tif_rawdata) {
-		if (tif->tif_flags & TIFF_MYBUFFER)
-			_TIFFfree(tif->tif_rawdata);
-		tif->tif_rawdata = NULL;
-	}
-
-	if (bp) {
-		tif->tif_rawdatasize = size;
-		tif->tif_rawdata = (tidata_t) bp;
-		tif->tif_flags &= ~TIFF_MYBUFFER;
-	} else {
-		tif->tif_rawdatasize = TIFFroundup(size, 1024);
-		if (tif->tif_rawdatasize > 0)
-			tif->tif_rawdata = (tidata_t) _TIFFmalloc(tif->tif_rawdatasize);
-		tif->tif_flags |= TIFF_MYBUFFER;
-	}
-	if ((tif->tif_rawdata == NULL) || (tif->tif_rawdatasize == 0)) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%s: No space for data buffer at scanline %ld",
-		    tif->tif_name, (long) tif->tif_row);
-		tif->tif_rawdatasize = 0;
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * Set state to appear as if a
- * strip has just been read in.
- */
-static int
-TIFFStartStrip(TIFF* tif, tstrip_t strip)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
-		if (!(*tif->tif_setupdecode)(tif))
-			return (0);
-		tif->tif_flags |= TIFF_CODERSETUP;
-	}
-	tif->tif_curstrip = strip;
-	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
-	if (tif->tif_flags&TIFF_NOREADRAW)
-	{
-		tif->tif_rawcp = NULL;
-		tif->tif_rawcc = 0;
-	}
-	else
-	{
-		tif->tif_rawcp = tif->tif_rawdata;
-		tif->tif_rawcc = td->td_stripbytecount[strip];
-	}
-	return ((*tif->tif_predecode)(tif,
-			(tsample_t)(strip / td->td_stripsperimage)));
-}
-
-/*
- * Set state to appear as if a
- * tile has just been read in.
- */
-static int
-TIFFStartTile(TIFF* tif, ttile_t tile)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
-		if (!(*tif->tif_setupdecode)(tif))
-			return (0);
-		tif->tif_flags |= TIFF_CODERSETUP;
-	}
-	tif->tif_curtile = tile;
-	tif->tif_row =
-	    (tile % TIFFhowmany(td->td_imagewidth, td->td_tilewidth)) *
-		td->td_tilelength;
-	tif->tif_col =
-	    (tile % TIFFhowmany(td->td_imagelength, td->td_tilelength)) *
-		td->td_tilewidth;
-	if (tif->tif_flags&TIFF_NOREADRAW)
-	{
-		tif->tif_rawcp = NULL;
-		tif->tif_rawcc = 0;
-	}
-	else
-	{
-		tif->tif_rawcp = tif->tif_rawdata;
-		tif->tif_rawcc = td->td_stripbytecount[tile];
-	}
-	return ((*tif->tif_predecode)(tif,
-			(tsample_t)(tile/td->td_stripsperimage)));
-}
-
-static int
-TIFFCheckRead(TIFF* tif, int tiles)
-{
-	if (tif->tif_mode == O_WRONLY) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "File not open for reading");
-		return (0);
-	}
-	if (tiles ^ isTiled(tif)) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?
-		    "Can not read tiles from a stripped image" :
-		    "Can not read scanlines from a tiled image");
-		return (0);
-	}
-	return (1);
-}
-
-void
-_TIFFNoPostDecode(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-    (void) tif; (void) buf; (void) cc;
-}
-
-void
-_TIFFSwab16BitData(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-    (void) tif;
-    assert((cc & 1) == 0);
-    TIFFSwabArrayOfShort((uint16*) buf, cc/2);
-}
-
-void
-_TIFFSwab24BitData(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-    (void) tif;
-    assert((cc % 3) == 0);
-    TIFFSwabArrayOfTriples((uint8*) buf, cc/3);
-}
-
-void
-_TIFFSwab32BitData(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-    (void) tif;
-    assert((cc & 3) == 0);
-    TIFFSwabArrayOfLong((uint32*) buf, cc/4);
-}
-
-void
-_TIFFSwab64BitData(TIFF* tif, tidata_t buf, tsize_t cc)
-{
-    (void) tif;
-    assert((cc & 7) == 0);
-    TIFFSwabArrayOfDouble((double*) buf, cc/8);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_stream.cxx b/thirdparty/libtiff/tif_stream.cxx
deleted file mode 100644
index 2a2351b..0000000
--- a/thirdparty/libtiff/tif_stream.cxx
+++ /dev/null
@@ -1,295 +0,0 @@
-/* $Id: tif_stream.cxx,v 1.6.2.1 2009-01-01 00:10:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library UNIX-specific Routines.
- */
-#include "tiffiop.h"
-#include <iostream>
-
-#ifndef __VMS
-using namespace std;
-#endif
-
-class tiffis_data
-{
-  public:
-
-	istream	*myIS;
-        long	myStreamStartPos;
-};
-
-class tiffos_data
-{
-  public:
-
-	ostream	*myOS;
-	long	myStreamStartPos;
-};
-
-static tsize_t
-_tiffosReadProc(thandle_t, tdata_t, tsize_t)
-{
-        return 0;
-}
-
-static tsize_t
-_tiffisReadProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-        tiffis_data	*data = (tiffis_data *)fd;
-
-        data->myIS->read((char *)buf, (int)size);
-
-        return data->myIS->gcount();
-}
-
-static tsize_t
-_tiffosWriteProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	tiffos_data	*data = (tiffos_data *)fd;
-	ostream		*os = data->myOS;
-	int		pos = os->tellp();
-
-	os->write((const char *)buf, size);
-
-	return ((int)os->tellp()) - pos;
-}
-
-static tsize_t
-_tiffisWriteProc(thandle_t, tdata_t, tsize_t)
-{
-	return 0;
-}
-
-static toff_t
-_tiffosSeekProc(thandle_t fd, toff_t off, int whence)
-{
-	tiffos_data	*data = (tiffos_data *)fd;
-	ostream	*os = data->myOS;
-
-	// if the stream has already failed, don't do anything
-	if( os->fail() )
-		return os->tellp();
-
-	switch(whence) {
-	case SEEK_SET:
-	    os->seekp(data->myStreamStartPos + off, ios::beg);
-		break;
-	case SEEK_CUR:
-		os->seekp(off, ios::cur);
-		break;
-	case SEEK_END:
-		os->seekp(off, ios::end);
-		break;
-	}
-
-	// Attempt to workaround problems with seeking past the end of the
-	// stream.  ofstream doesn't have a problem with this but
-	// ostrstream/ostringstream does. In that situation, add intermediate
-	// '\0' characters.
-	if( os->fail() ) {
-#ifdef __VMS
-		int		old_state;
-#else
-		ios::iostate	old_state;
-#endif
-		toff_t		origin=0;
-
-		old_state = os->rdstate();
-		// reset the fail bit or else tellp() won't work below
-		os->clear(os->rdstate() & ~ios::failbit);
-		switch( whence ) {
-			case SEEK_SET:
-				origin = data->myStreamStartPos;
-				break;
-			case SEEK_CUR:
-				origin = os->tellp();
-				break;
-			case SEEK_END:
-				os->seekp(0, ios::end);
-				origin = os->tellp();
-				break;
-		}
-		// restore original stream state
-		os->clear(old_state);	
-
-		// only do something if desired seek position is valid
-		if( origin + off > data->myStreamStartPos ) {
-			toff_t	num_fill;
-
-			// clear the fail bit 
-			os->clear(os->rdstate() & ~ios::failbit);
-
-			// extend the stream to the expected size
-			os->seekp(0, ios::end);
-			num_fill = origin + off - (toff_t)os->tellp();
-			for( toff_t i = 0; i < num_fill; i++ )
-				os->put('\0');
-
-			// retry the seek
-			os->seekp(origin + off, ios::beg);
-		}
-	}
-
-	return os->tellp();
-}
-
-static toff_t
-_tiffisSeekProc(thandle_t fd, toff_t off, int whence)
-{
-	tiffis_data	*data = (tiffis_data *)fd;
-
-	switch(whence) {
-	case SEEK_SET:
-		data->myIS->seekg(data->myStreamStartPos + off, ios::beg);
-		break;
-	case SEEK_CUR:
-		data->myIS->seekg(off, ios::cur);
-		break;
-	case SEEK_END:
-		data->myIS->seekg(off, ios::end);
-		break;
-	}
-
-	return ((long)data->myIS->tellg()) - data->myStreamStartPos;
-}
-
-static toff_t
-_tiffosSizeProc(thandle_t fd)
-{
-	tiffos_data	*data = (tiffos_data *)fd;
-	ostream		*os = data->myOS;
-	toff_t		pos = os->tellp();
-	toff_t		len;
-
-	os->seekp(0, ios::end);
-	len = os->tellp();
-	os->seekp(pos);
-
-	return len;
-}
-
-static toff_t
-_tiffisSizeProc(thandle_t fd)
-{
-	tiffis_data	*data = (tiffis_data *)fd;
-	int		pos = data->myIS->tellg();
-	int		len;
-
-	data->myIS->seekg(0, ios::end);
-	len = data->myIS->tellg();
-	data->myIS->seekg(pos);
-
-	return len;
-}
-
-static int
-_tiffosCloseProc(thandle_t fd)
-{
-	// Our stream was not allocated by us, so it shouldn't be closed by us.
-	delete (tiffos_data *)fd;
-	return 0;
-}
-
-static int
-_tiffisCloseProc(thandle_t fd)
-{
-	// Our stream was not allocated by us, so it shouldn't be closed by us.
-	delete (tiffis_data *)fd;
-	return 0;
-}
-
-static int
-_tiffDummyMapProc(thandle_t , tdata_t* , toff_t* )
-{
-	return (0);
-}
-
-static void
-_tiffDummyUnmapProc(thandle_t , tdata_t , toff_t )
-{
-}
-
-/*
- * Open a TIFF file descriptor for read/writing.
- */
-static TIFF*
-_tiffStreamOpen(const char* name, const char* mode, void *fd)
-{
-	TIFF*	tif;
-
-	if( strchr(mode, 'w') ) {
-		tiffos_data	*data = new tiffos_data;
-		data->myOS = (ostream *)fd;
-		data->myStreamStartPos = data->myOS->tellp();
-
-		// Open for writing.
-		tif = TIFFClientOpen(name, mode,
-				(thandle_t) data,
-				_tiffosReadProc, _tiffosWriteProc,
-				_tiffosSeekProc, _tiffosCloseProc,
-				_tiffosSizeProc,
-				_tiffDummyMapProc, _tiffDummyUnmapProc);
-	} else {
-		tiffis_data	*data = new tiffis_data;
-		data->myIS = (istream *)fd;
-		data->myStreamStartPos = data->myIS->tellg();
-		// Open for reading.
-		tif = TIFFClientOpen(name, mode,
-				(thandle_t) data,
-				_tiffisReadProc, _tiffisWriteProc,
-				_tiffisSeekProc, _tiffisCloseProc,
-				_tiffisSizeProc,
-				_tiffDummyMapProc, _tiffDummyUnmapProc);
-	}
-
-	return (tif);
-}
-
-TIFF*
-TIFFStreamOpen(const char* name, ostream *os)
-{
-	// If os is either a ostrstream or ostringstream, and has no data
-	// written to it yet, then tellp() will return -1 which will break us.
-	// We workaround this by writing out a dummy character and
-	// then seek back to the beginning.
-	if( !os->fail() && (int)os->tellp() < 0 ) {
-		*os << '\0';
-		os->seekp(0);
-	}
-
-	// NB: We don't support mapped files with streams so add 'm'
-	return _tiffStreamOpen(name, "wm", os);
-}
-
-TIFF*
-TIFFStreamOpen(const char* name, istream *is)
-{
-	// NB: We don't support mapped files with streams so add 'm'
-	return _tiffStreamOpen(name, "rm", is);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/thirdparty/libtiff/tif_strip.c b/thirdparty/libtiff/tif_strip.c
deleted file mode 100644
index 63dec6b..0000000
--- a/thirdparty/libtiff/tif_strip.c
+++ /dev/null
@@ -1,370 +0,0 @@
-/* $Id: tif_strip.c,v 1.19.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1991-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Strip-organized Image Support Routines.
- */
-#include "tiffiop.h"
-
-static uint32
-summarize(TIFF* tif, size_t summand1, size_t summand2, const char* where)
-{
-	/*
-	 * XXX: We are using casting to uint32 here, bacause sizeof(size_t)
-	 * may be larger than sizeof(uint32) on 64-bit architectures.
-	 */
-	uint32	bytes = summand1 + summand2;
-
-	if (bytes - summand1 != summand2) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Integer overflow in %s", where);
-		bytes = 0;
-	}
-
-	return (bytes);
-}
-
-static uint32
-multiply(TIFF* tif, size_t nmemb, size_t elem_size, const char* where)
-{
-	uint32	bytes = nmemb * elem_size;
-
-	if (elem_size && bytes / elem_size != nmemb) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Integer overflow in %s", where);
-		bytes = 0;
-	}
-
-	return (bytes);
-}
-
-/*
- * Compute which strip a (row,sample) value is in.
- */
-tstrip_t
-TIFFComputeStrip(TIFF* tif, uint32 row, tsample_t sample)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tstrip_t strip;
-
-	strip = row / td->td_rowsperstrip;
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-		if (sample >= td->td_samplesperpixel) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "%lu: Sample out of range, max %lu",
-			    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);
-			return ((tstrip_t) 0);
-		}
-		strip += sample*td->td_stripsperimage;
-	}
-	return (strip);
-}
-
-/*
- * Compute how many strips are in an image.
- */
-tstrip_t
-TIFFNumberOfStrips(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tstrip_t nstrips;
-
-	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
-	     TIFFhowmany(td->td_imagelength, td->td_rowsperstrip));
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		nstrips = multiply(tif, nstrips, td->td_samplesperpixel,
-				   "TIFFNumberOfStrips");
-	return (nstrips);
-}
-
-/*
- * Compute the # bytes in a variable height, row-aligned strip.
- */
-tsize_t
-TIFFVStripSize(TIFF* tif, uint32 nrows)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if (nrows == (uint32) -1)
-		nrows = td->td_imagelength;
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG &&
-	    td->td_photometric == PHOTOMETRIC_YCBCR &&
-	    !isUpSampled(tif)) {
-		/*
-		 * Packed YCbCr data contain one Cb+Cr for every
-		 * HorizontalSampling*VerticalSampling Y values.
-		 * Must also roundup width and height when calculating
-		 * since images that are not a multiple of the
-		 * horizontal/vertical subsampling area include
-		 * YCbCr data for the extended image.
-		 */
-		uint16 ycbcrsubsampling[2];
-		tsize_t w, scanline, samplingarea;
-
-		TIFFGetField( tif, TIFFTAG_YCBCRSUBSAMPLING,
-			      ycbcrsubsampling + 0,
-			      ycbcrsubsampling + 1 );
-
-		samplingarea = ycbcrsubsampling[0]*ycbcrsubsampling[1];
-		if (samplingarea == 0) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-				     "Invalid YCbCr subsampling");
-			return 0;
-		}
-
-		w = TIFFroundup(td->td_imagewidth, ycbcrsubsampling[0]);
-		scanline = TIFFhowmany8(multiply(tif, w, td->td_bitspersample,
-						 "TIFFVStripSize"));
-		nrows = TIFFroundup(nrows, ycbcrsubsampling[1]);
-		/* NB: don't need TIFFhowmany here 'cuz everything is rounded */
-		scanline = multiply(tif, nrows, scanline, "TIFFVStripSize");
-		return ((tsize_t)
-		    summarize(tif, scanline,
-			      multiply(tif, 2, scanline / samplingarea,
-				       "TIFFVStripSize"), "TIFFVStripSize"));
-	} else
-		return ((tsize_t) multiply(tif, nrows, TIFFScanlineSize(tif),
-					   "TIFFVStripSize"));
-}
-
-
-/*
- * Compute the # bytes in a raw strip.
- */
-tsize_t
-TIFFRawStripSize(TIFF* tif, tstrip_t strip)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	tsize_t bytecount = td->td_stripbytecount[strip];
-
-	if (bytecount <= 0) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			  "%lu: Invalid strip byte count, strip %lu",
-			  (unsigned long) bytecount, (unsigned long) strip);
-		bytecount = (tsize_t) -1;
-	}
-
-	return bytecount;
-}
-
-/*
- * Compute the # bytes in a (row-aligned) strip.
- *
- * Note that if RowsPerStrip is larger than the
- * recorded ImageLength, then the strip size is
- * truncated to reflect the actual space required
- * to hold the strip.
- */
-tsize_t
-TIFFStripSize(TIFF* tif)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-	uint32 rps = td->td_rowsperstrip;
-	if (rps > td->td_imagelength)
-		rps = td->td_imagelength;
-	return (TIFFVStripSize(tif, rps));
-}
-
-/*
- * Compute a default strip size based on the image
- * characteristics and a requested value.  If the
- * request is <1 then we choose a strip size according
- * to certain heuristics.
- */
-uint32
-TIFFDefaultStripSize(TIFF* tif, uint32 request)
-{
-	return (*tif->tif_defstripsize)(tif, request);
-}
-
-uint32
-_TIFFDefaultStripSize(TIFF* tif, uint32 s)
-{
-	if ((int32) s < 1) {
-		/*
-		 * If RowsPerStrip is unspecified, try to break the
-		 * image up into strips that are approximately
-		 * STRIP_SIZE_DEFAULT bytes long.
-		 */
-		tsize_t scanline = TIFFScanlineSize(tif);
-		s = (uint32)STRIP_SIZE_DEFAULT / (scanline == 0 ? 1 : scanline);
-		if (s == 0)		/* very wide images */
-			s = 1;
-	}
-	return (s);
-}
-
-/*
- * Return the number of bytes to read/write in a call to
- * one of the scanline-oriented i/o routines.  Note that
- * this number may be 1/samples-per-pixel if data is
- * stored as separate planes.
- */
-tsize_t
-TIFFScanlineSize(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t scanline;
-
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		if (td->td_photometric == PHOTOMETRIC_YCBCR
-		    && !isUpSampled(tif)) {
-			uint16 ycbcrsubsampling[2];
-
-			TIFFGetField(tif, TIFFTAG_YCBCRSUBSAMPLING,
-				     ycbcrsubsampling + 0,
-				     ycbcrsubsampling + 1);
-
-			if (ycbcrsubsampling[0] == 0) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-					     "Invalid YCbCr subsampling");
-				return 0;
-			}
-
-			scanline = TIFFroundup(td->td_imagewidth,
-					       ycbcrsubsampling[0]);
-			scanline = TIFFhowmany8(multiply(tif, scanline,
-							 td->td_bitspersample,
-							 "TIFFScanlineSize"));
-			return ((tsize_t)
-				summarize(tif, scanline,
-					  multiply(tif, 2,
-						scanline / ycbcrsubsampling[0],
-						"TIFFVStripSize"),
-					  "TIFFVStripSize"));
-		} else {
-			scanline = multiply(tif, td->td_imagewidth,
-					    td->td_samplesperpixel,
-					    "TIFFScanlineSize");
-		}
-	} else
-		scanline = td->td_imagewidth;
-	return ((tsize_t) TIFFhowmany8(multiply(tif, scanline,
-						td->td_bitspersample,
-						"TIFFScanlineSize")));
-}
-
-/*
- * Some stuff depends on this older version of TIFFScanlineSize
- * TODO: resolve this
- */
-tsize_t
-TIFFOldScanlineSize(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t scanline;
-
-	scanline = multiply (tif, td->td_bitspersample, td->td_imagewidth,
-			     "TIFFScanlineSize");
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG)
-		scanline = multiply (tif, scanline, td->td_samplesperpixel,
-				     "TIFFScanlineSize");
-	return ((tsize_t) TIFFhowmany8(scanline));
-}
-
-/*
- * Return the number of bytes to read/write in a call to
- * one of the scanline-oriented i/o routines.  Note that
- * this number may be 1/samples-per-pixel if data is
- * stored as separate planes.
- * The ScanlineSize in case of YCbCrSubsampling is defined as the
- * strip size divided by the strip height, i.e. the size of a pack of vertical
- * subsampling lines divided by vertical subsampling. It should thus make
- * sense when multiplied by a multiple of vertical subsampling.
- * Some stuff depends on this newer version of TIFFScanlineSize
- * TODO: resolve this
- */
-tsize_t
-TIFFNewScanlineSize(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t scanline;
-
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		if (td->td_photometric == PHOTOMETRIC_YCBCR
-		    && !isUpSampled(tif)) {
-			uint16 ycbcrsubsampling[2];
-
-			TIFFGetField(tif, TIFFTAG_YCBCRSUBSAMPLING,
-				     ycbcrsubsampling + 0,
-				     ycbcrsubsampling + 1);
-
-			if (ycbcrsubsampling[0]*ycbcrsubsampling[1] == 0) {
-				TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-					     "Invalid YCbCr subsampling");
-				return 0;
-			}
-
-			return((tsize_t) ((((td->td_imagewidth+ycbcrsubsampling[0]-1)
-					    /ycbcrsubsampling[0])
-					   *(ycbcrsubsampling[0]*ycbcrsubsampling[1]+2)
-					   *td->td_bitspersample+7)
-					  /8)/ycbcrsubsampling[1]);
-
-		} else {
-			scanline = multiply(tif, td->td_imagewidth,
-					    td->td_samplesperpixel,
-					    "TIFFScanlineSize");
-		}
-	} else
-		scanline = td->td_imagewidth;
-	return ((tsize_t) TIFFhowmany8(multiply(tif, scanline,
-						td->td_bitspersample,
-						"TIFFScanlineSize")));
-}
-
-/*
- * Return the number of bytes required to store a complete
- * decoded and packed raster scanline (as opposed to the
- * I/O size returned by TIFFScanlineSize which may be less
- * if data is store as separate planes).
- */
-tsize_t
-TIFFRasterScanlineSize(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t scanline;
-	
-	scanline = multiply (tif, td->td_bitspersample, td->td_imagewidth,
-			     "TIFFRasterScanlineSize");
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
-		scanline = multiply (tif, scanline, td->td_samplesperpixel,
-				     "TIFFRasterScanlineSize");
-		return ((tsize_t) TIFFhowmany8(scanline));
-	} else
-		return ((tsize_t) multiply (tif, TIFFhowmany8(scanline),
-					    td->td_samplesperpixel,
-					    "TIFFRasterScanlineSize"));
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_swab.c b/thirdparty/libtiff/tif_swab.c
deleted file mode 100644
index e4f1a6d..0000000
--- a/thirdparty/libtiff/tif_swab.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* $Id: tif_swab.c,v 1.4.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library Bit & Byte Swapping Support.
- *
- * XXX We assume short = 16-bits and long = 32-bits XXX
- */
-#include "tiffiop.h"
-
-#ifndef TIFFSwabShort
-void
-TIFFSwabShort(uint16* wp)
-{
-	register unsigned char* cp = (unsigned char*) wp;
-	unsigned char t;
-
-	t = cp[1]; cp[1] = cp[0]; cp[0] = t;
-}
-#endif
-
-#ifndef TIFFSwabLong
-void
-TIFFSwabLong(uint32* lp)
-{
-	register unsigned char* cp = (unsigned char*) lp;
-	unsigned char t;
-
-	t = cp[3]; cp[3] = cp[0]; cp[0] = t;
-	t = cp[2]; cp[2] = cp[1]; cp[1] = t;
-}
-#endif
-
-#ifndef TIFFSwabArrayOfShort
-void
-TIFFSwabArrayOfShort(uint16* wp, register unsigned long n)
-{
-	register unsigned char* cp;
-	register unsigned char t;
-
-	/* XXX unroll loop some */
-	while (n-- > 0) {
-		cp = (unsigned char*) wp;
-		t = cp[1]; cp[1] = cp[0]; cp[0] = t;
-		wp++;
-	}
-}
-#endif
-
-#ifndef TIFFSwabArrayOfTriples
-void
-TIFFSwabArrayOfTriples(uint8* tp, unsigned long n)
-{
-	unsigned char* cp;
-	unsigned char t;
-
-	/* XXX unroll loop some */
-	while (n-- > 0) {
-		cp = (unsigned char*) tp;
-		t = cp[2]; cp[2] = cp[0]; cp[0] = t;
-		tp += 3;
-	}
-}
-#endif
-
-#ifndef TIFFSwabArrayOfLong
-void
-TIFFSwabArrayOfLong(register uint32* lp, register unsigned long n)
-{
-	register unsigned char *cp;
-	register unsigned char t;
-
-	/* XXX unroll loop some */
-	while (n-- > 0) {
-		cp = (unsigned char *)lp;
-		t = cp[3]; cp[3] = cp[0]; cp[0] = t;
-		t = cp[2]; cp[2] = cp[1]; cp[1] = t;
-		lp++;
-	}
-}
-#endif
-
-#ifndef TIFFSwabDouble
-void
-TIFFSwabDouble(double *dp)
-{
-        register uint32* lp = (uint32*) dp;
-        uint32 t;
-
-	TIFFSwabArrayOfLong(lp, 2);
-	t = lp[0]; lp[0] = lp[1]; lp[1] = t;
-}
-#endif
-
-#ifndef TIFFSwabArrayOfDouble
-void
-TIFFSwabArrayOfDouble(double* dp, register unsigned long n)
-{
-	register uint32* lp = (uint32*) dp;
-        register uint32 t;
-
-	TIFFSwabArrayOfLong(lp, n + n);
-        while (n-- > 0) {
-		t = lp[0]; lp[0] = lp[1]; lp[1] = t;
-                lp += 2;
-        }
-}
-#endif
-
-/*
- * Bit reversal tables.  TIFFBitRevTable[<byte>] gives
- * the bit reversed value of <byte>.  Used in various
- * places in the library when the FillOrder requires
- * bit reversal of byte values (e.g. CCITT Fax 3
- * encoding/decoding).  TIFFNoBitRevTable is provided
- * for algorithms that want an equivalent table that
- * do not reverse bit values.
- */
-static const unsigned char TIFFBitRevTable[256] = {
-    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
-    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
-    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
-    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
-    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
-    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
-    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
-    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
-    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
-    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
-    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
-    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
-    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
-    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
-    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
-    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
-    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
-    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
-    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
-    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
-    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
-    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
-    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
-    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
-    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
-    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
-    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
-    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
-    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
-    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
-    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
-    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
-};
-static const unsigned char TIFFNoBitRevTable[256] = {
-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 
-    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
-    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
-    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
-    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
-    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
-    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
-    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
-    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
-    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
-    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 
-    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
-    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 
-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 
-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 
-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 
-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 
-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 
-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 
-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 
-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 
-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 
-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 
-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 
-};
-
-const unsigned char*
-TIFFGetBitRevTable(int reversed)
-{
-	return (reversed ? TIFFBitRevTable : TIFFNoBitRevTable);
-}
-
-void
-TIFFReverseBits(register unsigned char* cp, register unsigned long n)
-{
-	for (; n > 8; n -= 8) {
-		cp[0] = TIFFBitRevTable[cp[0]];
-		cp[1] = TIFFBitRevTable[cp[1]];
-		cp[2] = TIFFBitRevTable[cp[2]];
-		cp[3] = TIFFBitRevTable[cp[3]];
-		cp[4] = TIFFBitRevTable[cp[4]];
-		cp[5] = TIFFBitRevTable[cp[5]];
-		cp[6] = TIFFBitRevTable[cp[6]];
-		cp[7] = TIFFBitRevTable[cp[7]];
-		cp += 8;
-	}
-	while (n-- > 0)
-		*cp = TIFFBitRevTable[*cp], cp++;
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_thunder.c b/thirdparty/libtiff/tif_thunder.c
deleted file mode 100644
index 8e7a125..0000000
--- a/thirdparty/libtiff/tif_thunder.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/* $Id: tif_thunder.c,v 1.5.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef THUNDER_SUPPORT
-/*
- * TIFF Library.
- *
- * ThunderScan 4-bit Compression Algorithm Support
- */
-
-/*
- * ThunderScan uses an encoding scheme designed for
- * 4-bit pixel values.  Data is encoded in bytes, with
- * each byte split into a 2-bit code word and a 6-bit
- * data value.  The encoding gives raw data, runs of
- * pixels, or pixel values encoded as a delta from the
- * previous pixel value.  For the latter, either 2-bit
- * or 3-bit delta values are used, with the deltas packed
- * into a single byte.
- */
-#define	THUNDER_DATA		0x3f	/* mask for 6-bit data */
-#define	THUNDER_CODE		0xc0	/* mask for 2-bit code word */
-/* code values */
-#define	THUNDER_RUN		0x00	/* run of pixels w/ encoded count */
-#define	THUNDER_2BITDELTAS	0x40	/* 3 pixels w/ encoded 2-bit deltas */
-#define	    DELTA2_SKIP		2	/* skip code for 2-bit deltas */
-#define	THUNDER_3BITDELTAS	0x80	/* 2 pixels w/ encoded 3-bit deltas */
-#define	    DELTA3_SKIP		4	/* skip code for 3-bit deltas */
-#define	THUNDER_RAW		0xc0	/* raw data encoded */
-
-static const int twobitdeltas[4] = { 0, 1, 0, -1 };
-static const int threebitdeltas[8] = { 0, 1, 2, 3, 0, -3, -2, -1 };
-
-#define	SETPIXEL(op, v) { \
-	lastpixel = (v) & 0xf; \
-	if (npixels++ & 1) \
-	    *op++ |= lastpixel; \
-	else \
-	    op[0] = (tidataval_t) (lastpixel << 4); \
-}
-
-static int
-ThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels)
-{
-	register unsigned char *bp;
-	register tsize_t cc;
-	unsigned int lastpixel;
-	tsize_t npixels;
-
-	bp = (unsigned char *)tif->tif_rawcp;
-	cc = tif->tif_rawcc;
-	lastpixel = 0;
-	npixels = 0;
-	while (cc > 0 && npixels < maxpixels) {
-		int n, delta;
-
-		n = *bp++, cc--;
-		switch (n & THUNDER_CODE) {
-		case THUNDER_RUN:		/* pixel run */
-			/*
-			 * Replicate the last pixel n times,
-			 * where n is the lower-order 6 bits.
-			 */
-			if (npixels & 1) {
-				op[0] |= lastpixel;
-				lastpixel = *op++; npixels++; n--;
-			} else
-				lastpixel |= lastpixel << 4;
-			npixels += n;
-			if (npixels < maxpixels) {
-				for (; n > 0; n -= 2)
-					*op++ = (tidataval_t) lastpixel;
-			}
-			if (n == -1)
-				*--op &= 0xf0;
-			lastpixel &= 0xf;
-			break;
-		case THUNDER_2BITDELTAS:	/* 2-bit deltas */
-			if ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)
-				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
-			if ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)
-				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
-			if ((delta = (n & 3)) != DELTA2_SKIP)
-				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
-			break;
-		case THUNDER_3BITDELTAS:	/* 3-bit deltas */
-			if ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)
-				SETPIXEL(op, lastpixel + threebitdeltas[delta]);
-			if ((delta = (n & 7)) != DELTA3_SKIP)
-				SETPIXEL(op, lastpixel + threebitdeltas[delta]);
-			break;
-		case THUNDER_RAW:		/* raw data */
-			SETPIXEL(op, n);
-			break;
-		}
-	}
-	tif->tif_rawcp = (tidata_t) bp;
-	tif->tif_rawcc = cc;
-	if (npixels != maxpixels) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		    "ThunderDecode: %s data at scanline %ld (%lu != %lu)",
-		    npixels < maxpixels ? "Not enough" : "Too much",
-		    (long) tif->tif_row, (long) npixels, (long) maxpixels);
-		return (0);
-	}
-	return (1);
-}
-
-static int
-ThunderDecodeRow(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
-{
-	tidata_t row = buf;
-	
-	(void) s;
-	while ((long)occ > 0) {
-		if (!ThunderDecode(tif, row, tif->tif_dir.td_imagewidth))
-			return (0);
-		occ -= tif->tif_scanlinesize;
-		row += tif->tif_scanlinesize;
-	}
-	return (1);
-}
-
-int
-TIFFInitThunderScan(TIFF* tif, int scheme)
-{
-	(void) scheme;
-	tif->tif_decoderow = ThunderDecodeRow;
-	tif->tif_decodestrip = ThunderDecodeRow;
-	return (1);
-}
-#endif /* THUNDER_SUPPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_tile.c b/thirdparty/libtiff/tif_tile.c
deleted file mode 100644
index d8379e6..0000000
--- a/thirdparty/libtiff/tif_tile.c
+++ /dev/null
@@ -1,280 +0,0 @@
-/* $Id: tif_tile.c,v 1.12.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1991-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Tiled Image Support Routines.
- */
-#include "tiffiop.h"
-
-static uint32
-summarize(TIFF* tif, size_t summand1, size_t summand2, const char* where)
-{
-	/*
-	 * XXX: We are using casting to uint32 here, because sizeof(size_t)
-	 * may be larger than sizeof(uint32) on 64-bit architectures.
-	 */
-	uint32	bytes = summand1 + summand2;
-
-	if (bytes - summand1 != summand2) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Integer overflow in %s", where);
-		bytes = 0;
-	}
-
-	return (bytes);
-}
-
-static uint32
-multiply(TIFF* tif, size_t nmemb, size_t elem_size, const char* where)
-{
-	uint32	bytes = nmemb * elem_size;
-
-	if (elem_size && bytes / elem_size != nmemb) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Integer overflow in %s", where);
-		bytes = 0;
-	}
-
-	return (bytes);
-}
-
-/*
- * Compute which tile an (x,y,z,s) value is in.
- */
-ttile_t
-TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, tsample_t s)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	uint32 dx = td->td_tilewidth;
-	uint32 dy = td->td_tilelength;
-	uint32 dz = td->td_tiledepth;
-	ttile_t tile = 1;
-
-	if (td->td_imagedepth == 1)
-		z = 0;
-	if (dx == (uint32) -1)
-		dx = td->td_imagewidth;
-	if (dy == (uint32) -1)
-		dy = td->td_imagelength;
-	if (dz == (uint32) -1)
-		dz = td->td_imagedepth;
-	if (dx != 0 && dy != 0 && dz != 0) {
-		uint32 xpt = TIFFhowmany(td->td_imagewidth, dx); 
-		uint32 ypt = TIFFhowmany(td->td_imagelength, dy); 
-		uint32 zpt = TIFFhowmany(td->td_imagedepth, dz); 
-
-		if (td->td_planarconfig == PLANARCONFIG_SEPARATE) 
-			tile = (xpt*ypt*zpt)*s +
-			     (xpt*ypt)*(z/dz) +
-			     xpt*(y/dy) +
-			     x/dx;
-		else
-			tile = (xpt*ypt)*(z/dz) + xpt*(y/dy) + x/dx;
-	}
-	return (tile);
-}
-
-/*
- * Check an (x,y,z,s) coordinate
- * against the image bounds.
- */
-int
-TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, tsample_t s)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if (x >= td->td_imagewidth) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Col out of range, max %lu",
-			     (unsigned long) x,
-			     (unsigned long) (td->td_imagewidth - 1));
-		return (0);
-	}
-	if (y >= td->td_imagelength) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Row out of range, max %lu",
-			     (unsigned long) y,
-			     (unsigned long) (td->td_imagelength - 1));
-		return (0);
-	}
-	if (z >= td->td_imagedepth) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Depth out of range, max %lu",
-			     (unsigned long) z,
-			     (unsigned long) (td->td_imagedepth - 1));
-		return (0);
-	}
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE &&
-	    s >= td->td_samplesperpixel) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			     "%lu: Sample out of range, max %lu",
-			     (unsigned long) s,
-			     (unsigned long) (td->td_samplesperpixel - 1));
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * Compute how many tiles are in an image.
- */
-ttile_t
-TIFFNumberOfTiles(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	uint32 dx = td->td_tilewidth;
-	uint32 dy = td->td_tilelength;
-	uint32 dz = td->td_tiledepth;
-	ttile_t ntiles;
-
-	if (dx == (uint32) -1)
-		dx = td->td_imagewidth;
-	if (dy == (uint32) -1)
-		dy = td->td_imagelength;
-	if (dz == (uint32) -1)
-		dz = td->td_imagedepth;
-	ntiles = (dx == 0 || dy == 0 || dz == 0) ? 0 :
-	    multiply(tif, multiply(tif, TIFFhowmany(td->td_imagewidth, dx),
-				   TIFFhowmany(td->td_imagelength, dy),
-				   "TIFFNumberOfTiles"),
-		     TIFFhowmany(td->td_imagedepth, dz), "TIFFNumberOfTiles");
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		ntiles = multiply(tif, ntiles, td->td_samplesperpixel,
-				  "TIFFNumberOfTiles");
-	return (ntiles);
-}
-
-/*
- * Compute the # bytes in each row of a tile.
- */
-tsize_t
-TIFFTileRowSize(TIFF* tif)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t rowsize;
-	
-	if (td->td_tilelength == 0 || td->td_tilewidth == 0)
-		return ((tsize_t) 0);
-	rowsize = multiply(tif, td->td_bitspersample, td->td_tilewidth,
-			   "TIFFTileRowSize");
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG)
-		rowsize = multiply(tif, rowsize, td->td_samplesperpixel,
-				   "TIFFTileRowSize");
-	return ((tsize_t) TIFFhowmany8(rowsize));
-}
-
-/*
- * Compute the # bytes in a variable length, row-aligned tile.
- */
-tsize_t
-TIFFVTileSize(TIFF* tif, uint32 nrows)
-{
-	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t tilesize;
-
-	if (td->td_tilelength == 0 || td->td_tilewidth == 0 ||
-	    td->td_tiledepth == 0)
-		return ((tsize_t) 0);
-	if (td->td_planarconfig == PLANARCONFIG_CONTIG &&
-	    td->td_photometric == PHOTOMETRIC_YCBCR &&
-	    !isUpSampled(tif)) {
-		/*
-		 * Packed YCbCr data contain one Cb+Cr for every
-		 * HorizontalSampling*VerticalSampling Y values.
-		 * Must also roundup width and height when calculating
-		 * since images that are not a multiple of the
-		 * horizontal/vertical subsampling area include
-		 * YCbCr data for the extended image.
-		 */
-		tsize_t w =
-		    TIFFroundup(td->td_tilewidth, td->td_ycbcrsubsampling[0]);
-		tsize_t rowsize =
-		    TIFFhowmany8(multiply(tif, w, td->td_bitspersample,
-					  "TIFFVTileSize"));
-		tsize_t samplingarea =
-		    td->td_ycbcrsubsampling[0]*td->td_ycbcrsubsampling[1];
-		if (samplingarea == 0) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Invalid YCbCr subsampling");
-			return 0;
-		}
-		nrows = TIFFroundup(nrows, td->td_ycbcrsubsampling[1]);
-		/* NB: don't need TIFFhowmany here 'cuz everything is rounded */
-		tilesize = multiply(tif, nrows, rowsize, "TIFFVTileSize");
-		tilesize = summarize(tif, tilesize,
-				     multiply(tif, 2, tilesize / samplingarea,
-					      "TIFFVTileSize"),
-				     "TIFFVTileSize");
-	} else
-		tilesize = multiply(tif, nrows, TIFFTileRowSize(tif),
-				    "TIFFVTileSize");
-	return ((tsize_t)
-	    multiply(tif, tilesize, td->td_tiledepth, "TIFFVTileSize"));
-}
-
-/*
- * Compute the # bytes in a row-aligned tile.
- */
-tsize_t
-TIFFTileSize(TIFF* tif)
-{
-	return (TIFFVTileSize(tif, tif->tif_dir.td_tilelength));
-}
-
-/*
- * Compute a default tile size based on the image
- * characteristics and a requested value.  If a
- * request is <1 then we choose a size according
- * to certain heuristics.
- */
-void
-TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
-{
-	(*tif->tif_deftilesize)(tif, tw, th);
-}
-
-void
-_TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)
-{
-	(void) tif;
-	if (*(int32*) tw < 1)
-		*tw = 256;
-	if (*(int32*) th < 1)
-		*th = 256;
-	/* roundup to a multiple of 16 per the spec */
-	if (*tw & 0xf)
-		*tw = TIFFroundup(*tw, 16);
-	if (*th & 0xf)
-		*th = TIFFroundup(*th, 16);
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_unix.c b/thirdparty/libtiff/tif_unix.c
deleted file mode 100644
index e0f1a8d..0000000
--- a/thirdparty/libtiff/tif_unix.c
+++ /dev/null
@@ -1,296 +0,0 @@
-/* $Id: tif_unix.c,v 1.12.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library UNIX-specific Routines. These are should also work with the
- * Windows Common RunTime Library.
- */
-#include "tif_config.h"
-
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <sys/stat.h>
-
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-
-#include "tiffiop.h"
-
-static tsize_t
-_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	return ((tsize_t) read((int) fd, buf, (size_t) size));
-}
-
-static tsize_t
-_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	return ((tsize_t) write((int) fd, buf, (size_t) size));
-}
-
-static toff_t
-_tiffSeekProc(thandle_t fd, toff_t off, int whence)
-{
-	return ((toff_t) lseek((int) fd, (off_t) off, whence));
-}
-
-static int
-_tiffCloseProc(thandle_t fd)
-{
-	return (close((int) fd));
-}
-
-
-static toff_t
-_tiffSizeProc(thandle_t fd)
-{
-#ifdef _AM29K
-	long fsize;
-	return ((fsize = lseek((int) fd, 0, SEEK_END)) < 0 ? 0 : fsize);
-#else
-	struct stat sb;
-	return (toff_t) (fstat((int) fd, &sb) < 0 ? 0 : sb.st_size);
-#endif
-}
-
-#ifdef HAVE_MMAP
-#include <sys/mman.h>
-
-static int
-_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	toff_t size = _tiffSizeProc(fd);
-	if (size != (toff_t) -1) {
-		*pbase = (tdata_t)
-		    mmap(0, size, PROT_READ, MAP_SHARED, (int) fd, 0);
-		if (*pbase != (tdata_t) -1) {
-			*psize = size;
-			return (1);
-		}
-	}
-	return (0);
-}
-
-static void
-_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-	(void) fd;
-	(void) munmap(base, (off_t) size);
-}
-#else /* !HAVE_MMAP */
-static int
-_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	(void) fd; (void) pbase; (void) psize;
-	return (0);
-}
-
-static void
-_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-	(void) fd; (void) base; (void) size;
-}
-#endif /* !HAVE_MMAP */
-
-/*
- * Open a TIFF file descriptor for read/writing.
- */
-TIFF*
-TIFFFdOpen(int fd, const char* name, const char* mode)
-{
-	TIFF* tif;
-
-	tif = TIFFClientOpen(name, mode,
-	    (thandle_t) fd,
-	    _tiffReadProc, _tiffWriteProc,
-	    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
-	    _tiffMapProc, _tiffUnmapProc);
-	if (tif)
-		tif->tif_fd = fd;
-	return (tif);
-}
-
-/*
- * Open a TIFF file for read/writing.
- */
-TIFF*
-TIFFOpen(const char* name, const char* mode)
-{
-	static const char module[] = "TIFFOpen";
-	int m, fd;
-        TIFF* tif;
-
-	m = _TIFFgetMode(mode, module);
-	if (m == -1)
-		return ((TIFF*)0);
-
-/* for cygwin and mingw */        
-#ifdef O_BINARY
-        m |= O_BINARY;
-#endif        
-        
-#ifdef _AM29K
-	fd = open(name, m);
-#else
-	fd = open(name, m, 0666);
-#endif
-	if (fd < 0) {
-		TIFFErrorExt(0, module, "%s: Cannot open", name);
-		return ((TIFF *)0);
-	}
-
-	tif = TIFFFdOpen((int)fd, name, mode);
-	if(!tif)
-		close(fd);
-	return tif;
-}
-
-#ifdef __WIN32__
-#include <windows.h>
-/*
- * Open a TIFF file with a Unicode filename, for read/writing.
- */
-TIFF*
-TIFFOpenW(const wchar_t* name, const char* mode)
-{
-	static const char module[] = "TIFFOpenW";
-	int m, fd;
-	int mbsize;
-	char *mbname;
-	TIFF* tif;
-
-	m = _TIFFgetMode(mode, module);
-	if (m == -1)
-		return ((TIFF*)0);
-
-/* for cygwin and mingw */        
-#ifdef O_BINARY
-        m |= O_BINARY;
-#endif        
-        
-	fd = _wopen(name, m, 0666);
-	if (fd < 0) {
-		TIFFErrorExt(0, module, "%s: Cannot open", name);
-		return ((TIFF *)0);
-	}
-
-	mbname = NULL;
-	mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);
-	if (mbsize > 0) {
-		mbname = _TIFFmalloc(mbsize);
-		if (!mbname) {
-			TIFFErrorExt(0, module,
-			"Can't allocate space for filename conversion buffer");
-			return ((TIFF*)0);
-		}
-
-		WideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,
-				    NULL, NULL);
-	}
-
-	tif = TIFFFdOpen((int)fd, (mbname != NULL) ? mbname : "<unknown>",
-			 mode);
-	
-	_TIFFfree(mbname);
-	
-	if(!tif)
-		close(fd);
-	return tif;
-}
-#endif
-
-void*
-_TIFFmalloc(tsize_t s)
-{
-	return (malloc((size_t) s));
-}
-
-void
-_TIFFfree(tdata_t p)
-{
-	free(p);
-}
-
-void*
-_TIFFrealloc(tdata_t p, tsize_t s)
-{
-	return (realloc(p, (size_t) s));
-}
-
-void
-_TIFFmemset(tdata_t p, int v, tsize_t c)
-{
-	memset(p, v, (size_t) c);
-}
-
-void
-_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c)
-{
-	memcpy(d, s, (size_t) c);
-}
-
-int
-_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)
-{
-	return (memcmp(p1, p2, (size_t) c));
-}
-
-static void
-unixWarningHandler(const char* module, const char* fmt, va_list ap)
-{
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	fprintf(stderr, "Warning, ");
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-}
-TIFFErrorHandler _TIFFwarningHandler = unixWarningHandler;
-
-static void
-unixErrorHandler(const char* module, const char* fmt, va_list ap)
-{
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-}
-TIFFErrorHandler _TIFFerrorHandler = unixErrorHandler;
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_version.c b/thirdparty/libtiff/tif_version.c
deleted file mode 100644
index 218dab5..0000000
--- a/thirdparty/libtiff/tif_version.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_version.c,v 1.2.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-/*
- * Copyright (c) 1992-1997 Sam Leffler
- * Copyright (c) 1992-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-#include "tiffiop.h"
-
-static const char TIFFVersion[] = TIFFLIB_VERSION_STR;
-
-const char*
-TIFFGetVersion(void)
-{
-	return (TIFFVersion);
-}
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_warning.c b/thirdparty/libtiff/tif_warning.c
deleted file mode 100644
index fe974d9..0000000
--- a/thirdparty/libtiff/tif_warning.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_warning.c,v 1.2.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- */
-#include "tiffiop.h"
-
-TIFFErrorHandlerExt _TIFFwarningHandlerExt = NULL;
-
-TIFFErrorHandler
-TIFFSetWarningHandler(TIFFErrorHandler handler)
-{
-	TIFFErrorHandler prev = _TIFFwarningHandler;
-	_TIFFwarningHandler = handler;
-	return (prev);
-}
-
-TIFFErrorHandlerExt
-TIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler)
-{
-	TIFFErrorHandlerExt prev = _TIFFwarningHandlerExt;
-	_TIFFwarningHandlerExt = handler;
-	return (prev);
-}
-
-void
-TIFFWarning(const char* module, const char* fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	if (_TIFFwarningHandler)
-		(*_TIFFwarningHandler)(module, fmt, ap);
-	if (_TIFFwarningHandlerExt)
-		(*_TIFFwarningHandlerExt)(0, module, fmt, ap);
-	va_end(ap);
-}
-
-void
-TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	if (_TIFFwarningHandler)
-		(*_TIFFwarningHandler)(module, fmt, ap);
-	if (_TIFFwarningHandlerExt)
-		(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);
-	va_end(ap);
-}
-
-
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_win32.c b/thirdparty/libtiff/tif_win32.c
deleted file mode 100644
index 2ab944b..0000000
--- a/thirdparty/libtiff/tif_win32.c
+++ /dev/null
@@ -1,408 +0,0 @@
-/* $Id: tif_win32.c,v 1.21.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library Win32-specific Routines.  Adapted from tif_unix.c 4/5/95 by
- * Scott Wagner (wagner@itek.com), Itek Graphix, Rochester, NY USA
- */
-#include "tiffiop.h"
-
-#include <windows.h>
-
-static tsize_t
-_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	DWORD dwSizeRead;
-	if (!ReadFile(fd, buf, size, &dwSizeRead, NULL))
-		return(0);
-	return ((tsize_t) dwSizeRead);
-}
-
-static tsize_t
-_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)
-{
-	DWORD dwSizeWritten;
-	if (!WriteFile(fd, buf, size, &dwSizeWritten, NULL))
-		return(0);
-	return ((tsize_t) dwSizeWritten);
-}
-
-static toff_t
-_tiffSeekProc(thandle_t fd, toff_t off, int whence)
-{
-        ULARGE_INTEGER li;
-	DWORD dwMoveMethod;
-
-	li.QuadPart = off;
-        
-	switch(whence)
-	{
-	case SEEK_SET:
-		dwMoveMethod = FILE_BEGIN;
-		break;
-	case SEEK_CUR:
-		dwMoveMethod = FILE_CURRENT;
-		break;
-	case SEEK_END:
-		dwMoveMethod = FILE_END;
-		break;
-	default:
-		dwMoveMethod = FILE_BEGIN;
-		break;
-	}
-	return ((toff_t)SetFilePointer(fd, (LONG) li.LowPart,
-				       (PLONG)&li.HighPart, dwMoveMethod));
-}
-
-static int
-_tiffCloseProc(thandle_t fd)
-{
-	return (CloseHandle(fd) ? 0 : -1);
-}
-
-static toff_t
-_tiffSizeProc(thandle_t fd)
-{
-	return ((toff_t)GetFileSize(fd, NULL));
-}
-
-static int
-_tiffDummyMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	(void) fd;
-	(void) pbase;
-	(void) psize;
-	return (0);
-}
-
-/*
- * From "Hermann Josef Hill" <lhill@rhein-zeitung.de>:
- *
- * Windows uses both a handle and a pointer for file mapping,
- * but according to the SDK documentation and Richter's book
- * "Advanced Windows Programming" it is safe to free the handle
- * after obtaining the file mapping pointer
- *
- * This removes a nasty OS dependency and cures a problem
- * with Visual C++ 5.0
- */
-static int
-_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
-{
-	toff_t size;
-	HANDLE hMapFile;
-
-	if ((size = _tiffSizeProc(fd)) == 0xFFFFFFFF)
-		return (0);
-	hMapFile = CreateFileMapping(fd, NULL, PAGE_READONLY, 0, size, NULL);
-	if (hMapFile == NULL)
-		return (0);
-	*pbase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
-	CloseHandle(hMapFile);
-	if (*pbase == NULL)
-		return (0);
-	*psize = size;
-	return(1);
-}
-
-static void
-_tiffDummyUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-	(void) fd;
-	(void) base;
-	(void) size;
-}
-
-static void
-_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)
-{
-	UnmapViewOfFile(base);
-}
-
-/*
- * Open a TIFF file descriptor for read/writing.
- * Note that TIFFFdOpen and TIFFOpen recognise the character 'u' in the mode
- * string, which forces the file to be opened unmapped.
- */
-TIFF*
-TIFFFdOpen(int ifd, const char* name, const char* mode)
-{
-	TIFF* tif;
-	BOOL fSuppressMap = (mode[1] == 'u' || (mode[1]!=0 && mode[2] == 'u'));
-
-	tif = TIFFClientOpen(name, mode, (thandle_t)ifd,
-			_tiffReadProc, _tiffWriteProc,
-			_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
-			fSuppressMap ? _tiffDummyMapProc : _tiffMapProc,
-			fSuppressMap ? _tiffDummyUnmapProc : _tiffUnmapProc);
-	if (tif)
-		tif->tif_fd = ifd;
-	return (tif);
-}
-
-#ifndef _WIN32_WCE
-
-/*
- * Open a TIFF file for read/writing.
- */
-TIFF*
-TIFFOpen(const char* name, const char* mode)
-{
-	static const char module[] = "TIFFOpen";
-	thandle_t fd;
-	int m;
-	DWORD dwMode;
-	TIFF* tif;
-
-	m = _TIFFgetMode(mode, module);
-
-	switch(m)
-	{
-	case O_RDONLY:
-		dwMode = OPEN_EXISTING;
-		break;
-	case O_RDWR:
-		dwMode = OPEN_ALWAYS;
-		break;
-	case O_RDWR|O_CREAT:
-		dwMode = OPEN_ALWAYS;
-		break;
-	case O_RDWR|O_TRUNC:
-		dwMode = CREATE_ALWAYS;
-		break;
-	case O_RDWR|O_CREAT|O_TRUNC:
-		dwMode = CREATE_ALWAYS;
-		break;
-	default:
-		return ((TIFF*)0);
-	}
-	fd = (thandle_t)CreateFileA(name,
-		(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE),
-		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,
-		(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,
-		NULL);
-	if (fd == INVALID_HANDLE_VALUE) {
-		TIFFErrorExt(0, module, "%s: Cannot open", name);
-		return ((TIFF *)0);
-	}
-
-	tif = TIFFFdOpen((int)fd, name, mode);
-	if(!tif)
-		CloseHandle(fd);
-	return tif;
-}
-
-/*
- * Open a TIFF file with a Unicode filename, for read/writing.
- */
-TIFF*
-TIFFOpenW(const wchar_t* name, const char* mode)
-{
-	static const char module[] = "TIFFOpenW";
-	thandle_t fd;
-	int m;
-	DWORD dwMode;
-	int mbsize;
-	char *mbname;
-	TIFF *tif;
-
-	m = _TIFFgetMode(mode, module);
-
-	switch(m) {
-		case O_RDONLY:			dwMode = OPEN_EXISTING; break;
-		case O_RDWR:			dwMode = OPEN_ALWAYS;   break;
-		case O_RDWR|O_CREAT:		dwMode = OPEN_ALWAYS;   break;
-		case O_RDWR|O_TRUNC:		dwMode = CREATE_ALWAYS; break;
-		case O_RDWR|O_CREAT|O_TRUNC:	dwMode = CREATE_ALWAYS; break;
-		default:			return ((TIFF*)0);
-	}
-
-	fd = (thandle_t)CreateFileW(name,
-		(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),
-		FILE_SHARE_READ, NULL, dwMode,
-		(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,
-		NULL);
-	if (fd == INVALID_HANDLE_VALUE) {
-		TIFFErrorExt(0, module, "%S: Cannot open", name);
-		return ((TIFF *)0);
-	}
-
-	mbname = NULL;
-	mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);
-	if (mbsize > 0) {
-		mbname = (char *)_TIFFmalloc(mbsize);
-		if (!mbname) {
-			TIFFErrorExt(0, module,
-			"Can't allocate space for filename conversion buffer");
-			return ((TIFF*)0);
-		}
-
-		WideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,
-				    NULL, NULL);
-	}
-
-	tif = TIFFFdOpen((int)fd,
-			 (mbname != NULL) ? mbname : "<unknown>", mode);
-	if(!tif)
-		CloseHandle(fd);
-
-	_TIFFfree(mbname);
-
-	return tif;
-}
-
-#endif /* ndef _WIN32_WCE */
-
-
-tdata_t
-_TIFFmalloc(tsize_t s)
-{
-	return ((tdata_t)GlobalAlloc(GMEM_FIXED, s));
-}
-
-void
-_TIFFfree(tdata_t p)
-{
-	GlobalFree(p);
-	return;
-}
-
-tdata_t
-_TIFFrealloc(tdata_t p, tsize_t s)
-{
-	void* pvTmp;
-	tsize_t old;
-
-	if(p == NULL)
-		return ((tdata_t)GlobalAlloc(GMEM_FIXED, s));
-
-	old = GlobalSize(p);
-
-	if (old>=s) {
-		if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) {
-			CopyMemory(pvTmp, p, s);
-			GlobalFree(p);
-		}
-	} else {
-		if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) {
-			CopyMemory(pvTmp, p, old);
-			GlobalFree(p);
-		}
-	}
-	return ((tdata_t)pvTmp);
-}
-
-void
-_TIFFmemset(void* p, int v, tsize_t c)
-{
-	FillMemory(p, c, (BYTE)v);
-}
-
-void
-_TIFFmemcpy(void* d, const tdata_t s, tsize_t c)
-{
-	CopyMemory(d, s, c);
-}
-
-int
-_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)
-{
-	register const BYTE *pb1 = (const BYTE *) p1;
-	register const BYTE *pb2 = (const BYTE *) p2;
-	register DWORD dwTmp = c;
-	register int iTmp;
-	for (iTmp = 0; dwTmp-- && !iTmp; iTmp = (int)*pb1++ - (int)*pb2++)
-		;
-	return (iTmp);
-}
-
-#ifndef _WIN32_WCE
-
-static void
-Win32WarningHandler(const char* module, const char* fmt, va_list ap)
-{
-#ifndef TIF_PLATFORM_CONSOLE
-	LPTSTR szTitle;
-	LPTSTR szTmp;
-	LPCTSTR szTitleText = "%s Warning";
-	LPCTSTR szDefaultModule = "LIBTIFF";
-	LPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;
-	if ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +
-		strlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)
-		return;
-	sprintf(szTitle, szTitleText, szTmpModule);
-	szTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);
-	vsprintf(szTmp, fmt, ap);
-	MessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);
-	LocalFree(szTitle);
-	return;
-#else
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	fprintf(stderr, "Warning, ");
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-#endif        
-}
-TIFFErrorHandler _TIFFwarningHandler = Win32WarningHandler;
-
-static void
-Win32ErrorHandler(const char* module, const char* fmt, va_list ap)
-{
-#ifndef TIF_PLATFORM_CONSOLE
-	LPTSTR szTitle;
-	LPTSTR szTmp;
-	LPCTSTR szTitleText = "%s Error";
-	LPCTSTR szDefaultModule = "LIBTIFF";
-	LPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;
-	if ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +
-		strlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)
-		return;
-	sprintf(szTitle, szTitleText, szTmpModule);
-	szTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);
-	vsprintf(szTmp, fmt, ap);
-	MessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);
-	LocalFree(szTitle);
-	return;
-#else
-	if (module != NULL)
-		fprintf(stderr, "%s: ", module);
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ".\n");
-#endif        
-}
-TIFFErrorHandler _TIFFerrorHandler = Win32ErrorHandler;
-
-#endif /* ndef _WIN32_WCE */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_write.c b/thirdparty/libtiff/tif_write.c
deleted file mode 100644
index bd08418..0000000
--- a/thirdparty/libtiff/tif_write.c
+++ /dev/null
@@ -1,718 +0,0 @@
-/* $Id: tif_write.c,v 1.22.2.5 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-/*
- * TIFF Library.
- *
- * Scanline-oriented Write Support
- */
-#include "tiffiop.h"
-#include <stdio.h>
-
-#define	STRIPINCR	20		/* expansion factor on strip array */
-
-#define	WRITECHECKSTRIPS(tif, module)				\
-	(((tif)->tif_flags&TIFF_BEENWRITING) || TIFFWriteCheck((tif),0,module))
-#define	WRITECHECKTILES(tif, module)				\
-	(((tif)->tif_flags&TIFF_BEENWRITING) || TIFFWriteCheck((tif),1,module))
-#define	BUFFERCHECK(tif)					\
-	((((tif)->tif_flags & TIFF_BUFFERSETUP) && tif->tif_rawdata) ||	\
-	    TIFFWriteBufferSetup((tif), NULL, (tsize_t) -1))
-
-static	int TIFFGrowStrips(TIFF*, int, const char*);
-static	int TIFFAppendToStrip(TIFF*, tstrip_t, tidata_t, tsize_t);
-
-int
-TIFFWriteScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample)
-{
-	static const char module[] = "TIFFWriteScanline";
-	register TIFFDirectory *td;
-	int status, imagegrew = 0;
-	tstrip_t strip;
-
-	if (!WRITECHECKSTRIPS(tif, module))
-		return (-1);
-	/*
-	 * Handle delayed allocation of data buffer.  This
-	 * permits it to be sized more intelligently (using
-	 * directory information).
-	 */
-	if (!BUFFERCHECK(tif))
-		return (-1);
-	td = &tif->tif_dir;
-	/*
-	 * Extend image length if needed
-	 * (but only for PlanarConfig=1).
-	 */
-	if (row >= td->td_imagelength) {	/* extend image */
-		if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"Can not change \"ImageLength\" when using separate planes");
-			return (-1);
-		}
-		td->td_imagelength = row+1;
-		imagegrew = 1;
-	}
-	/*
-	 * Calculate strip and check for crossings.
-	 */
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-		if (sample >= td->td_samplesperpixel) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-			    "%d: Sample out of range, max %d",
-			    sample, td->td_samplesperpixel);
-			return (-1);
-		}
-		strip = sample*td->td_stripsperimage + row/td->td_rowsperstrip;
-	} else
-		strip = row / td->td_rowsperstrip;
-	/*
-	 * Check strip array to make sure there's space. We don't support
-	 * dynamically growing files that have data organized in separate
-	 * bitplanes because it's too painful.  In that case we require that
-	 * the imagelength be set properly before the first write (so that the
-	 * strips array will be fully allocated above).
-	 */
-	if (strip >= td->td_nstrips && !TIFFGrowStrips(tif, 1, module))
-		return (-1);
-	if (strip != tif->tif_curstrip) {
-		/*
-		 * Changing strips -- flush any data present.
-		 */
-		if (!TIFFFlushData(tif))
-			return (-1);
-		tif->tif_curstrip = strip;
-		/*
-		 * Watch out for a growing image.  The value of strips/image
-		 * will initially be 1 (since it can't be deduced until the
-		 * imagelength is known).
-		 */
-		if (strip >= td->td_stripsperimage && imagegrew)
-			td->td_stripsperimage =
-			    TIFFhowmany(td->td_imagelength,td->td_rowsperstrip);
-		tif->tif_row =
-		    (strip % td->td_stripsperimage) * td->td_rowsperstrip;
-		if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
-			if (!(*tif->tif_setupencode)(tif))
-				return (-1);
-			tif->tif_flags |= TIFF_CODERSETUP;
-		}
-        
-		tif->tif_rawcc = 0;
-		tif->tif_rawcp = tif->tif_rawdata;
-
-		if( td->td_stripbytecount[strip] > 0 )
-		{
-			/* if we are writing over existing tiles, zero length */
-			td->td_stripbytecount[strip] = 0;
-
-			/* this forces TIFFAppendToStrip() to do a seek */
-			tif->tif_curoff = 0;
-		}
-
-		if (!(*tif->tif_preencode)(tif, sample))
-			return (-1);
-		tif->tif_flags |= TIFF_POSTENCODE;
-	}
-	/*
-	 * Ensure the write is either sequential or at the
-	 * beginning of a strip (or that we can randomly
-	 * access the data -- i.e. no encoding).
-	 */
-	if (row != tif->tif_row) {
-		if (row < tif->tif_row) {
-			/*
-			 * Moving backwards within the same strip:
-			 * backup to the start and then decode
-			 * forward (below).
-			 */
-			tif->tif_row = (strip % td->td_stripsperimage) *
-			    td->td_rowsperstrip;
-			tif->tif_rawcp = tif->tif_rawdata;
-		}
-		/*
-		 * Seek forward to the desired row.
-		 */
-		if (!(*tif->tif_seek)(tif, row - tif->tif_row))
-			return (-1);
-		tif->tif_row = row;
-	}
-
-        /* swab if needed - note that source buffer will be altered */
-        tif->tif_postdecode( tif, (tidata_t) buf, tif->tif_scanlinesize );
-
-	status = (*tif->tif_encoderow)(tif, (tidata_t) buf,
-	    tif->tif_scanlinesize, sample);
-
-        /* we are now poised at the beginning of the next row */
-	tif->tif_row = row + 1;
-	return (status);
-}
-
-/*
- * Encode the supplied data and write it to the
- * specified strip.
- *
- * NB: Image length must be setup before writing.
- */
-tsize_t
-TIFFWriteEncodedStrip(TIFF* tif, tstrip_t strip, tdata_t data, tsize_t cc)
-{
-	static const char module[] = "TIFFWriteEncodedStrip";
-	TIFFDirectory *td = &tif->tif_dir;
-	tsample_t sample;
-
-	if (!WRITECHECKSTRIPS(tif, module))
-		return ((tsize_t) -1);
-	/*
-	 * Check strip array to make sure there's space.
-	 * We don't support dynamically growing files that
-	 * have data organized in separate bitplanes because
-	 * it's too painful.  In that case we require that
-	 * the imagelength be set properly before the first
-	 * write (so that the strips array will be fully
-	 * allocated above).
-	 */
-	if (strip >= td->td_nstrips) {
-		if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"Can not grow image by strips when using separate planes");
-			return ((tsize_t) -1);
-		}
-		if (!TIFFGrowStrips(tif, 1, module))
-			return ((tsize_t) -1);
-		td->td_stripsperimage =
-		    TIFFhowmany(td->td_imagelength, td->td_rowsperstrip);
-	}
-	/*
-	 * Handle delayed allocation of data buffer.  This
-	 * permits it to be sized according to the directory
-	 * info.
-	 */
-	if (!BUFFERCHECK(tif))
-		return ((tsize_t) -1);
-	tif->tif_curstrip = strip;
-	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
-	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
-		if (!(*tif->tif_setupencode)(tif))
-			return ((tsize_t) -1);
-		tif->tif_flags |= TIFF_CODERSETUP;
-	}
-        
-	tif->tif_rawcc = 0;
-	tif->tif_rawcp = tif->tif_rawdata;
-
-        if( td->td_stripbytecount[strip] > 0 )
-        {
-	    /* Force TIFFAppendToStrip() to consider placing data at end
-               of file. */
-            tif->tif_curoff = 0;
-        }
-        
-	tif->tif_flags &= ~TIFF_POSTENCODE;
-	sample = (tsample_t)(strip / td->td_stripsperimage);
-	if (!(*tif->tif_preencode)(tif, sample))
-		return ((tsize_t) -1);
-
-        /* swab if needed - note that source buffer will be altered */
-        tif->tif_postdecode( tif, (tidata_t) data, cc );
-
-	if (!(*tif->tif_encodestrip)(tif, (tidata_t) data, cc, sample))
-		return ((tsize_t) 0);
-	if (!(*tif->tif_postencode)(tif))
-		return ((tsize_t) -1);
-	if (!isFillOrder(tif, td->td_fillorder) &&
-	    (tif->tif_flags & TIFF_NOBITREV) == 0)
-		TIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);
-	if (tif->tif_rawcc > 0 &&
-	    !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))
-		return ((tsize_t) -1);
-	tif->tif_rawcc = 0;
-	tif->tif_rawcp = tif->tif_rawdata;
-	return (cc);
-}
-
-/*
- * Write the supplied data to the specified strip.
- *
- * NB: Image length must be setup before writing.
- */
-tsize_t
-TIFFWriteRawStrip(TIFF* tif, tstrip_t strip, tdata_t data, tsize_t cc)
-{
-	static const char module[] = "TIFFWriteRawStrip";
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if (!WRITECHECKSTRIPS(tif, module))
-		return ((tsize_t) -1);
-	/*
-	 * Check strip array to make sure there's space.
-	 * We don't support dynamically growing files that
-	 * have data organized in separate bitplanes because
-	 * it's too painful.  In that case we require that
-	 * the imagelength be set properly before the first
-	 * write (so that the strips array will be fully
-	 * allocated above).
-	 */
-	if (strip >= td->td_nstrips) {
-		if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
-			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
-		"Can not grow image by strips when using separate planes");
-			return ((tsize_t) -1);
-		}
-		/*
-		 * Watch out for a growing image.  The value of
-		 * strips/image will initially be 1 (since it
-		 * can't be deduced until the imagelength is known).
-		 */
-		if (strip >= td->td_stripsperimage)
-			td->td_stripsperimage =
-			    TIFFhowmany(td->td_imagelength,td->td_rowsperstrip);
-		if (!TIFFGrowStrips(tif, 1, module))
-			return ((tsize_t) -1);
-	}
-	tif->tif_curstrip = strip;
-	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
-	return (TIFFAppendToStrip(tif, strip, (tidata_t) data, cc) ?
-	    cc : (tsize_t) -1);
-}
-
-/*
- * Write and compress a tile of data.  The
- * tile is selected by the (x,y,z,s) coordinates.
- */
-tsize_t
-TIFFWriteTile(TIFF* tif,
-    tdata_t buf, uint32 x, uint32 y, uint32 z, tsample_t s)
-{
-	if (!TIFFCheckTile(tif, x, y, z, s))
-		return (-1);
-	/*
-	 * NB: A tile size of -1 is used instead of tif_tilesize knowing
-	 *     that TIFFWriteEncodedTile will clamp this to the tile size.
-	 *     This is done because the tile size may not be defined until
-	 *     after the output buffer is setup in TIFFWriteBufferSetup.
-	 */
-	return (TIFFWriteEncodedTile(tif,
-	    TIFFComputeTile(tif, x, y, z, s), buf, (tsize_t) -1));
-}
-
-/*
- * Encode the supplied data and write it to the
- * specified tile.  There must be space for the
- * data.  The function clamps individual writes
- * to a tile to the tile size, but does not (and
- * can not) check that multiple writes to the same
- * tile do not write more than tile size data.
- *
- * NB: Image length must be setup before writing; this
- *     interface does not support automatically growing
- *     the image on each write (as TIFFWriteScanline does).
- */
-tsize_t
-TIFFWriteEncodedTile(TIFF* tif, ttile_t tile, tdata_t data, tsize_t cc)
-{
-	static const char module[] = "TIFFWriteEncodedTile";
-	TIFFDirectory *td;
-	tsample_t sample;
-
-	if (!WRITECHECKTILES(tif, module))
-		return ((tsize_t) -1);
-	td = &tif->tif_dir;
-	if (tile >= td->td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: Tile %lu out of range, max %lu",
-		    tif->tif_name, (unsigned long) tile, (unsigned long) td->td_nstrips);
-		return ((tsize_t) -1);
-	}
-	/*
-	 * Handle delayed allocation of data buffer.  This
-	 * permits it to be sized more intelligently (using
-	 * directory information).
-	 */
-	if (!BUFFERCHECK(tif))
-		return ((tsize_t) -1);
-	tif->tif_curtile = tile;
-
-	tif->tif_rawcc = 0;
-	tif->tif_rawcp = tif->tif_rawdata;
-
-        if( td->td_stripbytecount[tile] > 0 )
-        {
-	    /* Force TIFFAppendToStrip() to consider placing data at end
-               of file. */
-            tif->tif_curoff = 0;
-        }
-        
-	/* 
-	 * Compute tiles per row & per column to compute
-	 * current row and column
-	 */
-	tif->tif_row = (tile % TIFFhowmany(td->td_imagelength, td->td_tilelength))
-		* td->td_tilelength;
-	tif->tif_col = (tile % TIFFhowmany(td->td_imagewidth, td->td_tilewidth))
-		* td->td_tilewidth;
-
-	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
-		if (!(*tif->tif_setupencode)(tif))
-			return ((tsize_t) -1);
-		tif->tif_flags |= TIFF_CODERSETUP;
-	}
-	tif->tif_flags &= ~TIFF_POSTENCODE;
-	sample = (tsample_t)(tile/td->td_stripsperimage);
-	if (!(*tif->tif_preencode)(tif, sample))
-		return ((tsize_t) -1);
-	/*
-	 * Clamp write amount to the tile size.  This is mostly
-	 * done so that callers can pass in some large number
-	 * (e.g. -1) and have the tile size used instead.
-	 */
-	if ( cc < 1 || cc > tif->tif_tilesize)
-		cc = tif->tif_tilesize;
-
-        /* swab if needed - note that source buffer will be altered */
-        tif->tif_postdecode( tif, (tidata_t) data, cc );
-
-	if (!(*tif->tif_encodetile)(tif, (tidata_t) data, cc, sample))
-		return ((tsize_t) 0);
-	if (!(*tif->tif_postencode)(tif))
-		return ((tsize_t) -1);
-	if (!isFillOrder(tif, td->td_fillorder) &&
-	    (tif->tif_flags & TIFF_NOBITREV) == 0)
-		TIFFReverseBits((unsigned char *)tif->tif_rawdata, tif->tif_rawcc);
-	if (tif->tif_rawcc > 0 && !TIFFAppendToStrip(tif, tile,
-	    tif->tif_rawdata, tif->tif_rawcc))
-		return ((tsize_t) -1);
-	tif->tif_rawcc = 0;
-	tif->tif_rawcp = tif->tif_rawdata;
-	return (cc);
-}
-
-/*
- * Write the supplied data to the specified strip.
- * There must be space for the data; we don't check
- * if strips overlap!
- *
- * NB: Image length must be setup before writing; this
- *     interface does not support automatically growing
- *     the image on each write (as TIFFWriteScanline does).
- */
-tsize_t
-TIFFWriteRawTile(TIFF* tif, ttile_t tile, tdata_t data, tsize_t cc)
-{
-	static const char module[] = "TIFFWriteRawTile";
-
-	if (!WRITECHECKTILES(tif, module))
-		return ((tsize_t) -1);
-	if (tile >= tif->tif_dir.td_nstrips) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: Tile %lu out of range, max %lu",
-		    tif->tif_name, (unsigned long) tile,
-		    (unsigned long) tif->tif_dir.td_nstrips);
-		return ((tsize_t) -1);
-	}
-	return (TIFFAppendToStrip(tif, tile, (tidata_t) data, cc) ?
-	    cc : (tsize_t) -1);
-}
-
-#define	isUnspecified(tif, f) \
-    (TIFFFieldSet(tif,f) && (tif)->tif_dir.td_imagelength == 0)
-
-int
-TIFFSetupStrips(TIFF* tif)
-{
-	TIFFDirectory* td = &tif->tif_dir;
-
-	if (isTiled(tif))
-		td->td_stripsperimage =
-		    isUnspecified(tif, FIELD_TILEDIMENSIONS) ?
-			td->td_samplesperpixel : TIFFNumberOfTiles(tif);
-	else
-		td->td_stripsperimage =
-		    isUnspecified(tif, FIELD_ROWSPERSTRIP) ?
-			td->td_samplesperpixel : TIFFNumberOfStrips(tif);
-	td->td_nstrips = td->td_stripsperimage;
-	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		td->td_stripsperimage /= td->td_samplesperpixel;
-	td->td_stripoffset = (uint32 *)
-	    _TIFFmalloc(td->td_nstrips * sizeof (uint32));
-	td->td_stripbytecount = (uint32 *)
-	    _TIFFmalloc(td->td_nstrips * sizeof (uint32));
-	if (td->td_stripoffset == NULL || td->td_stripbytecount == NULL)
-		return (0);
-	/*
-	 * Place data at the end-of-file
-	 * (by setting offsets to zero).
-	 */
-	_TIFFmemset(td->td_stripoffset, 0, td->td_nstrips*sizeof (uint32));
-	_TIFFmemset(td->td_stripbytecount, 0, td->td_nstrips*sizeof (uint32));
-	TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
-	TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
-	return (1);
-}
-#undef isUnspecified
-
-/*
- * Verify file is writable and that the directory
- * information is setup properly.  In doing the latter
- * we also "freeze" the state of the directory so
- * that important information is not changed.
- */
-int
-TIFFWriteCheck(TIFF* tif, int tiles, const char* module)
-{
-	if (tif->tif_mode == O_RDONLY) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: File not open for writing",
-		    tif->tif_name);
-		return (0);
-	}
-	if (tiles ^ isTiled(tif)) {
-		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?
-		    "Can not write tiles to a stripped image" :
-		    "Can not write scanlines to a tiled image");
-		return (0);
-	}
-        
-	/*
-	 * On the first write verify all the required information
-	 * has been setup and initialize any data structures that
-	 * had to wait until directory information was set.
-	 * Note that a lot of our work is assumed to remain valid
-	 * because we disallow any of the important parameters
-	 * from changing after we start writing (i.e. once
-	 * TIFF_BEENWRITING is set, TIFFSetField will only allow
-	 * the image's length to be changed).
-	 */
-	if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%s: Must set \"ImageWidth\" before writing data",
-		    tif->tif_name);
-		return (0);
-	}
-	if (tif->tif_dir.td_samplesperpixel == 1) {
-		/* 
-		 * Planarconfiguration is irrelevant in case of single band
-		 * images and need not be included. We will set it anyway,
-		 * because this field is used in other parts of library even
-		 * in the single band case.
-		 */
-		if (!TIFFFieldSet(tif, FIELD_PLANARCONFIG))
-                    tif->tif_dir.td_planarconfig = PLANARCONFIG_CONTIG;
-	} else {
-		if (!TIFFFieldSet(tif, FIELD_PLANARCONFIG)) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-		    "%s: Must set \"PlanarConfiguration\" before writing data",
-			    tif->tif_name);
-			return (0);
-		}
-	}
-	if (tif->tif_dir.td_stripoffset == NULL && !TIFFSetupStrips(tif)) {
-		tif->tif_dir.td_nstrips = 0;
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: No space for %s arrays",
-		    tif->tif_name, isTiled(tif) ? "tile" : "strip");
-		return (0);
-	}
-	tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
-	tif->tif_scanlinesize = TIFFScanlineSize(tif);
-	tif->tif_flags |= TIFF_BEENWRITING;
-	return (1);
-}
-
-/*
- * Setup the raw data buffer used for encoding.
- */
-int
-TIFFWriteBufferSetup(TIFF* tif, tdata_t bp, tsize_t size)
-{
-	static const char module[] = "TIFFWriteBufferSetup";
-
-	if (tif->tif_rawdata) {
-		if (tif->tif_flags & TIFF_MYBUFFER) {
-			_TIFFfree(tif->tif_rawdata);
-			tif->tif_flags &= ~TIFF_MYBUFFER;
-		}
-		tif->tif_rawdata = NULL;
-	}
-	if (size == (tsize_t) -1) {
-		size = (isTiled(tif) ?
-		    tif->tif_tilesize : TIFFStripSize(tif));
-		/*
-		 * Make raw data buffer at least 8K
-		 */
-		if (size < 8*1024)
-			size = 8*1024;
-		bp = NULL;			/* NB: force malloc */
-	}
-	if (bp == NULL) {
-		bp = _TIFFmalloc(size);
-		if (bp == NULL) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: No space for output buffer",
-			    tif->tif_name);
-			return (0);
-		}
-		tif->tif_flags |= TIFF_MYBUFFER;
-	} else
-		tif->tif_flags &= ~TIFF_MYBUFFER;
-	tif->tif_rawdata = (tidata_t) bp;
-	tif->tif_rawdatasize = size;
-	tif->tif_rawcc = 0;
-	tif->tif_rawcp = tif->tif_rawdata;
-	tif->tif_flags |= TIFF_BUFFERSETUP;
-	return (1);
-}
-
-/*
- * Grow the strip data structures by delta strips.
- */
-static int
-TIFFGrowStrips(TIFF* tif, int delta, const char* module)
-{
-	TIFFDirectory	*td = &tif->tif_dir;
-	uint32		*new_stripoffset, *new_stripbytecount;
-
-	assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
-	new_stripoffset = (uint32*)_TIFFrealloc(td->td_stripoffset,
-		(td->td_nstrips + delta) * sizeof (uint32));
-	new_stripbytecount = (uint32*)_TIFFrealloc(td->td_stripbytecount,
-		(td->td_nstrips + delta) * sizeof (uint32));
-	if (new_stripoffset == NULL || new_stripbytecount == NULL) {
-		if (new_stripoffset)
-			_TIFFfree(new_stripoffset);
-		if (new_stripbytecount)
-			_TIFFfree(new_stripbytecount);
-		td->td_nstrips = 0;
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: No space to expand strip arrays",
-			  tif->tif_name);
-		return (0);
-	}
-	td->td_stripoffset = new_stripoffset;
-	td->td_stripbytecount = new_stripbytecount;
-	_TIFFmemset(td->td_stripoffset + td->td_nstrips,
-		    0, delta*sizeof (uint32));
-	_TIFFmemset(td->td_stripbytecount + td->td_nstrips,
-		    0, delta*sizeof (uint32));
-	td->td_nstrips += delta;
-	return (1);
-}
-
-/*
- * Append the data to the specified strip.
- */
-static int
-TIFFAppendToStrip(TIFF* tif, tstrip_t strip, tidata_t data, tsize_t cc)
-{
-	static const char module[] = "TIFFAppendToStrip";
-	TIFFDirectory *td = &tif->tif_dir;
-
-	if (td->td_stripoffset[strip] == 0 || tif->tif_curoff == 0) {
-            assert(td->td_nstrips > 0);
-
-            if( td->td_stripbytecount[strip] != 0 
-                && td->td_stripoffset[strip] != 0 
-                && td->td_stripbytecount[strip] >= cc )
-            {
-                /* 
-                 * There is already tile data on disk, and the new tile
-                 * data we have to will fit in the same space.  The only 
-                 * aspect of this that is risky is that there could be
-                 * more data to append to this strip before we are done
-                 * depending on how we are getting called.
-                 */
-                if (!SeekOK(tif, td->td_stripoffset[strip])) {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                                 "Seek error at scanline %lu",
-                                 (unsigned long)tif->tif_row);
-                    return (0);
-                }
-            }
-            else
-            {
-                /* 
-                 * Seek to end of file, and set that as our location to 
-                 * write this strip.
-                 */
-                td->td_stripoffset[strip] = TIFFSeekFile(tif, 0, SEEK_END);
-            }
-
-            tif->tif_curoff = td->td_stripoffset[strip];
-
-            /*
-             * We are starting a fresh strip/tile, so set the size to zero.
-             */
-            td->td_stripbytecount[strip] = 0;
-	}
-
-	if (!WriteOK(tif, data, cc)) {
-		TIFFErrorExt(tif->tif_clientdata, module, "Write error at scanline %lu",
-		    (unsigned long) tif->tif_row);
-		    return (0);
-	}
-	tif->tif_curoff =  tif->tif_curoff+cc;
-	td->td_stripbytecount[strip] += cc;
-	return (1);
-}
-
-/*
- * Internal version of TIFFFlushData that can be
- * called by ``encodestrip routines'' w/o concern
- * for infinite recursion.
- */
-int
-TIFFFlushData1(TIFF* tif)
-{
-	if (tif->tif_rawcc > 0) {
-		if (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&
-		    (tif->tif_flags & TIFF_NOBITREV) == 0)
-			TIFFReverseBits((unsigned char *)tif->tif_rawdata,
-			    tif->tif_rawcc);
-		if (!TIFFAppendToStrip(tif,
-		    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,
-		    tif->tif_rawdata, tif->tif_rawcc))
-			return (0);
-		tif->tif_rawcc = 0;
-		tif->tif_rawcp = tif->tif_rawdata;
-	}
-	return (1);
-}
-
-/*
- * Set the current write offset.  This should only be
- * used to set the offset to a known previous location
- * (very carefully), or to 0 so that the next write gets
- * appended to the end of the file.
- */
-void
-TIFFSetWriteOffset(TIFF* tif, toff_t off)
-{
-	tif->tif_curoff = off;
-}
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tif_zip.c b/thirdparty/libtiff/tif_zip.c
deleted file mode 100644
index 15091f8..0000000
--- a/thirdparty/libtiff/tif_zip.c
+++ /dev/null
@@ -1,419 +0,0 @@
-/* $Id: tif_zip.c,v 1.11.2.4 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1995-1997 Sam Leffler
- * Copyright (c) 1995-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#include "tiffiop.h"
-#ifdef ZIP_SUPPORT
-/*
- * TIFF Library.
- *
- * ZIP (aka Deflate) Compression Support
- *
- * This file is simply an interface to the zlib library written by
- * Jean-loup Gailly and Mark Adler.  You must use version 1.0 or later
- * of the library: this code assumes the 1.0 API and also depends on
- * the ability to write the zlib header multiple times (one per strip)
- * which was not possible with versions prior to 0.95.  Note also that
- * older versions of this codec avoided this bug by supressing the header
- * entirely.  This means that files written with the old library cannot
- * be read; they should be converted to a different compression scheme
- * and then reconverted.
- *
- * The data format used by the zlib library is described in the files
- * zlib-3.1.doc, deflate-1.1.doc and gzip-4.1.doc, available in the
- * directory ftp://ftp.uu.net/pub/archiving/zip/doc.  The library was
- * last found at ftp://ftp.uu.net/pub/archiving/zip/zlib/zlib-0.99.tar.gz.
- */
-#include "tif_predict.h"
-#include "zlib.h"
-
-#include <stdio.h>
-
-/*
- * Sigh, ZLIB_VERSION is defined as a string so there's no
- * way to do a proper check here.  Instead we guess based
- * on the presence of #defines that were added between the
- * 0.95 and 1.0 distributions.
- */
-#if !defined(Z_NO_COMPRESSION) || !defined(Z_DEFLATED)
-#error "Antiquated ZLIB software; you must use version 1.0 or later"
-#endif
-
-/*
- * State block for each open TIFF
- * file using ZIP compression/decompression.
- */
-typedef	struct {
-	TIFFPredictorState predict;
-	z_stream	stream;
-	int		zipquality;		/* compression level */
-	int		state;			/* state flags */
-#define ZSTATE_INIT_DECODE 0x01
-#define ZSTATE_INIT_ENCODE 0x02
-
-	TIFFVGetMethod	vgetparent;		/* super-class method */
-	TIFFVSetMethod	vsetparent;		/* super-class method */
-} ZIPState;
-
-#define	ZState(tif)		((ZIPState*) (tif)->tif_data)
-#define	DecoderState(tif)	ZState(tif)
-#define	EncoderState(tif)	ZState(tif)
-
-static	int ZIPEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-static	int ZIPDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-
-static int
-ZIPSetupDecode(TIFF* tif)
-{
-	ZIPState* sp = DecoderState(tif);
-	static const char module[] = "ZIPSetupDecode";
-
-	assert(sp != NULL);
-        
-        /* if we were last encoding, terminate this mode */
-	if (sp->state & ZSTATE_INIT_ENCODE) {
-            deflateEnd(&sp->stream);
-            sp->state = 0;
-        }
-
-	if (inflateInit(&sp->stream) != Z_OK) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: %s", tif->tif_name, sp->stream.msg);
-		return (0);
-	} else {
-		sp->state |= ZSTATE_INIT_DECODE;
-		return (1);
-	}
-}
-
-/*
- * Setup state for decoding a strip.
- */
-static int
-ZIPPreDecode(TIFF* tif, tsample_t s)
-{
-	ZIPState* sp = DecoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-
-        if( (sp->state & ZSTATE_INIT_DECODE) == 0 )
-            tif->tif_setupdecode( tif );
-
-	sp->stream.next_in = tif->tif_rawdata;
-	sp->stream.avail_in = tif->tif_rawcc;
-	return (inflateReset(&sp->stream) == Z_OK);
-}
-
-static int
-ZIPDecode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
-{
-	ZIPState* sp = DecoderState(tif);
-	static const char module[] = "ZIPDecode";
-
-	(void) s;
-	assert(sp != NULL);
-        assert(sp->state == ZSTATE_INIT_DECODE);
-
-	sp->stream.next_out = op;
-	sp->stream.avail_out = occ;
-	do {
-		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
-		if (state == Z_STREAM_END)
-			break;
-		if (state == Z_DATA_ERROR) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Decoding error at scanline %d, %s",
-			    tif->tif_name, tif->tif_row, sp->stream.msg);
-			if (inflateSync(&sp->stream) != Z_OK)
-				return (0);
-			continue;
-		}
-		if (state != Z_OK) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-			    tif->tif_name, sp->stream.msg);
-			return (0);
-		}
-	} while (sp->stream.avail_out > 0);
-	if (sp->stream.avail_out != 0) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-		    "%s: Not enough data at scanline %d (short %d bytes)",
-		    tif->tif_name, tif->tif_row, sp->stream.avail_out);
-		return (0);
-	}
-	return (1);
-}
-
-static int
-ZIPSetupEncode(TIFF* tif)
-{
-	ZIPState* sp = EncoderState(tif);
-	static const char module[] = "ZIPSetupEncode";
-
-	assert(sp != NULL);
-	if (sp->state & ZSTATE_INIT_DECODE) {
-            inflateEnd(&sp->stream);
-            sp->state = 0;
-        }
-
-	if (deflateInit(&sp->stream, sp->zipquality) != Z_OK) {
-		TIFFErrorExt(tif->tif_clientdata, module, "%s: %s", tif->tif_name, sp->stream.msg);
-		return (0);
-	} else {
-		sp->state |= ZSTATE_INIT_ENCODE;
-		return (1);
-	}
-}
-
-/*
- * Reset encoding state at the start of a strip.
- */
-static int
-ZIPPreEncode(TIFF* tif, tsample_t s)
-{
-	ZIPState *sp = EncoderState(tif);
-
-	(void) s;
-	assert(sp != NULL);
-        if( sp->state != ZSTATE_INIT_ENCODE )
-            tif->tif_setupencode( tif );
-
-	sp->stream.next_out = tif->tif_rawdata;
-	sp->stream.avail_out = tif->tif_rawdatasize;
-	return (deflateReset(&sp->stream) == Z_OK);
-}
-
-/*
- * Encode a chunk of pixels.
- */
-static int
-ZIPEncode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
-{
-	ZIPState *sp = EncoderState(tif);
-	static const char module[] = "ZIPEncode";
-
-        assert(sp != NULL);
-        assert(sp->state == ZSTATE_INIT_ENCODE);
-
-	(void) s;
-	sp->stream.next_in = bp;
-	sp->stream.avail_in = cc;
-	do {
-		if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: Encoder error: %s",
-			    tif->tif_name, sp->stream.msg);
-			return (0);
-		}
-		if (sp->stream.avail_out == 0) {
-			tif->tif_rawcc = tif->tif_rawdatasize;
-			TIFFFlushData1(tif);
-			sp->stream.next_out = tif->tif_rawdata;
-			sp->stream.avail_out = tif->tif_rawdatasize;
-		}
-	} while (sp->stream.avail_in > 0);
-	return (1);
-}
-
-/*
- * Finish off an encoded strip by flushing the last
- * string and tacking on an End Of Information code.
- */
-static int
-ZIPPostEncode(TIFF* tif)
-{
-	ZIPState *sp = EncoderState(tif);
-	static const char module[] = "ZIPPostEncode";
-	int state;
-
-	sp->stream.avail_in = 0;
-	do {
-		state = deflate(&sp->stream, Z_FINISH);
-		switch (state) {
-		case Z_STREAM_END:
-		case Z_OK:
-		    if ((int)sp->stream.avail_out != (int)tif->tif_rawdatasize)
-                    {
-			    tif->tif_rawcc =
-				tif->tif_rawdatasize - sp->stream.avail_out;
-			    TIFFFlushData1(tif);
-			    sp->stream.next_out = tif->tif_rawdata;
-			    sp->stream.avail_out = tif->tif_rawdatasize;
-		    }
-		    break;
-		default:
-			TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-			tif->tif_name, sp->stream.msg);
-		    return (0);
-		}
-	} while (state != Z_STREAM_END);
-	return (1);
-}
-
-static void
-ZIPCleanup(TIFF* tif)
-{
-	ZIPState* sp = ZState(tif);
-
-	assert(sp != 0);
-
-	(void)TIFFPredictorCleanup(tif);
-
-	tif->tif_tagmethods.vgetfield = sp->vgetparent;
-	tif->tif_tagmethods.vsetfield = sp->vsetparent;
-
-	if (sp->state & ZSTATE_INIT_ENCODE) {
-            deflateEnd(&sp->stream);
-            sp->state = 0;
-        } else if( sp->state & ZSTATE_INIT_DECODE) {
-            inflateEnd(&sp->stream);
-            sp->state = 0;
-	}
-	_TIFFfree(sp);
-	tif->tif_data = NULL;
-
-	_TIFFSetDefaultCompressionState(tif);
-}
-
-static int
-ZIPVSetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	ZIPState* sp = ZState(tif);
-	static const char module[] = "ZIPVSetField";
-
-	switch (tag) {
-	case TIFFTAG_ZIPQUALITY:
-		sp->zipquality = va_arg(ap, int);
-		if ( sp->state&ZSTATE_INIT_ENCODE ) {
-			if (deflateParams(&sp->stream,
-			    sp->zipquality, Z_DEFAULT_STRATEGY) != Z_OK) {
-				TIFFErrorExt(tif->tif_clientdata, module, "%s: zlib error: %s",
-				    tif->tif_name, sp->stream.msg);
-				return (0);
-			}
-		}
-		return (1);
-	default:
-		return (*sp->vsetparent)(tif, tag, ap);
-	}
-	/*NOTREACHED*/
-}
-
-static int
-ZIPVGetField(TIFF* tif, ttag_t tag, va_list ap)
-{
-	ZIPState* sp = ZState(tif);
-
-	switch (tag) {
-	case TIFFTAG_ZIPQUALITY:
-		*va_arg(ap, int*) = sp->zipquality;
-		break;
-	default:
-		return (*sp->vgetparent)(tif, tag, ap);
-	}
-	return (1);
-}
-
-static const TIFFFieldInfo zipFieldInfo[] = {
-    { TIFFTAG_ZIPQUALITY,	 0, 0,	TIFF_ANY,	FIELD_PSEUDO,
-      TRUE,	FALSE,	"" },
-};
-
-int
-TIFFInitZIP(TIFF* tif, int scheme)
-{
-	static const char module[] = "TIFFInitZIP";
-	ZIPState* sp;
-
-	assert( (scheme == COMPRESSION_DEFLATE)
-		|| (scheme == COMPRESSION_ADOBE_DEFLATE));
-
-	/*
-	 * Merge codec-specific tag information.
-	 */
-	if (!_TIFFMergeFieldInfo(tif, zipFieldInfo,
-				 TIFFArrayCount(zipFieldInfo))) {
-		TIFFErrorExt(tif->tif_clientdata, module,
-			     "Merging Deflate codec-specific tags failed");
-		return 0;
-	}
-
-	/*
-	 * Allocate state block so tag methods have storage to record values.
-	 */
-	tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (ZIPState));
-	if (tif->tif_data == NULL)
-		goto bad;
-	sp = ZState(tif);
-	sp->stream.zalloc = NULL;
-	sp->stream.zfree = NULL;
-	sp->stream.opaque = NULL;
-	sp->stream.data_type = Z_BINARY;
-
-	/*
-	 * Override parent get/set field methods.
-	 */
-	sp->vgetparent = tif->tif_tagmethods.vgetfield;
-	tif->tif_tagmethods.vgetfield = ZIPVGetField; /* hook for codec tags */
-	sp->vsetparent = tif->tif_tagmethods.vsetfield;
-	tif->tif_tagmethods.vsetfield = ZIPVSetField; /* hook for codec tags */
-
-	/* Default values for codec-specific fields */
-	sp->zipquality = Z_DEFAULT_COMPRESSION;	/* default comp. level */
-	sp->state = 0;
-
-	/*
-	 * Install codec methods.
-	 */
-	tif->tif_setupdecode = ZIPSetupDecode;
-	tif->tif_predecode = ZIPPreDecode;
-	tif->tif_decoderow = ZIPDecode;
-	tif->tif_decodestrip = ZIPDecode;
-	tif->tif_decodetile = ZIPDecode;
-	tif->tif_setupencode = ZIPSetupEncode;
-	tif->tif_preencode = ZIPPreEncode;
-	tif->tif_postencode = ZIPPostEncode;
-	tif->tif_encoderow = ZIPEncode;
-	tif->tif_encodestrip = ZIPEncode;
-	tif->tif_encodetile = ZIPEncode;
-	tif->tif_cleanup = ZIPCleanup;
-	/*
-	 * Setup predictor setup.
-	 */
-	(void) TIFFPredictorInit(tif);
-	return (1);
-bad:
-	TIFFErrorExt(tif->tif_clientdata, module,
-		     "No space for ZIP state block");
-	return (0);
-}
-#endif /* ZIP_SUPORT */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiff.h b/thirdparty/libtiff/tiff.h
deleted file mode 100644
index 0d4ab9f..0000000
--- a/thirdparty/libtiff/tiff.h
+++ /dev/null
@@ -1,654 +0,0 @@
-/* $Id: tiff.h,v 1.43.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFF_
-#define	_TIFF_
-
-#include "tiffconf.h"
-
-/*
- * Tag Image File Format (TIFF)
- *
- * Based on Rev 6.0 from:
- *    Developer's Desk
- *    Aldus Corporation
- *    411 First Ave. South
- *    Suite 200
- *    Seattle, WA  98104
- *    206-622-5500
- *    
- *    (http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf)
- *
- * For Big TIFF design notes see the following link
- *    http://www.remotesensing.org/libtiff/bigtiffdesign.html
- */
-#define	TIFF_VERSION	        42
-#define TIFF_BIGTIFF_VERSION    43
-
-#define	TIFF_BIGENDIAN		0x4d4d
-#define	TIFF_LITTLEENDIAN	0x4949
-#define	MDI_LITTLEENDIAN        0x5045
-#define	MDI_BIGENDIAN           0x4550
-/*
- * Intrinsic data types required by the file format:
- *
- * 8-bit quantities	int8/uint8
- * 16-bit quantities	int16/uint16
- * 32-bit quantities	int32/uint32
- * strings		unsigned char*
- */
-
-#ifndef HAVE_INT8
-typedef	signed char int8;	/* NB: non-ANSI compilers may not grok */
-#endif
-typedef	unsigned char uint8;
-#ifndef HAVE_INT16
-typedef	short int16;
-#endif
-typedef	unsigned short uint16;	/* sizeof (uint16) must == 2 */
-#if SIZEOF_INT == 4
-#ifndef HAVE_INT32
-typedef	int int32;
-#endif
-typedef	unsigned int uint32;	/* sizeof (uint32) must == 4 */
-#elif SIZEOF_LONG == 4
-#ifndef HAVE_INT32
-typedef	long int32;
-#endif
-typedef	unsigned long uint32;	/* sizeof (uint32) must == 4 */
-#endif
-
-/* For TIFFReassignTagToIgnore */
-enum TIFFIgnoreSense /* IGNORE tag table */
-{
-	TIS_STORE,
-	TIS_EXTRACT,
-	TIS_EMPTY
-};
-
-/*
- * TIFF header.
- */
-typedef	struct {
-	uint16	tiff_magic;	/* magic number (defines byte order) */
-#define TIFF_MAGIC_SIZE		2
-	uint16	tiff_version;	/* TIFF version number */
-#define TIFF_VERSION_SIZE	2
-	uint32	tiff_diroff;	/* byte offset to first directory */
-#define TIFF_DIROFFSET_SIZE	4
-} TIFFHeader;
-
-
-/*
- * TIFF Image File Directories are comprised of a table of field
- * descriptors of the form shown below.  The table is sorted in
- * ascending order by tag.  The values associated with each entry are
- * disjoint and may appear anywhere in the file (so long as they are
- * placed on a word boundary).
- *
- * If the value is 4 bytes or less, then it is placed in the offset
- * field to save space.  If the value is less than 4 bytes, it is
- * left-justified in the offset field.
- */
-typedef	struct {
-	uint16		tdir_tag;	/* see below */
-	uint16		tdir_type;	/* data type; see below */
-	uint32		tdir_count;	/* number of items; length in spec */
-	uint32		tdir_offset;	/* byte offset to field data */
-} TIFFDirEntry;
-
-/*
- * NB: In the comments below,
- *  - items marked with a + are obsoleted by revision 5.0,
- *  - items marked with a ! are introduced in revision 6.0.
- *  - items marked with a % are introduced post revision 6.0.
- *  - items marked with a $ are obsoleted by revision 6.0.
- *  - items marked with a & are introduced by Adobe DNG specification.
- */
-
-/*
- * Tag data type information.
- *
- * Note: RATIONALs are the ratio of two 32-bit integer values.
- */
-typedef	enum {
-	TIFF_NOTYPE	= 0,	/* placeholder */
-	TIFF_BYTE	= 1,	/* 8-bit unsigned integer */
-	TIFF_ASCII	= 2,	/* 8-bit bytes w/ last byte null */
-	TIFF_SHORT	= 3,	/* 16-bit unsigned integer */
-	TIFF_LONG	= 4,	/* 32-bit unsigned integer */
-	TIFF_RATIONAL	= 5,	/* 64-bit unsigned fraction */
-	TIFF_SBYTE	= 6,	/* !8-bit signed integer */
-	TIFF_UNDEFINED	= 7,	/* !8-bit untyped data */
-	TIFF_SSHORT	= 8,	/* !16-bit signed integer */
-	TIFF_SLONG	= 9,	/* !32-bit signed integer */
-	TIFF_SRATIONAL	= 10,	/* !64-bit signed fraction */
-	TIFF_FLOAT	= 11,	/* !32-bit IEEE floating point */
-	TIFF_DOUBLE	= 12,	/* !64-bit IEEE floating point */
-	TIFF_IFD	= 13	/* %32-bit unsigned integer (offset) */
-} TIFFDataType;
-
-/*
- * TIFF Tag Definitions.
- */
-#define	TIFFTAG_SUBFILETYPE		254	/* subfile data descriptor */
-#define	    FILETYPE_REDUCEDIMAGE	0x1	/* reduced resolution version */
-#define	    FILETYPE_PAGE		0x2	/* one page of many */
-#define	    FILETYPE_MASK		0x4	/* transparency mask */
-#define	TIFFTAG_OSUBFILETYPE		255	/* +kind of data in subfile */
-#define	    OFILETYPE_IMAGE		1	/* full resolution image data */
-#define	    OFILETYPE_REDUCEDIMAGE	2	/* reduced size image data */
-#define	    OFILETYPE_PAGE		3	/* one page of many */
-#define	TIFFTAG_IMAGEWIDTH		256	/* image width in pixels */
-#define	TIFFTAG_IMAGELENGTH		257	/* image height in pixels */
-#define	TIFFTAG_BITSPERSAMPLE		258	/* bits per channel (sample) */
-#define	TIFFTAG_COMPRESSION		259	/* data compression technique */
-#define	    COMPRESSION_NONE		1	/* dump mode */
-#define	    COMPRESSION_CCITTRLE	2	/* CCITT modified Huffman RLE */
-#define	    COMPRESSION_CCITTFAX3	3	/* CCITT Group 3 fax encoding */
-#define     COMPRESSION_CCITT_T4        3       /* CCITT T.4 (TIFF 6 name) */
-#define	    COMPRESSION_CCITTFAX4	4	/* CCITT Group 4 fax encoding */
-#define     COMPRESSION_CCITT_T6        4       /* CCITT T.6 (TIFF 6 name) */
-#define	    COMPRESSION_LZW		5       /* Lempel-Ziv  & Welch */
-#define	    COMPRESSION_OJPEG		6	/* !6.0 JPEG */
-#define	    COMPRESSION_JPEG		7	/* %JPEG DCT compression */
-#define	    COMPRESSION_NEXT		32766	/* NeXT 2-bit RLE */
-#define	    COMPRESSION_CCITTRLEW	32771	/* #1 w/ word alignment */
-#define	    COMPRESSION_PACKBITS	32773	/* Macintosh RLE */
-#define	    COMPRESSION_THUNDERSCAN	32809	/* ThunderScan RLE */
-/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
-#define	    COMPRESSION_IT8CTPAD	32895   /* IT8 CT w/padding */
-#define	    COMPRESSION_IT8LW		32896   /* IT8 Linework RLE */
-#define	    COMPRESSION_IT8MP		32897   /* IT8 Monochrome picture */
-#define	    COMPRESSION_IT8BL		32898   /* IT8 Binary line art */
-/* compression codes 32908-32911 are reserved for Pixar */
-#define     COMPRESSION_PIXARFILM	32908   /* Pixar companded 10bit LZW */
-#define	    COMPRESSION_PIXARLOG	32909   /* Pixar companded 11bit ZIP */
-#define	    COMPRESSION_DEFLATE		32946	/* Deflate compression */
-#define     COMPRESSION_ADOBE_DEFLATE   8       /* Deflate compression,
-						   as recognized by Adobe */
-/* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */
-#define     COMPRESSION_DCS             32947   /* Kodak DCS encoding */
-#define	    COMPRESSION_JBIG		34661	/* ISO JBIG */
-#define     COMPRESSION_SGILOG		34676	/* SGI Log Luminance RLE */
-#define     COMPRESSION_SGILOG24	34677	/* SGI Log 24-bit packed */
-#define     COMPRESSION_JP2000          34712   /* Leadtools JPEG2000 */
-#define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
-#define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
-#define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
-#define	    PHOTOMETRIC_RGB		2	/* RGB color model */
-#define	    PHOTOMETRIC_PALETTE		3	/* color map indexed */
-#define	    PHOTOMETRIC_MASK		4	/* $holdout mask */
-#define	    PHOTOMETRIC_SEPARATED	5	/* !color separations */
-#define	    PHOTOMETRIC_YCBCR		6	/* !CCIR 601 */
-#define	    PHOTOMETRIC_CIELAB		8	/* !1976 CIE L*a*b* */
-#define	    PHOTOMETRIC_ICCLAB		9	/* ICC L*a*b* [Adobe TIFF Technote 4] */
-#define	    PHOTOMETRIC_ITULAB		10	/* ITU L*a*b* */
-#define     PHOTOMETRIC_LOGL		32844	/* CIE Log2(L) */
-#define     PHOTOMETRIC_LOGLUV		32845	/* CIE Log2(L) (u',v') */
-#define	TIFFTAG_THRESHHOLDING		263	/* +thresholding used on data */
-#define	    THRESHHOLD_BILEVEL		1	/* b&w art scan */
-#define	    THRESHHOLD_HALFTONE		2	/* or dithered scan */
-#define	    THRESHHOLD_ERRORDIFFUSE	3	/* usually floyd-steinberg */
-#define	TIFFTAG_CELLWIDTH		264	/* +dithering matrix width */
-#define	TIFFTAG_CELLLENGTH		265	/* +dithering matrix height */
-#define	TIFFTAG_FILLORDER		266	/* data order within a byte */
-#define	    FILLORDER_MSB2LSB		1	/* most significant -> least */
-#define	    FILLORDER_LSB2MSB		2	/* least significant -> most */
-#define	TIFFTAG_DOCUMENTNAME		269	/* name of doc. image is from */
-#define	TIFFTAG_IMAGEDESCRIPTION	270	/* info about image */
-#define	TIFFTAG_MAKE			271	/* scanner manufacturer name */
-#define	TIFFTAG_MODEL			272	/* scanner model name/number */
-#define	TIFFTAG_STRIPOFFSETS		273	/* offsets to data strips */
-#define	TIFFTAG_ORIENTATION		274	/* +image orientation */
-#define	    ORIENTATION_TOPLEFT		1	/* row 0 top, col 0 lhs */
-#define	    ORIENTATION_TOPRIGHT	2	/* row 0 top, col 0 rhs */
-#define	    ORIENTATION_BOTRIGHT	3	/* row 0 bottom, col 0 rhs */
-#define	    ORIENTATION_BOTLEFT		4	/* row 0 bottom, col 0 lhs */
-#define	    ORIENTATION_LEFTTOP		5	/* row 0 lhs, col 0 top */
-#define	    ORIENTATION_RIGHTTOP	6	/* row 0 rhs, col 0 top */
-#define	    ORIENTATION_RIGHTBOT	7	/* row 0 rhs, col 0 bottom */
-#define	    ORIENTATION_LEFTBOT		8	/* row 0 lhs, col 0 bottom */
-#define	TIFFTAG_SAMPLESPERPIXEL		277	/* samples per pixel */
-#define	TIFFTAG_ROWSPERSTRIP		278	/* rows per strip of data */
-#define	TIFFTAG_STRIPBYTECOUNTS		279	/* bytes counts for strips */
-#define	TIFFTAG_MINSAMPLEVALUE		280	/* +minimum sample value */
-#define	TIFFTAG_MAXSAMPLEVALUE		281	/* +maximum sample value */
-#define	TIFFTAG_XRESOLUTION		282	/* pixels/resolution in x */
-#define	TIFFTAG_YRESOLUTION		283	/* pixels/resolution in y */
-#define	TIFFTAG_PLANARCONFIG		284	/* storage organization */
-#define	    PLANARCONFIG_CONTIG		1	/* single image plane */
-#define	    PLANARCONFIG_SEPARATE	2	/* separate planes of data */
-#define	TIFFTAG_PAGENAME		285	/* page name image is from */
-#define	TIFFTAG_XPOSITION		286	/* x page offset of image lhs */
-#define	TIFFTAG_YPOSITION		287	/* y page offset of image lhs */
-#define	TIFFTAG_FREEOFFSETS		288	/* +byte offset to free block */
-#define	TIFFTAG_FREEBYTECOUNTS		289	/* +sizes of free blocks */
-#define	TIFFTAG_GRAYRESPONSEUNIT	290	/* $gray scale curve accuracy */
-#define	    GRAYRESPONSEUNIT_10S	1	/* tenths of a unit */
-#define	    GRAYRESPONSEUNIT_100S	2	/* hundredths of a unit */
-#define	    GRAYRESPONSEUNIT_1000S	3	/* thousandths of a unit */
-#define	    GRAYRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
-#define	    GRAYRESPONSEUNIT_100000S	5	/* hundred-thousandths */
-#define	TIFFTAG_GRAYRESPONSECURVE	291	/* $gray scale response curve */
-#define	TIFFTAG_GROUP3OPTIONS		292	/* 32 flag bits */
-#define	TIFFTAG_T4OPTIONS		292	/* TIFF 6.0 proper name alias */
-#define	    GROUP3OPT_2DENCODING	0x1	/* 2-dimensional coding */
-#define	    GROUP3OPT_UNCOMPRESSED	0x2	/* data not compressed */
-#define	    GROUP3OPT_FILLBITS		0x4	/* fill to byte boundary */
-#define	TIFFTAG_GROUP4OPTIONS		293	/* 32 flag bits */
-#define TIFFTAG_T6OPTIONS               293     /* TIFF 6.0 proper name */
-#define	    GROUP4OPT_UNCOMPRESSED	0x2	/* data not compressed */
-#define	TIFFTAG_RESOLUTIONUNIT		296	/* units of resolutions */
-#define	    RESUNIT_NONE		1	/* no meaningful units */
-#define	    RESUNIT_INCH		2	/* english */
-#define	    RESUNIT_CENTIMETER		3	/* metric */
-#define	TIFFTAG_PAGENUMBER		297	/* page numbers of multi-page */
-#define	TIFFTAG_COLORRESPONSEUNIT	300	/* $color curve accuracy */
-#define	    COLORRESPONSEUNIT_10S	1	/* tenths of a unit */
-#define	    COLORRESPONSEUNIT_100S	2	/* hundredths of a unit */
-#define	    COLORRESPONSEUNIT_1000S	3	/* thousandths of a unit */
-#define	    COLORRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
-#define	    COLORRESPONSEUNIT_100000S	5	/* hundred-thousandths */
-#define	TIFFTAG_TRANSFERFUNCTION	301	/* !colorimetry info */
-#define	TIFFTAG_SOFTWARE		305	/* name & release */
-#define	TIFFTAG_DATETIME		306	/* creation date and time */
-#define	TIFFTAG_ARTIST			315	/* creator of image */
-#define	TIFFTAG_HOSTCOMPUTER		316	/* machine where created */
-#define	TIFFTAG_PREDICTOR		317	/* prediction scheme w/ LZW */
-#define     PREDICTOR_NONE		1	/* no prediction scheme used */
-#define     PREDICTOR_HORIZONTAL	2	/* horizontal differencing */
-#define     PREDICTOR_FLOATINGPOINT	3	/* floating point predictor */
-#define	TIFFTAG_WHITEPOINT		318	/* image white point */
-#define	TIFFTAG_PRIMARYCHROMATICITIES	319	/* !primary chromaticities */
-#define	TIFFTAG_COLORMAP		320	/* RGB map for pallette image */
-#define	TIFFTAG_HALFTONEHINTS		321	/* !highlight+shadow info */
-#define	TIFFTAG_TILEWIDTH		322	/* !tile width in pixels */
-#define	TIFFTAG_TILELENGTH		323	/* !tile height in pixels */
-#define TIFFTAG_TILEOFFSETS		324	/* !offsets to data tiles */
-#define TIFFTAG_TILEBYTECOUNTS		325	/* !byte counts for tiles */
-#define	TIFFTAG_BADFAXLINES		326	/* lines w/ wrong pixel count */
-#define	TIFFTAG_CLEANFAXDATA		327	/* regenerated line info */
-#define	    CLEANFAXDATA_CLEAN		0	/* no errors detected */
-#define	    CLEANFAXDATA_REGENERATED	1	/* receiver regenerated lines */
-#define	    CLEANFAXDATA_UNCLEAN	2	/* uncorrected errors exist */
-#define	TIFFTAG_CONSECUTIVEBADFAXLINES	328	/* max consecutive bad lines */
-#define	TIFFTAG_SUBIFD			330	/* subimage descriptors */
-#define	TIFFTAG_INKSET			332	/* !inks in separated image */
-#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black color */
-#define	    INKSET_MULTIINK		2	/* !multi-ink or hi-fi color */
-#define	TIFFTAG_INKNAMES		333	/* !ascii names of inks */
-#define	TIFFTAG_NUMBEROFINKS		334	/* !number of inks */
-#define	TIFFTAG_DOTRANGE		336	/* !0% and 100% dot codes */
-#define	TIFFTAG_TARGETPRINTER		337	/* !separation target */
-#define	TIFFTAG_EXTRASAMPLES		338	/* !info about extra samples */
-#define	    EXTRASAMPLE_UNSPECIFIED	0	/* !unspecified data */
-#define	    EXTRASAMPLE_ASSOCALPHA	1	/* !associated alpha data */
-#define	    EXTRASAMPLE_UNASSALPHA	2	/* !unassociated alpha data */
-#define	TIFFTAG_SAMPLEFORMAT		339	/* !data sample format */
-#define	    SAMPLEFORMAT_UINT		1	/* !unsigned integer data */
-#define	    SAMPLEFORMAT_INT		2	/* !signed integer data */
-#define	    SAMPLEFORMAT_IEEEFP		3	/* !IEEE floating point data */
-#define	    SAMPLEFORMAT_VOID		4	/* !untyped data */
-#define	    SAMPLEFORMAT_COMPLEXINT	5	/* !complex signed int */
-#define	    SAMPLEFORMAT_COMPLEXIEEEFP	6	/* !complex ieee floating */
-#define	TIFFTAG_SMINSAMPLEVALUE		340	/* !variable MinSampleValue */
-#define	TIFFTAG_SMAXSAMPLEVALUE		341	/* !variable MaxSampleValue */
-#define	TIFFTAG_CLIPPATH		343	/* %ClipPath
-						   [Adobe TIFF technote 2] */
-#define	TIFFTAG_XCLIPPATHUNITS		344	/* %XClipPathUnits
-						   [Adobe TIFF technote 2] */
-#define	TIFFTAG_YCLIPPATHUNITS		345	/* %YClipPathUnits
-						   [Adobe TIFF technote 2] */
-#define	TIFFTAG_INDEXED			346	/* %Indexed
-						   [Adobe TIFF Technote 3] */
-#define	TIFFTAG_JPEGTABLES		347	/* %JPEG table stream */
-#define	TIFFTAG_OPIPROXY		351	/* %OPI Proxy [Adobe TIFF technote] */
-/*
- * Tags 512-521 are obsoleted by Technical Note #2 which specifies a
- * revised JPEG-in-TIFF scheme.
- */
-#define	TIFFTAG_JPEGPROC		512	/* !JPEG processing algorithm */
-#define	    JPEGPROC_BASELINE		1	/* !baseline sequential */
-#define	    JPEGPROC_LOSSLESS		14	/* !Huffman coded lossless */
-#define	TIFFTAG_JPEGIFOFFSET		513	/* !pointer to SOI marker */
-#define	TIFFTAG_JPEGIFBYTECOUNT		514	/* !JFIF stream length */
-#define	TIFFTAG_JPEGRESTARTINTERVAL	515	/* !restart interval length */
-#define	TIFFTAG_JPEGLOSSLESSPREDICTORS	517	/* !lossless proc predictor */
-#define	TIFFTAG_JPEGPOINTTRANSFORM	518	/* !lossless point transform */
-#define	TIFFTAG_JPEGQTABLES		519	/* !Q matrice offsets */
-#define	TIFFTAG_JPEGDCTABLES		520	/* !DCT table offsets */
-#define	TIFFTAG_JPEGACTABLES		521	/* !AC coefficient offsets */
-#define	TIFFTAG_YCBCRCOEFFICIENTS	529	/* !RGB -> YCbCr transform */
-#define	TIFFTAG_YCBCRSUBSAMPLING	530	/* !YCbCr subsampling factors */
-#define	TIFFTAG_YCBCRPOSITIONING	531	/* !subsample positioning */
-#define	    YCBCRPOSITION_CENTERED	1	/* !as in PostScript Level 2 */
-#define	    YCBCRPOSITION_COSITED	2	/* !as in CCIR 601-1 */
-#define	TIFFTAG_REFERENCEBLACKWHITE	532	/* !colorimetry info */
-#define	TIFFTAG_XMLPACKET		700	/* %XML packet
-						   [Adobe XMP Specification,
-						   January 2004 */
-#define TIFFTAG_OPIIMAGEID		32781	/* %OPI ImageID
-						   [Adobe TIFF technote] */
-/* tags 32952-32956 are private tags registered to Island Graphics */
-#define TIFFTAG_REFPTS			32953	/* image reference points */
-#define TIFFTAG_REGIONTACKPOINT		32954	/* region-xform tack point */
-#define TIFFTAG_REGIONWARPCORNERS	32955	/* warp quadrilateral */
-#define TIFFTAG_REGIONAFFINE		32956	/* affine transformation mat */
-/* tags 32995-32999 are private tags registered to SGI */
-#define	TIFFTAG_MATTEING		32995	/* $use ExtraSamples */
-#define	TIFFTAG_DATATYPE		32996	/* $use SampleFormat */
-#define	TIFFTAG_IMAGEDEPTH		32997	/* z depth of image */
-#define	TIFFTAG_TILEDEPTH		32998	/* z depth/data tile */
-/* tags 33300-33309 are private tags registered to Pixar */
-/*
- * TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
- * are set when an image has been cropped out of a larger image.  
- * They reflect the size of the original uncropped image.
- * The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
- * to determine the position of the smaller image in the larger one.
- */
-#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   /* full image size in x */
-#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   /* full image size in y */
- /* Tags 33302-33306 are used to identify special image modes and data
-  * used by Pixar's texture formats.
-  */
-#define TIFFTAG_PIXAR_TEXTUREFORMAT	33302	/* texture map format */
-#define TIFFTAG_PIXAR_WRAPMODES		33303	/* s & t wrap modes */
-#define TIFFTAG_PIXAR_FOVCOT		33304	/* cotan(fov) for env. maps */
-#define TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN 33305
-#define TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA 33306
-/* tag 33405 is a private tag registered to Eastman Kodak */
-#define TIFFTAG_WRITERSERIALNUMBER      33405   /* device serial number */
-/* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
-#define	TIFFTAG_COPYRIGHT		33432	/* copyright string */
-/* IPTC TAG from RichTIFF specifications */
-#define TIFFTAG_RICHTIFFIPTC		33723
-/* 34016-34029 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
-#define TIFFTAG_IT8SITE			34016	/* site name */
-#define TIFFTAG_IT8COLORSEQUENCE	34017	/* color seq. [RGB,CMYK,etc] */
-#define TIFFTAG_IT8HEADER		34018	/* DDES Header */
-#define TIFFTAG_IT8RASTERPADDING	34019	/* raster scanline padding */
-#define TIFFTAG_IT8BITSPERRUNLENGTH	34020	/* # of bits in short run */
-#define TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH 34021/* # of bits in long run */
-#define TIFFTAG_IT8COLORTABLE		34022	/* LW colortable */
-#define TIFFTAG_IT8IMAGECOLORINDICATOR	34023	/* BP/BL image color switch */
-#define TIFFTAG_IT8BKGCOLORINDICATOR	34024	/* BP/BL bg color switch */
-#define TIFFTAG_IT8IMAGECOLORVALUE	34025	/* BP/BL image color value */
-#define TIFFTAG_IT8BKGCOLORVALUE	34026	/* BP/BL bg color value */
-#define TIFFTAG_IT8PIXELINTENSITYRANGE	34027	/* MP pixel intensity value */
-#define TIFFTAG_IT8TRANSPARENCYINDICATOR 34028	/* HC transparency switch */
-#define TIFFTAG_IT8COLORCHARACTERIZATION 34029	/* color character. table */
-#define TIFFTAG_IT8HCUSAGE		34030	/* HC usage indicator */
-#define TIFFTAG_IT8TRAPINDICATOR	34031	/* Trapping indicator
-						   (untrapped=0, trapped=1) */
-#define TIFFTAG_IT8CMYKEQUIVALENT	34032	/* CMYK color equivalents */
-/* tags 34232-34236 are private tags registered to Texas Instruments */
-#define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
-/* tag 34377 is private tag registered to Adobe for PhotoShop */
-#define TIFFTAG_PHOTOSHOP		34377 
-/* tags 34665, 34853 and 40965 are documented in EXIF specification */
-#define TIFFTAG_EXIFIFD			34665	/* Pointer to EXIF private directory */
-/* tag 34750 is a private tag registered to Adobe? */
-#define TIFFTAG_ICCPROFILE		34675	/* ICC profile data */
-/* tag 34750 is a private tag registered to Pixel Magic */
-#define	TIFFTAG_JBIGOPTIONS		34750	/* JBIG options */
-#define TIFFTAG_GPSIFD			34853	/* Pointer to GPS private directory */
-/* tags 34908-34914 are private tags registered to SGI */
-#define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. parms */
-#define	TIFFTAG_FAXSUBADDRESS		34909	/* received SubAddr string */
-#define	TIFFTAG_FAXRECVTIME		34910	/* receive time (secs) */
-#define	TIFFTAG_FAXDCS			34911	/* encoded fax ses. params, Table 2/T.30 */
-/* tags 37439-37443 are registered to SGI <gregl@sgi.com> */
-#define TIFFTAG_STONITS			37439	/* Sample value to Nits */
-/* tag 34929 is a private tag registered to FedEx */
-#define	TIFFTAG_FEDEX_EDR		34929	/* unknown use */
-#define TIFFTAG_INTEROPERABILITYIFD	40965	/* Pointer to Interoperability private directory */
-/* Adobe Digital Negative (DNG) format tags */
-#define TIFFTAG_DNGVERSION		50706	/* &DNG version number */
-#define TIFFTAG_DNGBACKWARDVERSION	50707	/* &DNG compatibility version */
-#define TIFFTAG_UNIQUECAMERAMODEL	50708	/* &name for the camera model */
-#define TIFFTAG_LOCALIZEDCAMERAMODEL	50709	/* &localized camera model
-						   name */
-#define TIFFTAG_CFAPLANECOLOR		50710	/* &CFAPattern->LinearRaw space
-						   mapping */
-#define TIFFTAG_CFALAYOUT		50711	/* &spatial layout of the CFA */
-#define TIFFTAG_LINEARIZATIONTABLE	50712	/* &lookup table description */
-#define TIFFTAG_BLACKLEVELREPEATDIM	50713	/* &repeat pattern size for
-						   the BlackLevel tag */
-#define TIFFTAG_BLACKLEVEL		50714	/* &zero light encoding level */
-#define TIFFTAG_BLACKLEVELDELTAH	50715	/* &zero light encoding level
-						   differences (columns) */
-#define TIFFTAG_BLACKLEVELDELTAV	50716	/* &zero light encoding level
-						   differences (rows) */
-#define TIFFTAG_WHITELEVEL		50717	/* &fully saturated encoding
-						   level */
-#define TIFFTAG_DEFAULTSCALE		50718	/* &default scale factors */
-#define TIFFTAG_DEFAULTCROPORIGIN	50719	/* &origin of the final image
-						   area */
-#define TIFFTAG_DEFAULTCROPSIZE		50720	/* &size of the final image 
-						   area */
-#define TIFFTAG_COLORMATRIX1		50721	/* &XYZ->reference color space
-						   transformation matrix 1 */
-#define TIFFTAG_COLORMATRIX2		50722	/* &XYZ->reference color space
-						   transformation matrix 2 */
-#define TIFFTAG_CAMERACALIBRATION1	50723	/* &calibration matrix 1 */
-#define TIFFTAG_CAMERACALIBRATION2	50724	/* &calibration matrix 2 */
-#define TIFFTAG_REDUCTIONMATRIX1	50725	/* &dimensionality reduction
-						   matrix 1 */
-#define TIFFTAG_REDUCTIONMATRIX2	50726	/* &dimensionality reduction
-						   matrix 2 */
-#define TIFFTAG_ANALOGBALANCE		50727	/* &gain applied the stored raw
-						   values*/
-#define TIFFTAG_ASSHOTNEUTRAL		50728	/* &selected white balance in
-						   linear reference space */
-#define TIFFTAG_ASSHOTWHITEXY		50729	/* &selected white balance in
-						   x-y chromaticity
-						   coordinates */
-#define TIFFTAG_BASELINEEXPOSURE	50730	/* &how much to move the zero
-						   point */
-#define TIFFTAG_BASELINENOISE		50731	/* &relative noise level */
-#define TIFFTAG_BASELINESHARPNESS	50732	/* &relative amount of
-						   sharpening */
-#define TIFFTAG_BAYERGREENSPLIT		50733	/* &how closely the values of
-						   the green pixels in the
-						   blue/green rows track the
-						   values of the green pixels
-						   in the red/green rows */
-#define TIFFTAG_LINEARRESPONSELIMIT	50734	/* &non-linear encoding range */
-#define TIFFTAG_CAMERASERIALNUMBER	50735	/* &camera's serial number */
-#define TIFFTAG_LENSINFO		50736	/* info about the lens */
-#define TIFFTAG_CHROMABLURRADIUS	50737	/* &chroma blur radius */
-#define TIFFTAG_ANTIALIASSTRENGTH	50738	/* &relative strength of the
-						   camera's anti-alias filter */
-#define TIFFTAG_SHADOWSCALE		50739	/* &used by Adobe Camera Raw */
-#define TIFFTAG_DNGPRIVATEDATA		50740	/* &manufacturer's private data */
-#define TIFFTAG_MAKERNOTESAFETY		50741	/* &whether the EXIF MakerNote
-						   tag is safe to preserve
-						   along with the rest of the
-						   EXIF data */
-#define	TIFFTAG_CALIBRATIONILLUMINANT1	50778	/* &illuminant 1 */
-#define TIFFTAG_CALIBRATIONILLUMINANT2	50779	/* &illuminant 2 */
-#define TIFFTAG_BESTQUALITYSCALE	50780	/* &best quality multiplier */
-#define TIFFTAG_RAWDATAUNIQUEID		50781	/* &unique identifier for
-						   the raw image data */
-#define TIFFTAG_ORIGINALRAWFILENAME	50827	/* &file name of the original
-						   raw file */
-#define TIFFTAG_ORIGINALRAWFILEDATA	50828	/* &contents of the original
-						   raw file */
-#define TIFFTAG_ACTIVEAREA		50829	/* &active (non-masked) pixels
-						   of the sensor */
-#define TIFFTAG_MASKEDAREAS		50830	/* &list of coordinates
-						   of fully masked pixels */
-#define TIFFTAG_ASSHOTICCPROFILE	50831	/* &these two tags used to */
-#define TIFFTAG_ASSHOTPREPROFILEMATRIX	50832	/* map cameras's color space
-						   into ICC profile space */
-#define TIFFTAG_CURRENTICCPROFILE	50833	/* & */
-#define TIFFTAG_CURRENTPREPROFILEMATRIX	50834	/* & */
-/* tag 65535 is an undefined tag used by Eastman Kodak */
-#define TIFFTAG_DCSHUESHIFTVALUES       65535   /* hue shift correction data */
-
-/*
- * The following are ``pseudo tags'' that can be used to control
- * codec-specific functionality.  These tags are not written to file.
- * Note that these values start at 0xffff+1 so that they'll never
- * collide with Aldus-assigned tags.
- *
- * If you want your private pseudo tags ``registered'' (i.e. added to
- * this file), please post a bug report via the tracking system at
- * http://www.remotesensing.org/libtiff/bugs.html with the appropriate
- * C definitions to add.
- */
-#define	TIFFTAG_FAXMODE			65536	/* Group 3/4 format control */
-#define	    FAXMODE_CLASSIC	0x0000		/* default, include RTC */
-#define	    FAXMODE_NORTC	0x0001		/* no RTC at end of data */
-#define	    FAXMODE_NOEOL	0x0002		/* no EOL code at end of row */
-#define	    FAXMODE_BYTEALIGN	0x0004		/* byte align row */
-#define	    FAXMODE_WORDALIGN	0x0008		/* word align row */
-#define	    FAXMODE_CLASSF	FAXMODE_NORTC	/* TIFF Class F */
-#define	TIFFTAG_JPEGQUALITY		65537	/* Compression quality level */
-/* Note: quality level is on the IJG 0-100 scale.  Default value is 75 */
-#define	TIFFTAG_JPEGCOLORMODE		65538	/* Auto RGB<=>YCbCr convert? */
-#define	    JPEGCOLORMODE_RAW	0x0000		/* no conversion (default) */
-#define	    JPEGCOLORMODE_RGB	0x0001		/* do auto conversion */
-#define	TIFFTAG_JPEGTABLESMODE		65539	/* What to put in JPEGTables */
-#define	    JPEGTABLESMODE_QUANT 0x0001		/* include quantization tbls */
-#define	    JPEGTABLESMODE_HUFF	0x0002		/* include Huffman tbls */
-/* Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF */
-#define	TIFFTAG_FAXFILLFUNC		65540	/* G3/G4 fill function */
-#define	TIFFTAG_PIXARLOGDATAFMT		65549	/* PixarLogCodec I/O data sz */
-#define	    PIXARLOGDATAFMT_8BIT	0	/* regular u_char samples */
-#define	    PIXARLOGDATAFMT_8BITABGR	1	/* ABGR-order u_chars */
-#define	    PIXARLOGDATAFMT_11BITLOG	2	/* 11-bit log-encoded (raw) */
-#define	    PIXARLOGDATAFMT_12BITPICIO	3	/* as per PICIO (1.0==2048) */
-#define	    PIXARLOGDATAFMT_16BIT	4	/* signed short samples */
-#define	    PIXARLOGDATAFMT_FLOAT	5	/* IEEE float samples */
-/* 65550-65556 are allocated to Oceana Matrix <dev@oceana.com> */
-#define TIFFTAG_DCSIMAGERTYPE           65550   /* imager model & filter */
-#define     DCSIMAGERMODEL_M3           0       /* M3 chip (1280 x 1024) */
-#define     DCSIMAGERMODEL_M5           1       /* M5 chip (1536 x 1024) */
-#define     DCSIMAGERMODEL_M6           2       /* M6 chip (3072 x 2048) */
-#define     DCSIMAGERFILTER_IR          0       /* infrared filter */
-#define     DCSIMAGERFILTER_MONO        1       /* monochrome filter */
-#define     DCSIMAGERFILTER_CFA         2       /* color filter array */
-#define     DCSIMAGERFILTER_OTHER       3       /* other filter */
-#define TIFFTAG_DCSINTERPMODE           65551   /* interpolation mode */
-#define     DCSINTERPMODE_NORMAL        0x0     /* whole image, default */
-#define     DCSINTERPMODE_PREVIEW       0x1     /* preview of image (384x256) */
-#define TIFFTAG_DCSBALANCEARRAY         65552   /* color balance values */
-#define TIFFTAG_DCSCORRECTMATRIX        65553   /* color correction values */
-#define TIFFTAG_DCSGAMMA                65554   /* gamma value */
-#define TIFFTAG_DCSTOESHOULDERPTS       65555   /* toe & shoulder points */
-#define TIFFTAG_DCSCALIBRATIONFD        65556   /* calibration file desc */
-/* Note: quality level is on the ZLIB 1-9 scale. Default value is -1 */
-#define	TIFFTAG_ZIPQUALITY		65557	/* compression quality level */
-#define	TIFFTAG_PIXARLOGQUALITY		65558	/* PixarLog uses same scale */
-/* 65559 is allocated to Oceana Matrix <dev@oceana.com> */
-#define TIFFTAG_DCSCLIPRECTANGLE	65559	/* area of image to acquire */
-#define TIFFTAG_SGILOGDATAFMT		65560	/* SGILog user data format */
-#define     SGILOGDATAFMT_FLOAT		0	/* IEEE float samples */
-#define     SGILOGDATAFMT_16BIT		1	/* 16-bit samples */
-#define     SGILOGDATAFMT_RAW		2	/* uninterpreted data */
-#define     SGILOGDATAFMT_8BIT		3	/* 8-bit RGB monitor values */
-#define TIFFTAG_SGILOGENCODE		65561 /* SGILog data encoding control*/
-#define     SGILOGENCODE_NODITHER	0     /* do not dither encoded values*/
-#define     SGILOGENCODE_RANDITHER	1     /* randomly dither encd values */
-
-/*
- * EXIF tags
- */
-#define EXIFTAG_EXPOSURETIME		33434	/* Exposure time */
-#define EXIFTAG_FNUMBER			33437	/* F number */
-#define EXIFTAG_EXPOSUREPROGRAM		34850	/* Exposure program */
-#define EXIFTAG_SPECTRALSENSITIVITY	34852	/* Spectral sensitivity */
-#define EXIFTAG_ISOSPEEDRATINGS		34855	/* ISO speed rating */
-#define EXIFTAG_OECF			34856	/* Optoelectric conversion
-						   factor */
-#define EXIFTAG_EXIFVERSION		36864	/* Exif version */
-#define EXIFTAG_DATETIMEORIGINAL	36867	/* Date and time of original
-						   data generation */
-#define EXIFTAG_DATETIMEDIGITIZED	36868	/* Date and time of digital
-						   data generation */
-#define EXIFTAG_COMPONENTSCONFIGURATION	37121	/* Meaning of each component */
-#define EXIFTAG_COMPRESSEDBITSPERPIXEL	37122	/* Image compression mode */
-#define EXIFTAG_SHUTTERSPEEDVALUE	37377	/* Shutter speed */
-#define EXIFTAG_APERTUREVALUE		37378	/* Aperture */
-#define EXIFTAG_BRIGHTNESSVALUE		37379	/* Brightness */
-#define EXIFTAG_EXPOSUREBIASVALUE	37380	/* Exposure bias */
-#define EXIFTAG_MAXAPERTUREVALUE	37381	/* Maximum lens aperture */
-#define EXIFTAG_SUBJECTDISTANCE		37382	/* Subject distance */
-#define EXIFTAG_METERINGMODE		37383	/* Metering mode */
-#define EXIFTAG_LIGHTSOURCE		37384	/* Light source */
-#define EXIFTAG_FLASH			37385	/* Flash */
-#define EXIFTAG_FOCALLENGTH		37386	/* Lens focal length */
-#define EXIFTAG_SUBJECTAREA		37396	/* Subject area */
-#define EXIFTAG_MAKERNOTE		37500	/* Manufacturer notes */
-#define EXIFTAG_USERCOMMENT		37510	/* User comments */
-#define EXIFTAG_SUBSECTIME		37520	/* DateTime subseconds */
-#define EXIFTAG_SUBSECTIMEORIGINAL	37521	/* DateTimeOriginal subseconds */
-#define EXIFTAG_SUBSECTIMEDIGITIZED	37522	/* DateTimeDigitized subseconds */
-#define EXIFTAG_FLASHPIXVERSION		40960	/* Supported Flashpix version */
-#define EXIFTAG_COLORSPACE		40961	/* Color space information */
-#define EXIFTAG_PIXELXDIMENSION		40962	/* Valid image width */
-#define EXIFTAG_PIXELYDIMENSION		40963	/* Valid image height */
-#define EXIFTAG_RELATEDSOUNDFILE	40964	/* Related audio file */
-#define EXIFTAG_FLASHENERGY		41483	/* Flash energy */
-#define EXIFTAG_SPATIALFREQUENCYRESPONSE 41484	/* Spatial frequency response */
-#define EXIFTAG_FOCALPLANEXRESOLUTION	41486	/* Focal plane X resolution */
-#define EXIFTAG_FOCALPLANEYRESOLUTION	41487	/* Focal plane Y resolution */
-#define EXIFTAG_FOCALPLANERESOLUTIONUNIT 41488	/* Focal plane resolution unit */
-#define EXIFTAG_SUBJECTLOCATION		41492	/* Subject location */
-#define EXIFTAG_EXPOSUREINDEX		41493	/* Exposure index */
-#define EXIFTAG_SENSINGMETHOD		41495	/* Sensing method */
-#define EXIFTAG_FILESOURCE		41728	/* File source */
-#define EXIFTAG_SCENETYPE		41729	/* Scene type */
-#define EXIFTAG_CFAPATTERN		41730	/* CFA pattern */
-#define EXIFTAG_CUSTOMRENDERED		41985	/* Custom image processing */
-#define EXIFTAG_EXPOSUREMODE		41986	/* Exposure mode */
-#define EXIFTAG_WHITEBALANCE		41987	/* White balance */
-#define EXIFTAG_DIGITALZOOMRATIO	41988	/* Digital zoom ratio */
-#define EXIFTAG_FOCALLENGTHIN35MMFILM	41989	/* Focal length in 35 mm film */
-#define EXIFTAG_SCENECAPTURETYPE	41990	/* Scene capture type */
-#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
-#define EXIFTAG_CONTRAST		41992	/* Contrast */
-#define EXIFTAG_SATURATION		41993	/* Saturation */
-#define EXIFTAG_SHARPNESS		41994	/* Sharpness */
-#define EXIFTAG_DEVICESETTINGDESCRIPTION 41995	/* Device settings description */
-#define EXIFTAG_SUBJECTDISTANCERANGE	41996	/* Subject distance range */
-#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
-#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
-#define EXIFTAG_IMAGEUNIQUEID		42016	/* Unique image ID */
-
-#endif /* _TIFF_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiffconf.h b/thirdparty/libtiff/tiffconf.h
deleted file mode 100644
index 68dfcf0..0000000
--- a/thirdparty/libtiff/tiffconf.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-  Configuration defines for installed libtiff.
-  This file maintained for backward compatibility. Do not use definitions
-  from this file in your programs.
-*/
-
-#ifndef _TIFFCONF_
-#define _TIFFCONF_
-
-/* Define to 1 if the system has the type `int16'. */
-/* #undef HAVE_INT16 */
-
-/* Define to 1 if the system has the type `int32'. */
-/* #undef HAVE_INT32 */
-
-/* Define to 1 if the system has the type `int8'. */
-/* #undef HAVE_INT8 */
-
-/* The size of a `int', as computed by sizeof. */
-#define SIZEOF_INT 4
-
-/* The size of a `long', as computed by sizeof. */
-#define SIZEOF_LONG 4
-
-/* Signed 64-bit type formatter */
-#define TIFF_INT64_FORMAT "%I64d"
-
-/* Signed 64-bit type */
-#ifdef _MSC_VER
-#define TIFF_INT64_T signed __int64
-#else
-#define TIFF_INT64_T long long
-#endif
-
-/* Unsigned 64-bit type formatter */
-#define TIFF_UINT64_FORMAT "%I64u"
-
-/* Unsigned 64-bit type */
-#ifdef _MSC_VER
-#define TIFF_UINT64_T unsigned __int64
-#else
-#define TIFF_UINT64_T unsigned long long
-#endif
-
-/* Compatibility stuff. */
-
-/* Define as 0 or 1 according to the floating point format suported by the
-   machine */
-#define HAVE_IEEEFP 1
-
-/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-
-/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
-   (Intel) */
-#define HOST_BIGENDIAN 0
-
-/* Support CCITT Group 3 & 4 algorithms */
-#define CCITT_SUPPORT 1
-
-/* Support JPEG compression (requires IJG JPEG library) */
-/* #undef JPEG_SUPPORT */
-
-/* Support LogLuv high dynamic range encoding */
-#define LOGLUV_SUPPORT 1
-
-/* Support LZW algorithm */
-#define LZW_SUPPORT 1
-
-/* Support NeXT 2-bit RLE algorithm */
-#define NEXT_SUPPORT 1
-
-/* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
-   fails with unpatched IJG JPEG library) */
-/* #undef OJPEG_SUPPORT */
-
-/* Support Macintosh PackBits algorithm */
-#define PACKBITS_SUPPORT 1
-
-/* Support Pixar log-format algorithm (requires Zlib) */
-/* #undef PIXARLOG_SUPPORT */
-
-/* Support ThunderScan 4-bit RLE algorithm */
-#define THUNDER_SUPPORT 1
-
-/* Support Deflate compression */
-/* #undef ZIP_SUPPORT */
-
-/* Support strip chopping (whether or not to convert single-strip uncompressed
-   images to mutiple strips of ~8Kb to reduce memory usage) */
-#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
-
-/* Enable SubIFD tag (330) support */
-#define SUBIFD_SUPPORT 1
-
-/* Treat extra sample as alpha (default enabled). The RGBA interface will
-   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
-   packages produce RGBA files but don't mark the alpha properly. */
-#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
-
-/* Pick up YCbCr subsampling info from the JPEG data stream to support files
-   lacking the tag (default enabled). */
-#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
-
-/*
- * Feature support definitions.
- * XXX: These macros are obsoleted. Don't use them in your apps!
- * Macros stays here for backward compatibility and should be always defined.
- */
-#define COLORIMETRY_SUPPORT
-#define YCBCR_SUPPORT
-#define CMYK_SUPPORT
-#define ICC_SUPPORT
-#define PHOTOSHOP_SUPPORT
-#define IPTC_SUPPORT
-
-#endif /* _TIFFCONF_ */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiffio.h b/thirdparty/libtiff/tiffio.h
deleted file mode 100644
index 36e4997..0000000
--- a/thirdparty/libtiff/tiffio.h
+++ /dev/null
@@ -1,526 +0,0 @@
-/* $Id: tiffio.h,v 1.56.2.4 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFIO_
-#define	_TIFFIO_
-
-/*
- * TIFF I/O Library Definitions.
- */
-#include "tiff.h"
-#include "tiffvers.h"
-
-/*
- * TIFF is defined as an incomplete type to hide the
- * library's internal data structures from clients.
- */
-typedef	struct tiff TIFF;
-
-/*
- * The following typedefs define the intrinsic size of
- * data types used in the *exported* interfaces.  These
- * definitions depend on the proper definition of types
- * in tiff.h.  Note also that the varargs interface used
- * to pass tag types and values uses the types defined in
- * tiff.h directly.
- *
- * NB: ttag_t is unsigned int and not unsigned short because
- *     ANSI C requires that the type before the ellipsis be a
- *     promoted type (i.e. one of int, unsigned int, pointer,
- *     or double) and because we defined pseudo-tags that are
- *     outside the range of legal Aldus-assigned tags.
- * NB: tsize_t is int32 and not uint32 because some functions
- *     return -1.
- * NB: toff_t is not off_t for many reasons; TIFFs max out at
- *     32-bit file offsets being the most important, and to ensure
- *     that it is unsigned, rather than signed.
- */
-typedef uint32 ttag_t;          /* directory tag */
-typedef uint16 tdir_t;          /* directory index */
-typedef uint16 tsample_t;       /* sample number */
-typedef uint32 tstrile_t;       /* strip or tile number */
-typedef tstrile_t tstrip_t;     /* strip number */
-typedef tstrile_t ttile_t;      /* tile number */
-typedef size_t tsize_t;          /* i/o size in bytes */
-typedef void* tdata_t;          /* image data ref */
-typedef uint32 toff_t;          /* file offset */
-
-#if !defined(__WIN32__) && (defined(_WIN32) || defined(WIN32))
-#define __WIN32__
-#endif
-
-/*
- * On windows you should define USE_WIN32_FILEIO if you are using tif_win32.c
- * or AVOID_WIN32_FILEIO if you are using something else (like tif_unix.c).
- *
- * By default tif_unix.c is assumed.
- */
-
-#if defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
-#  if !defined(__CYGWIN) && !defined(AVOID_WIN32_FILEIO) && !defined(USE_WIN32_FILEIO)
-#    define AVOID_WIN32_FILEIO
-#  endif
-#endif
-
-#if defined(USE_WIN32_FILEIO)
-# define VC_EXTRALEAN
-# include <windows.h>
-# ifdef __WIN32__
-DECLARE_HANDLE(thandle_t);	/* Win32 file handle */
-# else
-typedef	HFILE thandle_t;	/* client data handle */
-# endif /* __WIN32__ */
-#else
-typedef	void* thandle_t;	/* client data handle */
-#endif /* USE_WIN32_FILEIO */
-
-/*
- * Flags to pass to TIFFPrintDirectory to control
- * printing of data structures that are potentially
- * very large.   Bit-or these flags to enable printing
- * multiple items.
- */
-#define	TIFFPRINT_NONE		0x0		/* no extra info */
-#define	TIFFPRINT_STRIPS	0x1		/* strips/tiles info */
-#define	TIFFPRINT_CURVES	0x2		/* color/gray response curves */
-#define	TIFFPRINT_COLORMAP	0x4		/* colormap */
-#define	TIFFPRINT_JPEGQTABLES	0x100		/* JPEG Q matrices */
-#define	TIFFPRINT_JPEGACTABLES	0x200		/* JPEG AC tables */
-#define	TIFFPRINT_JPEGDCTABLES	0x200		/* JPEG DC tables */
-
-/* 
- * Colour conversion stuff
- */
-
-/* reference white */
-#define D65_X0 (95.0470F)
-#define D65_Y0 (100.0F)
-#define D65_Z0 (108.8827F)
-
-#define D50_X0 (96.4250F)
-#define D50_Y0 (100.0F)
-#define D50_Z0 (82.4680F)
-
-/* Structure for holding information about a display device. */
-
-typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
-
-typedef struct {
-	float d_mat[3][3]; 		/* XYZ -> luminance matrix */
-	float d_YCR;			/* Light o/p for reference white */
-	float d_YCG;
-	float d_YCB;
-	uint32 d_Vrwr;			/* Pixel values for ref. white */
-	uint32 d_Vrwg;
-	uint32 d_Vrwb;
-	float d_Y0R;			/* Residual light for black pixel */
-	float d_Y0G;
-	float d_Y0B;
-	float d_gammaR;			/* Gamma values for the three guns */
-	float d_gammaG;
-	float d_gammaB;
-} TIFFDisplay;
-
-typedef struct {				/* YCbCr->RGB support */
-	TIFFRGBValue* clamptab;			/* range clamping table */
-	int*	Cr_r_tab;
-	int*	Cb_b_tab;
-	int32*	Cr_g_tab;
-	int32*	Cb_g_tab;
-        int32*  Y_tab;
-} TIFFYCbCrToRGB;
-
-typedef struct {				/* CIE Lab 1976->RGB support */
-	int	range;				/* Size of conversion table */
-#define CIELABTORGB_TABLE_RANGE 1500
-	float	rstep, gstep, bstep;
-	float	X0, Y0, Z0;			/* Reference white point */
-	TIFFDisplay display;
-	float	Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */
-	float	Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */
-	float	Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */
-} TIFFCIELabToRGB;
-
-/*
- * RGBA-style image support.
- */
-typedef struct _TIFFRGBAImage TIFFRGBAImage;
-/*
- * The image reading and conversion routines invoke
- * ``put routines'' to copy/image/whatever tiles of
- * raw image data.  A default set of routines are 
- * provided to convert/copy raw image data to 8-bit
- * packed ABGR format rasters.  Applications can supply
- * alternate routines that unpack the data into a
- * different format or, for example, unpack the data
- * and draw the unpacked raster on the display.
- */
-typedef void (*tileContigRoutine)
-    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
-	unsigned char*);
-typedef void (*tileSeparateRoutine)
-    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
-	unsigned char*, unsigned char*, unsigned char*, unsigned char*);
-/*
- * RGBA-reader state.
- */
-struct _TIFFRGBAImage {
-	TIFF* tif;                              /* image handle */
-	int stoponerr;                          /* stop on read error */
-	int isContig;                           /* data is packed/separate */
-	int alpha;                              /* type of alpha data present */
-	uint32 width;                           /* image width */
-	uint32 height;                          /* image height */
-	uint16 bitspersample;                   /* image bits/sample */
-	uint16 samplesperpixel;                 /* image samples/pixel */
-	uint16 orientation;                     /* image orientation */
-	uint16 req_orientation;                 /* requested orientation */
-	uint16 photometric;                     /* image photometric interp */
-	uint16* redcmap;                        /* colormap pallete */
-	uint16* greencmap;
-	uint16* bluecmap;
-	/* get image data routine */
-	int (*get)(TIFFRGBAImage*, uint32*, uint32, uint32);
-	/* put decoded strip/tile */
-	union {
-	    void (*any)(TIFFRGBAImage*);
-	    tileContigRoutine contig;
-	    tileSeparateRoutine separate;
-	} put;
-	TIFFRGBValue* Map;                      /* sample mapping array */
-	uint32** BWmap;                         /* black&white map */
-	uint32** PALmap;                        /* palette image map */
-	TIFFYCbCrToRGB* ycbcr;                  /* YCbCr conversion state */
-	TIFFCIELabToRGB* cielab;                /* CIE L*a*b conversion state */
-
-	int row_offset;
-	int col_offset;
-};
-
-/*
- * Macros for extracting components from the
- * packed ABGR form returned by TIFFReadRGBAImage.
- */
-#define	TIFFGetR(abgr)	((abgr) & 0xff)
-#define	TIFFGetG(abgr)	(((abgr) >> 8) & 0xff)
-#define	TIFFGetB(abgr)	(((abgr) >> 16) & 0xff)
-#define	TIFFGetA(abgr)	(((abgr) >> 24) & 0xff)
-
-/*
- * A CODEC is a software package that implements decoding,
- * encoding, or decoding+encoding of a compression algorithm.
- * The library provides a collection of builtin codecs.
- * More codecs may be registered through calls to the library
- * and/or the builtin implementations may be overridden.
- */
-typedef	int (*TIFFInitMethod)(TIFF*, int);
-typedef struct {
-	char*		name;
-	uint16		scheme;
-	TIFFInitMethod	init;
-} TIFFCodec;
-
-#include <stdio.h>
-#include <stdarg.h>
-
-/* share internal LogLuv conversion routines? */
-#ifndef LOGLUV_PUBLIC
-#define LOGLUV_PUBLIC		1
-#endif
-
-#if !defined(__GNUC__) && !defined(__attribute__)
-#  define __attribute__(x) /*nothing*/
-#endif
-
-#if defined(c_plusplus) || defined(__cplusplus)
-extern "C" {
-#endif
-typedef	void (*TIFFErrorHandler)(const char*, const char*, va_list);
-typedef	void (*TIFFErrorHandlerExt)(thandle_t, const char*, const char*, va_list);
-typedef	tsize_t (*TIFFReadWriteProc)(thandle_t, tdata_t, tsize_t);
-typedef	toff_t (*TIFFSeekProc)(thandle_t, toff_t, int);
-typedef	int (*TIFFCloseProc)(thandle_t);
-typedef	toff_t (*TIFFSizeProc)(thandle_t);
-typedef	int (*TIFFMapFileProc)(thandle_t, tdata_t*, toff_t*);
-typedef	void (*TIFFUnmapFileProc)(thandle_t, tdata_t, toff_t);
-typedef	void (*TIFFExtendProc)(TIFF*); 
-
-extern	const char* TIFFGetVersion(void);
-
-extern	const TIFFCodec* TIFFFindCODEC(uint16);
-extern	TIFFCodec* TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod);
-extern	void TIFFUnRegisterCODEC(TIFFCodec*);
-extern  int TIFFIsCODECConfigured(uint16);
-extern	TIFFCodec* TIFFGetConfiguredCODECs(void);
-
-/*
- * Auxiliary functions.
- */
-
-extern	tdata_t _TIFFmalloc(tsize_t);
-extern	tdata_t _TIFFrealloc(tdata_t, tsize_t);
-extern	void _TIFFmemset(tdata_t, int, tsize_t);
-extern	void _TIFFmemcpy(tdata_t, const tdata_t, tsize_t);
-extern	int _TIFFmemcmp(const tdata_t, const tdata_t, tsize_t);
-extern	void _TIFFfree(tdata_t);
-
-/*
-** Stuff, related to tag handling and creating custom tags.
-*/
-extern  int  TIFFGetTagListCount( TIFF * );
-extern  ttag_t TIFFGetTagListEntry( TIFF *, int tag_index );
-    
-#define	TIFF_ANY	TIFF_NOTYPE	/* for field descriptor searching */
-#define	TIFF_VARIABLE	-1		/* marker for variable length tags */
-#define	TIFF_SPP	-2		/* marker for SamplesPerPixel tags */
-#define	TIFF_VARIABLE2	-3		/* marker for uint32 var-length tags */
-
-#define FIELD_CUSTOM    65    
-
-typedef	struct {
-	ttag_t	field_tag;		/* field's tag */
-	short	field_readcount;	/* read count/TIFF_VARIABLE/TIFF_SPP */
-	short	field_writecount;	/* write count/TIFF_VARIABLE */
-	TIFFDataType field_type;	/* type of associated data */
-        unsigned short field_bit;	/* bit in fieldsset bit vector */
-	unsigned char field_oktochange;	/* if true, can change while writing */
-	unsigned char field_passcount;	/* if true, pass dir count on set */
-	char	*field_name;		/* ASCII name */
-} TIFFFieldInfo;
-
-typedef struct _TIFFTagValue {
-    const TIFFFieldInfo  *info;
-    int             count;
-    void           *value;
-} TIFFTagValue;
-
-extern	void TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], int);
-extern	const TIFFFieldInfo* TIFFFindFieldInfo(TIFF*, ttag_t, TIFFDataType);
-extern  const TIFFFieldInfo* TIFFFindFieldInfoByName(TIFF* , const char *,
-						     TIFFDataType);
-extern	const TIFFFieldInfo* TIFFFieldWithTag(TIFF*, ttag_t);
-extern	const TIFFFieldInfo* TIFFFieldWithName(TIFF*, const char *);
-
-typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
-typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
-typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
-    
-typedef struct {
-    TIFFVSetMethod	vsetfield;	/* tag set routine */
-    TIFFVGetMethod	vgetfield;	/* tag get routine */
-    TIFFPrintMethod	printdir;	/* directory print routine */
-} TIFFTagMethods;
-        
-extern  TIFFTagMethods *TIFFAccessTagMethods( TIFF * );
-extern  void *TIFFGetClientInfo( TIFF *, const char * );
-extern  void TIFFSetClientInfo( TIFF *, void *, const char * );
-
-extern	void TIFFCleanup(TIFF*);
-extern	void TIFFClose(TIFF*);
-extern	int TIFFFlush(TIFF*);
-extern	int TIFFFlushData(TIFF*);
-extern	int TIFFGetField(TIFF*, ttag_t, ...);
-extern	int TIFFVGetField(TIFF*, ttag_t, va_list);
-extern	int TIFFGetFieldDefaulted(TIFF*, ttag_t, ...);
-extern	int TIFFVGetFieldDefaulted(TIFF*, ttag_t, va_list);
-extern	int TIFFReadDirectory(TIFF*);
-extern	int TIFFReadCustomDirectory(TIFF*, toff_t, const TIFFFieldInfo[],
-				    size_t);
-extern	int TIFFReadEXIFDirectory(TIFF*, toff_t);
-extern	tsize_t TIFFScanlineSize(TIFF*);
-extern	tsize_t TIFFOldScanlineSize(TIFF*);
-extern	tsize_t TIFFNewScanlineSize(TIFF*);
-extern	tsize_t TIFFRasterScanlineSize(TIFF*);
-extern	tsize_t TIFFStripSize(TIFF*);
-extern	tsize_t TIFFRawStripSize(TIFF*, tstrip_t);
-extern	tsize_t TIFFVStripSize(TIFF*, uint32);
-extern	tsize_t TIFFTileRowSize(TIFF*);
-extern	tsize_t TIFFTileSize(TIFF*);
-extern	tsize_t TIFFVTileSize(TIFF*, uint32);
-extern	uint32 TIFFDefaultStripSize(TIFF*, uint32);
-extern	void TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
-extern	int TIFFFileno(TIFF*);
-extern  int TIFFSetFileno(TIFF*, int);
-extern  thandle_t TIFFClientdata(TIFF*);
-extern  thandle_t TIFFSetClientdata(TIFF*, thandle_t);
-extern	int TIFFGetMode(TIFF*);
-extern	int TIFFSetMode(TIFF*, int);
-extern	int TIFFIsTiled(TIFF*);
-extern	int TIFFIsByteSwapped(TIFF*);
-extern	int TIFFIsUpSampled(TIFF*);
-extern	int TIFFIsMSB2LSB(TIFF*);
-extern	int TIFFIsBigEndian(TIFF*);
-extern	TIFFReadWriteProc TIFFGetReadProc(TIFF*);
-extern	TIFFReadWriteProc TIFFGetWriteProc(TIFF*);
-extern	TIFFSeekProc TIFFGetSeekProc(TIFF*);
-extern	TIFFCloseProc TIFFGetCloseProc(TIFF*);
-extern	TIFFSizeProc TIFFGetSizeProc(TIFF*);
-extern	TIFFMapFileProc TIFFGetMapFileProc(TIFF*);
-extern	TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF*);
-extern	uint32 TIFFCurrentRow(TIFF*);
-extern	tdir_t TIFFCurrentDirectory(TIFF*);
-extern	tdir_t TIFFNumberOfDirectories(TIFF*);
-extern	uint32 TIFFCurrentDirOffset(TIFF*);
-extern	tstrip_t TIFFCurrentStrip(TIFF*);
-extern	ttile_t TIFFCurrentTile(TIFF*);
-extern	int TIFFReadBufferSetup(TIFF*, tdata_t, tsize_t);
-extern	int TIFFWriteBufferSetup(TIFF*, tdata_t, tsize_t);
-extern	int TIFFSetupStrips(TIFF *);
-extern  int TIFFWriteCheck(TIFF*, int, const char *);
-extern	void TIFFFreeDirectory(TIFF*);
-extern  int TIFFCreateDirectory(TIFF*);
-extern	int TIFFLastDirectory(TIFF*);
-extern	int TIFFSetDirectory(TIFF*, tdir_t);
-extern	int TIFFSetSubDirectory(TIFF*, uint32);
-extern	int TIFFUnlinkDirectory(TIFF*, tdir_t);
-extern	int TIFFSetField(TIFF*, ttag_t, ...);
-extern	int TIFFVSetField(TIFF*, ttag_t, va_list);
-extern	int TIFFWriteDirectory(TIFF *);
-extern	int TIFFCheckpointDirectory(TIFF *);
-extern	int TIFFRewriteDirectory(TIFF *);
-extern	int TIFFReassignTagToIgnore(enum TIFFIgnoreSense, int);
-
-#if defined(c_plusplus) || defined(__cplusplus)
-extern	void TIFFPrintDirectory(TIFF*, FILE*, long = 0);
-extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
-extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
-extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0);
-extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,
-				      int = ORIENTATION_BOTLEFT, int = 0);
-#else
-extern	void TIFFPrintDirectory(TIFF*, FILE*, long);
-extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t);
-extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t);
-extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int);
-extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int);
-#endif
-
-extern	int TIFFReadRGBAStrip(TIFF*, tstrip_t, uint32 * );
-extern	int TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * );
-extern	int TIFFRGBAImageOK(TIFF*, char [1024]);
-extern	int TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024]);
-extern	int TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32);
-extern	void TIFFRGBAImageEnd(TIFFRGBAImage*);
-extern	TIFF* TIFFOpen(const char*, const char*);
-# ifdef __WIN32__
-extern	TIFF* TIFFOpenW(const wchar_t*, const char*);
-# endif /* __WIN32__ */
-extern	TIFF* TIFFFdOpen(int, const char*, const char*);
-extern	TIFF* TIFFClientOpen(const char*, const char*,
-	    thandle_t,
-	    TIFFReadWriteProc, TIFFReadWriteProc,
-	    TIFFSeekProc, TIFFCloseProc,
-	    TIFFSizeProc,
-	    TIFFMapFileProc, TIFFUnmapFileProc);
-extern	const char* TIFFFileName(TIFF*);
-extern	const char* TIFFSetFileName(TIFF*, const char *);
-extern void TIFFError(const char*, const char*, ...) __attribute__((format (printf,2,3)));
-extern void TIFFErrorExt(thandle_t, const char*, const char*, ...) __attribute__((format (printf,3,4)));
-extern void TIFFWarning(const char*, const char*, ...) __attribute__((format (printf,2,3)));
-extern void TIFFWarningExt(thandle_t, const char*, const char*, ...) __attribute__((format (printf,3,4)));
-extern	TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler);
-extern	TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt);
-extern	TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler);
-extern	TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt);
-extern	TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc);
-extern	ttile_t TIFFComputeTile(TIFF*, uint32, uint32, uint32, tsample_t);
-extern	int TIFFCheckTile(TIFF*, uint32, uint32, uint32, tsample_t);
-extern	ttile_t TIFFNumberOfTiles(TIFF*);
-extern	tsize_t TIFFReadTile(TIFF*,
-	    tdata_t, uint32, uint32, uint32, tsample_t);
-extern	tsize_t TIFFWriteTile(TIFF*,
-	    tdata_t, uint32, uint32, uint32, tsample_t);
-extern	tstrip_t TIFFComputeStrip(TIFF*, uint32, tsample_t);
-extern	tstrip_t TIFFNumberOfStrips(TIFF*);
-extern	tsize_t TIFFReadEncodedStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
-extern	tsize_t TIFFReadRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
-extern	tsize_t TIFFReadEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
-extern	tsize_t TIFFReadRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
-extern	tsize_t TIFFWriteEncodedStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
-extern	tsize_t TIFFWriteRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
-extern	tsize_t TIFFWriteEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
-extern	tsize_t TIFFWriteRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
-extern	int TIFFDataWidth(TIFFDataType);    /* table of tag datatype widths */
-extern	void TIFFSetWriteOffset(TIFF*, toff_t);
-extern	void TIFFSwabShort(uint16*);
-extern	void TIFFSwabLong(uint32*);
-extern	void TIFFSwabDouble(double*);
-extern	void TIFFSwabArrayOfShort(uint16*, unsigned long);
-extern	void TIFFSwabArrayOfTriples(uint8*, unsigned long);
-extern	void TIFFSwabArrayOfLong(uint32*, unsigned long);
-extern	void TIFFSwabArrayOfDouble(double*, unsigned long);
-extern	void TIFFReverseBits(unsigned char *, unsigned long);
-extern	const unsigned char* TIFFGetBitRevTable(int);
-
-#ifdef LOGLUV_PUBLIC
-#define U_NEU		0.210526316
-#define V_NEU		0.473684211
-#define UVSCALE		410.
-extern	double LogL16toY(int);
-extern	double LogL10toY(int);
-extern	void XYZtoRGB24(float*, uint8*);
-extern	int uv_decode(double*, double*, int);
-extern	void LogLuv24toXYZ(uint32, float*);
-extern	void LogLuv32toXYZ(uint32, float*);
-#if defined(c_plusplus) || defined(__cplusplus)
-extern	int LogL16fromY(double, int = SGILOGENCODE_NODITHER);
-extern	int LogL10fromY(double, int = SGILOGENCODE_NODITHER);
-extern	int uv_encode(double, double, int = SGILOGENCODE_NODITHER);
-extern	uint32 LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
-extern	uint32 LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
-#else
-extern	int LogL16fromY(double, int);
-extern	int LogL10fromY(double, int);
-extern	int uv_encode(double, double, int);
-extern	uint32 LogLuv24fromXYZ(float*, int);
-extern	uint32 LogLuv32fromXYZ(float*, int);
-#endif
-#endif /* LOGLUV_PUBLIC */
-    
-extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB*, TIFFDisplay *, float*);
-extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,
-			    float *, float *, float *);
-extern void TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,
-			 uint32 *, uint32 *, uint32 *);
-
-extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*);
-extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,
-			   uint32 *, uint32 *, uint32 *);
-
-#if defined(c_plusplus) || defined(__cplusplus)
-}
-#endif
-
-#endif /* _TIFFIO_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiffio.hxx b/thirdparty/libtiff/tiffio.hxx
deleted file mode 100644
index ee3fd32..0000000
--- a/thirdparty/libtiff/tiffio.hxx
+++ /dev/null
@@ -1,49 +0,0 @@
-/* $Id: tiffio.hxx,v 1.1.2.1 2010-06-08 18:50:43 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFIO_HXX_
-#define	_TIFFIO_HXX_
-
-/*
- * TIFF I/O library definitions which provide C++ streams API.
- */
-
-#include <iostream>
-#include "tiff.h"
-
-extern	TIFF* TIFFStreamOpen(const char*, std::ostream *);
-extern	TIFF* TIFFStreamOpen(const char*, std::istream *);
-
-#endif /* _TIFFIO_HXX_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c++
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiffiop.h b/thirdparty/libtiff/tiffiop.h
deleted file mode 100644
index a064039..0000000
--- a/thirdparty/libtiff/tiffiop.h
+++ /dev/null
@@ -1,350 +0,0 @@
-/* $Id: tiffiop.h,v 1.51.2.6 2010-06-12 02:55:16 bfriesen Exp $ */
-
-/*
- * Copyright (c) 1988-1997 Sam Leffler
- * Copyright (c) 1991-1997 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFIOP_
-#define	_TIFFIOP_
-/*
- * ``Library-private'' definitions.
- */
-
-#include "tif_config.h"
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-
-#ifdef HAVE_ASSERT_H
-# include <assert.h>
-#else
-# define assert(x) 
-#endif
-
-#ifdef HAVE_SEARCH_H
-# include <search.h>
-#else
-extern void *lfind(const void *, const void *, size_t *, size_t,
-		   int (*)(const void *, const void *));
-#endif
-
-/*
-  Libtiff itself does not require a 64-bit type, but bundled TIFF
-  utilities may use it.
-*/
-typedef TIFF_INT64_T  int64;
-typedef TIFF_UINT64_T uint64;
-
-#include "tiffio.h"
-#include "tif_dir.h"
-
-#ifndef STRIP_SIZE_DEFAULT
-# define STRIP_SIZE_DEFAULT 8192
-#endif
-
-#define    streq(a,b)      (strcmp(a,b) == 0)
-
-#ifndef TRUE
-#define	TRUE	1
-#define	FALSE	0
-#endif
-
-typedef struct client_info {
-    struct client_info *next;
-    void      *data;
-    char      *name;
-} TIFFClientInfoLink;
-
-/*
- * Typedefs for ``method pointers'' used internally.
- */
-typedef	unsigned char tidataval_t;	/* internal image data value type */
-typedef	tidataval_t* tidata_t;		/* reference to internal image data */
-
-typedef	void (*TIFFVoidMethod)(TIFF*);
-typedef	int (*TIFFBoolMethod)(TIFF*);
-typedef	int (*TIFFPreMethod)(TIFF*, tsample_t);
-typedef	int (*TIFFCodeMethod)(TIFF*, tidata_t, tsize_t, tsample_t);
-typedef	int (*TIFFSeekMethod)(TIFF*, uint32);
-typedef	void (*TIFFPostMethod)(TIFF*, tidata_t, tsize_t);
-typedef	uint32 (*TIFFStripMethod)(TIFF*, uint32);
-typedef	void (*TIFFTileMethod)(TIFF*, uint32*, uint32*);
-
-struct tiff {
-	char*		tif_name;	/* name of open file */
-	int		tif_fd;		/* open file descriptor */
-	int		tif_mode;	/* open mode (O_*) */
-	uint32		tif_flags;
-#define	TIFF_FILLORDER		0x00003	/* natural bit fill order for machine */
-#define	TIFF_DIRTYHEADER	0x00004	/* header must be written on close */
-#define	TIFF_DIRTYDIRECT	0x00008	/* current directory must be written */
-#define	TIFF_BUFFERSETUP	0x00010	/* data buffers setup */
-#define	TIFF_CODERSETUP		0x00020	/* encoder/decoder setup done */
-#define	TIFF_BEENWRITING	0x00040	/* written 1+ scanlines to file */
-#define	TIFF_SWAB		0x00080	/* byte swap file information */
-#define	TIFF_NOBITREV		0x00100	/* inhibit bit reversal logic */
-#define	TIFF_MYBUFFER		0x00200	/* my raw data buffer; free on close */
-#define	TIFF_ISTILED		0x00400	/* file is tile, not strip- based */
-#define	TIFF_MAPPED		0x00800	/* file is mapped into memory */
-#define	TIFF_POSTENCODE		0x01000	/* need call to postencode routine */
-#define	TIFF_INSUBIFD		0x02000	/* currently writing a subifd */
-#define	TIFF_UPSAMPLED		0x04000	/* library is doing data up-sampling */ 
-#define	TIFF_STRIPCHOP		0x08000	/* enable strip chopping support */
-#define	TIFF_HEADERONLY		0x10000	/* read header only, do not process */
-					/* the first directory */
-#define TIFF_NOREADRAW		0x20000 /* skip reading of raw uncompressed */
-					/* image data */
-#define	TIFF_INCUSTOMIFD	0x40000	/* currently writing a custom IFD */
-	toff_t		tif_diroff;	/* file offset of current directory */
-	toff_t		tif_nextdiroff;	/* file offset of following directory */
-	toff_t*		tif_dirlist;	/* list of offsets to already seen */
-					/* directories to prevent IFD looping */
-	tsize_t		tif_dirlistsize;/* number of entires in offset list */
-	uint16		tif_dirnumber;  /* number of already seen directories */
-	TIFFDirectory	tif_dir;	/* internal rep of current directory */
-	TIFFDirectory	tif_customdir;	/* custom IFDs are separated from
-					   the main ones */
-	TIFFHeader	tif_header;	/* file's header block */
-	const int*	tif_typeshift;	/* data type shift counts */
-	const long*	tif_typemask;	/* data type masks */
-	uint32		tif_row;	/* current scanline */
-	tdir_t		tif_curdir;	/* current directory (index) */
-	tstrip_t	tif_curstrip;	/* current strip for read/write */
-	toff_t		tif_curoff;	/* current offset for read/write */
-	toff_t		tif_dataoff;	/* current offset for writing dir */
-/* SubIFD support */
-	uint16		tif_nsubifd;	/* remaining subifds to write */
-	toff_t		tif_subifdoff;	/* offset for patching SubIFD link */
-/* tiling support */
-	uint32 		tif_col;	/* current column (offset by row too) */
-	ttile_t		tif_curtile;	/* current tile for read/write */
-	tsize_t		tif_tilesize;	/* # of bytes in a tile */
-/* compression scheme hooks */
-	int		tif_decodestatus;
-	TIFFBoolMethod	tif_setupdecode;/* called once before predecode */
-	TIFFPreMethod	tif_predecode;	/* pre- row/strip/tile decoding */
-	TIFFBoolMethod	tif_setupencode;/* called once before preencode */
-	int		tif_encodestatus;
-	TIFFPreMethod	tif_preencode;	/* pre- row/strip/tile encoding */
-	TIFFBoolMethod	tif_postencode;	/* post- row/strip/tile encoding */
-	TIFFCodeMethod	tif_decoderow;	/* scanline decoding routine */
-	TIFFCodeMethod	tif_encoderow;	/* scanline encoding routine */
-	TIFFCodeMethod	tif_decodestrip;/* strip decoding routine */
-	TIFFCodeMethod	tif_encodestrip;/* strip encoding routine */
-	TIFFCodeMethod	tif_decodetile;	/* tile decoding routine */
-	TIFFCodeMethod	tif_encodetile;	/* tile encoding routine */
-	TIFFVoidMethod	tif_close;	/* cleanup-on-close routine */
-	TIFFSeekMethod	tif_seek;	/* position within a strip routine */
-	TIFFVoidMethod	tif_cleanup;	/* cleanup state routine */
-	TIFFStripMethod	tif_defstripsize;/* calculate/constrain strip size */
-	TIFFTileMethod	tif_deftilesize;/* calculate/constrain tile size */
-	tidata_t	tif_data;	/* compression scheme private data */
-/* input/output buffering */
-	tsize_t		tif_scanlinesize;/* # of bytes in a scanline */
-	tsize_t		tif_scanlineskew;/* scanline skew for reading strips */
-	tidata_t	tif_rawdata;	/* raw data buffer */
-	tsize_t		tif_rawdatasize;/* # of bytes in raw data buffer */
-	tidata_t	tif_rawcp;	/* current spot in raw buffer */
-	tsize_t		tif_rawcc;	/* bytes unread from raw buffer */
-/* memory-mapped file support */
-	tidata_t	tif_base;	/* base of mapped file */
-	toff_t		tif_size;	/* size of mapped file region (bytes)
-					   FIXME: it should be tsize_t */
-	TIFFMapFileProc	tif_mapproc;	/* map file method */
-	TIFFUnmapFileProc tif_unmapproc;/* unmap file method */
-/* input/output callback methods */
-	thandle_t	tif_clientdata;	/* callback parameter */
-	TIFFReadWriteProc tif_readproc;	/* read method */
-	TIFFReadWriteProc tif_writeproc;/* write method */
-	TIFFSeekProc	tif_seekproc;	/* lseek method */
-	TIFFCloseProc	tif_closeproc;	/* close method */
-	TIFFSizeProc	tif_sizeproc;	/* filesize method */
-/* post-decoding support */
-	TIFFPostMethod	tif_postdecode;	/* post decoding routine */
-/* tag support */
-	TIFFFieldInfo**	tif_fieldinfo;	/* sorted table of registered tags */
-	size_t		tif_nfields;	/* # entries in registered tag table */
-	const TIFFFieldInfo *tif_foundfield;/* cached pointer to already found tag */
-        TIFFTagMethods  tif_tagmethods; /* tag get/set/print routines */
-        TIFFClientInfoLink *tif_clientinfo; /* extra client information. */
-};
-
-#define	isPseudoTag(t)	(t > 0xffff)	/* is tag value normal or pseudo */
-
-#define	isTiled(tif)	(((tif)->tif_flags & TIFF_ISTILED) != 0)
-#define	isMapped(tif)	(((tif)->tif_flags & TIFF_MAPPED) != 0)
-#define	isFillOrder(tif, o)	(((tif)->tif_flags & (o)) != 0)
-#define	isUpSampled(tif)	(((tif)->tif_flags & TIFF_UPSAMPLED) != 0)
-#define	TIFFReadFile(tif, buf, size) \
-	((*(tif)->tif_readproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFWriteFile(tif, buf, size) \
-	((*(tif)->tif_writeproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFSeekFile(tif, off, whence) \
-	((*(tif)->tif_seekproc)((tif)->tif_clientdata,(toff_t)(off),whence))
-#define	TIFFCloseFile(tif) \
-	((*(tif)->tif_closeproc)((tif)->tif_clientdata))
-#define	TIFFGetFileSize(tif) \
-	((*(tif)->tif_sizeproc)((tif)->tif_clientdata))
-#define	TIFFMapFileContents(tif, paddr, psize) \
-	((*(tif)->tif_mapproc)((tif)->tif_clientdata,paddr,psize))
-#define	TIFFUnmapFileContents(tif, addr, size) \
-	((*(tif)->tif_unmapproc)((tif)->tif_clientdata,addr,size))
-
-/*
- * Default Read/Seek/Write definitions.
- */
-#ifndef ReadOK
-#define	ReadOK(tif, buf, size) \
-	(TIFFReadFile(tif, (tdata_t) buf, (tsize_t)(size)) == (tsize_t)(size))
-#endif
-#ifndef SeekOK
-#define	SeekOK(tif, off) \
-	(TIFFSeekFile(tif, (toff_t) off, SEEK_SET) == (toff_t) off)
-#endif
-#ifndef WriteOK
-#define	WriteOK(tif, buf, size) \
-	(TIFFWriteFile(tif, (tdata_t) buf, (tsize_t) size) == (tsize_t) size)
-#endif
-
-/* NB: the uint32 casts are to silence certain ANSI-C compilers */
-#define TIFFhowmany(x, y) (((uint32)x < (0xffffffff - (uint32)(y-1))) ?	\
-			   ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y))) : \
-			   0U)
-#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)
-#define	TIFFroundup(x, y) (TIFFhowmany(x,y)*(y))
-
-/* Safe multiply which returns zero if there is an integer overflow */
-#define TIFFSafeMultiply(t,v,m) ((((t)m != (t)0) && (((t)((v*m)/m)) == (t)v)) ? (t)(v*m) : (t)0)
-
-#define TIFFmax(A,B) ((A)>(B)?(A):(B))
-#define TIFFmin(A,B) ((A)<(B)?(A):(B))
-
-#define TIFFArrayCount(a) (sizeof (a) / sizeof ((a)[0]))
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	int _TIFFgetMode(const char*, const char*);
-extern	int _TIFFNoRowEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoRowDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	void _TIFFNoPostDecode(TIFF*, tidata_t, tsize_t);
-extern  int  _TIFFNoPreCode (TIFF*, tsample_t); 
-extern	int _TIFFNoSeek(TIFF*, uint32);
-extern	void _TIFFSwab16BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab24BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab32BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab64BitData(TIFF*, tidata_t, tsize_t);
-extern	int TIFFFlushData1(TIFF*);
-extern	int TIFFDefaultDirectory(TIFF*);
-extern	void _TIFFSetDefaultCompressionState(TIFF*);
-extern	int TIFFSetCompressionScheme(TIFF*, int);
-extern	int TIFFSetDefaultCompressionState(TIFF*);
-extern	uint32 _TIFFDefaultStripSize(TIFF*, uint32);
-extern	void _TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
-extern	int _TIFFDataSize(TIFFDataType);
-
-extern	void _TIFFsetByteArray(void**, void*, uint32);
-extern	void _TIFFsetString(char**, char*);
-extern	void _TIFFsetShortArray(uint16**, uint16*, uint32);
-extern	void _TIFFsetLongArray(uint32**, uint32*, uint32);
-extern	void _TIFFsetFloatArray(float**, float*, uint32);
-extern	void _TIFFsetDoubleArray(double**, double*, uint32);
-
-extern	void _TIFFprintAscii(FILE*, const char*);
-extern	void _TIFFprintAsciiTag(FILE*, const char*, const char*);
-
-extern	TIFFErrorHandler _TIFFwarningHandler;
-extern	TIFFErrorHandler _TIFFerrorHandler;
-extern	TIFFErrorHandlerExt _TIFFwarningHandlerExt;
-extern	TIFFErrorHandlerExt _TIFFerrorHandlerExt;
-
-extern	tdata_t _TIFFCheckMalloc(TIFF*, size_t, size_t, const char*);
-extern	tdata_t _TIFFCheckRealloc(TIFF*, tdata_t, size_t, size_t, const char*);
-
-extern	int TIFFInitDumpMode(TIFF*, int);
-#ifdef PACKBITS_SUPPORT
-extern	int TIFFInitPackBits(TIFF*, int);
-#endif
-#ifdef CCITT_SUPPORT
-extern	int TIFFInitCCITTRLE(TIFF*, int), TIFFInitCCITTRLEW(TIFF*, int);
-extern	int TIFFInitCCITTFax3(TIFF*, int), TIFFInitCCITTFax4(TIFF*, int);
-#endif
-#ifdef THUNDER_SUPPORT
-extern	int TIFFInitThunderScan(TIFF*, int);
-#endif
-#ifdef NEXT_SUPPORT
-extern	int TIFFInitNeXT(TIFF*, int);
-#endif
-#ifdef LZW_SUPPORT
-extern	int TIFFInitLZW(TIFF*, int);
-#endif
-#ifdef OJPEG_SUPPORT
-extern	int TIFFInitOJPEG(TIFF*, int);
-#endif
-#ifdef JPEG_SUPPORT
-extern	int TIFFInitJPEG(TIFF*, int);
-#endif
-#ifdef JBIG_SUPPORT
-extern	int TIFFInitJBIG(TIFF*, int);
-#endif
-#ifdef ZIP_SUPPORT
-extern	int TIFFInitZIP(TIFF*, int);
-#endif
-#ifdef PIXARLOG_SUPPORT
-extern	int TIFFInitPixarLog(TIFF*, int);
-#endif
-#ifdef LOGLUV_SUPPORT
-extern	int TIFFInitSGILog(TIFF*, int);
-#endif
-#ifdef VMS
-extern	const TIFFCodec _TIFFBuiltinCODECS[];
-#else
-extern	TIFFCodec _TIFFBuiltinCODECS[];
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-#endif /* _TIFFIOP_ */
-
-/* vim: set ts=8 sts=8 sw=8 noet: */
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libtiff/tiffvers.h b/thirdparty/libtiff/tiffvers.h
deleted file mode 100644
index 314a22a..0000000
--- a/thirdparty/libtiff/tiffvers.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#define TIFFLIB_VERSION_STR "LIBTIFF, Version 3.9.4\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
-/*
- * This define can be used in code that requires
- * compilation-related definitions specific to a
- * version or versions of the library.  Runtime
- * version checking should be done based on the
- * string returned by TIFFGetVersion.
- */
-#define TIFFLIB_VERSION 20100615
diff --git a/thirdparty/libtiff/uvcode.h b/thirdparty/libtiff/uvcode.h
deleted file mode 100644
index 50f11d7..0000000
--- a/thirdparty/libtiff/uvcode.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/* Version 1.0 generated April 7, 1997 by Greg Ward Larson, SGI */
-#define UV_SQSIZ	(float)0.003500
-#define UV_NDIVS	16289
-#define UV_VSTART	(float)0.016940
-#define UV_NVS		163
-static struct {
-	float	ustart;
-	short	nus, ncum;
-}	uv_row[UV_NVS] = {
-	{ (float)0.247663,	4,	0 },
-	{ (float)0.243779,	6,	4 },
-	{ (float)0.241684,	7,	10 },
-	{ (float)0.237874,	9,	17 },
-	{ (float)0.235906,	10,	26 },
-	{ (float)0.232153,	12,	36 },
-	{ (float)0.228352,	14,	48 },
-	{ (float)0.226259,	15,	62 },
-	{ (float)0.222371,	17,	77 },
-	{ (float)0.220410,	18,	94 },
-	{ (float)0.214710,	21,	112 },
-	{ (float)0.212714,	22,	133 },
-	{ (float)0.210721,	23,	155 },
-	{ (float)0.204976,	26,	178 },
-	{ (float)0.202986,	27,	204 },
-	{ (float)0.199245,	29,	231 },
-	{ (float)0.195525,	31,	260 },
-	{ (float)0.193560,	32,	291 },
-	{ (float)0.189878,	34,	323 },
-	{ (float)0.186216,	36,	357 },
-	{ (float)0.186216,	36,	393 },
-	{ (float)0.182592,	38,	429 },
-	{ (float)0.179003,	40,	467 },
-	{ (float)0.175466,	42,	507 },
-	{ (float)0.172001,	44,	549 },
-	{ (float)0.172001,	44,	593 },
-	{ (float)0.168612,	46,	637 },
-	{ (float)0.168612,	46,	683 },
-	{ (float)0.163575,	49,	729 },
-	{ (float)0.158642,	52,	778 },
-	{ (float)0.158642,	52,	830 },
-	{ (float)0.158642,	52,	882 },
-	{ (float)0.153815,	55,	934 },
-	{ (float)0.153815,	55,	989 },
-	{ (float)0.149097,	58,	1044 },
-	{ (float)0.149097,	58,	1102 },
-	{ (float)0.142746,	62,	1160 },
-	{ (float)0.142746,	62,	1222 },
-	{ (float)0.142746,	62,	1284 },
-	{ (float)0.138270,	65,	1346 },
-	{ (float)0.138270,	65,	1411 },
-	{ (float)0.138270,	65,	1476 },
-	{ (float)0.132166,	69,	1541 },
-	{ (float)0.132166,	69,	1610 },
-	{ (float)0.126204,	73,	1679 },
-	{ (float)0.126204,	73,	1752 },
-	{ (float)0.126204,	73,	1825 },
-	{ (float)0.120381,	77,	1898 },
-	{ (float)0.120381,	77,	1975 },
-	{ (float)0.120381,	77,	2052 },
-	{ (float)0.120381,	77,	2129 },
-	{ (float)0.112962,	82,	2206 },
-	{ (float)0.112962,	82,	2288 },
-	{ (float)0.112962,	82,	2370 },
-	{ (float)0.107450,	86,	2452 },
-	{ (float)0.107450,	86,	2538 },
-	{ (float)0.107450,	86,	2624 },
-	{ (float)0.107450,	86,	2710 },
-	{ (float)0.100343,	91,	2796 },
-	{ (float)0.100343,	91,	2887 },
-	{ (float)0.100343,	91,	2978 },
-	{ (float)0.095126,	95,	3069 },
-	{ (float)0.095126,	95,	3164 },
-	{ (float)0.095126,	95,	3259 },
-	{ (float)0.095126,	95,	3354 },
-	{ (float)0.088276,	100,	3449 },
-	{ (float)0.088276,	100,	3549 },
-	{ (float)0.088276,	100,	3649 },
-	{ (float)0.088276,	100,	3749 },
-	{ (float)0.081523,	105,	3849 },
-	{ (float)0.081523,	105,	3954 },
-	{ (float)0.081523,	105,	4059 },
-	{ (float)0.081523,	105,	4164 },
-	{ (float)0.074861,	110,	4269 },
-	{ (float)0.074861,	110,	4379 },
-	{ (float)0.074861,	110,	4489 },
-	{ (float)0.074861,	110,	4599 },
-	{ (float)0.068290,	115,	4709 },
-	{ (float)0.068290,	115,	4824 },
-	{ (float)0.068290,	115,	4939 },
-	{ (float)0.068290,	115,	5054 },
-	{ (float)0.063573,	119,	5169 },
-	{ (float)0.063573,	119,	5288 },
-	{ (float)0.063573,	119,	5407 },
-	{ (float)0.063573,	119,	5526 },
-	{ (float)0.057219,	124,	5645 },
-	{ (float)0.057219,	124,	5769 },
-	{ (float)0.057219,	124,	5893 },
-	{ (float)0.057219,	124,	6017 },
-	{ (float)0.050985,	129,	6141 },
-	{ (float)0.050985,	129,	6270 },
-	{ (float)0.050985,	129,	6399 },
-	{ (float)0.050985,	129,	6528 },
-	{ (float)0.050985,	129,	6657 },
-	{ (float)0.044859,	134,	6786 },
-	{ (float)0.044859,	134,	6920 },
-	{ (float)0.044859,	134,	7054 },
-	{ (float)0.044859,	134,	7188 },
-	{ (float)0.040571,	138,	7322 },
-	{ (float)0.040571,	138,	7460 },
-	{ (float)0.040571,	138,	7598 },
-	{ (float)0.040571,	138,	7736 },
-	{ (float)0.036339,	142,	7874 },
-	{ (float)0.036339,	142,	8016 },
-	{ (float)0.036339,	142,	8158 },
-	{ (float)0.036339,	142,	8300 },
-	{ (float)0.032139,	146,	8442 },
-	{ (float)0.032139,	146,	8588 },
-	{ (float)0.032139,	146,	8734 },
-	{ (float)0.032139,	146,	8880 },
-	{ (float)0.027947,	150,	9026 },
-	{ (float)0.027947,	150,	9176 },
-	{ (float)0.027947,	150,	9326 },
-	{ (float)0.023739,	154,	9476 },
-	{ (float)0.023739,	154,	9630 },
-	{ (float)0.023739,	154,	9784 },
-	{ (float)0.023739,	154,	9938 },
-	{ (float)0.019504,	158,	10092 },
-	{ (float)0.019504,	158,	10250 },
-	{ (float)0.019504,	158,	10408 },
-	{ (float)0.016976,	161,	10566 },
-	{ (float)0.016976,	161,	10727 },
-	{ (float)0.016976,	161,	10888 },
-	{ (float)0.016976,	161,	11049 },
-	{ (float)0.012639,	165,	11210 },
-	{ (float)0.012639,	165,	11375 },
-	{ (float)0.012639,	165,	11540 },
-	{ (float)0.009991,	168,	11705 },
-	{ (float)0.009991,	168,	11873 },
-	{ (float)0.009991,	168,	12041 },
-	{ (float)0.009016,	170,	12209 },
-	{ (float)0.009016,	170,	12379 },
-	{ (float)0.009016,	170,	12549 },
-	{ (float)0.006217,	173,	12719 },
-	{ (float)0.006217,	173,	12892 },
-	{ (float)0.005097,	175,	13065 },
-	{ (float)0.005097,	175,	13240 },
-	{ (float)0.005097,	175,	13415 },
-	{ (float)0.003909,	177,	13590 },
-	{ (float)0.003909,	177,	13767 },
-	{ (float)0.002340,	177,	13944 },
-	{ (float)0.002389,	170,	14121 },
-	{ (float)0.001068,	164,	14291 },
-	{ (float)0.001653,	157,	14455 },
-	{ (float)0.000717,	150,	14612 },
-	{ (float)0.001614,	143,	14762 },
-	{ (float)0.000270,	136,	14905 },
-	{ (float)0.000484,	129,	15041 },
-	{ (float)0.001103,	123,	15170 },
-	{ (float)0.001242,	115,	15293 },
-	{ (float)0.001188,	109,	15408 },
-	{ (float)0.001011,	103,	15517 },
-	{ (float)0.000709,	97,	15620 },
-	{ (float)0.000301,	89,	15717 },
-	{ (float)0.002416,	82,	15806 },
-	{ (float)0.003251,	76,	15888 },
-	{ (float)0.003246,	69,	15964 },
-	{ (float)0.004141,	62,	16033 },
-	{ (float)0.005963,	55,	16095 },
-	{ (float)0.008839,	47,	16150 },
-	{ (float)0.010490,	40,	16197 },
-	{ (float)0.016994,	31,	16237 },
-	{ (float)0.023659,	21,	16268 },
-};
-/*
- * Local Variables:
- * mode: c
- * c-basic-offset: 8
- * fill-column: 78
- * End:
- */
diff --git a/thirdparty/libz/CMakeLists.txt b/thirdparty/libz/CMakeLists.txt
deleted file mode 100644
index 7cd0818..0000000
--- a/thirdparty/libz/CMakeLists.txt
+++ /dev/null
@@ -1,102 +0,0 @@
-#based on zlib-1.2.5/CMakeLists.txt
-#
-cmake_minimum_required(VERSION 2.6)
-SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
-
-PROJECT(zlib C)
-
-INCLUDE(CheckTypeSize)
-INCLUDE(CheckFunctionExists)
-INCLUDE(CheckIncludeFile)
-INCLUDE(CheckCSourceCompiles)
-
-CHECK_INCLUDE_FILE(sys/types.h HAVE_SYS_TYPES_H)
-CHECK_INCLUDE_FILE(stdint.h    HAVE_STDINT_H)
-CHECK_INCLUDE_FILE(stddef.h    HAVE_STDDEF_H)
-
-#
-# Check to see if we have large file support
-#
-SET(CMAKE_REQUIRED_DEFINITIONS -D_LARGEFILE64_SOURCE=1)
-# We add these other definitions here because CheckTypeSize.cmake
-# in CMake 2.4.x does not automatically do so and we want
-# compatibility with CMake 2.4.x.
-IF(HAVE_SYS_TYPES_H)
-    LIST(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_SYS_TYPES_H)
-ENDIF()
-IF(HAVE_STDINT_H)
-    LIST(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDINT_H)
-ENDIF()
-IF(HAVE_STDDEF_H)
-    LIST(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDDEF_H)
-ENDIF()
-CHECK_TYPE_SIZE(off64_t OFF64_T)
-IF(HAVE_OFF64_T)
-   ADD_DEFINITIONS(-D_LARGEFILE64_SOURCE=1)
-ENDIF()
-SET(CMAKE_REQUIRED_DEFINITIONS) # clear variable
-#
-# Check for fseeko
-#
-CHECK_FUNCTION_EXISTS(fseeko HAVE_FSEEKO)
-IF(NOT HAVE_FSEEKO)
-    ADD_DEFINITIONS(-DNO_FSEEKO)
-ENDIF()
-#
-# Check for unistd.h
-#
-CHECK_INCLUDE_FILE(unistd.h Z_HAVE_UNISTD_H)
-
-INCLUDE_DIRECTORIES(
- ${CMAKE_CURRENT_SOURCE_DIR}
- ${OPENJPEG_SOURCE_DIR}/thirdparty/include
-)
-#
-SET(EXT_HDRS
- ${OPENJPEG_SOURCE_DIR}/thirdparty/include/zlib.h
- ${OPENJPEG_SOURCE_DIR}/thirdparty/include/zconf.h
-)
-
-SET(HDRS
-    crc32.h
-    deflate.h
-    gzguts.h
-    inffast.h
-    inffixed.h
-    inflate.h
-    inftrees.h
-    trees.h
-    zutil.h
-)
-SET(SRCS
-    adler32.c
-    compress.c
-    crc32.c
-    deflate.c
-    gzclose.c
-    gzlib.c
-    gzread.c
-    gzwrite.c
-    inflate.c
-    infback.c
-    inftrees.c
-    inffast.c
-    trees.c
-    uncompr.c
-    zutil.c
-)
-
-SET(LIBTARGET "z")
-#
-ADD_LIBRARY(${LIBTARGET} STATIC ${SRCS} ${EXT_HDRS} ${HDRS})
-#
-IF(MSVC)
-  SET_TARGET_PROPERTIES(${LIBTARGET} PROPERTIES PREFIX "lib")
-ENDIF(MSVC)
-
-SET_TARGET_PROPERTIES(${LIBTARGET}
-    PROPERTIES
-    OUTPUT_NAME "${LIBTARGET}"
-    ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/thirdparty/lib
-)
-#
diff --git a/thirdparty/libz/adler32.c b/thirdparty/libz/adler32.c
deleted file mode 100644
index 65ad6a5..0000000
--- a/thirdparty/libz/adler32.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-2007 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zutil.h"
-
-#define local static
-
-local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2);
-
-#define BASE 65521UL    /* largest prime smaller than 65536 */
-#define NMAX 5552
-/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
-
-#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* use NO_DIVIDE if your processor does not do division in hardware */
-#ifdef NO_DIVIDE
-#  define MOD(a) \
-    do { \
-        if (a >= (BASE << 16)) a -= (BASE << 16); \
-        if (a >= (BASE << 15)) a -= (BASE << 15); \
-        if (a >= (BASE << 14)) a -= (BASE << 14); \
-        if (a >= (BASE << 13)) a -= (BASE << 13); \
-        if (a >= (BASE << 12)) a -= (BASE << 12); \
-        if (a >= (BASE << 11)) a -= (BASE << 11); \
-        if (a >= (BASE << 10)) a -= (BASE << 10); \
-        if (a >= (BASE << 9)) a -= (BASE << 9); \
-        if (a >= (BASE << 8)) a -= (BASE << 8); \
-        if (a >= (BASE << 7)) a -= (BASE << 7); \
-        if (a >= (BASE << 6)) a -= (BASE << 6); \
-        if (a >= (BASE << 5)) a -= (BASE << 5); \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#  define MOD4(a) \
-    do { \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#else
-#  define MOD(a) a %= BASE
-#  define MOD4(a) a %= BASE
-#endif
-
-/* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
-{
-    unsigned long sum2;
-    unsigned n;
-
-    /* split Adler-32 into component sums */
-    sum2 = (adler >> 16) & 0xffff;
-    adler &= 0xffff;
-
-    /* in case user likes doing a byte at a time, keep it fast */
-    if (len == 1) {
-        adler += buf[0];
-        if (adler >= BASE)
-            adler -= BASE;
-        sum2 += adler;
-        if (sum2 >= BASE)
-            sum2 -= BASE;
-        return adler | (sum2 << 16);
-    }
-
-    /* initial Adler-32 value (deferred check for len == 1 speed) */
-    if (buf == Z_NULL)
-        return 1L;
-
-    /* in case short lengths are provided, keep it somewhat fast */
-    if (len < 16) {
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        if (adler >= BASE)
-            adler -= BASE;
-        MOD4(sum2);             /* only added so many BASE's */
-        return adler | (sum2 << 16);
-    }
-
-    /* do length NMAX blocks -- requires just one modulo operation */
-    while (len >= NMAX) {
-        len -= NMAX;
-        n = NMAX / 16;          /* NMAX is divisible by 16 */
-        do {
-            DO16(buf);          /* 16 sums unrolled */
-            buf += 16;
-        } while (--n);
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* do remaining bytes (less than NMAX, still just one modulo) */
-    if (len) {                  /* avoid modulos if none remaining */
-        while (len >= 16) {
-            len -= 16;
-            DO16(buf);
-            buf += 16;
-        }
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* return recombined sums */
-    return adler | (sum2 << 16);
-}
-
-/* ========================================================================= */
-local uLong adler32_combine_(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    rem = (unsigned)(len2 % BASE);
-    sum1 = adler1 & 0xffff;
-    sum2 = rem * sum1;
-    MOD(sum2);
-    sum1 += (adler2 & 0xffff) + BASE - 1;
-    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
-    if (sum2 >= BASE) sum2 -= BASE;
-    return sum1 | (sum2 << 16);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
-
-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
diff --git a/thirdparty/libz/compress.c b/thirdparty/libz/compress.c
deleted file mode 100644
index ea4dfbe..0000000
--- a/thirdparty/libz/compress.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-#ifdef MAXSEG_64K
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-#endif
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-
-    err = deflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        deflateEnd(&stream);
-        return err == Z_OK ? Z_BUF_ERROR : err;
-    }
-    *destLen = stream.total_out;
-
-    err = deflateEnd(&stream);
-    return err;
-}
-
-/* ===========================================================================
- */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound (sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13;
-}
diff --git a/thirdparty/libz/crc32.c b/thirdparty/libz/crc32.c
deleted file mode 100644
index 91be372..0000000
--- a/thirdparty/libz/crc32.c
+++ /dev/null
@@ -1,442 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2006, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
- * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
- * tables for updating the shift register in one step with three exclusive-ors
- * instead of four steps with four exclusive-ors.  This results in about a
- * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
- */
-
-/* @(#) $Id$ */
-
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
- */
-
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-
-#include "zutil.h"      /* for STDC and FAR definitions */
-
-#define local static
-
-/* Find a four-byte integer type for crc32_little() and crc32_big(). */
-#ifndef NOBYFOUR
-#  ifdef STDC           /* need ANSI C limits.h to determine sizes */
-#    include <limits.h>
-#    define BYFOUR
-#    if (UINT_MAX == 0xffffffffUL)
-       typedef unsigned int u4;
-#    else
-#      if (ULONG_MAX == 0xffffffffUL)
-         typedef unsigned long u4;
-#      else
-#        if (USHRT_MAX == 0xffffffffUL)
-           typedef unsigned short u4;
-#        else
-#          undef BYFOUR     /* can't find a four-byte integer type! */
-#        endif
-#      endif
-#    endif
-#  endif /* STDC */
-#endif /* !NOBYFOUR */
-
-/* Definitions for doing the crc four data bytes at a time. */
-#ifdef BYFOUR
-#  define REV(w) ((((w)>>24)&0xff)+(((w)>>8)&0xff00)+ \
-                (((w)&0xff00)<<8)+(((w)&0xff)<<24))
-   local unsigned long crc32_little OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-   local unsigned long crc32_big OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-#  define TBLS 8
-#else
-#  define TBLS 1
-#endif /* BYFOUR */
-
-/* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times OF((unsigned long *mat,
-                                         unsigned long vec));
-local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
-local uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2);
-
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local volatile int crc_table_empty = 1;
-local unsigned long FAR crc_table[TBLS][256];
-local void make_crc_table OF((void));
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const unsigned long FAR *));
-#endif /* MAKECRCH */
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The first table is simply the CRC of all possible eight bit values.  This is
-  all the information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.  The remaining tables
-  allow for word-at-a-time CRC calculation for both big-endian and little-
-  endian machines, where a word is four bytes.
-*/
-local void make_crc_table()
-{
-    unsigned long c;
-    int n, k;
-    unsigned long poly;                 /* polynomial exclusive-or pattern */
-    /* terms of polynomial defining this crc (except x^32): */
-    static volatile int first = 1;      /* flag to limit concurrent making */
-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-    /* See if another task is already doing this (not thread-safe, but better
-       than nothing -- significantly reduces duration of vulnerability in
-       case the advice about DYNAMIC_CRC_TABLE is ignored) */
-    if (first) {
-        first = 0;
-
-        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0UL;
-        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
-            poly |= 1UL << (31 - p[n]);
-
-        /* generate a crc for every 8-bit value */
-        for (n = 0; n < 256; n++) {
-            c = (unsigned long)n;
-            for (k = 0; k < 8; k++)
-                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-            crc_table[0][n] = c;
-        }
-
-#ifdef BYFOUR
-        /* generate crc for each value followed by one, two, and three zeros,
-           and then the byte reversal of those as well as the first table */
-        for (n = 0; n < 256; n++) {
-            c = crc_table[0][n];
-            crc_table[4][n] = REV(c);
-            for (k = 1; k < 4; k++) {
-                c = crc_table[0][c & 0xff] ^ (c >> 8);
-                crc_table[k][n] = c;
-                crc_table[k + 4][n] = REV(c);
-            }
-        }
-#endif /* BYFOUR */
-
-        crc_table_empty = 0;
-    }
-    else {      /* not first */
-        /* wait for the other guy to finish (not efficient, but rare) */
-        while (crc_table_empty)
-            ;
-    }
-
-#ifdef MAKECRCH
-    /* write out CRC tables to crc32.h */
-    {
-        FILE *out;
-
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
-        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const unsigned long FAR ");
-        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
-        write_table(out, crc_table[0]);
-#  ifdef BYFOUR
-        fprintf(out, "#ifdef BYFOUR\n");
-        for (k = 1; k < 8; k++) {
-            fprintf(out, "  },\n  {\n");
-            write_table(out, crc_table[k]);
-        }
-        fprintf(out, "#endif\n");
-#  endif /* BYFOUR */
-        fprintf(out, "  }\n};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-
-#ifdef MAKECRCH
-local void write_table(out, table)
-    FILE *out;
-    const unsigned long FAR *table;
-{
-    int n;
-
-    for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
-                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
-}
-#endif /* MAKECRCH */
-
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables of CRC-32s of all single-byte values, made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const unsigned long FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const unsigned long FAR *)crc_table;
-}
-
-/* ========================================================================= */
-#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
-#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
-
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    uInt len;
-{
-    if (buf == Z_NULL) return 0UL;
-
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-
-#ifdef BYFOUR
-    if (sizeof(void *) == sizeof(ptrdiff_t)) {
-        u4 endian;
-
-        endian = 1;
-        if (*((unsigned char *)(&endian)))
-            return crc32_little(crc, buf, len);
-        else
-            return crc32_big(crc, buf, len);
-    }
-#endif /* BYFOUR */
-    crc = crc ^ 0xffffffffUL;
-    while (len >= 8) {
-        DO8;
-        len -= 8;
-    }
-    if (len) do {
-        DO1;
-    } while (--len);
-    return crc ^ 0xffffffffUL;
-}
-
-#ifdef BYFOUR
-
-/* ========================================================================= */
-#define DOLIT4 c ^= *buf4++; \
-        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
-            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
-#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
-
-/* ========================================================================= */
-local unsigned long crc32_little(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register u4 c;
-    register const u4 FAR *buf4;
-
-    c = (u4)crc;
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-        len--;
-    }
-
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
-    while (len >= 32) {
-        DOLIT32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOLIT4;
-        len -= 4;
-    }
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)c;
-}
-
-/* ========================================================================= */
-#define DOBIG4 c ^= *++buf4; \
-        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
-            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
-#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
-
-/* ========================================================================= */
-local unsigned long crc32_big(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register u4 c;
-    register const u4 FAR *buf4;
-
-    c = REV((u4)crc);
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-        len--;
-    }
-
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
-    buf4--;
-    while (len >= 32) {
-        DOBIG32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOBIG4;
-        len -= 4;
-    }
-    buf4++;
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)(REV(c));
-}
-
-#endif /* BYFOUR */
-
-#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
-
-/* ========================================================================= */
-local unsigned long gf2_matrix_times(mat, vec)
-    unsigned long *mat;
-    unsigned long vec;
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec & 1)
-            sum ^= *mat;
-        vec >>= 1;
-        mat++;
-    }
-    return sum;
-}
-
-/* ========================================================================= */
-local void gf2_matrix_square(square, mat)
-    unsigned long *square;
-    unsigned long *mat;
-{
-    int n;
-
-    for (n = 0; n < GF2_DIM; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-/* ========================================================================= */
-local uLong crc32_combine_(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    int n;
-    unsigned long row;
-    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
-    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
-
-    /* degenerate case (also disallow negative lengths) */
-    if (len2 <= 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n < GF2_DIM; n++) {
-        odd[n] = row;
-        row <<= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
-
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
-
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
diff --git a/thirdparty/libz/crc32.h b/thirdparty/libz/crc32.h
deleted file mode 100644
index 8053b61..0000000
--- a/thirdparty/libz/crc32.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/* crc32.h -- tables for rapid CRC calculation
- * Generated automatically by crc32.c
- */
-
-local const unsigned long FAR crc_table[TBLS][256] =
-{
-  {
-    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-    0x2d02ef8dUL
-#ifdef BYFOUR
-  },
-  {
-    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
-    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
-    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
-    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
-    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
-    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
-    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
-    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
-    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
-    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
-    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
-    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
-    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
-    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
-    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
-    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
-    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
-    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
-    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
-    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
-    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
-    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
-    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
-    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
-    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
-    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
-    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
-    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
-    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
-    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
-    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
-    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
-    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
-    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
-    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
-    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
-    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
-    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
-    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
-    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
-    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
-    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
-    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
-    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
-    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
-    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
-    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
-    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
-    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
-    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
-    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
-    0x9324fd72UL
-  },
-  {
-    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
-    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
-    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
-    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
-    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
-    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
-    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
-    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
-    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
-    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
-    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
-    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
-    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
-    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
-    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
-    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
-    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
-    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
-    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
-    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
-    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
-    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
-    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
-    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
-    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
-    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
-    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
-    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
-    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
-    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
-    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
-    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
-    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
-    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
-    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
-    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
-    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
-    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
-    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
-    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
-    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
-    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
-    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
-    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
-    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
-    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
-    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
-    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
-    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
-    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
-    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
-    0xbe9834edUL
-  },
-  {
-    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
-    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
-    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
-    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
-    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
-    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
-    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
-    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
-    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
-    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
-    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
-    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
-    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
-    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
-    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
-    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
-    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
-    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
-    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
-    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
-    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
-    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
-    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
-    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
-    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
-    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
-    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
-    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
-    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
-    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
-    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
-    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
-    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
-    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
-    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
-    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
-    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
-    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
-    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
-    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
-    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
-    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
-    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
-    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
-    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
-    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
-    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
-    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
-    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
-    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
-    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
-    0xde0506f1UL
-  },
-  {
-    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
-    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
-    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
-    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
-    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
-    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
-    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
-    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
-    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
-    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
-    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
-    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
-    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
-    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
-    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
-    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
-    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
-    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
-    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
-    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
-    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
-    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
-    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
-    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
-    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
-    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
-    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
-    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
-    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
-    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
-    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
-    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
-    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
-    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
-    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
-    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
-    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
-    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
-    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
-    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
-    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
-    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
-    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
-    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
-    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
-    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
-    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
-    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
-    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
-    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
-    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
-    0x8def022dUL
-  },
-  {
-    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
-    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
-    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
-    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
-    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
-    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
-    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
-    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
-    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
-    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
-    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
-    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
-    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
-    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
-    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
-    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
-    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
-    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
-    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
-    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
-    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
-    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
-    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
-    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
-    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
-    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
-    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
-    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
-    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
-    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
-    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
-    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
-    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
-    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
-    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
-    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
-    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
-    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
-    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
-    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
-    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
-    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
-    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
-    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
-    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
-    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
-    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
-    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
-    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
-    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
-    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
-    0x72fd2493UL
-  },
-  {
-    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
-    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
-    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
-    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
-    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
-    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
-    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
-    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
-    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
-    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
-    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
-    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
-    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
-    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
-    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
-    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
-    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
-    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
-    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
-    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
-    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
-    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
-    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
-    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
-    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
-    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
-    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
-    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
-    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
-    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
-    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
-    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
-    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
-    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
-    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
-    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
-    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
-    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
-    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
-    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
-    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
-    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
-    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
-    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
-    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
-    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
-    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
-    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
-    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
-    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
-    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
-    0xed3498beUL
-  },
-  {
-    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
-    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
-    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
-    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
-    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
-    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
-    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
-    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
-    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
-    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
-    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
-    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
-    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
-    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
-    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
-    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
-    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
-    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
-    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
-    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
-    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
-    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
-    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
-    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
-    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
-    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
-    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
-    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
-    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
-    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
-    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
-    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
-    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
-    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
-    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
-    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
-    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
-    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
-    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
-    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
-    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
-    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
-    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
-    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
-    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
-    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
-    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
-    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
-    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
-    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
-    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
-    0xf10605deUL
-#endif
-  }
-};
diff --git a/thirdparty/libz/deflate.c b/thirdparty/libz/deflate.c
deleted file mode 100644
index 5c4022f..0000000
--- a/thirdparty/libz/deflate.c
+++ /dev/null
@@ -1,1834 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://www.ietf.org/rfc/rfc1951.txt
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-/* @(#) $Id$ */
-
-#include "deflate.h"
-
-const char deflate_copyright[] =
-   " deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly and Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-local block_state deflate_rle    OF((deflate_state *s, int flush));
-local block_state deflate_huff   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifdef ASMV
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#endif
-
-#ifdef DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-#ifndef NO_DUMMY_DECL
-struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
-#endif
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
- *    input characters, so that a running hash key can be computed from the
- *    previous key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
- *    input characters and the first MIN_MATCH bytes of str are valid
- *    (except for the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    s->head[s->hash_size-1] = NIL; \
-    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
-
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-
-    s->high_water = 0;      /* nothing written to s->window yet */
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return deflateReset(strm);
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt length = dictLength;
-    uInt n;
-    IPos hash_head = 0;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
-        strm->state->wrap == 2 ||
-        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
-        return Z_STREAM_ERROR;
-
-    s = strm->state;
-    if (s->wrap)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-
-    if (length < MIN_MATCH) return Z_OK;
-    if (length > s->w_size) {
-        length = s->w_size;
-        dictionary += dictLength - length; /* use the tail of the dictionary */
-    }
-    zmemcpy(s->window, dictionary, length);
-    s->strstart = length;
-    s->block_start = (long)length;
-
-    /* Insert all strings in the hash table (except for the last two bytes).
-     * s->lookahead stays null, so s->ins_h will be recomputed at the next
-     * call of fill_window.
-     */
-    s->ins_h = s->window[0];
-    UPDATE_HASH(s, s->ins_h, s->window[1]);
-    for (n = 0; n <= length - MIN_MATCH; n++) {
-        INSERT_STRING(s, n, hash_head);
-    }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
-        return Z_STREAM_ERROR;
-    }
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = Z_NO_FLUSH;
-
-    _tr_init(s);
-    lm_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader (strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePrime (strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    strm->state->bi_valid = bits;
-    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    int err = Z_OK;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if ((strategy != s->strategy || func != configuration_table[level].func) &&
-        strm->total_in != 0) {
-        /* Flush the last buffer: */
-        err = deflate(strm, Z_BLOCK);
-    }
-    if (s->level != level) {
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return err;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = good_length;
-    s->max_lazy_match = max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = max_chain;
-    return Z_OK;
-}
-
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns
- * a close to exact, as well as small, upper bound on the compressed size.
- * They are coded as constants here for a reason--if the #define's are
- * changed, then this function needs to be changed as well.  The return
- * value for 15 and 8 only works for those exact settings.
- *
- * For any setting other than those defaults for windowBits and memLevel,
- * the value returned is a conservative worst case for the maximum expansion
- * resulting from using fixed blocks instead of stored blocks, which deflate
- * can emit on compressed data for some combinations of the parameters.
- *
- * This function could be more sophisticated to provide closer upper bounds for
- * every combination of windowBits and memLevel.  But even the conservative
- * upper bound of about 14% expansion does not seem onerous for output buffer
- * allocation.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong complen, wraplen;
-    Bytef *str;
-
-    /* conservative upper bound for compressed data */
-    complen = sourceLen +
-              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
-
-    /* if can't get parameters, return conservative bound plus zlib wrapper */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return complen + 6;
-
-    /* compute wrapper length */
-    s = strm->state;
-    switch (s->wrap) {
-    case 0:                                 /* raw deflate */
-        wraplen = 0;
-        break;
-    case 1:                                 /* zlib wrapper */
-        wraplen = 6 + (s->strstart ? 4 : 0);
-        break;
-    case 2:                                 /* gzip wrapper */
-        wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            if (s->gzhead->extra != Z_NULL)
-                wraplen += 2 + s->gzhead->extra_len;
-            str = s->gzhead->name;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            str = s->gzhead->comment;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            if (s->gzhead->hcrc)
-                wraplen += 2;
-        }
-        break;
-    default:                                /* for compiler happiness */
-        wraplen = 6;
-    }
-
-    /* if not default parameters, return conservative bound */
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return complen + wraplen;
-
-    /* default settings: return tight bound for that case */
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13 - 6 + wraplen;
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output goes
- * through this function so some applications may wish to modify it
- * to avoid allocating a large strm->next_out buffer and copying into it.
- * (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len = strm->state->pending;
-
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    zmemcpy(strm->next_out, strm->state->pending_out, len);
-    strm->next_out  += len;
-    strm->state->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out  -= len;
-    strm->state->pending -= len;
-    if (strm->state->pending == 0) {
-        strm->state->pending_out = strm->state->pending_buf;
-    }
-}
-
-/* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        flush > Z_BLOCK || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-
-    if (strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-
-    s->strm = strm; /* just in case */
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Write the header */
-    if (s->status == INIT_STATE) {
-#ifdef GZIP
-        if (s->wrap == 2) {
-            strm->adler = crc32(0L, Z_NULL, 0);
-            put_byte(s, 31);
-            put_byte(s, 139);
-            put_byte(s, 8);
-            if (s->gzhead == Z_NULL) {
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, OS_CODE);
-                s->status = BUSY_STATE;
-            }
-            else {
-                put_byte(s, (s->gzhead->text ? 1 : 0) +
-                            (s->gzhead->hcrc ? 2 : 0) +
-                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                            (s->gzhead->name == Z_NULL ? 0 : 8) +
-                            (s->gzhead->comment == Z_NULL ? 0 : 16)
-                        );
-                put_byte(s, (Byte)(s->gzhead->time & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, s->gzhead->os & 0xff);
-                if (s->gzhead->extra != Z_NULL) {
-                    put_byte(s, s->gzhead->extra_len & 0xff);
-                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-                }
-                if (s->gzhead->hcrc)
-                    strm->adler = crc32(strm->adler, s->pending_buf,
-                                        s->pending);
-                s->gzindex = 0;
-                s->status = EXTRA_STATE;
-            }
-        }
-        else
-#endif
-        {
-            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-            uInt level_flags;
-
-            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-                level_flags = 0;
-            else if (s->level < 6)
-                level_flags = 1;
-            else if (s->level == 6)
-                level_flags = 2;
-            else
-                level_flags = 3;
-            header |= (level_flags << 6);
-            if (s->strstart != 0) header |= PRESET_DICT;
-            header += 31 - (header % 31);
-
-            s->status = BUSY_STATE;
-            putShortMSB(s, header);
-
-            /* Save the adler32 of the preset dictionary: */
-            if (s->strstart != 0) {
-                putShortMSB(s, (uInt)(strm->adler >> 16));
-                putShortMSB(s, (uInt)(strm->adler & 0xffff));
-            }
-            strm->adler = adler32(0L, Z_NULL, 0);
-        }
-    }
-#ifdef GZIP
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-
-            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size)
-                        break;
-                }
-                put_byte(s, s->gzhead->extra[s->gzindex]);
-                s->gzindex++;
-            }
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (s->gzindex == s->gzhead->extra_len) {
-                s->gzindex = 0;
-                s->status = NAME_STATE;
-            }
-        }
-        else
-            s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0) {
-                s->gzindex = 0;
-                s->status = COMMENT_STATE;
-            }
-        }
-        else
-            s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0)
-                s->status = HCRC_STATE;
-        }
-        else
-            s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size)
-                flush_pending(strm);
-            if (s->pending + 2 <= s->pending_buf_size) {
-                put_byte(s, (Byte)(strm->adler & 0xff));
-                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-                strm->adler = crc32(0L, Z_NULL, 0);
-                s->status = BUSY_STATE;
-            }
-        }
-        else
-            s->status = BUSY_STATE;
-    }
-#endif
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && flush <= old_flush &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
-                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
-                        (*(configuration_table[s->level].func))(s, flush));
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                    if (s->lookahead == 0) {
-                        s->strstart = 0;
-                        s->block_start = 0L;
-                    }
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    Assert(strm->avail_out > 0, "bug2");
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-
-    status = strm->state->status;
-    if (status != INIT_STATE &&
-        status != EXTRA_STATE &&
-        status != NAME_STATE &&
-        status != COMMENT_STATE &&
-        status != HCRC_STATE &&
-        status != BUSY_STATE &&
-        status != FINISH_STATE) {
-      return Z_STREAM_ERROR;
-    }
-
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-
-
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = source->state;
-
-    zmemcpy(dest, source, sizeof(z_stream));
-
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy(ds, ss, sizeof(deflate_state));
-    ds->strm = dest;
-
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uchf *) overlay;
-
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, strm->next_in, len);
-    }
-#ifdef GZIP
-    else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, strm->next_in, len);
-    }
-#endif
-    zmemcpy(buf, strm->next_in, len);
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return (int)len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-#ifndef FASTEST
-#ifdef ASMV
-    match_init(); /* initialize the asm code */
-#endif
-#endif
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-#ifndef ASMV
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = s->prev_length;              /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2.  Note that the checks below
-         * for insufficient lookahead only occur occasionally for performance
-         * reasons.  Therefore uninitialized memory will be accessed, and
-         * conditional jumps will be made that depend on those values.
-         * However the length of the match is limited to the lookahead, so
-         * the output of deflate is not affected by the uninitialized values.
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-#endif /* ASMV */
-
-#else /* FASTEST */
-
-/* ---------------------------------------------------------------------------
- * Optimized version for FASTEST only
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    Assert(cur_match < s->strstart, "no future");
-
-    match = s->window + cur_match;
-
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-
-    /* The check at best_len-1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart+258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-    len = MAX_MATCH - (int)(strend - scan);
-
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-
-    s->match_start = cur_match;
-    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
-}
-
-#endif /* FASTEST */
-
-#ifdef DEBUG
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif /* DEBUG */
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    register unsigned n, m;
-    register Posf *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-
-            /* Slide the hash table (could be avoided with 32 bit values
-               at the expense of memory usage). We slide even when level == 0
-               to keep the hash table consistent if we switch back to level > 0
-               later. (Using level 0 permanently is not an optimal usage of
-               zlib, so we don't care about this pathological case.)
-             */
-            n = s->hash_size;
-            p = &s->head[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-            } while (--n);
-
-            n = wsize;
-#ifndef FASTEST
-            p = &s->prev[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-                /* If n is not on any hash chain, prev[n] is garbage but
-                 * its value will never be used.
-                 */
-            } while (--n);
-#endif
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) return;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead >= MIN_MATCH) {
-            s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-
-    /* If the WIN_INIT bytes after the end of the current data have never been
-     * written, then zero those bytes in order to avoid memory check reports of
-     * the use of uninitialized (or uninitialised as Julian writes) bytes by
-     * the longest match routines.  Update the high water mark for the next
-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
-     */
-    if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
-
-        if (s->high_water < curr) {
-            /* Previous high water mark below current data -- zero WIN_INIT
-             * bytes or up to end of window, whichever is less.
-             */
-            init = s->window_size - curr;
-            if (init > WIN_INIT)
-                init = WIN_INIT;
-            zmemzero(s->window + curr, (unsigned)init);
-            s->high_water = curr + init;
-        }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
-            /* High water mark at or above current data, but below current data
-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
-             * to end of window, whichever is less.
-             */
-            init = (ulg)curr + WIN_INIT - s->high_water;
-            if (init > s->window_size - s->high_water)
-                init = s->window_size - s->high_water;
-            zmemzero(s->window + s->high_water, (unsigned)init);
-            s->high_water += init;
-        }
-    }
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, last) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (last)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, last) { \
-   FLUSH_BLOCK_ONLY(s, last); \
-   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
-}
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- * This function does not insert new strings in the dictionary since
- * uncompressible data is probably not useful. This function is used
- * only for the level=0 compression option.
- * NOTE: this function should be optimized to avoid extra copying from
- * window to pending_buf.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
-     * to pending_buf_size, and each stored block has a 5 byte header:
-     */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
-
-    if (max_block_size > s->pending_buf_size - 5) {
-        max_block_size = s->pending_buf_size - 5;
-    }
-
-    /* Copy as much as possible from input to output: */
-    for (;;) {
-        /* Fill the window as much as possible: */
-        if (s->lookahead <= 1) {
-
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-                   s->block_start >= (long)s->w_size, "slide too late");
-
-            fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
-
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        Assert(s->block_start >= 0L, "block gone");
-
-        s->strstart += s->lookahead;
-        s->lookahead = 0;
-
-        /* Emit a stored block if pending_buf will be full: */
-        max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
-            /* strstart == 0 is possible when wraparound on 16-bit machine */
-            s->lookahead = (uInt)(s->strstart - max_start);
-            s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
-        }
-        /* Flush if we may have to slide, otherwise block_start may become
-         * negative and the data will be gone:
-         */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
-        }
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;       /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;          /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-        s->match_available = 0;
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-#endif /* FASTEST */
-
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest encodable run.
-         */
-        if (s->lookahead < MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* See how many times the previous byte repeats */
-        s->match_length = 0;
-        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
-            scan = s->window + s->strstart - 1;
-            prev = *scan;
-            if (prev == *++scan && prev == *++scan && prev == *++scan) {
-                strend = s->window + s->strstart + MAX_MATCH;
-                do {
-                } while (prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         scan < strend);
-                s->match_length = MAX_MATCH - (int)(strend - scan);
-                if (s->match_length > s->lookahead)
-                    s->match_length = s->lookahead;
-            }
-        }
-
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, s->match_length);
-
-            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-            s->strstart += s->match_length;
-            s->match_length = 0;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
- * (It will be regenerated if this run of deflate switches away from Huffman.)
- */
-local block_state deflate_huff(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we have a literal to write. */
-        if (s->lookahead == 0) {
-            fill_window(s);
-            if (s->lookahead == 0) {
-                if (flush == Z_NO_FLUSH)
-                    return need_more;
-                break;      /* flush the current block */
-            }
-        }
-
-        /* Output a literal byte */
-        s->match_length = 0;
-        Tracevv((stderr,"%c", s->window[s->strstart]));
-        _tr_tally_lit (s, s->window[s->strstart], bflush);
-        s->lookahead--;
-        s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
diff --git a/thirdparty/libz/deflate.h b/thirdparty/libz/deflate.h
deleted file mode 100644
index cbf0d1e..0000000
--- a/thirdparty/libz/deflate.h
+++ /dev/null
@@ -1,342 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2010 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef DEFLATE_H
-#define DEFLATE_H
-
-#include "zutil.h"
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define INIT_STATE    42
-#define EXTRA_STATE   69
-#define NAME_STATE    73
-#define COMMENT_STATE 91
-#define HCRC_STATE   103
-#define BUSY_STATE   113
-#define FINISH_STATE 666
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    static_tree_desc *stat_desc; /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    uInt   pending;      /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    uInt   gzindex;      /* where in extra, name, or comment */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to supress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    int last_eob_len;   /* bit length of EOB code for last block */
-
-#ifdef DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-    ulg high_water;
-    /* High water mark offset in window for initialized bytes -- bytes above
-     * this are set to zero in order to avoid memory check warnings when
-     * longest match routines access bytes past the input.  This is then
-     * updated to the new high water mark.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-#define WIN_INIT MAX_MATCH
-/* Number of bytes after end of data in window to initialize in order to avoid
-   memory checker errors from longest match routines */
-
-        /* in trees.c */
-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (length); \
-    ush dist = (distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif /* DEFLATE_H */
diff --git a/thirdparty/libz/example.c b/thirdparty/libz/example.c
deleted file mode 100644
index 604736f..0000000
--- a/thirdparty/libz/example.c
+++ /dev/null
@@ -1,565 +0,0 @@
-/* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2006 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
-#else
-#  define TESTFILE "foo.gz"
-#endif
-
-#define CHECK_ERR(err, msg) { \
-    if (err != Z_OK) { \
-        fprintf(stderr, "%s error: %d\n", msg, err); \
-        exit(1); \
-    } \
-}
-
-const char hello[] = "hello, hello!";
-/* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- */
-
-const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_compress      OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_gzio          OF((const char *fname,
-                            Byte *uncompr, uLong uncomprLen));
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-int  main               OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Test compress() and uncompress()
- */
-void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
-    CHECK_ERR(err, "compress");
-
-    strcpy((char*)uncompr, "garbage");
-
-    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
-    CHECK_ERR(err, "uncompress");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad uncompress\n");
-        exit(1);
-    } else {
-        printf("uncompress(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test read/write of .gz files
- */
-void test_gzio(fname, uncompr, uncomprLen)
-    const char *fname; /* compressed file name */
-    Byte *uncompr;
-    uLong uncomprLen;
-{
-#ifdef NO_GZCOMPRESS
-    fprintf(stderr, "NO_GZCOMPRESS -- gz* functions cannot compress\n");
-#else
-    int err;
-    int len = (int)strlen(hello)+1;
-    gzFile file;
-    z_off_t pos;
-
-    file = gzopen(fname, "wb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    gzputc(file, 'h');
-    if (gzputs(file, "ello") != 4) {
-        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (gzprintf(file, ", %s!", "hello") != 8) {
-        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
-    gzclose(file);
-
-    file = gzopen(fname, "rb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    strcpy((char*)uncompr, "garbage");
-
-    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {
-        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
-        exit(1);
-    } else {
-        printf("gzread(): %s\n", (char*)uncompr);
-    }
-
-    pos = gzseek(file, -8L, SEEK_CUR);
-    if (pos != 6 || gztell(file) != pos) {
-        fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
-        exit(1);
-    }
-
-    if (gzgetc(file) != ' ') {
-        fprintf(stderr, "gzgetc error\n");
-        exit(1);
-    }
-
-    if (gzungetc(' ', file) != ' ') {
-        fprintf(stderr, "gzungetc error\n");
-        exit(1);
-    }
-
-    gzgets(file, (char*)uncompr, (int)uncomprLen);
-    if (strlen((char*)uncompr) != 7) { /* " hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello + 6)) {
-        fprintf(stderr, "bad gzgets after gzseek\n");
-        exit(1);
-    } else {
-        printf("gzgets() after gzseek: %s\n", (char*)uncompr);
-    }
-
-    gzclose(file);
-#endif
-}
-
-/* ===========================================================================
- * Test deflate() with small buffers
- */
-void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-
-    while (c_stream.total_in != len && c_stream.total_out < comprLen) {
-        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
-        err = deflate(&c_stream, Z_NO_FLUSH);
-        CHECK_ERR(err, "deflate");
-    }
-    /* Finish the stream, still forcing small buffers: */
-    for (;;) {
-        c_stream.avail_out = 1;
-        err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "deflate");
-    }
-
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with small buffers
- */
-void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 0;
-    d_stream.next_out = uncompr;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
-        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate\n");
-        exit(1);
-    } else {
-        printf("inflate(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with large buffers and dynamic change of compression level
- */
-void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_SPEED);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    /* At this point, uncompr is still mostly zeroes, so it should compress
-     * very well:
-     */
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-    if (c_stream.avail_in != 0) {
-        fprintf(stderr, "deflate not greedy\n");
-        exit(1);
-    }
-
-    /* Feed in already compressed data and switch to no compression: */
-    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-    c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    /* Switch back to compressing mode: */
-    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with large buffers
- */
-void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    for (;;) {
-        d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "large inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
-        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
-        exit(1);
-    } else {
-        printf("large_inflate(): OK\n");
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with full flush
- */
-void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uInt len = (uInt)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-    c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
-    err = deflate(&c_stream, Z_FULL_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    compr[3]++; /* force an error in first compressed block */
-    c_stream.avail_in = len - 3;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        CHECK_ERR(err, "deflate");
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-
-    *comprLen = c_stream.total_out;
-}
-
-/* ===========================================================================
- * Test inflateSync()
- */
-void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 2; /* just read the zlib header */
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    inflate(&d_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "inflate");
-
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
-    err = inflateSync(&d_stream);           /* but skip the damaged part */
-    CHECK_ERR(err, "inflateSync");
-
-    err = inflate(&d_stream, Z_FINISH);
-    if (err != Z_DATA_ERROR) {
-        fprintf(stderr, "inflate should report DATA_ERROR\n");
-        /* Because of incorrect adler32 */
-        exit(1);
-    }
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    printf("after inflateSync(): hel%s\n", (char *)uncompr);
-}
-
-/* ===========================================================================
- * Test deflate() with preset dictionary
- */
-void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    err = deflateSetDictionary(&c_stream,
-                               (const Bytef*)dictionary, sizeof(dictionary));
-    CHECK_ERR(err, "deflateSetDictionary");
-
-    dictId = c_stream.adler;
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with a preset dictionary
- */
-void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    for (;;) {
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        if (err == Z_NEED_DICT) {
-            if (d_stream.adler != dictId) {
-                fprintf(stderr, "unexpected dictionary");
-                exit(1);
-            }
-            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
-                                       sizeof(dictionary));
-        }
-        CHECK_ERR(err, "inflate with dict");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate with dict\n");
-        exit(1);
-    } else {
-        printf("inflate with dictionary: %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Usage:  example [output.gz  [input.gz]]
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
-
-    if (zlibVersion()[0] != myVersion[0]) {
-        fprintf(stderr, "incompatible zlib version\n");
-        exit(1);
-
-    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
-        fprintf(stderr, "warning: different zlib version\n");
-    }
-
-    printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n",
-            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());
-
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
-    /* compr and uncompr are cleared to avoid reading uninitialized
-     * data and to ensure that uncompr compresses well.
-     */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
-        printf("out of memory\n");
-        exit(1);
-    }
-    test_compress(compr, comprLen, uncompr, uncomprLen);
-
-    test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              uncompr, uncomprLen);
-
-    test_deflate(compr, comprLen);
-    test_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-    test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_flush(compr, &comprLen);
-    test_sync(compr, comprLen, uncompr, uncomprLen);
-    comprLen = uncomprLen;
-
-    test_dict_deflate(compr, comprLen);
-    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    free(compr);
-    free(uncompr);
-
-    return 0;
-}
diff --git a/thirdparty/libz/gzclose.c b/thirdparty/libz/gzclose.c
deleted file mode 100644
index caeb99a..0000000
--- a/thirdparty/libz/gzclose.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/* gzclose.c -- zlib gzclose() function
- * Copyright (C) 2004, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* gzclose() is in a separate file so that it is linked in only if it is used.
-   That way the other gzclose functions can be used instead to avoid linking in
-   unneeded compression or decompression routines. */
-int ZEXPORT gzclose(file)
-    gzFile file;
-{
-#ifndef NO_GZCOMPRESS
-    gz_statep state;
-
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
-#else
-    return gzclose_r(file);
-#endif
-}
diff --git a/thirdparty/libz/gzguts.h b/thirdparty/libz/gzguts.h
deleted file mode 100644
index 0f8fb79..0000000
--- a/thirdparty/libz/gzguts.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/* gzguts.h -- zlib internal header definitions for gz* operations
- * Copyright (C) 2004, 2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifdef _LARGEFILE64_SOURCE
-#  ifndef _LARGEFILE_SOURCE
-#    define _LARGEFILE_SOURCE 1
-#  endif
-#  ifdef _FILE_OFFSET_BITS
-#    undef _FILE_OFFSET_BITS
-#  endif
-#endif
-
-#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 >= 33) && !defined(NO_VIZ)
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include <stdio.h>
-#include "zlib.h"
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#  include <limits.h>
-#endif
-#include <fcntl.h>
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-#ifdef _MSC_VER
-#  include <io.h>
-#  define vsnprintf _vsnprintf
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-/* gz* functions always use library allocation functions */
-#ifndef STDC
-  extern voidp  malloc OF((uInt size));
-  extern void   free   OF((voidpf ptr));
-#endif
-
-/* get errno and strerror definition */
-#if defined UNDER_CE
-#  include <windows.h>
-#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
-#else
-#  ifdef STDC
-#    include <errno.h>
-#    define zstrerror() strerror(errno)
-#  else
-#    define zstrerror() "stdio error (consult errno)"
-#  endif
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-#endif
-
-/* default i/o buffer size -- double this for output when reading */
-#define GZBUFSIZE 8192
-
-/* gzip modes, also provide a little integrity check on the passed structure */
-#define GZ_NONE 0
-#define GZ_READ 7247
-#define GZ_WRITE 31153
-#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */
-
-/* values for gz_state how */
-#define LOOK 0      /* look for a gzip header */
-#define COPY 1      /* copy input directly */
-#define GZIP 2      /* decompress a gzip stream */
-
-/* internal gzip file state data structure */
-typedef struct {
-        /* used for both reading and writing */
-    int mode;               /* see gzip modes above */
-    int fd;                 /* file descriptor */
-    char *path;             /* path or fd for error messages */
-    z_off64_t pos;          /* current position in uncompressed data */
-    unsigned size;          /* buffer size, zero if not allocated yet */
-    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
-    unsigned char *in;      /* input buffer */
-    unsigned char *out;     /* output buffer (double-sized when reading) */
-    unsigned char *next;    /* next output data to deliver or write */
-        /* just for reading */
-    unsigned have;          /* amount of output data unused at next */
-    int eof;                /* true if end of input file reached */
-    z_off64_t start;        /* where the gzip data started, for rewinding */
-    z_off64_t raw;          /* where the raw data started, for seeking */
-    int how;                /* 0: get header, 1: copy, 2: decompress */
-    int direct;             /* true if last read direct, false if gzip */
-        /* just for writing */
-    int level;              /* compression level */
-    int strategy;           /* compression strategy */
-        /* seek request */
-    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
-    int seek;               /* true if seek request pending */
-        /* error information */
-    int err;                /* error code */
-    char *msg;              /* error message */
-        /* zlib inflate or deflate stream */
-    z_stream strm;          /* stream structure in-place (not a pointer) */
-} gz_state;
-typedef gz_state FAR *gz_statep;
-
-/* shared functions */
-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
-#if defined UNDER_CE
-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
-#endif
-
-/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
-   value -- needed when comparing unsigned to z_off64_t, which is signed
-   (possible z_off64_t types off_t, off64_t, and long are all signed) */
-#ifdef INT_MAX
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
-#else
-unsigned ZLIB_INTERNAL gz_intmax OF((void));
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
-#endif
diff --git a/thirdparty/libz/gzlib.c b/thirdparty/libz/gzlib.c
deleted file mode 100644
index 603e60e..0000000
--- a/thirdparty/libz/gzlib.c
+++ /dev/null
@@ -1,537 +0,0 @@
-/* gzlib.c -- zlib functions common to reading and writing gzip files
- * Copyright (C) 2004, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define LSEEK lseek64
-#else
-#  define LSEEK lseek
-#endif
-
-/* Local functions */
-local void gz_reset OF((gz_statep));
-local gzFile gz_open OF((const char *, int, const char *));
-
-#if defined UNDER_CE
-
-/* Map the Windows error number in ERROR to a locale-dependent error message
-   string and return a pointer to it.  Typically, the values for ERROR come
-   from GetLastError.
-
-   The string pointed to shall not be modified by the application, but may be
-   overwritten by a subsequent call to gz_strwinerror
-
-   The gz_strwinerror function does not change the current setting of
-   GetLastError. */
-char ZLIB_INTERNAL *gz_strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-#endif /* UNDER_CE */
-
-/* Reset gzip file state */
-local void gz_reset(state)
-    gz_statep state;
-{
-    if (state->mode == GZ_READ) {   /* for reading ... */
-        state->have = 0;            /* no output data available */
-        state->eof = 0;             /* not at end of file */
-        state->how = LOOK;          /* look for gzip header */
-        state->direct = 1;          /* default for empty file */
-    }
-    state->seek = 0;                /* no seek request pending */
-    gz_error(state, Z_OK, NULL);    /* clear error */
-    state->pos = 0;                 /* no uncompressed data yet */
-    state->strm.avail_in = 0;       /* no input data yet */
-}
-
-/* Open a gzip file either by name or file descriptor. */
-local gzFile gz_open(path, fd, mode)
-    const char *path;
-    int fd;
-    const char *mode;
-{
-    gz_statep state;
-
-    /* allocate gzFile structure to return */
-    state = malloc(sizeof(gz_state));
-    if (state == NULL)
-        return NULL;
-    state->size = 0;            /* no buffers allocated yet */
-    state->want = GZBUFSIZE;    /* requested buffer size */
-    state->msg = NULL;          /* no error message yet */
-
-    /* interpret mode */
-    state->mode = GZ_NONE;
-    state->level = Z_DEFAULT_COMPRESSION;
-    state->strategy = Z_DEFAULT_STRATEGY;
-    while (*mode) {
-        if (*mode >= '0' && *mode <= '9')
-            state->level = *mode - '0';
-        else
-            switch (*mode) {
-            case 'r':
-                state->mode = GZ_READ;
-                break;
-#ifndef NO_GZCOMPRESS
-            case 'w':
-                state->mode = GZ_WRITE;
-                break;
-            case 'a':
-                state->mode = GZ_APPEND;
-                break;
-#endif
-            case '+':       /* can't read and write at the same time */
-                free(state);
-                return NULL;
-            case 'b':       /* ignore -- will request binary anyway */
-                break;
-            case 'f':
-                state->strategy = Z_FILTERED;
-                break;
-            case 'h':
-                state->strategy = Z_HUFFMAN_ONLY;
-                break;
-            case 'R':
-                state->strategy = Z_RLE;
-                break;
-            case 'F':
-                state->strategy = Z_FIXED;
-            default:        /* could consider as an error, but just ignore */
-                ;
-            }
-        mode++;
-    }
-
-    /* must provide an "r", "w", or "a" */
-    if (state->mode == GZ_NONE) {
-        free(state);
-        return NULL;
-    }
-
-    /* save the path name for error messages */
-    state->path = malloc(strlen(path) + 1);
-    if (state->path == NULL) {
-        free(state);
-        return NULL;
-    }
-    strcpy(state->path, path);
-
-    /* open the file with the appropriate mode (or just use fd) */
-    state->fd = fd != -1 ? fd :
-        open(path,
-#ifdef O_LARGEFILE
-            O_LARGEFILE |
-#endif
-#ifdef O_BINARY
-            O_BINARY |
-#endif
-            (state->mode == GZ_READ ?
-                O_RDONLY :
-                (O_WRONLY | O_CREAT | (
-                    state->mode == GZ_WRITE ?
-                        O_TRUNC :
-                        O_APPEND))),
-            0666);
-    if (state->fd == -1) {
-        free(state->path);
-        free(state);
-        return NULL;
-    }
-    if (state->mode == GZ_APPEND)
-        state->mode = GZ_WRITE;         /* simplify later checks */
-
-    /* save the current position for rewinding (only if reading) */
-    if (state->mode == GZ_READ) {
-        state->start = LSEEK(state->fd, 0, SEEK_CUR);
-        if (state->start == -1) state->start = 0;
-    }
-
-    /* initialize stream */
-    gz_reset(state);
-
-    /* return stream */
-    return (gzFile)state;
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen64(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzdopen(fd, mode)
-    int fd;
-    const char *mode;
-{
-    char *path;         /* identifier for error messages */
-    gzFile gz;
-
-    if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)
-        return NULL;
-    sprintf(path, "<fd:%d>", fd);   /* for debugging */
-    gz = gz_open(path, fd, mode);
-    free(path);
-    return gz;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzbuffer(file, size)
-    gzFile file;
-    unsigned size;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* make sure we haven't already allocated memory */
-    if (state->size != 0)
-        return -1;
-
-    /* check and set requested size */
-    if (size == 0)
-        return -1;
-    state->want = size;
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzrewind(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ || state->err != Z_OK)
-        return -1;
-
-    /* back up and start over */
-    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
-        return -1;
-    gz_reset(state);
-    return 0;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzseek64(file, offset, whence)
-    gzFile file;
-    z_off64_t offset;
-    int whence;
-{
-    unsigned n;
-    z_off64_t ret;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* check that there's no error */
-    if (state->err != Z_OK)
-        return -1;
-
-    /* can only seek from start or relative to current position */
-    if (whence != SEEK_SET && whence != SEEK_CUR)
-        return -1;
-
-    /* normalize offset to a SEEK_CUR specification */
-    if (whence == SEEK_SET)
-        offset -= state->pos;
-    else if (state->seek)
-        offset += state->skip;
-    state->seek = 0;
-
-    /* if within raw area while reading, just go there */
-    if (state->mode == GZ_READ && state->how == COPY &&
-        state->pos + offset >= state->raw) {
-        ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);
-        if (ret == -1)
-            return -1;
-        state->have = 0;
-        state->eof = 0;
-        state->seek = 0;
-        gz_error(state, Z_OK, NULL);
-        state->strm.avail_in = 0;
-        state->pos += offset;
-        return state->pos;
-    }
-
-    /* calculate skip amount, rewinding if needed for back seek when reading */
-    if (offset < 0) {
-        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
-            return -1;
-        offset += state->pos;
-        if (offset < 0)                     /* before start of file! */
-            return -1;
-        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
-            return -1;
-    }
-
-    /* if reading, skip what's in output buffer (one less gzgetc() check) */
-    if (state->mode == GZ_READ) {
-        n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?
-            (unsigned)offset : state->have;
-        state->have -= n;
-        state->next += n;
-        state->pos += n;
-        offset -= n;
-    }
-
-    /* request skip (if not zero) */
-    if (offset) {
-        state->seek = 1;
-        state->skip = offset;
-    }
-    return state->pos + offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzseek(file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    z_off64_t ret;
-
-    ret = gzseek64(file, (z_off64_t)offset, whence);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gztell64(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* return position */
-    return state->pos + (state->seek ? state->skip : 0);
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gztell(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gztell64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzoffset64(file)
-    gzFile file;
-{
-    z_off64_t offset;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* compute and return effective offset in file */
-    offset = LSEEK(state->fd, 0, SEEK_CUR);
-    if (offset == -1)
-        return -1;
-    if (state->mode == GZ_READ)             /* reading */
-        offset -= state->strm.avail_in;     /* don't count buffered input */
-    return offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzoffset(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gzoffset64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzeof(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return 0;
-
-    /* return end-of-file state */
-    return state->mode == GZ_READ ?
-        (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;
-}
-
-/* -- see zlib.h -- */
-const char * ZEXPORT gzerror(file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return NULL;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return NULL;
-
-    /* return error information */
-    if (errnum != NULL)
-        *errnum = state->err;
-    return state->msg == NULL ? "" : state->msg;
-}
-
-/* -- see zlib.h -- */
-void ZEXPORT gzclearerr(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return;
-
-    /* clear error and end-of-file */
-    if (state->mode == GZ_READ)
-        state->eof = 0;
-    gz_error(state, Z_OK, NULL);
-}
-
-/* Create an error message in allocated memory and set state->err and
-   state->msg accordingly.  Free any previous error message already there.  Do
-   not try to free or allocate space if the error is Z_MEM_ERROR (out of
-   memory).  Simply save the error message as a static string.  If there is an
-   allocation failure constructing the error message, then convert the error to
-   out of memory. */
-void ZLIB_INTERNAL gz_error(state, err, msg)
-    gz_statep state;
-    int err;
-    const char *msg;
-{
-    /* free previously allocated message and clear */
-    if (state->msg != NULL) {
-        if (state->err != Z_MEM_ERROR)
-            free(state->msg);
-        state->msg = NULL;
-    }
-
-    /* set error code, and if no message, then done */
-    state->err = err;
-    if (msg == NULL)
-        return;
-
-    /* for an out of memory error, save as static string */
-    if (err == Z_MEM_ERROR) {
-        state->msg = (char *)msg;
-        return;
-    }
-
-    /* construct error message with path */
-    if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {
-        state->err = Z_MEM_ERROR;
-        state->msg = (char *)"out of memory";
-        return;
-    }
-    strcpy(state->msg, state->path);
-    strcat(state->msg, ": ");
-    strcat(state->msg, msg);
-    return;
-}
-
-#ifndef INT_MAX
-/* portably return maximum value for an int (when limits.h presumed not
-   available) -- we need to do this to cover cases where 2's complement not
-   used, since C standard permits 1's complement and sign-bit representations,
-   otherwise we could just use ((unsigned)-1) >> 1 */
-unsigned ZLIB_INTERNAL gz_intmax()
-{
-    unsigned p, q;
-
-    p = 1;
-    do {
-        q = p;
-        p <<= 1;
-        p++;
-    } while (p > q);
-    return q >> 1;
-}
-#endif
diff --git a/thirdparty/libz/gzread.c b/thirdparty/libz/gzread.c
deleted file mode 100644
index 548201a..0000000
--- a/thirdparty/libz/gzread.c
+++ /dev/null
@@ -1,653 +0,0 @@
-/* gzread.c -- zlib functions for reading gzip files
- * Copyright (C) 2004, 2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
-local int gz_avail OF((gz_statep));
-local int gz_next4 OF((gz_statep, unsigned long *));
-local int gz_head OF((gz_statep));
-local int gz_decomp OF((gz_statep));
-local int gz_make OF((gz_statep));
-local int gz_skip OF((gz_statep, z_off64_t));
-
-/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
-   state->fd, and update state->eof, state->err, and state->msg as appropriate.
-   This function needs to loop on read(), since read() is not guaranteed to
-   read the number of bytes requested, depending on the type of descriptor. */
-local int gz_load(state, buf, len, have)
-    gz_statep state;
-    unsigned char *buf;
-    unsigned len;
-    unsigned *have;
-{
-    int ret;
-
-    *have = 0;
-    do {
-        ret = read(state->fd, buf + *have, len - *have);
-        if (ret <= 0)
-            break;
-        *have += ret;
-    } while (*have < len);
-    if (ret < 0) {
-        gz_error(state, Z_ERRNO, zstrerror());
-        return -1;
-    }
-    if (ret == 0)
-        state->eof = 1;
-    return 0;
-}
-
-/* Load up input buffer and set eof flag if last data loaded -- return -1 on
-   error, 0 otherwise.  Note that the eof flag is set when the end of the input
-   file is reached, even though there may be unused data in the buffer.  Once
-   that data has been used, no more attempts will be made to read the file.
-   gz_avail() assumes that strm->avail_in == 0. */
-local int gz_avail(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    if (state->err != Z_OK)
-        return -1;
-    if (state->eof == 0) {
-        if (gz_load(state, state->in, state->size,
-                (unsigned *)&(strm->avail_in)) == -1)
-            return -1;
-        strm->next_in = state->in;
-    }
-    return 0;
-}
-
-/* Get next byte from input, or -1 if end or error. */
-#define NEXT() ((strm->avail_in == 0 && gz_avail(state) == -1) ? -1 : \
-                (strm->avail_in == 0 ? -1 : \
-                 (strm->avail_in--, *(strm->next_in)++)))
-
-/* Get a four-byte little-endian integer and return 0 on success and the value
-   in *ret.  Otherwise -1 is returned and *ret is not modified. */
-local int gz_next4(state, ret)
-    gz_statep state;
-    unsigned long *ret;
-{
-    int ch;
-    unsigned long val;
-    z_streamp strm = &(state->strm);
-
-    val = NEXT();
-    val += (unsigned)NEXT() << 8;
-    val += (unsigned long)NEXT() << 16;
-    ch = NEXT();
-    if (ch == -1)
-        return -1;
-    val += (unsigned long)ch << 24;
-    *ret = val;
-    return 0;
-}
-
-/* Look for gzip header, set up for inflate or copy.  state->have must be zero.
-   If this is the first time in, allocate required memory.  state->how will be
-   left unchanged if there is no more input data available, will be set to COPY
-   if there is no gzip header and direct copying will be performed, or it will
-   be set to GZIP for decompression, and the gzip header will be skipped so
-   that the next available input data is the raw deflate stream.  If direct
-   copying, then leftover input data from the input buffer will be copied to
-   the output buffer.  In that case, all further file reads will be directly to
-   either the output buffer or a user buffer.  If decompressing, the inflate
-   state and the check value will be initialized.  gz_head() will return 0 on
-   success or -1 on failure.  Failures may include read errors or gzip header
-   errors.  */
-local int gz_head(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-    int flags;
-    unsigned len;
-
-    /* allocate read buffers and inflate memory */
-    if (state->size == 0) {
-        /* allocate buffers */
-        state->in = malloc(state->want);
-        state->out = malloc(state->want << 1);
-        if (state->in == NULL || state->out == NULL) {
-            if (state->out != NULL)
-                free(state->out);
-            if (state->in != NULL)
-                free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        state->size = state->want;
-
-        /* allocate inflate memory */
-        state->strm.zalloc = Z_NULL;
-        state->strm.zfree = Z_NULL;
-        state->strm.opaque = Z_NULL;
-        state->strm.avail_in = 0;
-        state->strm.next_in = Z_NULL;
-        if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */
-            free(state->out);
-            free(state->in);
-            state->size = 0;
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-    }
-
-    /* get some data in the input buffer */
-    if (strm->avail_in == 0) {
-        if (gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0)
-            return 0;
-    }
-
-    /* look for the gzip magic header bytes 31 and 139 */
-    if (strm->next_in[0] == 31) {
-        strm->avail_in--;
-        strm->next_in++;
-        if (strm->avail_in == 0 && gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in && strm->next_in[0] == 139) {
-            /* we have a gzip header, woo hoo! */
-            strm->avail_in--;
-            strm->next_in++;
-
-            /* skip rest of header */
-            if (NEXT() != 8) {      /* compression method */
-                gz_error(state, Z_DATA_ERROR, "unknown compression method");
-                return -1;
-            }
-            flags = NEXT();
-            if (flags & 0xe0) {     /* reserved flag bits */
-                gz_error(state, Z_DATA_ERROR, "unknown header flags set");
-                return -1;
-            }
-            NEXT();                 /* modification time */
-            NEXT();
-            NEXT();
-            NEXT();
-            NEXT();                 /* extra flags */
-            NEXT();                 /* operating system */
-            if (flags & 4) {        /* extra field */
-                len = (unsigned)NEXT();
-                len += (unsigned)NEXT() << 8;
-                while (len--)
-                    if (NEXT() < 0)
-                        break;
-            }
-            if (flags & 8)          /* file name */
-                while (NEXT() > 0)
-                    ;
-            if (flags & 16)         /* comment */
-                while (NEXT() > 0)
-                    ;
-            if (flags & 2) {        /* header crc */
-                NEXT();
-                NEXT();
-            }
-            /* an unexpected end of file is not checked for here -- it will be
-               noticed on the first request for uncompressed data */
-
-            /* set up for decompression */
-            inflateReset(strm);
-            strm->adler = crc32(0L, Z_NULL, 0);
-            state->how = GZIP;
-            state->direct = 0;
-            return 0;
-        }
-        else {
-            /* not a gzip file -- save first byte (31) and fall to raw i/o */
-            state->out[0] = 31;
-            state->have = 1;
-        }
-    }
-
-    /* doing raw i/o, save start of raw data for seeking, copy any leftover
-       input to output -- this assumes that the output buffer is larger than
-       the input buffer, which also assures space for gzungetc() */
-    state->raw = state->pos;
-    state->next = state->out;
-    if (strm->avail_in) {
-        memcpy(state->next + state->have, strm->next_in, strm->avail_in);
-        state->have += strm->avail_in;
-        strm->avail_in = 0;
-    }
-    state->how = COPY;
-    state->direct = 1;
-    return 0;
-}
-
-/* Decompress from input to the provided next_out and avail_out in the state.
-   If the end of the compressed data is reached, then verify the gzip trailer
-   check value and length (modulo 2^32).  state->have and state->next are set
-   to point to the just decompressed data, and the crc is updated.  If the
-   trailer is verified, state->how is reset to LOOK to look for the next gzip
-   stream or raw data, once state->have is depleted.  Returns 0 on success, -1
-   on failure.  Failures may include invalid compressed data or a failed gzip
-   trailer verification. */
-local int gz_decomp(state)
-    gz_statep state;
-{
-    int ret;
-    unsigned had;
-    unsigned long crc, len;
-    z_streamp strm = &(state->strm);
-
-    /* fill output buffer up to end of deflate stream */
-    had = strm->avail_out;
-    do {
-        /* get more input for inflate() */
-        if (strm->avail_in == 0 && gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0) {
-            gz_error(state, Z_DATA_ERROR, "unexpected end of file");
-            return -1;
-        }
-
-        /* decompress and handle errors */
-        ret = inflate(strm, Z_NO_FLUSH);
-        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
-            gz_error(state, Z_STREAM_ERROR,
-                      "internal error: inflate stream corrupt");
-            return -1;
-        }
-        if (ret == Z_MEM_ERROR) {
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
-            gz_error(state, Z_DATA_ERROR,
-                      strm->msg == NULL ? "compressed data error" : strm->msg);
-            return -1;
-        }
-    } while (strm->avail_out && ret != Z_STREAM_END);
-
-    /* update available output and crc check value */
-    state->have = had - strm->avail_out;
-    state->next = strm->next_out - state->have;
-    strm->adler = crc32(strm->adler, state->next, state->have);
-
-    /* check gzip trailer if at end of deflate stream */
-    if (ret == Z_STREAM_END) {
-        if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {
-            gz_error(state, Z_DATA_ERROR, "unexpected end of file");
-            return -1;
-        }
-        if (crc != strm->adler) {
-            gz_error(state, Z_DATA_ERROR, "incorrect data check");
-            return -1;
-        }
-        if (len != (strm->total_out & 0xffffffffL)) {
-            gz_error(state, Z_DATA_ERROR, "incorrect length check");
-            return -1;
-        }
-        state->how = LOOK;      /* ready for next stream, once have is 0 (leave
-                                   state->direct unchanged to remember how) */
-    }
-
-    /* good decompression */
-    return 0;
-}
-
-/* Make data and put in the output buffer.  Assumes that state->have == 0.
-   Data is either copied from the input file or decompressed from the input
-   file depending on state->how.  If state->how is LOOK, then a gzip header is
-   looked for (and skipped if found) to determine wither to copy or decompress.
-   Returns -1 on error, otherwise 0.  gz_make() will leave state->have as COPY
-   or GZIP unless the end of the input file has been reached and all data has
-   been processed.  */
-local int gz_make(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    if (state->how == LOOK) {           /* look for gzip header */
-        if (gz_head(state) == -1)
-            return -1;
-        if (state->have)                /* got some data from gz_head() */
-            return 0;
-    }
-    if (state->how == COPY) {           /* straight copy */
-        if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)
-            return -1;
-        state->next = state->out;
-    }
-    else if (state->how == GZIP) {      /* decompress */
-        strm->avail_out = state->size << 1;
-        strm->next_out = state->out;
-        if (gz_decomp(state) == -1)
-            return -1;
-    }
-    return 0;
-}
-
-/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
-local int gz_skip(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    unsigned n;
-
-    /* skip over len bytes or reach end-of-file, whichever comes first */
-    while (len)
-        /* skip over whatever is in output buffer */
-        if (state->have) {
-            n = GT_OFF(state->have) || (z_off64_t)state->have > len ?
-                (unsigned)len : state->have;
-            state->have -= n;
-            state->next += n;
-            state->pos += n;
-            len -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0)
-            break;
-
-        /* need more data to skip -- load up output buffer */
-        else {
-            /* get more output, looking for header if required */
-            if (gz_make(state) == -1)
-                return -1;
-        }
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzread(file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    unsigned got, n;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ || state->err != Z_OK)
-        return -1;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");
-        return -1;
-    }
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* get len bytes to buf, or less than len if at the end */
-    got = 0;
-    do {
-        /* first just try copying data from the output buffer */
-        if (state->have) {
-            n = state->have > len ? len : state->have;
-            memcpy(buf, state->next, n);
-            state->next += n;
-            state->have -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && strm->avail_in == 0)
-            break;
-
-        /* need output data -- for small len or new stream load up our output
-           buffer */
-        else if (state->how == LOOK || len < (state->size << 1)) {
-            /* get more output, looking for header if required */
-            if (gz_make(state) == -1)
-                return -1;
-            continue;       /* no progress yet -- go back to memcpy() above */
-            /* the copy above assures that we will leave with space in the
-               output buffer, allowing at least one gzungetc() to succeed */
-        }
-
-        /* large len -- read directly into user buffer */
-        else if (state->how == COPY) {      /* read directly */
-            if (gz_load(state, buf, len, &n) == -1)
-                return -1;
-        }
-
-        /* large len -- decompress directly into user buffer */
-        else {  /* state->how == GZIP */
-            strm->avail_out = len;
-            strm->next_out = buf;
-            if (gz_decomp(state) == -1)
-                return -1;
-            n = state->have;
-            state->have = 0;
-        }
-
-        /* update progress */
-        len -= n;
-        buf = (char *)buf + n;
-        got += n;
-        state->pos += n;
-    } while (len);
-
-    /* return number of bytes read into user buffer (will fit in int) */
-    return (int)got;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    int ret;
-    unsigned char buf[1];
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ || state->err != Z_OK)
-        return -1;
-
-    /* try output buffer (no need to check for skip request) */
-    if (state->have) {
-        state->have--;
-        state->pos++;
-        return *(state->next)++;
-    }
-
-    /* nothing there -- try gzread() */
-    ret = gzread(file, buf, 1);
-    return ret < 1 ? -1 : buf[0];
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ || state->err != Z_OK)
-        return -1;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* can't push EOF */
-    if (c < 0)
-        return -1;
-
-    /* if output buffer empty, put byte at end (allows more pushing) */
-    if (state->have == 0) {
-        state->have = 1;
-        state->next = state->out + (state->size << 1) - 1;
-        state->next[0] = c;
-        state->pos--;
-        return c;
-    }
-
-    /* if no room, give up (must have already done a gzungetc()) */
-    if (state->have == (state->size << 1)) {
-        gz_error(state, Z_BUF_ERROR, "out of room to push characters");
-        return -1;
-    }
-
-    /* slide output data if needed and insert byte before existing data */
-    if (state->next == state->out) {
-        unsigned char *src = state->out + state->have;
-        unsigned char *dest = state->out + (state->size << 1);
-        while (src > state->out)
-            *--dest = *--src;
-        state->next = dest;
-    }
-    state->have++;
-    state->next--;
-    state->next[0] = c;
-    state->pos--;
-    return c;
-}
-
-/* -- see zlib.h -- */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    unsigned left, n;
-    char *str;
-    unsigned char *eol;
-    gz_statep state;
-
-    /* check parameters and get internal structure */
-    if (file == NULL || buf == NULL || len < 1)
-        return NULL;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ || state->err != Z_OK)
-        return NULL;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return NULL;
-    }
-
-    /* copy output bytes up to new line or len - 1, whichever comes first --
-       append a terminating zero to the string (we don't check for a zero in
-       the contents, let the user worry about that) */
-    str = buf;
-    left = (unsigned)len - 1;
-    if (left) do {
-        /* assure that something is in the output buffer */
-        if (state->have == 0) {
-            if (gz_make(state) == -1)
-                return NULL;            /* error */
-            if (state->have == 0) {     /* end of file */
-                if (buf == str)         /* got bupkus */
-                    return NULL;
-                break;                  /* got something -- return it */
-            }
-        }
-
-        /* look for end-of-line in current output buffer */
-        n = state->have > left ? left : state->have;
-        eol = memchr(state->next, '\n', n);
-        if (eol != NULL)
-            n = (unsigned)(eol - state->next) + 1;
-
-        /* copy through end-of-line, or remainder if not found */
-        memcpy(buf, state->next, n);
-        state->have -= n;
-        state->next += n;
-        state->pos += n;
-        left -= n;
-        buf += n;
-    } while (left && eol == NULL);
-
-    /* found end-of-line or out of space -- terminate string and return it */
-    buf[0] = 0;
-    return str;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzdirect(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* check that we're reading */
-    if (state->mode != GZ_READ)
-        return 0;
-
-    /* if the state is not known, but we can find out, then do so (this is
-       mainly for right after a gzopen() or gzdopen()) */
-    if (state->how == LOOK && state->have == 0)
-        (void)gz_head(state);
-
-    /* return 1 if reading direct, 0 if decompressing a gzip stream */
-    return state->direct;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_r(file)
-    gzFile file;
-{
-    int ret;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're reading */
-    if (state->mode != GZ_READ)
-        return Z_STREAM_ERROR;
-
-    /* free memory and close file */
-    if (state->size) {
-        inflateEnd(&(state->strm));
-        free(state->out);
-        free(state->in);
-    }
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    ret = close(state->fd);
-    free(state);
-    return ret ? Z_ERRNO : Z_OK;
-}
diff --git a/thirdparty/libz/gzwrite.c b/thirdparty/libz/gzwrite.c
deleted file mode 100644
index e8defc6..0000000
--- a/thirdparty/libz/gzwrite.c
+++ /dev/null
@@ -1,531 +0,0 @@
-/* gzwrite.c -- zlib functions for writing gzip files
- * Copyright (C) 2004, 2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_init OF((gz_statep));
-local int gz_comp OF((gz_statep, int));
-local int gz_zero OF((gz_statep, z_off64_t));
-
-/* Initialize state for writing a gzip file.  Mark initialization by setting
-   state->size to non-zero.  Return -1 on failure or 0 on success. */
-local int gz_init(state)
-    gz_statep state;
-{
-    int ret;
-    z_streamp strm = &(state->strm);
-
-    /* allocate input and output buffers */
-    state->in = malloc(state->want);
-    state->out = malloc(state->want);
-    if (state->in == NULL || state->out == NULL) {
-        if (state->out != NULL)
-            free(state->out);
-        if (state->in != NULL)
-            free(state->in);
-        gz_error(state, Z_MEM_ERROR, "out of memory");
-        return -1;
-    }
-
-    /* allocate deflate memory, set up for gzip compression */
-    strm->zalloc = Z_NULL;
-    strm->zfree = Z_NULL;
-    strm->opaque = Z_NULL;
-    ret = deflateInit2(strm, state->level, Z_DEFLATED,
-                       15 + 16, 8, state->strategy);
-    if (ret != Z_OK) {
-        free(state->in);
-        gz_error(state, Z_MEM_ERROR, "out of memory");
-        return -1;
-    }
-
-    /* mark state as initialized */
-    state->size = state->want;
-
-    /* initialize write buffer */
-    strm->avail_out = state->size;
-    strm->next_out = state->out;
-    state->next = strm->next_out;
-    return 0;
-}
-
-/* Compress whatever is at avail_in and next_in and write to the output file.
-   Return -1 if there is an error writing to the output file, otherwise 0.
-   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
-   then the deflate() state is reset to start a new gzip stream. */
-local int gz_comp(state, flush)
-    gz_statep state;
-    int flush;
-{
-    int ret, got;
-    unsigned have;
-    z_streamp strm = &(state->strm);
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return -1;
-
-    /* run deflate() on provided input until it produces no more output */
-    ret = Z_OK;
-    do {
-        /* write out current buffer contents if full, or if flushing, but if
-           doing Z_FINISH then don't write until we get to Z_STREAM_END */
-        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
-            (flush != Z_FINISH || ret == Z_STREAM_END))) {
-            have = (unsigned)(strm->next_out - state->next);
-            if (have && ((got = write(state->fd, state->next, have)) < 0 ||
-                         (unsigned)got != have)) {
-                gz_error(state, Z_ERRNO, zstrerror());
-                return -1;
-            }
-            if (strm->avail_out == 0) {
-                strm->avail_out = state->size;
-                strm->next_out = state->out;
-            }
-            state->next = strm->next_out;
-        }
-
-        /* compress */
-        have = strm->avail_out;
-        ret = deflate(strm, flush);
-        if (ret == Z_STREAM_ERROR) {
-            gz_error(state, Z_STREAM_ERROR,
-                      "internal error: deflate stream corrupt");
-            return -1;
-        }
-        have -= strm->avail_out;
-    } while (have);
-
-    /* if that completed a deflate stream, allow another to start */
-    if (flush == Z_FINISH)
-        deflateReset(strm);
-
-    /* all done, no errors */
-    return 0;
-}
-
-/* Compress len zeros to output.  Return -1 on error, 0 on success. */
-local int gz_zero(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    int first;
-    unsigned n;
-    z_streamp strm = &(state->strm);
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return -1;
-
-    /* compress len zeros (len guaranteed > 0) */
-    first = 1;
-    while (len) {
-        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
-            (unsigned)len : state->size;
-        if (first) {
-            memset(state->in, 0, n);
-            first = 0;
-        }
-        strm->avail_in = n;
-        strm->next_in = state->in;
-        state->pos += n;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return -1;
-        len -= n;
-    }
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzwrite(file, buf, len)
-    gzFile file;
-    voidpc buf;
-    unsigned len;
-{
-    unsigned put = len;
-    unsigned n;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");
-        return 0;
-    }
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* for small len, copy to input buffer, otherwise compress directly */
-    if (len < state->size) {
-        /* copy to input buffer, compress when full */
-        do {
-            if (strm->avail_in == 0)
-                strm->next_in = state->in;
-            n = state->size - strm->avail_in;
-            if (n > len)
-                n = len;
-            memcpy(strm->next_in + strm->avail_in, buf, n);
-            strm->avail_in += n;
-            state->pos += n;
-            buf = (char *)buf + n;
-            len -= n;
-            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-        } while (len);
-    }
-    else {
-        /* consume whatever's left in the input buffer */
-        if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-
-        /* directly compress user buffer to file */
-        strm->avail_in = len;
-        strm->next_in = (voidp)buf;
-        state->pos += len;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-    }
-
-    /* input was all buffered or compressed (put will fit in int) */
-    return (int)put;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned char buf[1];
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* try writing to input buffer for speed (state->size == 0 if buffer not
-       initialized) */
-    if (strm->avail_in < state->size) {
-        if (strm->avail_in == 0)
-            strm->next_in = state->in;
-        strm->next_in[strm->avail_in++] = c;
-        state->pos++;
-        return c;
-    }
-
-    /* no room in buffer or not initialized, use gz_write() */
-    buf[0] = c;
-    if (gzwrite(file, buf, 1) != 1)
-        return -1;
-    return c;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputs(file, str)
-    gzFile file;
-    const char *str;
-{
-    int ret;
-    unsigned len;
-
-    /* write string */
-    len = (unsigned)strlen(str);
-    ret = gzwrite(file, str, len);
-    return ret == 0 && len != 0 ? -1 : ret;
-}
-
-#ifdef STDC
-#include <stdarg.h>
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)
-{
-    int size, len;
-    gz_statep state;
-    z_streamp strm;
-    va_list va;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return 0;
-
-    /* do the printf() into the input buffer, put length in len */
-    size = (int)(state->size);
-    state->in[size - 1] = 0;
-    va_start(va, format);
-#ifdef NO_vsnprintf
-#  ifdef HAS_vsprintf_void
-    (void)vsprintf(state->in, format, va);
-    va_end(va);
-    for (len = 0; len < size; len++)
-        if (state->in[len] == 0) break;
-#  else
-    len = vsprintf(state->in, format, va);
-    va_end(va);
-#  endif
-#else
-#  ifdef HAS_vsnprintf_void
-    (void)vsnprintf(state->in, size, format, va);
-    va_end(va);
-    len = strlen(state->in);
-#  else
-    len = vsnprintf((char *)(state->in), size, format, va);
-    va_end(va);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, defer compression until needed */
-    strm->avail_in = (unsigned)len;
-    strm->next_in = state->in;
-    state->pos += len;
-    return len;
-}
-
-#else /* !STDC */
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    int size, len;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return 0;
-
-    /* do the printf() into the input buffer, put length in len */
-    size = (int)(state->size);
-    state->in[size - 1] = 0;
-#ifdef NO_snprintf
-#  ifdef HAS_sprintf_void
-    sprintf(state->in, format, a1, a2, a3, a4, a5, a6, a7, a8,
-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    for (len = 0; len < size; len++)
-        if (state->in[len] == 0) break;
-#  else
-    len = sprintf(state->in, format, a1, a2, a3, a4, a5, a6, a7, a8,
-                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#else
-#  ifdef HAS_snprintf_void
-    snprintf(state->in, size, format, a1, a2, a3, a4, a5, a6, a7, a8,
-             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    len = strlen(state->in);
-#  else
-    len = snprintf(state->in, size, format, a1, a2, a3, a4, a5, a6, a7, a8,
-                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, defer compression until needed */
-    strm->avail_in = (unsigned)len;
-    strm->next_in = state->in;
-    state->pos += len;
-    return len;
-}
-
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzflush(file, flush)
-    gzFile file;
-    int flush;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* check flush parameter */
-    if (flush < 0 || flush > Z_FINISH)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* compress remaining data with requested flush */
-    gz_comp(state, flush);
-    return state->err;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzsetparams(file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* if no change is requested, then do nothing */
-    if (level == state->level && strategy == state->strategy)
-        return Z_OK;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* change compression parameters for subsequent input */
-    if (state->size) {
-        /* flush previous input with previous parameters before changing */
-        if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)
-            return state->err;
-        deflateParams(strm, level, strategy);
-    }
-    state->level = level;
-    state->strategy = strategy;
-    return Z_OK;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_w(file)
-    gzFile file;
-{
-    int ret = 0;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're writing */
-    if (state->mode != GZ_WRITE)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        ret += gz_zero(state, state->skip);
-    }
-
-    /* flush, free memory, and close file */
-    ret += gz_comp(state, Z_FINISH);
-    (void)deflateEnd(&(state->strm));
-    free(state->out);
-    free(state->in);
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    ret += close(state->fd);
-    free(state);
-    return ret ? Z_ERRNO : Z_OK;
-}
diff --git a/thirdparty/libz/infback.c b/thirdparty/libz/infback.c
deleted file mode 100644
index af3a8c9..0000000
--- a/thirdparty/libz/infback.c
+++ /dev/null
@@ -1,632 +0,0 @@
-/* infback.c -- inflate using a call-back interface
- * Copyright (C) 1995-2009 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
-   This code is largely copied from inflate.c.  Normally either infback.o or
-   inflate.o would be linked into an application--not both.  The interface
-   with inffast.c is retained so that optimized assembler-coded versions of
-   inflate_fast() can be used with either inflate.c or infback.c.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   windowBits is in the range 8..15, and window is a user-supplied
-   window and output buffer that is 2**windowBits bytes.
- */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_streamp strm;
-int windowBits;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
-        windowBits < 8 || windowBits > 15)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->dmax = 32768U;
-    state->wbits = windowBits;
-    state->wsize = 1U << windowBits;
-    state->window = window;
-    state->wnext = 0;
-    state->whave = 0;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-/* Macros for inflateBack(): */
-
-/* Load returned state from inflate_fast() */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Set state from registers for inflate_fast() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = state->window; \
-            left = state->wsize; \
-            state->whave = left; \
-            if (out(out_desc, put, left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_streamp strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    state->mode = TYPE;
-    state->last = 0;
-    state->whave = 0;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = state->window;
-    left = state->wsize;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (state->mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (state->last) {
-                BYTEBITS();
-                state->mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (state->length != 0) {
-                copy = state->length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    NEEDBITS(here.bits);
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-
-        case LEN:
-            /* use inflate_fast() if we have enough input and output */
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                if (state->whave < state->wsize)
-                    state->whave = state->wsize - left;
-                inflate_fast(strm, state->wsize);
-                LOAD();
-                break;
-            }
-
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            state->length = (unsigned)here.val;
-
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(state->length);
-                left--;
-                state->mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-
-            /* get distance code */
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-
-            /* get distance extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            if (state->offset > state->wsize - (state->whave < state->wsize ?
-                                                left : 0)) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = state->wsize - state->offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - state->offset;
-                    copy = left;
-                }
-                if (copy > state->length) copy = state->length;
-                state->length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (state->length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < state->wsize) {
-                if (out(out_desc, state->window, state->wsize - left))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBackEnd(strm)
-z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff --git a/thirdparty/libz/inffast.c b/thirdparty/libz/inffast.c
deleted file mode 100644
index 2f1d60b..0000000
--- a/thirdparty/libz/inffast.c
+++ /dev/null
@@ -1,340 +0,0 @@
-/* inffast.c -- fast decoding
- * Copyright (C) 1995-2008, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifndef ASMINF
-
-/* Allow machine dependent optimization for post-increment or pre-increment.
-   Based on testing to date,
-   Pre-increment preferred for:
-   - PowerPC G3 (Adler)
-   - MIPS R5000 (Randers-Pehrson)
-   Post-increment preferred for:
-   - none
-   No measurable difference:
-   - Pentium III (Anderson)
-   - M68060 (Nikl)
- */
-#ifdef POSTINC
-#  define OFF 0
-#  define PUP(a) *(a)++
-#else
-#  define OFF 1
-#  define PUP(a) *++(a)
-#endif
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void ZLIB_INTERNAL inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *in;      /* local strm->next_in */
-    unsigned char FAR *last;    /* while in < last, enough input available */
-    unsigned char FAR *out;     /* local strm->next_out */
-    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
-    unsigned char FAR *end;     /* while out < end, enough space available */
-#ifdef INFLATE_STRICT
-    unsigned dmax;              /* maximum distance from zlib header */
-#endif
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
-    unsigned bits;              /* local strm->bits */
-    code const FAR *lcode;      /* local strm->lencode */
-    code const FAR *dcode;      /* local strm->distcode */
-    unsigned lmask;             /* mask for first level of length codes */
-    unsigned dmask;             /* mask for first level of distance codes */
-    code here;                  /* retrieved table entry */
-    unsigned op;                /* code bits, operation, extra bits, or */
-                                /*  window position, window bytes to copy */
-    unsigned len;               /* match length, unused bytes */
-    unsigned dist;              /* match distance */
-    unsigned char FAR *from;    /* where to copy match from */
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    in = strm->next_in - OFF;
-    last = in + (strm->avail_in - 5);
-    out = strm->next_out - OFF;
-    beg = out - (start - strm->avail_out);
-    end = out + (strm->avail_out - 257);
-#ifdef INFLATE_STRICT
-    dmax = state->dmax;
-#endif
-    wsize = state->wsize;
-    whave = state->whave;
-    wnext = state->wnext;
-    window = state->window;
-    hold = state->hold;
-    bits = state->bits;
-    lcode = state->lencode;
-    dcode = state->distcode;
-    lmask = (1U << state->lenbits) - 1;
-    dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-    do {
-        if (bits < 15) {
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-        }
-        here = lcode[hold & lmask];
-      dolen:
-        op = (unsigned)(here.bits);
-        hold >>= op;
-        bits -= op;
-        op = (unsigned)(here.op);
-        if (op == 0) {                          /* literal */
-            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                    "inflate:         literal '%c'\n" :
-                    "inflate:         literal 0x%02x\n", here.val));
-            PUP(out) = (unsigned char)(here.val);
-        }
-        else if (op & 16) {                     /* length base */
-            len = (unsigned)(here.val);
-            op &= 15;                           /* number of extra bits */
-            if (op) {
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                }
-                len += (unsigned)hold & ((1U << op) - 1);
-                hold >>= op;
-                bits -= op;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", len));
-            if (bits < 15) {
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-            }
-            here = dcode[hold & dmask];
-          dodist:
-            op = (unsigned)(here.bits);
-            hold >>= op;
-            bits -= op;
-            op = (unsigned)(here.op);
-            if (op & 16) {                      /* distance base */
-                dist = (unsigned)(here.val);
-                op &= 15;                       /* number of extra bits */
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                    if (bits < op) {
-                        hold += (unsigned long)(PUP(in)) << bits;
-                        bits += 8;
-                    }
-                }
-                dist += (unsigned)hold & ((1U << op) - 1);
-#ifdef INFLATE_STRICT
-                if (dist > dmax) {
-                    strm->msg = (char *)"invalid distance too far back";
-                    state->mode = BAD;
-                    break;
-                }
-#endif
-                hold >>= op;
-                bits -= op;
-                Tracevv((stderr, "inflate:         distance %u\n", dist));
-                op = (unsigned)(out - beg);     /* max distance in output */
-                if (dist > op) {                /* see if copy from window */
-                    op = dist - op;             /* distance back in window */
-                    if (op > whave) {
-                        if (state->sane) {
-                            strm->msg =
-                                (char *)"invalid distance too far back";
-                            state->mode = BAD;
-                            break;
-                        }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        if (len <= op - whave) {
-                            do {
-                                PUP(out) = 0;
-                            } while (--len);
-                            continue;
-                        }
-                        len -= op - whave;
-                        do {
-                            PUP(out) = 0;
-                        } while (--op > whave);
-                        if (op == 0) {
-                            from = out - dist;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--len);
-                            continue;
-                        }
-#endif
-                    }
-                    from = window - OFF;
-                    if (wnext == 0) {           /* very common case */
-                        from += wsize - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    else if (wnext < op) {      /* wrap around window */
-                        from += wsize + wnext - op;
-                        op -= wnext;
-                        if (op < len) {         /* some from end of window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = window - OFF;
-                            if (wnext < len) {  /* some from start of window */
-                                op = wnext;
-                                len -= op;
-                                do {
-                                    PUP(out) = PUP(from);
-                                } while (--op);
-                                from = out - dist;      /* rest from output */
-                            }
-                        }
-                    }
-                    else {                      /* contiguous in window */
-                        from += wnext - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    while (len > 2) {
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    }
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-                else {
-                    from = out - dist;          /* copy direct from output */
-                    do {                        /* minimum length is three */
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    } while (len > 2);
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-            }
-            else if ((op & 64) == 0) {          /* 2nd level distance code */
-                here = dcode[here.val + (hold & ((1U << op) - 1))];
-                goto dodist;
-            }
-            else {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-        }
-        else if ((op & 64) == 0) {              /* 2nd level length code */
-            here = lcode[here.val + (hold & ((1U << op) - 1))];
-            goto dolen;
-        }
-        else if (op & 32) {                     /* end-of-block */
-            Tracevv((stderr, "inflate:         end of block\n"));
-            state->mode = TYPE;
-            break;
-        }
-        else {
-            strm->msg = (char *)"invalid literal/length code";
-            state->mode = BAD;
-            break;
-        }
-    } while (in < last && out < end);
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    len = bits >> 3;
-    in -= len;
-    bits -= len << 3;
-    hold &= (1U << bits) - 1;
-
-    /* update state and return */
-    strm->next_in = in + OFF;
-    strm->next_out = out + OFF;
-    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
-    strm->avail_out = (unsigned)(out < end ?
-                                 257 + (end - out) : 257 - (out - end));
-    state->hold = hold;
-    state->bits = bits;
-    return;
-}
-
-/*
-   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
-   - Using bit fields for code structure
-   - Different op definition to avoid & for extra bits (do & for table bits)
-   - Three separate decoding do-loops for direct, window, and wnext == 0
-   - Special case for distance > 1 copies to do overlapped load and store copy
-   - Explicit branch predictions (based on measured branch probabilities)
-   - Deferring match copy and interspersed it with decoding subsequent codes
-   - Swapping literal/length else
-   - Swapping window/direct else
-   - Larger unrolled copy loops (three is about right)
-   - Moving len -= 3 statement into middle of loop
- */
-
-#endif /* !ASMINF */
diff --git a/thirdparty/libz/inffast.h b/thirdparty/libz/inffast.h
deleted file mode 100644
index e5c1aa4..0000000
--- a/thirdparty/libz/inffast.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));
diff --git a/thirdparty/libz/inffixed.h b/thirdparty/libz/inffixed.h
deleted file mode 100644
index 75ed4b5..0000000
--- a/thirdparty/libz/inffixed.h
+++ /dev/null
@@ -1,94 +0,0 @@
-    /* inffixed.h -- table for decoding fixed codes
-     * Generated automatically by makefixed().
-     */
-
-    /* WARNING: this file should *not* be used by applications. It
-       is part of the implementation of the compression library and
-       is subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
-        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
-        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
-        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
-        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
-        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
-        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
-        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
-        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
-        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
-        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
-        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
-        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
-        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
-        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
-        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
-        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
-        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
-        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
-        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
-        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
-        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
-        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
-        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
-        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
-        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
-        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
-        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
-        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
-        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
-        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
-        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
-        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
-        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
-        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
-        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
-        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
-        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
-        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
-        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
-        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
-        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
-        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
-        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
-        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
-        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
-        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
-        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
-        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
-        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
-        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
-        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
-        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
-        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
-        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
-        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
-        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
-        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
-        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
-        {0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
-        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
-        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
-        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
-        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
-        {22,5,193},{64,5,0}
-    };
diff --git a/thirdparty/libz/inflate.c b/thirdparty/libz/inflate.c
deleted file mode 100644
index a8431ab..0000000
--- a/thirdparty/libz/inflate.c
+++ /dev/null
@@ -1,1480 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common wnext == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, unsigned out));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
-                              unsigned len));
-
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    strm->adler = 1;        /* to support ill-conceived Java test suite */
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->wsize = 0;
-    state->whave = 0;
-    state->wnext = 0;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    state->sane = 1;
-    state->back = -1;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateReset2(strm, windowBits)
-z_streamp strm;
-int windowBits;
-{
-    int wrap;
-    struct inflate_state FAR *state;
-
-    /* get the state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* extract wrap request from windowBits parameter */
-    if (windowBits < 0) {
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        wrap = (windowBits >> 4) + 1;
-#ifdef GUNZIP
-        if (windowBits < 48)
-            windowBits &= 15;
-#endif
-    }
-
-    /* set number of window bits, free window if different */
-    if (windowBits && (windowBits < 8 || windowBits > 15))
-        return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
-    }
-
-    /* update state and reset the rest of it */
-    state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
-}
-
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    int ret;
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->window = Z_NULL;
-    ret = inflateReset2(strm, windowBits);
-    if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-    }
-    return ret;
-}
-
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits < 0) {
-        state->hold = 0;
-        state->bits = 0;
-        return Z_OK;
-    }
-    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += value << state->bits;
-    state->bits += bits;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-
-    void makefixed(void);
-
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.lencode[low].op, state.lencode[low].bits,
-               state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, out)
-z_streamp strm;
-unsigned out;
-{
-    struct inflate_state FAR *state;
-    unsigned copy, dist;
-
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->wnext = 0;
-        state->whave = 0;
-    }
-
-    /* copy state->wsize or less output bytes into the circular window */
-    copy = out - strm->avail_out;
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
-        state->wnext = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->wnext;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, strm->next_out - copy, copy);
-            state->wnext = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->wnext += dist;
-            if (state->wnext == state->wsize) state->wnext = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-
-/* Macros for inflate(): */
-
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE(check, buf, len) adler32(check, buf, len)
-#endif
-
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Reverse the bytes in a 32-bit value */
-#define REVERSE(q) \
-    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            state->flags = 0;           /* expect zlib header */
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (state->wbits == 0)
-                state->wbits = len;
-            else if (len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            state->dmax = 1U << len;
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if (state->flags & 0x0200) CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if (state->flags & 0x0200) CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if (state->flags & 0x0200)
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if (hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = REVERSE(hold);
-            INITBITS();
-            state->mode = DICT;
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-        case TYPE:
-            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN_;             /* decode codes */
-                if (flush == Z_TREES) {
-                    DROPBITS(2);
-                    goto inf_leave;
-                }
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY_;
-            if (flush == Z_TREES) goto inf_leave;
-        case COPY_:
-            state->mode = COPY;
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    NEEDBITS(here.bits);
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN_;
-            if (flush == Z_TREES) goto inf_leave;
-        case LEN_:
-            state->mode = LEN;
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            state->length = (unsigned)here.val;
-            if ((int)(here.op) == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                state->mode = LIT;
-                break;
-            }
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->back = -1;
-                state->mode = TYPE;
-                break;
-            }
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = LENEXT;
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->was = state->length;
-            state->mode = DIST;
-        case DIST:
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = DISTEXT;
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-        case MATCH:
-            if (left == 0) goto inf_leave;
-            copy = out - left;
-            if (state->offset > copy) {         /* copy from window */
-                copy = state->offset - copy;
-                if (copy > state->whave) {
-                    if (state->sane) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                    Trace((stderr, "inflate.c too far\n"));
-                    copy -= state->whave;
-                    if (copy > state->length) copy = state->length;
-                    if (copy > left) copy = left;
-                    left -= copy;
-                    state->length -= copy;
-                    do {
-                        *put++ = 0;
-                    } while (--copy);
-                    if (state->length == 0) state->mode = LEN;
-                    break;
-#endif
-                }
-                if (copy > state->wnext) {
-                    copy -= state->wnext;
-                    from = state->window + (state->wsize - copy);
-                }
-                else
-                    from = state->window + (state->wnext - copy);
-                if (copy > state->length) copy = state->length;
-            }
-            else {                              /* copy from output */
-                from = put - state->offset;
-                copy = state->length;
-            }
-            if (copy > left) copy = left;
-            left -= copy;
-            state->length -= copy;
-            do {
-                *put++ = *from++;
-            } while (--copy);
-            if (state->length == 0) state->mode = LEN;
-            break;
-        case LIT:
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            left--;
-            state->mode = LEN;
-            break;
-        case CHECK:
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                if (out)
-                    strm->adler = state->check =
-                        UPDATE(state->check, put - out, out);
-                out = left;
-                if ((
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     REVERSE(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if (hold != (state->total & 0xffffffffUL)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-        default:
-            return Z_STREAM_ERROR;
-        }
-
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
-        if (updatewindow(strm, out)) {
-            state->mode = MEM;
-            return Z_MEM_ERROR;
-        }
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    if (state->wrap && out)
-        strm->adler = state->check =
-            UPDATE(state->check, strm->next_out - out, out);
-    strm->data_type = state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0) +
-                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long id;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-
-    /* check for correct dictionary id */
-    if (state->mode == DICT) {
-        id = adler32(0L, Z_NULL, 0);
-        id = adler32(id, dictionary, dictLength);
-        if (id != state->check)
-            return Z_DATA_ERROR;
-    }
-
-    /* copy dictionary to window */
-    if (updatewindow(strm, strm->avail_out)) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
-    }
-    if (dictLength > state->wsize) {
-        zmemcpy(state->window, dictionary + dictLength - state->wsize,
-                state->wsize);
-        state->whave = state->wsize;
-    }
-    else {
-        zmemcpy(state->window + state->wsize - dictLength, dictionary,
-                dictLength);
-        state->whave = dictLength;
-    }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-
-    /* check parameters */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->mode = TYPE;
-    return Z_OK;
-}
-
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize;
-
-    /* check input */
-    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
-        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        window = (unsigned char FAR *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-
-    /* copy state */
-    zmemcpy(dest, source, sizeof(z_stream));
-    zmemcpy(copy, state, sizeof(struct inflate_state));
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        wsize = 1U << state->wbits;
-        zmemcpy(window, state->window, wsize);
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
-
-int ZEXPORT inflateUndermine(strm, subvert)
-z_streamp strm;
-int subvert;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->sane = !subvert;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    return Z_OK;
-#else
-    state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
-}
-
-long ZEXPORT inflateMark(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
-    state = (struct inflate_state FAR *)strm->state;
-    return ((long)(state->back) << 16) +
-        (state->mode == COPY ? state->length :
-            (state->mode == MATCH ? state->was - state->length : 0));
-}
diff --git a/thirdparty/libz/inflate.h b/thirdparty/libz/inflate.h
deleted file mode 100644
index 95f4986..0000000
--- a/thirdparty/libz/inflate.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2009 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD,       /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY_,      /* i/o: same as COPY below, but only first time in */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN_,       /* i: same as LEN below, but only first time in */
-            LEN,        /* i: waiting for length/lit/eob code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to BAD or MEM on error -- not shown for clarity)
-
-    Process header:
-        HEAD -> (gzip) or (zlib) or (raw)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
-                  HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-        (raw) -> TYPEDO
-    Read deflate blocks:
-            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
-            STORED -> COPY_ -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN_
-            LEN_ -> LEN
-    Read deflate codes in fixed or dynamic block:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-
-/* state maintained between inflate() calls.  Approximately 10K bytes. */
-struct inflate_state {
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-    int sane;                   /* if false, allow invalid distance too far */
-    int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
-};
diff --git a/thirdparty/libz/inftrees.c b/thirdparty/libz/inftrees.c
deleted file mode 100644
index 11e9c52..0000000
--- a/thirdparty/libz/inftrees.c
+++ /dev/null
@@ -1,330 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-
-#define MAXBITS 15
-
-const char inflate_copyright[] =
-   " inflate 1.2.5 Copyright 1995-2010 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code here;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        here.op = (unsigned char)64;    /* invalid code marker */
-        here.bits = (unsigned char)1;
-        here.val = (unsigned short)0;
-        *(*table)++ = here;             /* make a table to force an error */
-        *(*table)++ = here;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min < max; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftrees.h
-       for more information.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if ((type == LENS && used >= ENOUGH_LENS) ||
-        (type == DISTS && used >= ENOUGH_DISTS))
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        here.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            here.op = (unsigned char)0;
-            here.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            here.op = (unsigned char)(extra[work[sym]]);
-            here.val = base[work[sym]];
-        }
-        else {
-            here.op = (unsigned char)(32 + 64);         /* end of block */
-            here.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = here;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used >= ENOUGH_LENS) ||
-                (type == DISTS && used >= ENOUGH_DISTS))
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    here.op = (unsigned char)64;                /* invalid code marker */
-    here.bits = (unsigned char)(len - drop);
-    here.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            here.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = here;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff --git a/thirdparty/libz/inftrees.h b/thirdparty/libz/inftrees.h
deleted file mode 100644
index baa53a0..0000000
--- a/thirdparty/libz/inftrees.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff --git a/thirdparty/libz/minigzip.c b/thirdparty/libz/minigzip.c
deleted file mode 100644
index 9825ccc..0000000
--- a/thirdparty/libz/minigzip.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/* minigzip.c -- simulate gzip using the zlib compression library
- * Copyright (C) 1995-2006, 2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * minigzip is a minimal implementation of the gzip utility. This is
- * only an example of using zlib and isn't meant to replace the
- * full-featured gzip. No attempt is made to deal with file systems
- * limiting names to 14 or 8+3 characters, etc... Error checking is
- * very limited. So use minigzip only for testing; use gzip for the
- * real thing. On MSDOS, use only on file names without extension
- * or in pipe mode.
- */
-
-/* @(#) $Id$ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
-#endif
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  ifdef UNDER_CE
-#    include <stdlib.h>
-#  endif
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
-#endif
-#ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
-#endif
-#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
-#endif
-
-#if !defined(Z_HAVE_UNISTD_H) && !defined(_LARGEFILE64_SOURCE)
-#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
-#endif
-#endif
-
-#if defined(UNDER_CE)
-#  include <windows.h>
-#  define perror(s) pwinerror(s)
-
-/* Map the Windows error number in ERROR to a locale-dependent error
-   message string and return a pointer to it.  Typically, the values
-   for ERROR come from GetLastError.
-
-   The string pointed to shall not be modified by the application,
-   but may be overwritten by a subsequent call to strwinerror
-
-   The strwinerror function does not change the current setting
-   of GetLastError.  */
-
-static char *strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-static void pwinerror (s)
-    const char *s;
-{
-    if (s && *s)
-        fprintf(stderr, "%s: %s\n", s, strwinerror(GetLastError ()));
-    else
-        fprintf(stderr, "%s\n", strwinerror(GetLastError ()));
-}
-
-#endif /* UNDER_CE */
-
-#ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
-#endif
-#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
-
-#define BUFLEN      16384
-#define MAX_NAME_LEN 1024
-
-#ifdef MAXSEG_64K
-#  define local static
-   /* Needed for systems with limitation on stack size. */
-#else
-#  define local
-#endif
-
-char *prog;
-
-void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
-#ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
-#endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
-void file_compress    OF((char  *file, char *mode));
-void file_uncompress  OF((char  *file));
-int  main             OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Display error message and exit
- */
-void error(msg)
-    const char *msg;
-{
-    fprintf(stderr, "%s: %s\n", prog, msg);
-    exit(1);
-}
-
-/* ===========================================================================
- * Compress input to output then close both files.
- */
-
-void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-#ifdef USE_MMAP
-    /* Try first compressing with mmap. If mmap fails (minigzip used in a
-     * pipe), use the normal fread loop.
-     */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
-#endif
-    for (;;) {
-        len = (int)fread(buf, 1, sizeof(buf), in);
-        if (ferror(in)) {
-            perror("fread");
-            exit(1);
-        }
-        if (len == 0) break;
-
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
-    }
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-}
-
-#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
-
-/* Try compressing the input file at once using mmap. Return Z_OK if
- * if success, Z_ERRNO otherwise.
- */
-int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    int len;
-    int err;
-    int ifd = fileno(in);
-    caddr_t buf;    /* mmap'ed buffer for the entire input file */
-    off_t buf_len;  /* length of the input file */
-    struct stat sb;
-
-    /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
-    buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
-
-    /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
-
-    /* Compress the whole file at once: */
-    len = gzwrite(out, (char *)buf, (unsigned)buf_len);
-
-    if (len != (int)buf_len) error(gzerror(out, &err));
-
-    munmap(buf, buf_len);
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-    return Z_OK;
-}
-#endif /* USE_MMAP */
-
-/* ===========================================================================
- * Uncompress input to output then close both files.
- */
-void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-    for (;;) {
-        len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
-
-        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
-            error("failed fwrite");
-        }
-    }
-    if (fclose(out)) error("failed fclose");
-
-    if (gzclose(in) != Z_OK) error("failed gzclose");
-}
-
-
-/* ===========================================================================
- * Compress the given file: create a corresponding .gz file and remove the
- * original.
- */
-void file_compress(file, mode)
-    char  *file;
-    char  *mode;
-{
-    local char outfile[MAX_NAME_LEN];
-    FILE  *in;
-    gzFile out;
-
-    if (strlen(file) + strlen(GZ_SUFFIX) >= sizeof(outfile)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(outfile, file);
-    strcat(outfile, GZ_SUFFIX);
-
-    in = fopen(file, "rb");
-    if (in == NULL) {
-        perror(file);
-        exit(1);
-    }
-    out = gzopen(outfile, mode);
-    if (out == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
-        exit(1);
-    }
-    gz_compress(in, out);
-
-    unlink(file);
-}
-
-
-/* ===========================================================================
- * Uncompress the given file and remove the original.
- */
-void file_uncompress(file)
-    char  *file;
-{
-    local char buf[MAX_NAME_LEN];
-    char *infile, *outfile;
-    FILE  *out;
-    gzFile in;
-    size_t len = strlen(file);
-
-    if (len + strlen(GZ_SUFFIX) >= sizeof(buf)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(buf, file);
-
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
-        infile = file;
-        outfile = buf;
-        outfile[len-3] = '\0';
-    } else {
-        outfile = file;
-        infile = buf;
-        strcat(infile, GZ_SUFFIX);
-    }
-    in = gzopen(infile, "rb");
-    if (in == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
-        exit(1);
-    }
-    out = fopen(outfile, "wb");
-    if (out == NULL) {
-        perror(file);
-        exit(1);
-    }
-
-    gz_uncompress(in, out);
-
-    unlink(infile);
-}
-
-
-/* ===========================================================================
- * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]
- *   -c : write to standard output
- *   -d : decompress
- *   -f : compress with Z_FILTERED
- *   -h : compress with Z_HUFFMAN_ONLY
- *   -r : compress with Z_RLE
- *   -1 to -9 : compression level
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    int copyout = 0;
-    int uncompr = 0;
-    gzFile file;
-    char *bname, outmode[20];
-
-    strcpy(outmode, "wb6 ");
-
-    prog = argv[0];
-    bname = strrchr(argv[0], '/');
-    if (bname)
-      bname++;
-    else
-      bname = argv[0];
-    argc--, argv++;
-
-    if (!strcmp(bname, "gunzip"))
-      uncompr = 1;
-    else if (!strcmp(bname, "zcat"))
-      copyout = uncompr = 1;
-
-    while (argc > 0) {
-      if (strcmp(*argv, "-c") == 0)
-        copyout = 1;
-      else if (strcmp(*argv, "-d") == 0)
-        uncompr = 1;
-      else if (strcmp(*argv, "-f") == 0)
-        outmode[3] = 'f';
-      else if (strcmp(*argv, "-h") == 0)
-        outmode[3] = 'h';
-      else if (strcmp(*argv, "-r") == 0)
-        outmode[3] = 'R';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-               (*argv)[2] == 0)
-        outmode[2] = (*argv)[1];
-      else
-        break;
-      argc--, argv++;
-    }
-    if (outmode[3] == ' ')
-        outmode[3] = 0;
-    if (argc == 0) {
-        SET_BINARY_MODE(stdin);
-        SET_BINARY_MODE(stdout);
-        if (uncompr) {
-            file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
-            gz_uncompress(file, stdout);
-        } else {
-            file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
-            gz_compress(stdin, file);
-        }
-    } else {
-        if (copyout) {
-            SET_BINARY_MODE(stdout);
-        }
-        do {
-            if (uncompr) {
-                if (copyout) {
-                    file = gzopen(*argv, "rb");
-                    if (file == NULL)
-                        fprintf(stderr, "%s: can't gzopen %s\n", prog, *argv);
-                    else
-                        gz_uncompress(file, stdout);
-                } else {
-                    file_uncompress(*argv);
-                }
-            } else {
-                if (copyout) {
-                    FILE * in = fopen(*argv, "rb");
-
-                    if (in == NULL) {
-                        perror(*argv);
-                    } else {
-                        file = gzdopen(fileno(stdout), outmode);
-                        if (file == NULL) error("can't gzdopen stdout");
-
-                        gz_compress(in, file);
-                    }
-
-                } else {
-                    file_compress(*argv, outmode);
-                }
-            }
-        } while (argv++, --argc);
-    }
-    return 0;
-}
diff --git a/thirdparty/libz/trees.c b/thirdparty/libz/trees.c
deleted file mode 100644
index 56e9bb1..0000000
--- a/thirdparty/libz/trees.c
+++ /dev/null
@@ -1,1244 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2010 Jean-loup Gailly
- * detect_data_type() function provided freely by Cosmin Truta, 2006
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* @(#) $Id$ */
-
-/* #define GEN_TREES_H */
-
-#include "deflate.h"
-
-#ifdef DEBUG
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-#define Buf_size (8 * 2*sizeof(char))
-/* Number of bits used within bi_buf. (bi_buf might be implemented on
- * more than 16 bits on some systems.)
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local int  detect_data_type OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
-                              int header));
-
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-
-#ifndef DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !DEBUG */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* DEBUG */
-
-
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void ZLIB_INTERNAL _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-#ifdef DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Trace((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
-#ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-#endif
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
-}
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- * The current inflate code requires 9 bits of lookahead. If the
- * last two codes for the previous block (real code plus EOB) were coded
- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
- * the last real code. In this case we send two empty static blocks instead
- * of one. (There are no problems if the previous block is stored or fixed.)
- * To simplify the code, we assume the worst case of last real code encoded
- * on one bit only.
- */
-void ZLIB_INTERNAL _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-    /* Of the 10 bits for the empty block, we have already sent
-     * (10 - bi_valid) bits. The lookahead for the last real code (before
-     * the EOB of the previous block) was thus at least one plus the length
-     * of the EOB plus what we have just sent of the empty static block.
-     */
-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
-        send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-        s->compressed_len += 10L;
-#endif
-        bi_flush(s);
-    }
-    s->last_eob_len = 7;
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and output the encoded block to the zip file.
- */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-        /* Check if the file is binary or text */
-        if (s->strm->data_type == Z_UNKNOWN)
-            s->strm->data_type = detect_data_type(s);
-
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len+3+7)>>3;
-        static_lenb = (s->static_len+3+7)>>3;
-
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->last_lit));
-
-        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, last);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+last, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1)+last, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-
-    if (last) {
-        bi_windup(s);
-#ifdef DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*last));
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int ZLIB_INTERNAL _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-#ifdef TRUNCATE_BLOCK
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-#endif
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
-               "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-    s->last_eob_len = ltree[END_BLOCK].Len;
-}
-
-/* ===========================================================================
- * Check if the data type is TEXT or BINARY, using the following algorithm:
- * - TEXT if the two conditions below are satisfied:
- *    a) There are no non-portable control characters belonging to the
- *       "black list" (0..6, 14..25, 28..31).
- *    b) There is at least one printable character belonging to the
- *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
- * - BINARY otherwise.
- * - The following partially-portable control characters form a
- *   "gray list" that is ignored in this detection algorithm:
- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local int detect_data_type(s)
-    deflate_state *s;
-{
-    /* black_mask is the bit mask of black-listed bytes
-     * set bits 0..6, 14..25, and 28..31
-     * 0xf3ffc07f = binary 11110011111111111100000001111111
-     */
-    unsigned long black_mask = 0xf3ffc07fUL;
-    int n;
-
-    /* Check for non-textual ("black-listed") bytes. */
-    for (n = 0; n <= 31; n++, black_mask >>= 1)
-        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
-            return Z_BINARY;
-
-    /* Check for textual ("white-listed") bytes. */
-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
-            || s->dyn_ltree[13].Freq != 0)
-        return Z_TEXT;
-    for (n = 32; n < LITERALS; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            return Z_TEXT;
-
-    /* There are no "black-listed" or "white-listed" bytes:
-     * this stream either is empty or has tolerated ("gray-listed") bytes only.
-     */
-    return Z_BINARY;
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
-
-/* ===========================================================================
- * Copy a stored block, storing first the length and its
- * one's complement if requested.
- */
-local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
-{
-    bi_windup(s);        /* align on byte boundary */
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-
-    if (header) {
-        put_short(s, (ush)len);
-        put_short(s, (ush)~len);
-#ifdef DEBUG
-        s->bits_sent += 2*16;
-#endif
-    }
-#ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
-#endif
-    while (len--) {
-        put_byte(s, *buf++);
-    }
-}
diff --git a/thirdparty/libz/trees.h b/thirdparty/libz/trees.h
deleted file mode 100644
index d35639d..0000000
--- a/thirdparty/libz/trees.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
-
diff --git a/thirdparty/libz/uncompr.c b/thirdparty/libz/uncompr.c
deleted file mode 100644
index ad98be3..0000000
--- a/thirdparty/libz/uncompr.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/* uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-2003, 2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-
-    err = inflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        inflateEnd(&stream);
-        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
-            return Z_DATA_ERROR;
-        return err;
-    }
-    *destLen = stream.total_out;
-
-    err = inflateEnd(&stream);
-    return err;
-}
diff --git a/thirdparty/libz/zlib.h b/thirdparty/libz/zlib.h
deleted file mode 100644
index bfbba83..0000000
--- a/thirdparty/libz/zlib.h
+++ /dev/null
@@ -1,1613 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.5, April 19th, 2010
-
-  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.5"
-#define ZLIB_VERNUM 0x1250
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 5
-#define ZLIB_VER_SUBREVISION 0
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip streams in memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use in the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field (though see inflate()) */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).  Some
-    output may be provided even if flush is not set.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed code
-  block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error.  After
-  deflate has returned Z_STREAM_END, the only possible operations on the stream
-  are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step.  In this case, avail_out must be at least the
-  value returned by deflateBound (see below).  If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
-  binary.  This field is only for information purposes and does not affect the
-  compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
-  fatal, and deflate() can be called again with more input and more output
-  space to continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
-   exact value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit() does not process any header information -- that is deferred
-   until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing will
-    resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all the uncompressed data.  (The size
-  of the uncompressed data may have been saved by the compressor for this
-  purpose.) The next operation on this stream must be inflateEnd to deallocate
-  the decompression state.  The use of Z_FINISH is never required, but can be
-  used to inform inflate that a faster approach may be used for the single
-  inflate() call.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the only effect of the flush parameter in this implementation
-  is on the return value of inflate(), as noted below, or when it returns early
-  because Z_BLOCK or Z_TREES is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the adler32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed adler32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained, so applications that need that information should
-  instead use raw inflate, see inflateInit2() below, or inflateBack() and
-  perform their own processing of the gzip header and trailer.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
-  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is desired.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent.  In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute an adler32 check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to 255 (unknown).  If a
-   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any call
-   of deflate.  The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   adler32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort).  deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.  The
-   stream will keep the same compression level and any other attributes that
-   may have been set by deflateInit2.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression level is changed, the input available so far is
-   compressed with the old level (and may be flushed); the new level will take
-   effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to be
-   compressed and flushed.  In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
-   strm->avail_out was zero.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().
-*/
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an adler32 or a crc32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   crc32 instead of an adler32.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called
-   immediately after inflateInit2() or inflateReset() and before any call of
-   inflate() to set the dictionary.  The application must insure that the
-   dictionary that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a full flush point (see above the
-   description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-   if no more input was provided, Z_DATA_ERROR if no flush point has been
-   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the
-   success case, the application may save the current current value of total_in
-   which indicates where valid compressed data was found.  In the error case,
-   the application may repeatedly call inflateSync, providing more input each
-   time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above or -1 << 16 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the normal
-   behavior of inflate(), which expects either a zlib or gzip header and
-   trailer around the deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero--buf is ignored in that
-   case--and inflateBack() will return a buffer error.  inflateBack() will call
-   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
-   should return zero on success, or non-zero on failure.  If out() returns
-   non-zero, inflateBack() will return with an error.  Neither in() nor out()
-   are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.) Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
-*/
-
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef voidp gzFile;       /* opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.) Also "a"
-   can be used instead of "w" to request that the gzip stream that will be
-   written be appended to the file.  "+" will result in an error, since reading
-   and writing to the same gzip file is not supported.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Two buffers are allocated, either both of the specified size when
-   writing, or one of the specified size and the other twice that size when
-   reading.  A larger buffer size of, for example, 64K or 128K bytes will
-   noticeably increase the speed of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.
-
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file was not in gzip format, gzread copies the given number of
-   bytes into the buffer.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream, or failing that, reading the rest
-   of the input file directly without decompression.  The entire input file
-   will be read if gzread is called until it returns less than the requested
-   len.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or 0 in case of error.  The number of
-   uncompressed bytes written is limited to 8191, or one less than the buffer
-   size given to gzbuffer().  The caller should assure that this limit is not
-   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
-   nothing written.  In this case, there may also be a buffer overflow with
-   unpredictable consequences, which is possible only if zlib was compiled with
-   the insecure functions sprintf() or vsprintf() because the secure snprintf()
-   or vsnprintf() functions were not available.  This can be determined using
-   zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatented gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.  This state can change from
-   false to true while reading the input file if the end of a gzip stream is
-   reached, but is followed by data that is not another gzip stream.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the for the crc.  Pre- and post-conditioning (one's
-   complement) is performed within this function so it shouldn't be done by the
-   application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-#define inflateBackInit(strm, windowBits, window) \
-        inflateBackInit_((strm), (windowBits), (window), \
-                                            ZLIB_VERSION, sizeof(z_stream))
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && _FILE_OFFSET_BITS-0 == 64 && _LFS64_LARGEFILE-0
-#  define gzopen gzopen64
-#  define gzseek gzseek64
-#  define gztell gztell64
-#  define gzoffset gzoffset64
-#  define adler32_combine adler32_combine64
-#  define crc32_combine crc32_combine64
-#  ifdef _LARGEFILE64_SOURCE
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-/* hack for buggy compilers */
-#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;};
-#endif
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
diff --git a/thirdparty/libz/zutil.c b/thirdparty/libz/zutil.c
deleted file mode 100644
index 898ed34..0000000
--- a/thirdparty/libz/zutil.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2005, 2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zutil.h"
-
-#ifndef NO_DUMMY_DECL
-struct internal_state      {int dummy;}; /* for buggy compilers */
-#endif
-
-const char * const z_errmsg[10] = {
-"need dictionary",     /* Z_NEED_DICT       2  */
-"stream end",          /* Z_STREAM_END      1  */
-"",                    /* Z_OK              0  */
-"file error",          /* Z_ERRNO         (-1) */
-"stream error",        /* Z_STREAM_ERROR  (-2) */
-"data error",          /* Z_DATA_ERROR    (-3) */
-"insufficient memory", /* Z_MEM_ERROR     (-4) */
-"buffer error",        /* Z_BUF_ERROR     (-5) */
-"incompatible version",/* Z_VERSION_ERROR (-6) */
-""};
-
-
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-
-    flags = 0;
-    switch ((int)(sizeof(uInt))) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch ((int)(sizeof(uLong))) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch ((int)(sizeof(voidpf))) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch ((int)(sizeof(z_off_t))) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef DEBUG
-    flags += 1 << 8;
-#endif
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#ifdef STDC
-#  ifdef NO_vsnprintf
-        flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-        flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-        flags += 1L << 26;
-#    endif
-#  endif
-#else
-        flags += 1L << 24;
-#  ifdef NO_snprintf
-        flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-        flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-        flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-
-#ifdef DEBUG
-
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int ZLIB_INTERNAL z_verbose = verbose;
-
-void ZLIB_INTERNAL z_error (m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-
-#if defined(_WIN32_WCE)
-    /* The Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-
-#ifndef HAVE_MEMCPY
-
-void ZLIB_INTERNAL zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-
-int ZLIB_INTERNAL zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-
-void ZLIB_INTERNAL zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-
-
-#ifdef SYS16BIT
-
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-
-#define MAX_PTR 10
-/* 10*64K = 640K */
-
-local int next_ptr = 0;
-
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf = opaque; /* just to make some compilers happy */
-    ulg bsize = (ulg)items*size;
-
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    int n;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    ptr = opaque; /* just to make some compilers happy */
-    Assert(0, "zcfree: ptr not found");
-}
-
-#endif /* __TURBOC__ */
-
-
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    return _halloc((long)items, size);
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    _hfree(ptr);
-}
-
-#endif /* M_I86 */
-
-#endif /* SYS16BIT */
-
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    if (opaque) items += size - size; /* make compiler happy */
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-
-void ZLIB_INTERNAL zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    free(ptr);
-    if (opaque) return; /* make compiler happy */
-}
-
-#endif /* MY_ZCALLOC */
diff --git a/thirdparty/libz/zutil.h b/thirdparty/libz/zutil.h
deleted file mode 100644
index 258fa88..0000000
--- a/thirdparty/libz/zutil.h
+++ /dev/null
@@ -1,274 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZUTIL_H
-#define ZUTIL_H
-
-#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 >= 33) && !defined(NO_VIZ)
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include "zlib.h"
-
-#ifdef STDC
-#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = (char*)ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  if defined(__TURBOC__) || defined(__BORLANDC__)
-#    if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-       /* Allow compilation with ANSI keywords only enabled */
-       void _Cdecl farfree( void *block );
-       void *_Cdecl farmalloc( unsigned long nbytes );
-#    else
-#      include <alloc.h>
-#    endif
-#  else /* MSC or DJGPP */
-#    include <malloc.h>
-#  endif
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  0x01
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  0x02
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  0x05
-#endif
-
-#ifdef OS2
-#  define OS_CODE  0x06
-#  ifdef M_I86
-#    include <malloc.h>
-#  endif
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  0x07
-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#    include <unix.h> /* for fdopen */
-#  else
-#    ifndef fdopen
-#      define fdopen(fd,mode) NULL /* No fdopen() */
-#    endif
-#  endif
-#endif
-
-#ifdef TOPS20
-#  define OS_CODE  0x0a
-#endif
-
-#ifdef WIN32
-#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
-#    define OS_CODE  0x0b
-#  endif
-#endif
-
-#ifdef __50SERIES /* Prime/PRIMOS */
-#  define OS_CODE  0x0f
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#    ifndef _PTRDIFF_T_DEFINED
-       typedef int ptrdiff_t;
-#      define _PTRDIFF_T_DEFINED
-#    endif
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-
-#if defined(__BORLANDC__)
-  #pragma warn -8004
-  #pragma warn -8008
-  #pragma warn -8066
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#endif
-
-        /* common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  0x03  /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
-        but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
-#         define vsnprintf _vsnprintf
-#      endif
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#endif
-#ifdef VMS
-#  define NO_vsnprintf
-#endif
-
-#if defined(pyr)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef DEBUG
-#  include <stdio.h>
-   extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-
-voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
-                        unsigned size));
-void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-#endif /* ZUTIL_H */
-- 
2.9.3

