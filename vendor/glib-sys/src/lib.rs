// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

mod manual;

pub use manual::*;

#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};
#[allow(unused_imports)]
use libc::{intptr_t, off_t, size_t, ssize_t, time_t, uintptr_t, FILE};
#[allow(unused_imports)]
use std::ffi::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
};

pub type gboolean = c_int;
pub const GFALSE: c_int = 0;
pub const GTRUE: c_int = 1;

pub type gconstpointer = *const c_void;
pub type gpointer = *mut c_void;

// Aliases
pub type GDateDay = u8;
pub type GDateYear = u16;
pub type GMainContextPusher = c_void;
pub type GMutexLocker = c_void;
pub type GQuark = u32;
pub type GRWLockReaderLocker = c_void;
pub type GRWLockWriterLocker = c_void;
pub type GRecMutexLocker = c_void;
pub type GRefString = c_char;
pub type GStrv = *mut *mut c_char;
pub type GTime = i32;
pub type GTimeSpan = i64;

// Enums
pub type GBookmarkFileError = c_int;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;

pub type GChecksumType = c_int;
pub const G_CHECKSUM_MD5: GChecksumType = 0;
pub const G_CHECKSUM_SHA1: GChecksumType = 1;
pub const G_CHECKSUM_SHA256: GChecksumType = 2;
pub const G_CHECKSUM_SHA512: GChecksumType = 3;
pub const G_CHECKSUM_SHA384: GChecksumType = 4;

pub type GConvertError = c_int;
pub const G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;

pub type GDateDMY = c_int;
pub const G_DATE_DAY: GDateDMY = 0;
pub const G_DATE_MONTH: GDateDMY = 1;
pub const G_DATE_YEAR: GDateDMY = 2;

pub type GDateMonth = c_int;
pub const G_DATE_BAD_MONTH: GDateMonth = 0;
pub const G_DATE_JANUARY: GDateMonth = 1;
pub const G_DATE_FEBRUARY: GDateMonth = 2;
pub const G_DATE_MARCH: GDateMonth = 3;
pub const G_DATE_APRIL: GDateMonth = 4;
pub const G_DATE_MAY: GDateMonth = 5;
pub const G_DATE_JUNE: GDateMonth = 6;
pub const G_DATE_JULY: GDateMonth = 7;
pub const G_DATE_AUGUST: GDateMonth = 8;
pub const G_DATE_SEPTEMBER: GDateMonth = 9;
pub const G_DATE_OCTOBER: GDateMonth = 10;
pub const G_DATE_NOVEMBER: GDateMonth = 11;
pub const G_DATE_DECEMBER: GDateMonth = 12;

pub type GDateWeekday = c_int;
pub const G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const G_DATE_MONDAY: GDateWeekday = 1;
pub const G_DATE_TUESDAY: GDateWeekday = 2;
pub const G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const G_DATE_THURSDAY: GDateWeekday = 4;
pub const G_DATE_FRIDAY: GDateWeekday = 5;
pub const G_DATE_SATURDAY: GDateWeekday = 6;
pub const G_DATE_SUNDAY: GDateWeekday = 7;

pub type GErrorType = c_int;
pub const G_ERR_UNKNOWN: GErrorType = 0;
pub const G_ERR_UNEXP_EOF: GErrorType = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const G_ERR_FLOAT_MALFORMED: GErrorType = 7;

pub type GFileError = c_int;
pub const G_FILE_ERROR_EXIST: GFileError = 0;
pub const G_FILE_ERROR_ISDIR: GFileError = 1;
pub const G_FILE_ERROR_ACCES: GFileError = 2;
pub const G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const G_FILE_ERROR_NOENT: GFileError = 4;
pub const G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const G_FILE_ERROR_NXIO: GFileError = 6;
pub const G_FILE_ERROR_NODEV: GFileError = 7;
pub const G_FILE_ERROR_ROFS: GFileError = 8;
pub const G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const G_FILE_ERROR_FAULT: GFileError = 10;
pub const G_FILE_ERROR_LOOP: GFileError = 11;
pub const G_FILE_ERROR_NOSPC: GFileError = 12;
pub const G_FILE_ERROR_NOMEM: GFileError = 13;
pub const G_FILE_ERROR_MFILE: GFileError = 14;
pub const G_FILE_ERROR_NFILE: GFileError = 15;
pub const G_FILE_ERROR_BADF: GFileError = 16;
pub const G_FILE_ERROR_INVAL: GFileError = 17;
pub const G_FILE_ERROR_PIPE: GFileError = 18;
pub const G_FILE_ERROR_AGAIN: GFileError = 19;
pub const G_FILE_ERROR_INTR: GFileError = 20;
pub const G_FILE_ERROR_IO: GFileError = 21;
pub const G_FILE_ERROR_PERM: GFileError = 22;
pub const G_FILE_ERROR_NOSYS: GFileError = 23;
pub const G_FILE_ERROR_FAILED: GFileError = 24;

pub type GIOChannelError = c_int;
pub const G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;

pub type GIOError = c_int;
pub const G_IO_ERROR_NONE: GIOError = 0;
pub const G_IO_ERROR_AGAIN: GIOError = 1;
pub const G_IO_ERROR_INVAL: GIOError = 2;
pub const G_IO_ERROR_UNKNOWN: GIOError = 3;

pub type GIOStatus = c_int;
pub const G_IO_STATUS_ERROR: GIOStatus = 0;
pub const G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const G_IO_STATUS_EOF: GIOStatus = 2;
pub const G_IO_STATUS_AGAIN: GIOStatus = 3;

pub type GKeyFileError = c_int;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;

pub type GLogWriterOutput = c_int;
pub const G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;

pub type GMarkupError = c_int;
pub const G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;

pub type GNormalizeMode = c_int;
pub const G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const G_NORMALIZE_NFKC: GNormalizeMode = 3;

pub type GNumberParserError = c_int;
pub const G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;

pub type GOnceStatus = c_int;
pub const G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const G_ONCE_STATUS_READY: GOnceStatus = 2;

pub type GOptionArg = c_int;
pub const G_OPTION_ARG_NONE: GOptionArg = 0;
pub const G_OPTION_ARG_STRING: GOptionArg = 1;
pub const G_OPTION_ARG_INT: GOptionArg = 2;
pub const G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const G_OPTION_ARG_INT64: GOptionArg = 8;

pub type GOptionError = c_int;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const G_OPTION_ERROR_FAILED: GOptionError = 2;

pub type GRegexError = c_int;
pub const G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;

pub type GSeekType = c_int;
pub const G_SEEK_CUR: GSeekType = 0;
pub const G_SEEK_SET: GSeekType = 1;
pub const G_SEEK_END: GSeekType = 2;

pub type GShellError = c_int;
pub const G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const G_SHELL_ERROR_FAILED: GShellError = 2;

pub type GSliceConfig = c_int;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;

pub type GSpawnError = c_int;
pub const G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const G_SPAWN_ERROR_FAILED: GSpawnError = 19;

pub type GTestFileType = c_int;
pub const G_TEST_DIST: GTestFileType = 0;
pub const G_TEST_BUILT: GTestFileType = 1;

pub type GTestLogType = c_int;
pub const G_TEST_LOG_NONE: GTestLogType = 0;
pub const G_TEST_LOG_ERROR: GTestLogType = 1;
pub const G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const G_TEST_LOG_STOP_SUITE: GTestLogType = 11;

pub type GTestResult = c_int;
pub const G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const G_TEST_RUN_FAILURE: GTestResult = 2;
pub const G_TEST_RUN_INCOMPLETE: GTestResult = 3;

pub type GThreadError = c_int;
pub const G_THREAD_ERROR_AGAIN: GThreadError = 0;

pub type GThreadPriority = c_int;
pub const G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;

pub type GTimeType = c_int;
pub const G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const G_TIME_TYPE_UNIVERSAL: GTimeType = 2;

pub type GTokenType = c_int;
pub const G_TOKEN_EOF: GTokenType = 0;
pub const G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const G_TOKEN_COMMA: GTokenType = 44;
pub const G_TOKEN_NONE: GTokenType = 256;
pub const G_TOKEN_ERROR: GTokenType = 257;
pub const G_TOKEN_CHAR: GTokenType = 258;
pub const G_TOKEN_BINARY: GTokenType = 259;
pub const G_TOKEN_OCTAL: GTokenType = 260;
pub const G_TOKEN_INT: GTokenType = 261;
pub const G_TOKEN_HEX: GTokenType = 262;
pub const G_TOKEN_FLOAT: GTokenType = 263;
pub const G_TOKEN_STRING: GTokenType = 264;
pub const G_TOKEN_SYMBOL: GTokenType = 265;
pub const G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const G_TOKEN_COMMENT_MULTI: GTokenType = 269;

pub type GTraverseType = c_int;
pub const G_IN_ORDER: GTraverseType = 0;
pub const G_PRE_ORDER: GTraverseType = 1;
pub const G_POST_ORDER: GTraverseType = 2;
pub const G_LEVEL_ORDER: GTraverseType = 3;

pub type GUnicodeBreakType = c_int;
pub const G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
pub const G_UNICODE_BREAK_AKSARA: GUnicodeBreakType = 43;
pub const G_UNICODE_BREAK_AKSARA_PRE_BASE: GUnicodeBreakType = 44;
pub const G_UNICODE_BREAK_AKSARA_START: GUnicodeBreakType = 45;
pub const G_UNICODE_BREAK_VIRAMA_FINAL: GUnicodeBreakType = 46;
pub const G_UNICODE_BREAK_VIRAMA: GUnicodeBreakType = 47;

pub type GUnicodeScript = c_int;
pub const G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
pub const G_UNICODE_SCRIPT_TODHRI: GUnicodeScript = 165;
pub const G_UNICODE_SCRIPT_GARAY: GUnicodeScript = 166;
pub const G_UNICODE_SCRIPT_TULU_TIGALARI: GUnicodeScript = 167;
pub const G_UNICODE_SCRIPT_SUNUWAR: GUnicodeScript = 168;
pub const G_UNICODE_SCRIPT_GURUNG_KHEMA: GUnicodeScript = 169;
pub const G_UNICODE_SCRIPT_KIRAT_RAI: GUnicodeScript = 170;
pub const G_UNICODE_SCRIPT_OL_ONAL: GUnicodeScript = 171;

pub type GUnicodeType = c_int;
pub const G_UNICODE_CONTROL: GUnicodeType = 0;
pub const G_UNICODE_FORMAT: GUnicodeType = 1;
pub const G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;

#[cfg(unix)]
#[cfg_attr(docsrs, doc(cfg(unix)))]
pub type GUnixPipeEnd = c_int;
#[cfg(unix)]
#[cfg_attr(docsrs, doc(cfg(unix)))]
pub const G_UNIX_PIPE_END_READ: GUnixPipeEnd = 0;
#[cfg(unix)]
#[cfg_attr(docsrs, doc(cfg(unix)))]
pub const G_UNIX_PIPE_END_WRITE: GUnixPipeEnd = 1;

pub type GUriError = c_int;
pub const G_URI_ERROR_FAILED: GUriError = 0;
pub const G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const G_URI_ERROR_BAD_USER: GUriError = 2;
pub const G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;

pub type GUserDirectory = c_int;
pub const G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const G_USER_N_DIRECTORIES: GUserDirectory = 8;

pub type GVariantClass = c_int;
pub const G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;

pub type GVariantParseError = c_int;
pub const G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;

// Constants
pub const G_ALLOCATOR_LIST: c_int = 1;
pub const G_ALLOCATOR_NODE: c_int = 3;
pub const G_ALLOCATOR_SLIST: c_int = 2;
pub const G_ALLOC_AND_FREE: c_int = 2;
pub const G_ALLOC_ONLY: c_int = 1;
pub const G_ASCII_DTOSTR_BUF_SIZE: c_int = 39;
pub const G_ATOMIC_REF_COUNT_INIT: c_int = 1;
pub const G_BIG_ENDIAN: c_int = 4321;
pub const G_CSET_A_2_Z: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_DIGITS: &[u8] = b"0123456789\0";
pub const G_CSET_a_2_z: &[u8] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_DATALIST_FLAGS_MASK: c_int = 3;
pub const G_DATE_BAD_DAY: c_int = 0;
pub const G_DATE_BAD_JULIAN: c_int = 0;
pub const G_DATE_BAD_YEAR: c_int = 0;
pub const G_E: c_double = 2.718282;
pub const G_HOOK_FLAG_USER_SHIFT: c_int = 4;
pub const G_IEEE754_DOUBLE_BIAS: c_int = 1023;
pub const G_IEEE754_FLOAT_BIAS: c_int = 127;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8] = b"Directory\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8] = b"Link\0";
pub const G_LITTLE_ENDIAN: c_int = 1234;
pub const G_LN10: c_double = 2.302585;
pub const G_LN2: c_double = 0.693147;
pub const G_LOG_2_BASE_10: c_double = 0.301030;
pub const G_LOG_FATAL_MASK: c_int = 5;
pub const G_LOG_LEVEL_USER_SHIFT: c_int = 8;
pub const G_OPTION_REMAINING: &[u8] = b"\0";
pub const G_PDP_ENDIAN: c_int = 3412;
pub const G_PI: c_double = 3.141593;
pub const G_PI_2: c_double = 1.570796;
pub const G_PI_4: c_double = 0.785398;
pub const G_PRIORITY_DEFAULT: c_int = 0;
pub const G_PRIORITY_DEFAULT_IDLE: c_int = 200;
pub const G_PRIORITY_HIGH: c_int = -100;
pub const G_PRIORITY_HIGH_IDLE: c_int = 100;
pub const G_PRIORITY_LOW: c_int = 300;
pub const G_REF_COUNT_INIT: c_int = -1;
pub const G_SOURCE_CONTINUE: gboolean = GTRUE;
pub const G_SOURCE_REMOVE: gboolean = GFALSE;
pub const G_SQRT2: c_double = 1.414214;
pub const G_STR_DELIMITERS: &[u8] = b"_-|> <.\0";
pub const GLIB_SYSDEF_AF_INET: c_int = 2;
pub const GLIB_SYSDEF_AF_INET6: c_int = 10;
pub const GLIB_SYSDEF_AF_UNIX: c_int = 1;
pub const GLIB_SYSDEF_MSG_DONTROUTE: c_int = 4;
pub const GLIB_SYSDEF_MSG_OOB: c_int = 1;
pub const GLIB_SYSDEF_MSG_PEEK: c_int = 2;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8] = b"isolate_dirs\0";
pub const G_TEST_OPTION_NONFATAL_ASSERTIONS: &[u8] = b"nonfatal-assertions\0";
pub const G_TEST_OPTION_NO_PRGNAME: &[u8] = b"no_g_set_prgname\0";
pub const G_TIME_SPAN_DAY: i64 = 86400000000;
pub const G_TIME_SPAN_HOUR: i64 = 3600000000;
pub const G_TIME_SPAN_MILLISECOND: i64 = 1000;
pub const G_TIME_SPAN_MINUTE: i64 = 60000000;
pub const G_TIME_SPAN_SECOND: i64 = 1000000;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: c_int = 18;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8] = b"!$&'()*+,;=\0";
pub const G_USEC_PER_SEC: c_int = 1000000;
pub const G_WIN32_MSG_HANDLE: c_int = 19981206;

// Flags
pub type GAsciiType = c_uint;
pub const G_ASCII_ALNUM: GAsciiType = 1;
pub const G_ASCII_ALPHA: GAsciiType = 2;
pub const G_ASCII_CNTRL: GAsciiType = 4;
pub const G_ASCII_DIGIT: GAsciiType = 8;
pub const G_ASCII_GRAPH: GAsciiType = 16;
pub const G_ASCII_LOWER: GAsciiType = 32;
pub const G_ASCII_PRINT: GAsciiType = 64;
pub const G_ASCII_PUNCT: GAsciiType = 128;
pub const G_ASCII_SPACE: GAsciiType = 256;
pub const G_ASCII_UPPER: GAsciiType = 512;
pub const G_ASCII_XDIGIT: GAsciiType = 1024;

pub type GFileSetContentsFlags = c_uint;
pub const G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;

pub type GFileTest = c_uint;
pub const G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const G_FILE_TEST_EXISTS: GFileTest = 16;

pub type GFormatSizeFlags = c_uint;
pub const G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;

pub type GHookFlagMask = c_uint;
pub const G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const G_HOOK_FLAG_MASK: GHookFlagMask = 15;

pub type GIOCondition = c_uint;
pub const G_IO_IN: GIOCondition = 1;
pub const G_IO_OUT: GIOCondition = 4;
pub const G_IO_PRI: GIOCondition = 2;
pub const G_IO_ERR: GIOCondition = 8;
pub const G_IO_HUP: GIOCondition = 16;
pub const G_IO_NVAL: GIOCondition = 32;

pub type GIOFlags = c_uint;
pub const G_IO_FLAG_NONE: GIOFlags = 0;
pub const G_IO_FLAG_APPEND: GIOFlags = 1;
pub const G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const G_IO_FLAG_MASK: GIOFlags = 31;
pub const G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const G_IO_FLAG_SET_MASK: GIOFlags = 3;

pub type GKeyFileFlags = c_uint;
pub const G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;

pub type GLogLevelFlags = c_uint;
pub const G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const G_LOG_LEVEL_MASK: GLogLevelFlags = 4294967292;

pub type GMainContextFlags = c_uint;
pub const G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;

pub type GMarkupCollectType = c_uint;
pub const G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;

pub type GMarkupParseFlags = c_uint;
pub const G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;

pub type GOptionFlags = c_uint;
pub const G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[cfg(feature = "v2_84")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_84")))]
pub const G_OPTION_FLAG_DEPRECATED: GOptionFlags = 128;

pub type GRegexCompileFlags = c_uint;
pub const G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;

pub type GRegexMatchFlags = c_uint;
pub const G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;

pub type GSpawnFlags = c_uint;
pub const G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[cfg(feature = "v2_74")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
pub const G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[cfg(feature = "v2_74")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
pub const G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[cfg(feature = "v2_74")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
pub const G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;

pub type GTestSubprocessFlags = c_uint;
pub const G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;

pub type GTestTrapFlags = c_uint;
pub const G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;

pub type GTraverseFlags = c_uint;
pub const G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;

pub type GUriFlags = c_uint;
pub const G_URI_FLAGS_NONE: GUriFlags = 0;
pub const G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;

pub type GUriHideFlags = c_uint;
pub const G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;

pub type GUriParamsFlags = c_uint;
pub const G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;

// Unions
#[repr(C)]
#[allow(dead_code)]
pub struct GDoubleIEEE754 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GDoubleIEEE754 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDoubleIEEE754 @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GFloatIEEE754 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GFloatIEEE754 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GFloatIEEE754 @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GMutex {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GMutex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMutex @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut c_char,
    pub v_binary: c_ulong,
    pub v_octal: c_ulong,
    pub v_int: c_ulong,
    pub v_int64: u64,
    pub v_float: c_double,
    pub v_hex: c_ulong,
    pub v_string: *mut c_char,
    pub v_comment: *mut c_char,
    pub v_char: c_uchar,
    pub v_error: c_uint,
}

impl ::std::fmt::Debug for GTokenValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTokenValue @ {self:p}"))
            .field("v_symbol", unsafe { &self.v_symbol })
            .field("v_identifier", unsafe { &self.v_identifier })
            .field("v_binary", unsafe { &self.v_binary })
            .field("v_octal", unsafe { &self.v_octal })
            .field("v_int", unsafe { &self.v_int })
            .field("v_int64", unsafe { &self.v_int64 })
            .field("v_float", unsafe { &self.v_float })
            .field("v_hex", unsafe { &self.v_hex })
            .field("v_string", unsafe { &self.v_string })
            .field("v_comment", unsafe { &self.v_comment })
            .field("v_char", unsafe { &self.v_char })
            .field("v_error", unsafe { &self.v_error })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GVariantBuilder_u {
    pub s: GVariantBuilder_u_s,
    pub x: [uintptr_t; 16],
}

impl ::std::fmt::Debug for GVariantBuilder_u {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantBuilder_u @ {self:p}"))
            .field("s", unsafe { &self.s })
            .field("x", unsafe { &self.x })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GVariantDict_u {
    pub s: GVariantDict_u_s,
    pub x: [uintptr_t; 16],
}

impl ::std::fmt::Debug for GVariantDict_u {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantDict_u @ {self:p}"))
            .field("s", unsafe { &self.s })
            .field("x", unsafe { &self.x })
            .finish()
    }
}

// Callbacks
pub type GCacheDestroyFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GCacheDupFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GCacheNewFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GChildWatchFunc = Option<unsafe extern "C" fn(GPid, c_int, gpointer)>;
pub type GClearHandleFunc = Option<unsafe extern "C" fn(c_uint)>;
pub type GCompareDataFunc =
    Option<unsafe extern "C" fn(gconstpointer, gconstpointer, gpointer) -> c_int>;
pub type GCompareFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> c_int>;
pub type GCompletionFunc = Option<unsafe extern "C" fn(gpointer) -> *mut c_char>;
pub type GCompletionStrncmpFunc =
    Option<unsafe extern "C" fn(*const c_char, *const c_char, size_t) -> c_int>;
pub type GCopyFunc = Option<unsafe extern "C" fn(gconstpointer, gpointer) -> gpointer>;
pub type GDataForeachFunc = Option<unsafe extern "C" fn(GQuark, gpointer, gpointer)>;
pub type GDestroyNotify = Option<unsafe extern "C" fn(gpointer)>;
pub type GDuplicateFunc = Option<unsafe extern "C" fn(gpointer, gpointer) -> gpointer>;
pub type GEqualFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> gboolean>;
pub type GEqualFuncFull =
    Option<unsafe extern "C" fn(gconstpointer, gconstpointer, gpointer) -> gboolean>;
pub type GErrorClearFunc = Option<unsafe extern "C" fn(*mut GError)>;
pub type GErrorCopyFunc = Option<unsafe extern "C" fn(*const GError, *mut GError)>;
pub type GErrorInitFunc = Option<unsafe extern "C" fn(*mut GError)>;
pub type GFreeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GHFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer)>;
pub type GHRFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GHashFunc = Option<unsafe extern "C" fn(gconstpointer) -> c_uint>;
pub type GHookCheckFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GHookCheckMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookCompareFunc = Option<unsafe extern "C" fn(*mut GHook, *mut GHook) -> c_int>;
pub type GHookFinalizeFunc = Option<unsafe extern "C" fn(*mut GHookList, *mut GHook)>;
pub type GHookFindFunc = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GHookMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer)>;
pub type GIOFunc =
    Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition, gpointer) -> gboolean>;
pub type GLogFunc =
    Option<unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer)>;
pub type GLogWriterFunc = Option<
    unsafe extern "C" fn(GLogLevelFlags, *const GLogField, size_t, gpointer) -> GLogWriterOutput,
>;
pub type GNodeForeachFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer)>;
pub type GNodeTraverseFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer) -> gboolean>;
pub type GOptionArgFunc = Option<
    unsafe extern "C" fn(*const c_char, *const c_char, gpointer, *mut *mut GError) -> gboolean,
>;
pub type GOptionErrorFunc = Option<
    unsafe extern "C" fn(*mut GOptionContext, *mut GOptionGroup, gpointer, *mut *mut GError),
>;
pub type GOptionParseFunc = Option<
    unsafe extern "C" fn(
        *mut GOptionContext,
        *mut GOptionGroup,
        gpointer,
        *mut *mut GError,
    ) -> gboolean,
>;
pub type GPollFunc = Option<unsafe extern "C" fn(*mut GPollFD, c_uint, c_int) -> c_int>;
pub type GPrintFunc = Option<unsafe extern "C" fn(*const c_char)>;
pub type GRegexEvalCallback =
    Option<unsafe extern "C" fn(*const GMatchInfo, *mut GString, gpointer) -> gboolean>;
pub type GScannerMsgFunc = Option<unsafe extern "C" fn(*mut GScanner, *mut c_char, gboolean)>;
pub type GSequenceIterCompareFunc =
    Option<unsafe extern "C" fn(*mut GSequenceIter, *mut GSequenceIter, gpointer) -> c_int>;
pub type GSourceDisposeFunc = Option<unsafe extern "C" fn(*mut GSource)>;
pub type GSourceDummyMarshal = Option<unsafe extern "C" fn()>;
pub type GSourceFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GSourceFuncsCheckFunc = Option<unsafe extern "C" fn(*mut GSource) -> gboolean>;
pub type GSourceFuncsDispatchFunc =
    Option<unsafe extern "C" fn(*mut GSource, GSourceFunc, gpointer) -> gboolean>;
pub type GSourceFuncsFinalizeFunc = Option<unsafe extern "C" fn(*mut GSource)>;
pub type GSourceFuncsPrepareFunc =
    Option<unsafe extern "C" fn(*mut GSource, *mut c_int) -> gboolean>;
pub type GSourceOnceFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GSpawnChildSetupFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GTestDataFunc = Option<unsafe extern "C" fn(gconstpointer)>;
pub type GTestFixtureFunc = Option<unsafe extern "C" fn(gpointer, gconstpointer)>;
pub type GTestFunc = Option<unsafe extern "C" fn()>;
pub type GTestLogFatalFunc = Option<
    unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer) -> gboolean,
>;
pub type GThreadFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GTranslateFunc = Option<unsafe extern "C" fn(*const c_char, gpointer) -> *const c_char>;
pub type GTraverseFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GTraverseNodeFunc = Option<unsafe extern "C" fn(*mut GTreeNode, gpointer) -> gboolean>;
pub type GUnixFDSourceFunc =
    Option<unsafe extern "C" fn(c_int, GIOCondition, gpointer) -> gboolean>;
pub type GVoidFunc = Option<unsafe extern "C" fn()>;

// Records
#[repr(C)]
#[allow(dead_code)]
pub struct _GAllocator {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GAllocator = _GAllocator;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GArray {
    pub data: *mut c_char,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GArray @ {self:p}"))
            .field("data", &self.data)
            .field("len", &self.len)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GAsyncQueue {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GAsyncQueue = _GAsyncQueue;

#[repr(C)]
#[allow(dead_code)]
pub struct GBookmarkFile {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GBookmarkFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GBookmarkFile @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GByteArray {
    pub data: *mut u8,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GByteArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GByteArray @ {self:p}"))
            .field("data", &self.data)
            .field("len", &self.len)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GBytes {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GBytes @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GCache {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GCache = _GCache;

#[repr(C)]
#[allow(dead_code)]
pub struct GChecksum {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GChecksum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GChecksum @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut c_char,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}

impl ::std::fmt::Debug for GCompletion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GCompletion @ {self:p}"))
            .field("items", &self.items)
            .field("func", &self.func)
            .field("prefix", &self.prefix)
            .field("cache", &self.cache)
            .field("strncmp_func", &self.strncmp_func)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GCond {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GCond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GCond @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GData {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GData = _GData;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GDate {
    pub julian_days: c_uint,
    pub flags_dmy: c_uint,
}

impl ::std::fmt::Debug for GDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDate @ {self:p}"))
            .field("julian_days", &self.julian_days)
            .field("flags_dmy", &self.flags_dmy)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GDateTime {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GDateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDateTime @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GDebugKey {
    pub key: *const c_char,
    pub value: c_uint,
}

impl ::std::fmt::Debug for GDebugKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDebugKey @ {self:p}"))
            .field("key", &self.key)
            .field("value", &self.value)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GDir {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDir @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GDoubleIEEE754_mpn {
    pub mantissa_low: c_uint,
    _truncated_record_marker: c_void,
    // field mantissa_high has incomplete type
}

impl ::std::fmt::Debug for GDoubleIEEE754_mpn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GDoubleIEEE754_mpn @ {self:p}"))
            .field("mantissa_low", &self.mantissa_low)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GError {
    pub domain: GQuark,
    pub code: c_int,
    pub message: *mut c_char,
}

impl ::std::fmt::Debug for GError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GError @ {self:p}"))
            .field("domain", &self.domain)
            .field("code", &self.code)
            .field("message", &self.message)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GFloatIEEE754_mpn {
    pub mantissa: c_uint,
    _truncated_record_marker: c_void,
    // field biased_exponent has incomplete type
}

impl ::std::fmt::Debug for GFloatIEEE754_mpn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GFloatIEEE754_mpn @ {self:p}"))
            .field("mantissa", &self.mantissa)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GHashTable {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GHashTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GHashTable @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}

impl ::std::fmt::Debug for GHashTableIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GHashTableIter @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GHmac {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GHmac {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GHmac @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: c_uint,
    pub hook_id: c_ulong,
    pub flags: c_uint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}

impl ::std::fmt::Debug for GHook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GHook @ {self:p}"))
            .field("data", &self.data)
            .field("next", &self.next)
            .field("prev", &self.prev)
            .field("ref_count", &self.ref_count)
            .field("hook_id", &self.hook_id)
            .field("flags", &self.flags)
            .field("func", &self.func)
            .field("destroy", &self.destroy)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GHookList {
    pub seq_id: c_ulong,
    #[cfg(any(not(windows), not(target_pointer_width = "64")))]
    pub hook_size_and_setup: gpointer,
    #[cfg(all(windows, target_pointer_width = "64"))]
    pub hook_size_and_setup: c_ulong,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2],
}

impl ::std::fmt::Debug for GHookList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GHookList @ {self:p}")
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GIConv {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GIConv = *mut _GIConv;

#[repr(C)]
#[allow(dead_code)]
pub struct GIOChannel {
    pub ref_count: c_int,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut c_char,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut c_char,
    pub line_term_len: c_uint,
    pub buf_size: size_t,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [c_char; 6],
    pub use_buffer: c_uint,
    _truncated_record_marker: c_void,
    // field do_encode has incomplete type
}

impl ::std::fmt::Debug for GIOChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GIOChannel @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GIOFuncs {
    pub io_read: Option<
        unsafe extern "C" fn(
            *mut GIOChannel,
            *const c_char,
            size_t,
            *mut size_t,
            *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: Option<
        unsafe extern "C" fn(
            *mut GIOChannel,
            *const c_char,
            size_t,
            *mut size_t,
            *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: Option<
        unsafe extern "C" fn(*mut GIOChannel, i64, GSeekType, *mut *mut GError) -> GIOStatus,
    >,
    pub io_close: Option<unsafe extern "C" fn(*mut GIOChannel, *mut *mut GError) -> GIOStatus>,
    pub io_create_watch:
        Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition) -> *mut GSource>,
    pub io_free: Option<unsafe extern "C" fn(*mut GIOChannel)>,
    pub io_set_flags:
        Option<unsafe extern "C" fn(*mut GIOChannel, GIOFlags, *mut *mut GError) -> GIOStatus>,
    pub io_get_flags: Option<unsafe extern "C" fn(*mut GIOChannel) -> GIOFlags>,
}

impl ::std::fmt::Debug for GIOFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GIOFuncs @ {self:p}"))
            .field("io_read", &self.io_read)
            .field("io_write", &self.io_write)
            .field("io_seek", &self.io_seek)
            .field("io_close", &self.io_close)
            .field("io_create_watch", &self.io_create_watch)
            .field("io_free", &self.io_free)
            .field("io_set_flags", &self.io_set_flags)
            .field("io_get_flags", &self.io_get_flags)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GKeyFile {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GKeyFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GKeyFile @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}

impl ::std::fmt::Debug for GList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GList @ {self:p}"))
            .field("data", &self.data)
            .field("next", &self.next)
            .field("prev", &self.prev)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GLogField {
    pub key: *const c_char,
    pub value: gconstpointer,
    pub length: ssize_t,
}

impl ::std::fmt::Debug for GLogField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GLogField @ {self:p}"))
            .field("key", &self.key)
            .field("value", &self.value)
            .field("length", &self.length)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GMainContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GMainContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMainContext @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GMainLoop {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GMainLoop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMainLoop @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GMappedFile {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GMappedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMappedFile @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GMarkupParseContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GMarkupParseContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMarkupParseContext @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GMarkupParser {
    pub start_element: Option<
        unsafe extern "C" fn(
            *mut GMarkupParseContext,
            *const c_char,
            *mut *const c_char,
            *mut *const c_char,
            gpointer,
            *mut *mut GError,
        ),
    >,
    pub end_element: Option<
        unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, gpointer, *mut *mut GError),
    >,
    pub text: Option<
        unsafe extern "C" fn(
            *mut GMarkupParseContext,
            *const c_char,
            size_t,
            gpointer,
            *mut *mut GError,
        ),
    >,
    pub passthrough: Option<
        unsafe extern "C" fn(
            *mut GMarkupParseContext,
            *const c_char,
            size_t,
            gpointer,
            *mut *mut GError,
        ),
    >,
    pub error: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *mut GError, gpointer)>,
}

impl ::std::fmt::Debug for GMarkupParser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMarkupParser @ {self:p}"))
            .field("start_element", &self.start_element)
            .field("end_element", &self.end_element)
            .field("text", &self.text)
            .field("passthrough", &self.passthrough)
            .field("error", &self.error)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GMatchInfo {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMatchInfo @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GMemChunk {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GMemChunk = _GMemChunk;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GMemVTable {
    pub malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
    pub free: Option<unsafe extern "C" fn(gpointer)>,
    pub calloc: Option<unsafe extern "C" fn(size_t, size_t) -> gpointer>,
    pub try_malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub try_realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
}

impl ::std::fmt::Debug for GMemVTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMemVTable @ {self:p}"))
            .field("malloc", &self.malloc)
            .field("realloc", &self.realloc)
            .field("free", &self.free)
            .field("calloc", &self.calloc)
            .field("try_malloc", &self.try_malloc)
            .field("try_realloc", &self.try_realloc)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}

impl ::std::fmt::Debug for GNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GNode @ {self:p}"))
            .field("data", &self.data)
            .field("next", &self.next)
            .field("prev", &self.prev)
            .field("parent", &self.parent)
            .field("children", &self.children)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}

impl ::std::fmt::Debug for GOnce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GOnce @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GOptionContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GOptionContext = _GOptionContext;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GOptionEntry {
    pub long_name: *const c_char,
    pub short_name: c_char,
    pub flags: c_int,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const c_char,
    pub arg_description: *const c_char,
}

impl ::std::fmt::Debug for GOptionEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GOptionEntry @ {self:p}"))
            .field("long_name", &self.long_name)
            .field("short_name", &self.short_name)
            .field("flags", &self.flags)
            .field("arg", &self.arg)
            .field("arg_data", &self.arg_data)
            .field("description", &self.description)
            .field("arg_description", &self.arg_description)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GOptionGroup {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GOptionGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GOptionGroup @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GPathBuf {
    pub dummy: [gpointer; 8],
}

impl ::std::fmt::Debug for GPathBuf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GPathBuf @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GPatternSpec {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GPatternSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GPatternSpec @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2],
}

impl ::std::fmt::Debug for GPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GPrivate @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GPtrArray {
    pub pdata: *mut gpointer,
    pub len: c_uint,
}

impl ::std::fmt::Debug for GPtrArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GPtrArray @ {self:p}"))
            .field("pdata", &self.pdata)
            .field("len", &self.len)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: c_uint,
}

impl ::std::fmt::Debug for GQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GQueue @ {self:p}"))
            .field("head", &self.head)
            .field("tail", &self.tail)
            .field("length", &self.length)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GRWLock {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GRWLock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GRWLock @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GRand {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GRand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GRand @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GRecMutex {
    pub p: gpointer,
    pub i: [c_uint; 2],
}

impl ::std::fmt::Debug for GRecMutex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GRecMutex @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GRegex {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GRegex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GRegex @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GRelation {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GRelation = _GRelation;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}

impl ::std::fmt::Debug for GSList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSList @ {self:p}"))
            .field("data", &self.data)
            .field("next", &self.next)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: c_uint,
    pub parse_errors: c_uint,
    pub input_name: *const c_char,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: c_uint,
    pub position: c_uint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: c_uint,
    pub next_position: c_uint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: c_int,
    pub text: *const c_char,
    pub text_end: *const c_char,
    pub buffer: *mut c_char,
    pub scope_id: c_uint,
    pub msg_handler: GScannerMsgFunc,
}

impl ::std::fmt::Debug for GScanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GScanner @ {self:p}"))
            .field("user_data", &self.user_data)
            .field("max_parse_errors", &self.max_parse_errors)
            .field("parse_errors", &self.parse_errors)
            .field("input_name", &self.input_name)
            .field("qdata", &self.qdata)
            .field("config", &self.config)
            .field("token", &self.token)
            .field("value", &self.value)
            .field("line", &self.line)
            .field("position", &self.position)
            .field("next_token", &self.next_token)
            .field("next_value", &self.next_value)
            .field("next_line", &self.next_line)
            .field("next_position", &self.next_position)
            .field("msg_handler", &self.msg_handler)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GScannerConfig {
    pub cset_skip_characters: *mut c_char,
    pub cset_identifier_first: *mut c_char,
    pub cset_identifier_nth: *mut c_char,
    pub cpair_comment_single: *mut c_char,
    pub case_sensitive: c_uint,
    _truncated_record_marker: c_void,
    // field skip_comment_multi has incomplete type
}

impl ::std::fmt::Debug for GScannerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GScannerConfig @ {self:p}"))
            .field("cset_skip_characters", &self.cset_skip_characters)
            .field("cset_identifier_first", &self.cset_identifier_first)
            .field("cset_identifier_nth", &self.cset_identifier_nth)
            .field("cpair_comment_single", &self.cpair_comment_single)
            .field("case_sensitive", &self.case_sensitive)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GSequence {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GSequence = _GSequence;

#[repr(C)]
#[allow(dead_code)]
pub struct _GSequenceIter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GSequenceIter = _GSequenceIter;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: c_uint,
    pub context: *mut GMainContext,
    pub priority: c_int,
    pub flags: c_uint,
    pub source_id: c_uint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut c_char,
    pub priv_: *mut GSourcePrivate,
}

impl ::std::fmt::Debug for GSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSource @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSourceCallbackFuncs {
    pub ref_: Option<unsafe extern "C" fn(gpointer)>,
    pub unref: Option<unsafe extern "C" fn(gpointer)>,
    pub get: Option<unsafe extern "C" fn(gpointer, *mut GSource, *mut GSourceFunc, *mut gpointer)>,
}

impl ::std::fmt::Debug for GSourceCallbackFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSourceCallbackFuncs @ {self:p}"))
            .field("ref_", &self.ref_)
            .field("unref", &self.unref)
            .field("get", &self.get)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSourceFuncs {
    pub prepare: GSourceFuncsPrepareFunc,
    pub check: GSourceFuncsCheckFunc,
    pub dispatch: GSourceFuncsDispatchFunc,
    pub finalize: GSourceFuncsFinalizeFunc,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}

impl ::std::fmt::Debug for GSourceFuncs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSourceFuncs @ {self:p}"))
            .field("prepare", &self.prepare)
            .field("check", &self.check)
            .field("dispatch", &self.dispatch)
            .field("finalize", &self.finalize)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GSourcePrivate = _GSourcePrivate;

#[repr(C)]
#[allow(dead_code)]
pub struct _GStatBuf {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GStatBuf = _GStatBuf;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GString {
    pub str: *mut c_char,
    pub len: size_t,
    pub allocated_len: size_t,
}

impl ::std::fmt::Debug for GString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GString @ {self:p}"))
            .field("str", &self.str)
            .field("len", &self.len)
            .field("allocated_len", &self.allocated_len)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GStringChunk {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GStringChunk = _GStringChunk;

#[repr(C)]
#[allow(dead_code)]
pub struct GStrvBuilder {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GStrvBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GStrvBuilder @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GTestCase {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GTestCase = _GTestCase;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}

impl ::std::fmt::Debug for GTestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTestConfig @ {self:p}"))
            .field("test_initialized", &self.test_initialized)
            .field("test_quick", &self.test_quick)
            .field("test_perf", &self.test_perf)
            .field("test_verbose", &self.test_verbose)
            .field("test_quiet", &self.test_quiet)
            .field("test_undefined", &self.test_undefined)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}

impl ::std::fmt::Debug for GTestLogBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTestLogBuffer @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GTestSuite {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GTestSuite = _GTestSuite;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}

impl ::std::fmt::Debug for GThread {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GThread @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GThreadFunctions {
    pub mutex_new: Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: Option<unsafe extern "C" fn(*mut GMutex)>,
    pub mutex_trylock: Option<unsafe extern "C" fn(*mut GMutex) -> gboolean>,
    pub mutex_unlock: Option<unsafe extern "C" fn(*mut GMutex)>,
    pub mutex_free: Option<unsafe extern "C" fn(*mut GMutex)>,
    pub cond_new: Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: Option<unsafe extern "C" fn(*mut GCond)>,
    pub cond_broadcast: Option<unsafe extern "C" fn(*mut GCond)>,
    pub cond_wait: Option<unsafe extern "C" fn(*mut GCond, *mut GMutex)>,
    pub cond_timed_wait:
        Option<unsafe extern "C" fn(*mut GCond, *mut GMutex, *mut GTimeVal) -> gboolean>,
    pub cond_free: Option<unsafe extern "C" fn(*mut GCond)>,
    pub private_new: Option<unsafe extern "C" fn(GDestroyNotify) -> *mut GPrivate>,
    pub private_get: Option<unsafe extern "C" fn(*mut GPrivate) -> gpointer>,
    pub private_set: Option<unsafe extern "C" fn(*mut GPrivate, gpointer)>,
    pub thread_create: Option<
        unsafe extern "C" fn(
            GThreadFunc,
            gpointer,
            c_ulong,
            gboolean,
            gboolean,
            GThreadPriority,
            gpointer,
            *mut *mut GError,
        ),
    >,
    pub thread_yield: Option<unsafe extern "C" fn()>,
    pub thread_join: Option<unsafe extern "C" fn(gpointer)>,
    pub thread_exit: Option<unsafe extern "C" fn()>,
    pub thread_set_priority: Option<unsafe extern "C" fn(gpointer, GThreadPriority)>,
    pub thread_self: Option<unsafe extern "C" fn(gpointer)>,
    pub thread_equal: Option<unsafe extern "C" fn(gpointer, gpointer) -> gboolean>,
}

impl ::std::fmt::Debug for GThreadFunctions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GThreadFunctions @ {self:p}"))
            .field("mutex_new", &self.mutex_new)
            .field("mutex_lock", &self.mutex_lock)
            .field("mutex_trylock", &self.mutex_trylock)
            .field("mutex_unlock", &self.mutex_unlock)
            .field("mutex_free", &self.mutex_free)
            .field("cond_new", &self.cond_new)
            .field("cond_signal", &self.cond_signal)
            .field("cond_broadcast", &self.cond_broadcast)
            .field("cond_wait", &self.cond_wait)
            .field("cond_timed_wait", &self.cond_timed_wait)
            .field("cond_free", &self.cond_free)
            .field("private_new", &self.private_new)
            .field("private_get", &self.private_get)
            .field("private_set", &self.private_set)
            .field("thread_create", &self.thread_create)
            .field("thread_yield", &self.thread_yield)
            .field("thread_join", &self.thread_join)
            .field("thread_exit", &self.thread_exit)
            .field("thread_set_priority", &self.thread_set_priority)
            .field("thread_self", &self.thread_self)
            .field("thread_equal", &self.thread_equal)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}

impl ::std::fmt::Debug for GThreadPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GThreadPool @ {self:p}"))
            .field("func", &self.func)
            .field("user_data", &self.user_data)
            .field("exclusive", &self.exclusive)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTimeVal {
    pub tv_sec: c_long,
    pub tv_usec: c_long,
}

impl ::std::fmt::Debug for GTimeVal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTimeVal @ {self:p}"))
            .field("tv_sec", &self.tv_sec)
            .field("tv_usec", &self.tv_usec)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GTimeZone {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GTimeZone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTimeZone @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GTimer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GTimer = _GTimer;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTrashStack {
    pub next: *mut GTrashStack,
}

impl ::std::fmt::Debug for GTrashStack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTrashStack @ {self:p}"))
            .field("next", &self.next)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GTree {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GTree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTree @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GTreeNode {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GTreeNode = _GTreeNode;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTuples {
    pub len: c_uint,
}

impl ::std::fmt::Debug for GTuples {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTuples @ {self:p}"))
            .field("len", &self.len)
            .finish()
    }
}

#[cfg(unix)]
#[cfg_attr(docsrs, doc(cfg(unix)))]
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GUnixPipe {
    pub fds: [c_int; 2],
}

#[cfg(unix)]
#[cfg_attr(docsrs, doc(cfg(unix)))]
impl ::std::fmt::Debug for GUnixPipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GUnixPipe @ {self:p}"))
            .field("fds", &self.fds)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GUri {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GUri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GUri @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GUriParamsIter {
    pub dummy0: c_int,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [u8; 256],
}

impl ::std::fmt::Debug for GUriParamsIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GUriParamsIter @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GVariant {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariant @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GVariantBuilder {
    pub u: GVariantBuilder_u,
}

impl ::std::fmt::Debug for GVariantBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantBuilder @ {self:p}"))
            .field("u", &self.u)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GVariantBuilder_u_s {
    pub partial_magic: size_t,
    pub type_: *const GVariantType,
    pub y: [uintptr_t; 14],
}

impl ::std::fmt::Debug for GVariantBuilder_u_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantBuilder_u_s @ {self:p}"))
            .field("partial_magic", &self.partial_magic)
            .field("type_", &self.type_)
            .field("y", &self.y)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GVariantDict {
    pub u: GVariantDict_u,
}

impl ::std::fmt::Debug for GVariantDict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantDict @ {self:p}"))
            .field("u", &self.u)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GVariantDict_u_s {
    pub asv: *mut GVariant,
    pub partial_magic: size_t,
    pub y: [uintptr_t; 14],
}

impl ::std::fmt::Debug for GVariantDict_u_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantDict_u_s @ {self:p}"))
            .field("asv", &self.asv)
            .field("partial_magic", &self.partial_magic)
            .field("y", &self.y)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GVariantIter {
    pub x: [uintptr_t; 16],
}

impl ::std::fmt::Debug for GVariantIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantIter @ {self:p}")).finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GVariantType {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GVariantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GVariantType @ {self:p}")).finish()
    }
}

extern "C" {

    //=========================================================================
    // GNormalizeMode
    //=========================================================================
    pub fn g_normalize_mode_get_type() -> GType;

    //=========================================================================
    // GUnicodeBreakType
    //=========================================================================
    pub fn g_unicode_break_type_get_type() -> GType;

    //=========================================================================
    // GUnicodeScript
    //=========================================================================
    pub fn g_unicode_script_get_type() -> GType;
    pub fn g_unicode_script_from_iso15924(iso15924: u32) -> GUnicodeScript;
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> u32;

    //=========================================================================
    // GUnicodeType
    //=========================================================================
    pub fn g_unicode_type_get_type() -> GType;

    //=========================================================================
    // GIOCondition
    //=========================================================================
    pub fn g_io_condition_get_type() -> GType;

    //=========================================================================
    // GMutex
    //=========================================================================
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_free(mutex: *mut GMutex);
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);
    pub fn g_mutex_new() -> *mut GMutex;

    //=========================================================================
    // GAllocator
    //=========================================================================
    pub fn g_allocator_free(allocator: *mut GAllocator);
    pub fn g_allocator_new(name: *const c_char, n_preallocs: c_uint) -> *mut GAllocator;

    //=========================================================================
    // GArray
    //=========================================================================
    pub fn g_array_get_type() -> GType;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: c_uint)
        -> *mut GArray;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut c_uint,
    ) -> gboolean;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut c_char;
    pub fn g_array_get_element_size(array: *mut GArray) -> c_uint;
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: c_uint,
        data: gconstpointer,
        len: c_uint,
    ) -> *mut GArray;
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: c_uint,
    ) -> *mut GArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_array_new_take(
        data: gpointer,
        len: size_t,
        clear: gboolean,
        element_size: size_t,
    ) -> *mut GArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: size_t,
    ) -> *mut GArray;
    pub fn g_array_prepend_vals(
        array: *mut GArray,
        data: gconstpointer,
        len: c_uint,
    ) -> *mut GArray;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: c_uint, length: c_uint) -> *mut GArray;
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
    pub fn g_array_set_size(array: *mut GArray, length: c_uint) -> *mut GArray;
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: c_uint,
        reserved_size: c_uint,
    ) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_array_steal(array: *mut GArray, len: *mut size_t) -> gpointer;
    pub fn g_array_unref(array: *mut GArray);

    //=========================================================================
    // GAsyncQueue
    //=========================================================================
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;

    //=========================================================================
    // GBookmarkFile
    //=========================================================================
    pub fn g_bookmark_file_get_type() -> GType;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        exec: *const c_char,
    );
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        group: *const c_char,
    );
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> time_t;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        exec: *mut *mut c_char,
        count: *mut c_uint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        exec: *mut *mut c_char,
        count: *mut c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        href: *mut *mut c_char,
        mime_type: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> time_t;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> c_int;
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut size_t,
    ) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> time_t;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        group: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const c_char) -> gboolean;
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const u8,
        length: size_t,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const c_char,
        full_path: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const c_char,
        new_uri: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        group: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        added: time_t,
    );
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        added: *mut GDateTime,
    );
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        exec: *const c_char,
        count: c_int,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        name: *const c_char,
        exec: *const c_char,
        count: c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        description: *const c_char,
    );
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        groups: *mut *const c_char,
        length: size_t,
    );
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        href: *const c_char,
        mime_type: *const c_char,
    );
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        is_private: gboolean,
    );
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        mime_type: *const c_char,
    );
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        modified: time_t,
    );
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        modified: *mut GDateTime,
    );
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        title: *const c_char,
    );
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        visited: time_t,
    );
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const c_char,
        visited: *mut GDateTime,
    );
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut u8;
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_error_quark() -> GQuark;

    //=========================================================================
    // GByteArray
    //=========================================================================
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const u8,
        len: c_uint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut u8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut u8, len: size_t) -> *mut GByteArray;
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const u8,
        len: c_uint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(
        array: *mut GByteArray,
        index_: c_uint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: c_uint,
        length: c_uint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut size_t) -> *mut u8;
    pub fn g_byte_array_unref(array: *mut GByteArray);

    //=========================================================================
    // GBytes
    //=========================================================================
    pub fn g_bytes_get_type() -> GType;
    pub fn g_bytes_new(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: size_t,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> c_int;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut size_t) -> gconstpointer;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: size_t,
        offset: size_t,
        n_elements: size_t,
    ) -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> size_t;
    pub fn g_bytes_hash(bytes: gconstpointer) -> c_uint;
    pub fn g_bytes_new_from_bytes(
        bytes: *mut GBytes,
        offset: size_t,
        length: size_t,
    ) -> *mut GBytes;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut size_t) -> gpointer;

    //=========================================================================
    // GCache
    //=========================================================================
    pub fn g_cache_destroy(cache: *mut GCache);
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;

    //=========================================================================
    // GChecksum
    //=========================================================================
    pub fn g_checksum_get_type() -> GType;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut u8,
        digest_len: *mut size_t,
    );
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const c_char;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const u8, length: ssize_t);
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> ssize_t;

    //=========================================================================
    // GCompletion
    //=========================================================================
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const c_char,
        new_prefix: *mut *mut c_char,
    ) -> *mut GList;
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const c_char,
        new_prefix: *mut *mut c_char,
    ) -> *mut GList;
    pub fn g_completion_free(cmp: *mut GCompletion);
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;

    //=========================================================================
    // GCond
    //=========================================================================
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_free(cond: *mut GCond);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        abs_time: *mut GTimeVal,
    ) -> gboolean;
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: i64) -> gboolean;
    pub fn g_cond_new() -> *mut GCond;

    //=========================================================================
    // GDate
    //=========================================================================
    pub fn g_date_get_type() -> GType;
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
    pub fn g_date_new_julian(julian_day: u32) -> *mut GDate;
    pub fn g_date_add_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_add_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_add_years(date: *mut GDate, n_years: c_uint);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
    pub fn g_date_clear(date: *mut GDate, n_dates: c_uint);
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> c_int;
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> c_int;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_day_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_julian(date: *const GDate) -> u32;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> c_uint;
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_date_get_week_of_year(date: *const GDate, first_day_of_week: GDateWeekday) -> c_uint;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: u32);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_parse(date: *mut GDate, str: *const c_char);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: c_uint);
    //pub fn g_date_to_struct_tm(date: *const GDate, tm: /*Unimplemented*/*mut tm);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> u8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> u8;
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_date_get_weeks_in_year(year: GDateYear, first_day_of_week: GDateWeekday) -> u8;
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_strftime(
        s: *mut c_char,
        slen: size_t,
        format: *const c_char,
        date: *const GDate,
    ) -> size_t;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
    pub fn g_date_valid_julian(julian_date: u32) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;

    //=========================================================================
    // GDateTime
    //=========================================================================
    pub fn g_date_time_get_type() -> GType;
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        seconds: c_double,
    ) -> *mut GDateTime;
    pub fn g_date_time_new_from_iso8601(
        text: *const c_char,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: i64) -> *mut GDateTime;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_date_time_new_from_unix_local_usec(usecs: i64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: i64) -> *mut GDateTime;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_date_time_new_from_unix_utc_usec(usecs: i64) -> *mut GDateTime;
    pub fn g_date_time_new_local(
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        seconds: c_double,
    ) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_utc(
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        seconds: c_double,
    ) -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: c_int,
        months: c_int,
        days: c_int,
        hours: c_int,
        minutes: c_int,
        seconds: c_double,
    ) -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: c_int) -> *mut GDateTime;
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> c_int;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut c_char;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> c_double;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const c_char;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut c_int,
        month: *mut c_int,
        day: *mut c_int,
    );
    pub fn g_date_time_hash(datetime: gconstpointer) -> c_uint;
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> i64;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_date_time_to_unix_usec(datetime: *mut GDateTime) -> i64;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_unref(datetime: *mut GDateTime);

    //=========================================================================
    // GDir
    //=========================================================================
    pub fn g_dir_get_type() -> GType;
    pub fn g_dir_open(path: *const c_char, flags: c_uint, error: *mut *mut GError) -> *mut GDir;
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_dir_read_name(dir: *mut GDir) -> *const c_char;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_dir_ref(dir: *mut GDir) -> *mut GDir;
    pub fn g_dir_rewind(dir: *mut GDir);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_dir_unref(dir: *mut GDir);
    pub fn g_dir_make_tmp(tmpl: *const c_char, error: *mut *mut GError) -> *mut c_char;

    //=========================================================================
    // GError
    //=========================================================================
    pub fn g_error_get_type() -> GType;
    pub fn g_error_new(domain: GQuark, code: c_int, format: *const c_char, ...) -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: c_int, message: *const c_char) -> *mut GError;
    //pub fn g_error_new_valist(domain: GQuark, code: c_int, format: *const c_char, args: /*Unimplemented*/va_list) -> *mut GError;
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: c_int) -> gboolean;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_error_domain_register(
        error_type_name: *const c_char,
        error_type_private_size: size_t,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_error_domain_register_static(
        error_type_name: *const c_char,
        error_type_private_size: size_t,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;

    //=========================================================================
    // GHashTable
    //=========================================================================
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut c_uint,
    ) -> *mut gpointer;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> c_uint;
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);

    //=========================================================================
    // GHashTableIter
    //=========================================================================
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);

    //=========================================================================
    // GHmac
    //=========================================================================
    pub fn g_hmac_get_type() -> GType;
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const u8, key_len: size_t) -> *mut GHmac;
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut u8, digest_len: *mut size_t);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const c_char;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const u8, length: ssize_t);

    //=========================================================================
    // GHook
    //=========================================================================
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> c_int;
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: c_ulong) -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: c_ulong) -> *mut GHook;
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);

    //=========================================================================
    // GHookList
    //=========================================================================
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: c_uint);
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );

    //=========================================================================
    // GIConv
    //=========================================================================
    pub fn g_iconv_close(converter: GIConv) -> c_int;
    pub fn g_iconv_open(to_codeset: *const c_char, from_codeset: *const c_char) -> GIConv;

    //=========================================================================
    // GIOChannel
    //=========================================================================
    pub fn g_io_channel_get_type() -> GType;
    pub fn g_io_channel_new_file(
        filename: *const c_char,
        mode: *const c_char,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
    pub fn g_io_channel_unix_new(fd: c_int) -> *mut GIOChannel;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> size_t;
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const c_char;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_get_line_term(
        channel: *mut GIOChannel,
        length: *mut c_int,
    ) -> *const c_char;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut c_char,
        count: size_t,
        bytes_read: *mut size_t,
    ) -> GIOError;
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut u8,
        count: size_t,
        bytes_read: *mut size_t,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut c_char,
        length: *mut size_t,
        terminator_pos: *mut size_t,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut size_t,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut u8,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut u32,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: i64, type_: GSeekType) -> GIOError;
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: i64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: size_t);
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const c_char,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const c_char,
        length: c_int,
    );
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> c_int;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const c_char,
        count: size_t,
        bytes_written: *mut size_t,
    ) -> GIOError;
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const u8,
        count: ssize_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: u32,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_error_from_errno(en: c_int) -> GIOChannelError;
    pub fn g_io_channel_error_quark() -> GQuark;

    //=========================================================================
    // GKeyFile
    //=========================================================================
    pub fn g_key_file_get_type() -> GType;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut gboolean;
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> c_double;
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_double;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> i64;
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> c_int;
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_int;
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        locale: *const c_char,
    ) -> *mut c_char;
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        locale: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        locale: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut c_char;
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> u64;
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const c_char) -> gboolean;
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const c_char,
        length: size_t,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const c_char,
        full_path: *mut *mut c_char,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const c_char,
        search_dirs: *mut *const c_char,
        full_path: *mut *mut c_char,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const c_char,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: gboolean,
    );
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        list: *mut gboolean,
        length: size_t,
    );
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        comment: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: c_double,
    );
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        list: *mut c_double,
        length: size_t,
    );
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: i64,
    );
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: c_int,
    );
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        list: *mut c_int,
        length: size_t,
    );
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: c_char);
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        locale: *const c_char,
        string: *const c_char,
    );
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        locale: *const c_char,
        list: *const *const c_char,
        length: size_t,
    );
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        string: *const c_char,
    );
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        list: *const *const c_char,
        length: size_t,
    );
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: u64,
    );
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const c_char,
        key: *const c_char,
        value: *const c_char,
    );
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_error_quark() -> GQuark;

    //=========================================================================
    // GList
    //=========================================================================
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> c_int;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: c_int) -> *mut GList;
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> c_uint;
    pub fn g_list_nth(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: c_uint) -> gpointer;
    pub fn g_list_nth_prev(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_pop_allocator();
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> c_int;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;

    //=========================================================================
    // GMainContext
    //=========================================================================
    pub fn g_main_context_get_type() -> GType;
    pub fn g_main_context_new() -> *mut GMainContext;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: c_int);
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: c_int,
        fds: *mut GPollFD,
        n_fds: c_int,
    ) -> gboolean;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: c_uint,
    ) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: c_int,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut c_int) -> gboolean;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_main_context_pusher_new(main_context: *mut GMainContext) -> *mut GMainContextPusher;
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: c_int,
        timeout_: *mut c_int,
        fds: *mut GPollFD,
        n_fds: c_int,
    ) -> c_int;
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_main_context_pusher_free(pusher: *mut GMainContextPusher);
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;

    //=========================================================================
    // GMainLoop
    //=========================================================================
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);

    //=========================================================================
    // GMappedFile
    //=========================================================================
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_mapped_file_new(
        filename: *const c_char,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(
        fd: c_int,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut c_char;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> size_t;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);

    //=========================================================================
    // GMarkupParseContext
    //=========================================================================
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const c_char;
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut c_int,
        char_number: *mut c_int,
    );
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const c_char,
        text_len: ssize_t,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);

    //=========================================================================
    // GMatchInfo
    //=========================================================================
    pub fn g_match_info_get_type() -> GType;
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: c_int) -> *mut c_char;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut c_char;
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const c_char,
    ) -> *mut c_char;
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const c_char,
        start_pos: *mut c_int,
        end_pos: *mut c_int,
    ) -> gboolean;
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: c_int,
        start_pos: *mut c_int,
        end_pos: *mut c_int,
    ) -> gboolean;
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> c_int;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const c_char;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);

    //=========================================================================
    // GMemChunk
    //=========================================================================
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_info();
    pub fn g_mem_chunk_new(
        name: *const c_char,
        atom_size: c_int,
        area_size: size_t,
        type_: c_int,
    ) -> *mut GMemChunk;

    //=========================================================================
    // GNode
    //=========================================================================
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> c_int;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> c_int;
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
    pub fn g_node_depth(node: *mut GNode) -> c_uint;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: c_int, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_max_height(root: *mut GNode) -> c_uint;
    pub fn g_node_n_children(node: *mut GNode) -> c_uint;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> c_uint;
    pub fn g_node_nth_child(node: *mut GNode, n: c_uint) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: c_int,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_new(data: gpointer) -> *mut GNode;
    pub fn g_node_pop_allocator();
    pub fn g_node_push_allocator(allocator: *mut GAllocator);

    //=========================================================================
    // GOnce
    //=========================================================================
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
    pub fn g_once_init_enter(location: *mut c_void) -> gboolean;
    pub fn g_once_init_enter_impl(location: *mut size_t) -> gboolean;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_once_init_enter_pointer(location: *mut c_void) -> gboolean;
    pub fn g_once_init_leave(location: *mut c_void, result: size_t);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_once_init_leave_pointer(location: *mut c_void, result: gpointer);

    //=========================================================================
    // GOptionContext
    //=========================================================================
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const c_char,
    );
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut c_char;
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut c_int,
        argv: *mut *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const c_char,
    );
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const c_char);
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const c_char,
    );
    pub fn g_option_context_new(parameter_string: *const c_char) -> *mut GOptionContext;

    //=========================================================================
    // GOptionGroup
    //=========================================================================
    pub fn g_option_group_get_type() -> GType;
    pub fn g_option_group_new(
        name: *const c_char,
        description: *const c_char,
        help_description: *const c_char,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const c_char);
    pub fn g_option_group_unref(group: *mut GOptionGroup);

    //=========================================================================
    // GPathBuf
    //=========================================================================
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut c_char;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_free(buf: *mut GPathBuf);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut c_char;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_init_from_path(buf: *mut GPathBuf, path: *const c_char) -> *mut GPathBuf;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_push(buf: *mut GPathBuf, path: *const c_char) -> *mut GPathBuf;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_set_extension(buf: *mut GPathBuf, extension: *const c_char) -> gboolean;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_set_filename(buf: *mut GPathBuf, file_name: *const c_char) -> gboolean;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut c_char;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_new() -> *mut GPathBuf;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_path_buf_new_from_path(path: *const c_char) -> *mut GPathBuf;

    //=========================================================================
    // GPatternSpec
    //=========================================================================
    pub fn g_pattern_spec_get_type() -> GType;
    pub fn g_pattern_spec_new(pattern: *const c_char) -> *mut GPatternSpec;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: size_t,
        string: *const c_char,
        string_reversed: *const c_char,
    ) -> gboolean;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const c_char)
        -> gboolean;

    //=========================================================================
    // GPollFD
    //=========================================================================
    pub fn g_pollfd_get_type() -> GType;

    //=========================================================================
    // GPrivate
    //=========================================================================
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;

    //=========================================================================
    // GPtrArray
    //=========================================================================
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut c_uint,
    ) -> gboolean;
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut c_uint,
    ) -> gboolean;
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_segment: gboolean) -> *mut gpointer;
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: c_int, data: gpointer);
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: size_t,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(
        reserved_size: c_uint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: c_uint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: size_t,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: c_uint,
        length: c_uint,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: c_int);
    pub fn g_ptr_array_sized_new(reserved_size: c_uint) -> *mut GPtrArray;
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut size_t) -> *mut gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_unref(array: *mut GPtrArray);

    //=========================================================================
    // GQueue
    //=========================================================================
    pub fn g_queue_clear(queue: *mut GQueue);
    #[cfg(feature = "v2_60")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_60")))]
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_get_length(queue: *mut GQueue) -> c_uint;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> c_int;
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> c_int;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: c_int);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: c_int, link_: *mut GList);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> c_uint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_new() -> *mut GQueue;

    //=========================================================================
    // GRWLock
    //=========================================================================
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);

    //=========================================================================
    // GRand
    //=========================================================================
    pub fn g_rand_get_type() -> GType;
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_new_with_seed(seed: u32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const u32, seed_length: c_uint) -> *mut GRand;
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_double(rand_: *mut GRand) -> c_double;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: c_double, end: c_double) -> c_double;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_int(rand_: *mut GRand) -> u32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: i32, end: i32) -> i32;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: u32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const u32, seed_length: c_uint);

    //=========================================================================
    // GRecMutex
    //=========================================================================
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);

    //=========================================================================
    // GRegex
    //=========================================================================
    pub fn g_regex_get_type() -> GType;
    pub fn g_regex_new(
        pattern: *const c_char,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const c_char;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const c_char) -> c_int;
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const c_char,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const c_char,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        replacement: *const c_char,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        replacement: *const c_char,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const c_char,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut c_char;
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const c_char,
        string_len: ssize_t,
        start_position: c_int,
        match_options: GRegexMatchFlags,
        max_tokens: c_int,
        error: *mut *mut GError,
    ) -> *mut *mut c_char;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_check_replacement(
        replacement: *const c_char,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_escape_nul(string: *const c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_escape_string(string: *const c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_match_simple(
        pattern: *const c_char,
        string: *const c_char,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
    pub fn g_regex_split_simple(
        pattern: *const c_char,
        string: *const c_char,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut c_char;

    //=========================================================================
    // GRelation
    //=========================================================================
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: c_int) -> c_int;
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: c_int) -> c_int;
    pub fn g_relation_destroy(relation: *mut GRelation);
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: c_int,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
    pub fn g_relation_insert(relation: *mut GRelation, ...);
    pub fn g_relation_print(relation: *mut GRelation);
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: c_int,
    ) -> *mut GTuples;
    pub fn g_relation_new(fields: c_int) -> *mut GRelation;

    //=========================================================================
    // GSList
    //=========================================================================
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> c_int;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: c_int) -> *mut GSList;
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> c_uint;
    pub fn g_slist_nth(list: *mut GSList, n: c_uint) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: c_uint) -> gpointer;
    pub fn g_slist_pop_allocator();
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> c_int;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;

    //=========================================================================
    // GScanner
    //=========================================================================
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: c_int);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const c_char, text_len: c_uint);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const c_char) -> gpointer;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: c_uint,
        symbol: *const c_char,
        value: gpointer,
    );
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: c_uint,
        func: GHFunc,
        user_data: gpointer,
    );
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: c_uint,
        symbol: *const c_char,
    ) -> gpointer;
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: c_uint,
        symbol: *const c_char,
    );
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: c_uint) -> c_uint;
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const c_char,
        symbol_spec: *const c_char,
        symbol_name: *const c_char,
        message: *const c_char,
        is_error: c_int,
    );
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;

    //=========================================================================
    // GSequence
    //=========================================================================
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_get_length(seq: *mut GSequence) -> c_int;
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);

    //=========================================================================
    // GSequenceIter
    //=========================================================================
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;

    //=========================================================================
    // GSource
    //=========================================================================
    pub fn g_source_get_type() -> GType;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: c_uint) -> *mut GSource;
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: c_int, events: GIOCondition) -> gpointer;
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> c_uint;
    pub fn g_source_destroy(source: *mut GSource);
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_source_dup_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
    pub fn g_source_get_id(source: *mut GSource) -> c_uint;
    pub fn g_source_get_name(source: *mut GSource) -> *const c_char;
    pub fn g_source_get_priority(source: *mut GSource) -> c_int;
    pub fn g_source_get_ready_time(source: *mut GSource) -> i64;
    pub fn g_source_get_time(source: *mut GSource) -> i64;
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_set_name(source: *mut GSource, name: *const c_char);
    pub fn g_source_set_priority(source: *mut GSource, priority: c_int);
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: i64);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_source_set_static_name(source: *mut GSource, name: *const c_char);
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_remove(tag: c_uint) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_set_name_by_id(tag: c_uint, name: *const c_char);

    //=========================================================================
    // GStaticMutex
    //=========================================================================

    //=========================================================================
    // GStaticPrivate
    //=========================================================================

    //=========================================================================
    // GStaticRWLock
    //=========================================================================

    //=========================================================================
    // GStaticRecMutex
    //=========================================================================

    //=========================================================================
    // GString
    //=========================================================================
    pub fn g_gstring_get_type() -> GType;
    pub fn g_string_new(init: *const c_char) -> *mut GString;
    pub fn g_string_new_len(init: *const c_char, len: ssize_t) -> *mut GString;
    #[cfg(feature = "v2_78")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_78")))]
    pub fn g_string_new_take(init: *mut c_char) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: size_t) -> *mut GString;
    pub fn g_string_append(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const c_char,
        len: ssize_t,
    ) -> *mut GString;
    pub fn g_string_append_printf(string: *mut GString, format: *const c_char, ...);
    pub fn g_string_append_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const c_char,
        reserved_chars_allowed: *const c_char,
        allow_utf8: gboolean,
    ) -> *mut GString;
    //pub fn g_string_append_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_assign(string: *mut GString, rval: *const c_char) -> *mut GString;
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_string_copy(string: *mut GString) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_erase(string: *mut GString, pos: ssize_t, len: ssize_t) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut c_char;
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut c_char;
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_hash(str: *const GString) -> c_uint;
    pub fn g_string_insert(string: *mut GString, pos: ssize_t, val: *const c_char) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: ssize_t, c: c_char) -> *mut GString;
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: ssize_t,
        val: *const c_char,
        len: ssize_t,
    ) -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: ssize_t, wc: u32) -> *mut GString;
    pub fn g_string_overwrite(
        string: *mut GString,
        pos: size_t,
        val: *const c_char,
    ) -> *mut GString;
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: size_t,
        val: *const c_char,
        len: ssize_t,
    ) -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const c_char,
        len: ssize_t,
    ) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_printf(string: *mut GString, format: *const c_char, ...);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_string_replace(
        string: *mut GString,
        find: *const c_char,
        replace: *const c_char,
        limit: c_uint,
    ) -> c_uint;
    pub fn g_string_set_size(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    //pub fn g_string_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);

    //=========================================================================
    // GStringChunk
    //=========================================================================
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const c_char) -> *mut c_char;
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const c_char,
    ) -> *mut c_char;
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const c_char,
        len: ssize_t,
    ) -> *mut c_char;
    pub fn g_string_chunk_new(size: size_t) -> *mut GStringChunk;

    //=========================================================================
    // GStrvBuilder
    //=========================================================================
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_get_type() -> GType;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const c_char);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_addv(builder: *mut GStrvBuilder, value: *mut *const c_char);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> c_char;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_take(builder: *mut GStrvBuilder, value: *mut c_char);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
    #[cfg(feature = "v2_82")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_82")))]
    pub fn g_strv_builder_unref_to_strv(builder: *mut GStrvBuilder) -> c_char;

    //=========================================================================
    // GTestCase
    //=========================================================================
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_test_case_free(test_case: *mut GTestCase);

    //=========================================================================
    // GTestLogBuffer
    //=========================================================================
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    //pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> /*Ignored*/*mut GTestLogMsg;
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer, n_bytes: c_uint, bytes: *const u8);
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;

    //=========================================================================
    // GTestLogMsg
    //=========================================================================
    //pub fn g_test_log_msg_free(tmsg: /*Ignored*/*mut GTestLogMsg);

    //=========================================================================
    // GTestSuite
    //=========================================================================
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_test_suite_free(suite: *mut GTestSuite);

    //=========================================================================
    // GThread
    //=========================================================================
    pub fn g_thread_get_type() -> GType;
    pub fn g_thread_new(name: *const c_char, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_try_new(
        name: *const c_char,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
    #[cfg(feature = "v2_84")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_84")))]
    pub fn g_thread_get_name(thread: *mut GThread) -> *const c_char;
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: c_ulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
    pub fn g_thread_get_initialized() -> gboolean;
    pub fn g_thread_init(vtable: gpointer);
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_yield();

    //=========================================================================
    // GThreadPool
    //=========================================================================
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> c_int;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> c_uint;
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> c_uint;
    pub fn g_thread_pool_get_max_idle_time() -> c_uint;
    pub fn g_thread_pool_get_max_unused_threads() -> c_int;
    pub fn g_thread_pool_get_num_unused_threads() -> c_uint;
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: c_int,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: c_int,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
    pub fn g_thread_pool_set_max_idle_time(interval: c_uint);
    pub fn g_thread_pool_set_max_unused_threads(max_threads: c_int);
    pub fn g_thread_pool_stop_unused_threads();

    //=========================================================================
    // GTimeVal
    //=========================================================================
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: c_long);
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut c_char;
    pub fn g_time_val_from_iso8601(iso_date: *const c_char, time_: *mut GTimeVal) -> gboolean;

    //=========================================================================
    // GTimeZone
    //=========================================================================
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_time_zone_new(identifier: *const c_char) -> *mut GTimeZone;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_time_zone_new_identifier(identifier: *const c_char) -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_time_zone_new_offset(seconds: i32) -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, type_: GTimeType, time_: *mut i64) -> c_int;
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: i64) -> c_int;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: c_int) -> *const c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const c_char;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: c_int) -> i32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: c_int) -> gboolean;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);

    //=========================================================================
    // GTimer
    //=========================================================================
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut c_ulong) -> c_double;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_new() -> *mut GTimer;

    //=========================================================================
    // GTrashStack
    //=========================================================================
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> c_uint;
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);

    //=========================================================================
    // GTree
    //=========================================================================
    pub fn g_tree_get_type() -> GType;
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
    pub fn g_tree_height(tree: *mut GTree) -> c_int;
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
    pub fn g_tree_nnodes(tree: *mut GTree) -> c_int;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_tree_remove_all(tree: *mut GTree);
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
    pub fn g_tree_unref(tree: *mut GTree);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;

    //=========================================================================
    // GTreeNode
    //=========================================================================
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;

    //=========================================================================
    // GTuples
    //=========================================================================
    pub fn g_tuples_destroy(tuples: *mut GTuples);
    pub fn g_tuples_index(tuples: *mut GTuples, index_: c_int, field: c_int) -> gpointer;

    //=========================================================================
    // GUri
    //=========================================================================
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_type() -> GType;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_host(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_password(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_path(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_port(uri: *mut GUri) -> c_int;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_query(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_user(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const c_char,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_to_string_partial(uri: *mut GUri, flags: GUriHideFlags) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_unref(uri: *mut GUri);
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const c_char,
        userinfo: *const c_char,
        host: *const c_char,
        port: c_int,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut GUri;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const c_char,
        user: *const c_char,
        password: *const c_char,
        auth_params: *const c_char,
        host: *const c_char,
        port: c_int,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut GUri;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_error_quark() -> GQuark;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_escape_bytes(
        unescaped: *const u8,
        length: size_t,
        reserved_chars_allowed: *const c_char,
    ) -> *mut c_char;
    pub fn g_uri_escape_string(
        unescaped: *const c_char,
        reserved_chars_allowed: *const c_char,
        allow_utf8: gboolean,
    ) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_is_valid(
        uri_string: *const c_char,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const c_char,
        userinfo: *const c_char,
        host: *const c_char,
        port: c_int,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const c_char,
        user: *const c_char,
        password: *const c_char,
        auth_params: *const c_char,
        host: *const c_char,
        port: c_int,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut c_char;
    pub fn g_uri_list_extract_uris(uri_list: *const c_char) -> *mut *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_parse(
        uri_string: *const c_char,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_parse_params(
        params: *const c_char,
        length: ssize_t,
        separators: *const c_char,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
    pub fn g_uri_parse_scheme(uri: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_peek_scheme(uri: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_resolve_relative(
        base_uri_string: *const c_char,
        uri_ref: *const c_char,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut c_char;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_split(
        uri_ref: *const c_char,
        flags: GUriFlags,
        scheme: *mut *mut c_char,
        userinfo: *mut *mut c_char,
        host: *mut *mut c_char,
        port: *mut c_int,
        path: *mut *mut c_char,
        query: *mut *mut c_char,
        fragment: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_split_network(
        uri_string: *const c_char,
        flags: GUriFlags,
        scheme: *mut *mut c_char,
        host: *mut *mut c_char,
        port: *mut c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_split_with_user(
        uri_ref: *const c_char,
        flags: GUriFlags,
        scheme: *mut *mut c_char,
        user: *mut *mut c_char,
        password: *mut *mut c_char,
        auth_params: *mut *mut c_char,
        host: *mut *mut c_char,
        port: *mut c_int,
        path: *mut *mut c_char,
        query: *mut *mut c_char,
        fragment: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_unescape_bytes(
        escaped_string: *const c_char,
        length: ssize_t,
        illegal_characters: *const c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
    pub fn g_uri_unescape_segment(
        escaped_string: *const c_char,
        escaped_string_end: *const c_char,
        illegal_characters: *const c_char,
    ) -> *mut c_char;
    pub fn g_uri_unescape_string(
        escaped_string: *const c_char,
        illegal_characters: *const c_char,
    ) -> *mut c_char;

    //=========================================================================
    // GUriParamsIter
    //=========================================================================
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const c_char,
        length: ssize_t,
        separators: *const c_char,
        flags: GUriParamsFlags,
    );
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut c_char,
        value: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;

    //=========================================================================
    // GVariant
    //=========================================================================
    pub fn g_variant_new(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: size_t,
    ) -> *mut GVariant;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: u8) -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *const u8) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(
        strv: *const *const c_char,
        length: ssize_t,
    ) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_double(value: c_double) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: size_t,
        element_size: size_t,
    ) -> *mut GVariant;
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: size_t,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
    pub fn g_variant_new_handle(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int16(value: i16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: i64) -> *mut GVariant;
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *const *const c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const c_char, ...) -> *mut GVariant;
    //pub fn g_variant_new_parsed_va(format: *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    pub fn g_variant_new_printf(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_signature(signature: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *const *const c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_take_string(string: *mut c_char) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: size_t)
        -> *mut GVariant;
    pub fn g_variant_new_uint16(value: u16) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: u32) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: u64) -> *mut GVariant;
    //pub fn g_variant_new_va(format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const c_char,
        copy_only: gboolean,
    ) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> c_int;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut size_t) -> *mut u8;
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut size_t,
    ) -> *mut *mut c_char;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut size_t) -> *mut c_char;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
    pub fn g_variant_get(value: *mut GVariant, format_string: *const c_char, ...);
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> u8;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const u8;
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut size_t,
    ) -> *mut *const c_char;
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: size_t,
        format_string: *const c_char,
        ...
    );
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: size_t) -> *mut GVariant;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_get_double(value: *mut GVariant) -> c_double;
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut size_t,
        element_size: size_t,
    ) -> gconstpointer;
    pub fn g_variant_get_handle(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int16(value: *mut GVariant) -> i16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> i64;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut size_t) -> *mut *const c_char;
    pub fn g_variant_get_size(value: *mut GVariant) -> size_t;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut size_t) -> *const c_char;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut size_t) -> *mut *const c_char;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const c_char;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> u16;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> u32;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> u64;
    //pub fn g_variant_get_va(value: *mut GVariant, format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list);
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_hash(value: gconstpointer) -> c_uint;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const c_char,
        format_string: *const c_char,
        ...
    ) -> gboolean;
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const c_char,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> size_t;
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut c_char;
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_is_object_path(string: *const c_char) -> gboolean;
    pub fn g_variant_is_signature(string: *const c_char) -> gboolean;
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const c_char,
        limit: *const c_char,
        endptr: *mut *const c_char,
        error: *mut *mut GError,
    ) -> *mut GVariant;
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const c_char,
    ) -> *mut c_char;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_parser_get_error_quark() -> GQuark;

    //=========================================================================
    // GVariantBuilder
    //=========================================================================
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const c_char, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const c_char, ...);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
    #[cfg(feature = "v2_84")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_84")))]
    pub fn g_variant_builder_init_static(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);

    //=========================================================================
    // GVariantDict
    //=========================================================================
    pub fn g_variant_dict_get_type() -> GType;
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const c_char,
        format_string: *const c_char,
        ...
    );
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const c_char,
        value: *mut GVariant,
    );
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const c_char,
        format_string: *const c_char,
        ...
    ) -> gboolean;
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const c_char,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);

    //=========================================================================
    // GVariantIter
    //=========================================================================
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> size_t;
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const c_char,
        ...
    ) -> gboolean;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> size_t;
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const c_char,
        ...
    ) -> gboolean;
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;

    //=========================================================================
    // GVariantType
    //=========================================================================
    pub fn g_variant_type_get_gtype() -> GType;
    pub fn g_variant_type_new(type_string: *const c_char) -> *mut GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: c_int,
    ) -> *mut GVariantType;
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut c_char;
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_free(type_: *mut GVariantType);
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_hash(type_: gconstpointer) -> c_uint;
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const c_char;
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_checked_(type_string: *const c_char) -> *const GVariantType;
    pub fn g_variant_type_string_get_depth_(type_string: *const c_char) -> size_t;
    pub fn g_variant_type_string_is_valid(type_string: *const c_char) -> gboolean;
    pub fn g_variant_type_string_scan(
        string: *const c_char,
        limit: *const c_char,
        endptr: *mut *const c_char,
    ) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_access(filename: *const c_char, mode: c_int) -> c_int;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_aligned_alloc(n_blocks: size_t, n_block_bytes: size_t, alignment: size_t) -> gpointer;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_aligned_alloc0(n_blocks: size_t, n_block_bytes: size_t, alignment: size_t)
        -> gpointer;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_aligned_free(mem: gpointer);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_aligned_free_sized(mem: gpointer, alignment: size_t, size: size_t);
    pub fn g_ascii_digit_value(c: c_char) -> c_int;
    pub fn g_ascii_dtostr(buffer: *mut c_char, buf_len: c_int, d: c_double) -> *mut c_char;
    pub fn g_ascii_formatd(
        buffer: *mut c_char,
        buf_len: c_int,
        format: *const c_char,
        d: c_double,
    ) -> *mut c_char;
    pub fn g_ascii_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_ascii_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_ascii_string_to_signed(
        str: *const c_char,
        base: c_uint,
        min: i64,
        max: i64,
        out_num: *mut i64,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_ascii_string_to_unsigned(
        str: *const c_char,
        base: c_uint,
        min: u64,
        max: u64,
        out_num: *mut u64,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_ascii_strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;
    pub fn g_ascii_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_ascii_strtoll(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> i64;
    pub fn g_ascii_strtoull(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> u64;
    pub fn g_ascii_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_ascii_tolower(c: c_char) -> c_char;
    pub fn g_ascii_toupper(c: c_char) -> c_char;
    pub fn g_ascii_xdigit_value(c: c_char) -> c_int;
    pub fn g_assert_warning(
        log_domain: *const c_char,
        file: *const c_char,
        line: c_int,
        pretty_function: *const c_char,
        expression: *const c_char,
    );
    pub fn g_assertion_message(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        message: *const c_char,
    );
    #[cfg(feature = "v2_78")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_78")))]
    pub fn g_assertion_message_cmpint(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        expr: *const c_char,
        arg1: u64,
        cmp: *const c_char,
        arg2: u64,
        numtype: c_char,
    );
    //pub fn g_assertion_message_cmpnum(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, arg1: /*Unimplemented*/long double, cmp: *const c_char, arg2: /*Unimplemented*/long double, numtype: c_char);
    pub fn g_assertion_message_cmpstr(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        expr: *const c_char,
        arg1: *const c_char,
        cmp: *const c_char,
        arg2: *const c_char,
    );
    pub fn g_assertion_message_cmpstrv(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        expr: *const c_char,
        arg1: *const *const c_char,
        arg2: *const *const c_char,
        first_wrong_idx: size_t,
    );
    pub fn g_assertion_message_error(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        expr: *const c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: c_int,
    );
    pub fn g_assertion_message_expr(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        expr: *const c_char,
    );
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_atomic_int_add(atomic: *mut gint, val: c_int) -> c_int;
    pub fn g_atomic_int_and(atomic: *mut guint, val: c_uint) -> c_uint;
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: c_int,
        newval: c_int,
    ) -> gboolean;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: c_int,
        newval: c_int,
        preval: *mut c_int,
    ) -> gboolean;
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: c_int) -> c_int;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: c_int) -> c_int;
    pub fn g_atomic_int_inc(atomic: *mut gint);
    pub fn g_atomic_int_or(atomic: *mut guint, val: c_uint) -> c_uint;
    pub fn g_atomic_int_set(atomic: *mut gint, newval: c_int);
    pub fn g_atomic_int_xor(atomic: *mut guint, val: c_uint) -> c_uint;
    pub fn g_atomic_pointer_add(atomic: *mut c_void, val: ssize_t) -> intptr_t;
    pub fn g_atomic_pointer_and(atomic: *mut c_void, val: size_t) -> uintptr_t;
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut c_void,
    ) -> gboolean;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_atomic_pointer_exchange(atomic: *mut c_void, newval: gpointer) -> gpointer;
    pub fn g_atomic_pointer_get(atomic: *mut c_void) -> gpointer;
    pub fn g_atomic_pointer_or(atomic: *mut c_void, val: size_t) -> uintptr_t;
    pub fn g_atomic_pointer_set(atomic: *mut c_void, newval: gpointer);
    pub fn g_atomic_pointer_xor(atomic: *mut c_void, val: size_t) -> uintptr_t;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_alloc(block_size: size_t) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_alloc0(block_size: size_t) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_dup(block_size: size_t, mem_block: gconstpointer) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> size_t;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_ref_count_compare(arc: *mut c_int, val: c_int) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_ref_count_dec(arc: *mut c_int) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_ref_count_inc(arc: *mut c_int);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_atomic_ref_count_init(arc: *mut c_int);
    pub fn g_base64_decode(text: *const c_char, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_inplace(text: *mut u8, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_step(
        in_: *const u8,
        len: size_t,
        out: *mut u8,
        state: *mut c_int,
        save: *mut c_uint,
    ) -> size_t;
    pub fn g_base64_encode(data: *const u8, len: size_t) -> *mut c_char;
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut u8,
        state: *mut c_int,
        save: *mut c_int,
    ) -> size_t;
    pub fn g_base64_encode_step(
        in_: *const u8,
        len: size_t,
        break_lines: gboolean,
        out: *mut u8,
        state: *mut c_int,
        save: *mut c_int,
    ) -> size_t;
    pub fn g_basename(file_name: *const c_char) -> *const c_char;
    pub fn g_bit_lock(address: *mut gint, lock_bit: c_int);
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_bit_lock_and_get(address: *mut gint, lock_bit: c_uint, out_val: *mut c_int);
    pub fn g_bit_nth_lsf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_nth_msf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_storage(number: c_ulong) -> c_uint;
    pub fn g_bit_trylock(address: *mut gint, lock_bit: c_int) -> gboolean;
    pub fn g_bit_unlock(address: *mut gint, lock_bit: c_int);
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_bit_unlock_and_set(
        address: *mut gint,
        lock_bit: c_uint,
        new_val: c_int,
        preserve_mask: c_int,
    );
    pub fn g_build_filename(first_element: *const c_char, ...) -> *mut c_char;
    //pub fn g_build_filename_valist(first_element: *const c_char, args: /*Unimplemented*/*mut va_list) -> *mut c_char;
    pub fn g_build_filenamev(args: *mut *mut c_char) -> *mut c_char;
    pub fn g_build_path(separator: *const c_char, first_element: *const c_char, ...)
        -> *mut c_char;
    pub fn g_build_pathv(separator: *const c_char, args: *mut *mut c_char) -> *mut c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_canonicalize_filename(
        filename: *const c_char,
        relative_to: *const c_char,
    ) -> *mut c_char;
    pub fn g_chdir(path: *const c_char) -> c_int;
    pub fn glib_check_version(
        required_major: c_uint,
        required_minor: c_uint,
        required_micro: c_uint,
    ) -> *const c_char;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> c_uint;
    pub fn g_child_watch_add_full(
        priority: c_int,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_clear_error(error: *mut *mut GError);
    pub fn g_clear_handle_id(tag_ptr: *mut c_uint, clear_func: GClearHandleFunc);
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
    pub fn g_close(fd: c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_closefrom(lowfd: c_int) -> c_int;
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut c_char;
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const u8,
        length: size_t,
    ) -> *mut c_char;
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str: *const c_char,
        length: ssize_t,
    ) -> *mut c_char;
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut c_char;
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const u8,
        key_len: size_t,
        data: *const u8,
        length: size_t,
    ) -> *mut c_char;
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const u8,
        key_len: size_t,
        str: *const c_char,
        length: ssize_t,
    ) -> *mut c_char;
    pub fn g_convert(
        str: *const u8,
        len: ssize_t,
        to_codeset: *const c_char,
        from_codeset: *const c_char,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut u8;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_convert_with_fallback(
        str: *const u8,
        len: ssize_t,
        to_codeset: *const c_char,
        from_codeset: *const c_char,
        fallback: *const c_char,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut u8;
    pub fn g_convert_with_iconv(
        str: *const u8,
        len: ssize_t,
        converter: GIConv,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut u8;
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const c_char) -> gpointer;
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> c_uint;
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: size_t,
    );
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
    pub fn g_dcgettext(
        domain: *const c_char,
        msgid: *const c_char,
        category: c_int,
    ) -> *const c_char;
    pub fn g_dgettext(domain: *const c_char, msgid: *const c_char) -> *const c_char;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_direct_hash(v: gconstpointer) -> c_uint;
    pub fn g_dngettext(
        domain: *const c_char,
        msgid: *const c_char,
        msgid_plural: *const c_char,
        n: c_ulong,
    ) -> *const c_char;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> c_uint;
    pub fn g_dpgettext(
        domain: *const c_char,
        msgctxtid: *const c_char,
        msgidoffset: size_t,
    ) -> *const c_char;
    pub fn g_dpgettext2(
        domain: *const c_char,
        context: *const c_char,
        msgid: *const c_char,
    ) -> *const c_char;
    pub fn g_environ_getenv(envp: *mut *mut c_char, variable: *const c_char) -> *const c_char;
    pub fn g_environ_setenv(
        envp: *mut *mut c_char,
        variable: *const c_char,
        value: *const c_char,
        overwrite: gboolean,
    ) -> *mut *mut c_char;
    pub fn g_environ_unsetenv(envp: *mut *mut c_char, variable: *const c_char) -> *mut *mut c_char;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_fdwalk_set_cloexec(lowfd: c_int) -> c_int;
    pub fn g_file_error_from_errno(err_no: c_int) -> GFileError;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_get_contents(
        filename: *const c_char,
        contents: *mut *mut u8,
        length: *mut size_t,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_file_open_tmp(
        tmpl: *const c_char,
        name_used: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> c_int;
    pub fn g_file_read_link(filename: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_file_set_contents(
        filename: *const c_char,
        contents: *const u8,
        length: ssize_t,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_file_set_contents_full(
        filename: *const c_char,
        contents: *const u8,
        length: ssize_t,
        flags: GFileSetContentsFlags,
        mode: c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_file_test(filename: *const c_char, test: GFileTest) -> gboolean;
    pub fn g_filename_display_basename(filename: *const c_char) -> *mut c_char;
    pub fn g_filename_display_name(filename: *const c_char) -> *mut c_char;
    pub fn g_filename_from_uri(
        uri: *const c_char,
        hostname: *mut *mut c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_filename_from_utf8(
        utf8string: *const c_char,
        len: ssize_t,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_filename_to_uri(
        filename: *const c_char,
        hostname: *const c_char,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_filename_to_utf8(
        opsysstring: *const c_char,
        len: ssize_t,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_find_program_in_path(program: *const c_char) -> *mut c_char;
    pub fn g_format_size(size: u64) -> *mut c_char;
    pub fn g_format_size_for_display(size: i64) -> *mut c_char;
    pub fn g_format_size_full(size: u64, flags: GFormatSizeFlags) -> *mut c_char;
    pub fn g_fprintf(file: *mut FILE, format: *const c_char, ...) -> c_int;
    pub fn g_free(mem: gpointer);
    #[cfg(feature = "v2_76")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_76")))]
    pub fn g_free_sized(mem: gpointer, size: size_t);
    pub fn g_get_application_name() -> *const c_char;
    pub fn g_get_charset(charset: *mut *const c_char) -> gboolean;
    pub fn g_get_codeset() -> *mut c_char;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_get_console_charset(charset: *mut *const c_char) -> gboolean;
    pub fn g_get_current_dir() -> *mut c_char;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_environ() -> *mut *mut c_char;
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const c_char) -> gboolean;
    pub fn g_get_home_dir() -> *const c_char;
    pub fn g_get_host_name() -> *const c_char;
    pub fn g_get_language_names() -> *const *const c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_get_language_names_with_category(category_name: *const c_char)
        -> *const *const c_char;
    pub fn g_get_locale_variants(locale: *const c_char) -> *mut *mut c_char;
    pub fn g_get_monotonic_time() -> i64;
    pub fn g_get_num_processors() -> c_uint;
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_get_os_info(key_name: *const c_char) -> *mut c_char;
    pub fn g_get_prgname() -> *const c_char;
    pub fn g_get_real_name() -> *const c_char;
    pub fn g_get_real_time() -> i64;
    pub fn g_get_system_config_dirs() -> *const *const c_char;
    pub fn g_get_system_data_dirs() -> *const *const c_char;
    pub fn g_get_tmp_dir() -> *const c_char;
    pub fn g_get_user_cache_dir() -> *const c_char;
    pub fn g_get_user_config_dir() -> *const c_char;
    pub fn g_get_user_data_dir() -> *const c_char;
    pub fn g_get_user_name() -> *const c_char;
    pub fn g_get_user_runtime_dir() -> *const c_char;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const c_char;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_get_user_state_dir() -> *const c_char;
    pub fn g_getenv(variable: *const c_char) -> *const c_char;
    pub fn g_hostname_is_ascii_encoded(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_non_ascii(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const c_char) -> *mut c_char;
    pub fn g_hostname_to_unicode(hostname: *const c_char) -> *mut c_char;
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut c_char,
        inbytes_left: *mut size_t,
        outbuf: *mut *mut c_char,
        outbytes_left: *mut size_t,
    ) -> size_t;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_idle_add_full(
        priority: c_int,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> c_uint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> c_uint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> c_uint;
    pub fn g_intern_static_string(string: *const c_char) -> *const c_char;
    pub fn g_intern_string(string: *const c_char) -> *const c_char;
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: c_int,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
    pub fn g_listenv() -> *mut *mut c_char;
    pub fn g_locale_from_utf8(
        utf8string: *const c_char,
        len: ssize_t,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut u8;
    pub fn g_locale_to_utf8(
        opsysstring: *const u8,
        len: ssize_t,
        bytes_read: *mut size_t,
        bytes_written: *mut size_t,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_log(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, ...);
    pub fn g_log_default_handler(
        log_domain: *const c_char,
        log_level: GLogLevelFlags,
        message: *const c_char,
        unused_data: gpointer,
    );
    #[cfg(feature = "v2_86")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_86")))]
    pub fn g_log_get_always_fatal() -> GLogLevelFlags;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_log_get_debug_enabled() -> gboolean;
    pub fn g_log_remove_handler(log_domain: *const c_char, handler_id: c_uint);
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_log_set_debug_enabled(enabled: gboolean);
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
    pub fn g_log_set_fatal_mask(
        log_domain: *const c_char,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
    pub fn g_log_set_handler(
        log_domain: *const c_char,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_log_set_handler_full(
        log_domain: *const c_char,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> c_uint;
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
    pub fn g_log_structured(log_domain: *const c_char, log_level: GLogLevelFlags, ...);
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
    );
    pub fn g_log_structured_standard(
        log_domain: *const c_char,
        log_level: GLogLevelFlags,
        file: *const c_char,
        line: *const c_char,
        func: *const c_char,
        message_format: *const c_char,
        ...
    );
    pub fn g_log_variant(
        log_domain: *const c_char,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_log_writer_default_set_debug_domains(domains: *const *const c_char);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const c_char,
    ) -> gboolean;
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
        use_color: gboolean,
    ) -> *mut c_char;
    pub fn g_log_writer_is_journald(output_fd: c_int) -> gboolean;
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    pub fn g_log_writer_supports_color(output_fd: c_int) -> gboolean;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_log_writer_syslog(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: size_t,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    //pub fn g_logv(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_depth() -> c_int;
    pub fn g_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_markup_collect_attributes(
        element_name: *const c_char,
        attribute_names: *mut *const c_char,
        attribute_values: *mut *const c_char,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const c_char,
        ...
    ) -> gboolean;
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_escape_text(text: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn g_markup_printf_escaped(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_markup_vprintf_escaped(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_memdup(mem: gconstpointer, byte_size: c_uint) -> gpointer;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_memdup2(mem: gconstpointer, byte_size: size_t) -> gpointer;
    pub fn g_mkdir_with_parents(pathname: *const c_char, mode: c_int) -> c_int;
    pub fn g_mkdtemp(tmpl: *mut c_char) -> *mut c_char;
    pub fn g_mkdtemp_full(tmpl: *mut c_char, mode: c_int) -> *mut c_char;
    pub fn g_mkstemp(tmpl: *mut c_char) -> c_int;
    pub fn g_mkstemp_full(tmpl: *mut c_char, flags: c_int, mode: c_int) -> c_int;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_number_parser_error_quark() -> GQuark;
    pub fn g_on_error_query(prg_name: *const c_char);
    pub fn g_on_error_stack_trace(prg_name: *const c_char);
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_parse_debug_string(
        string: *const c_char,
        keys: *const GDebugKey,
        nkeys: c_uint,
    ) -> c_uint;
    pub fn g_path_get_basename(file_name: *const c_char) -> *mut c_char;
    pub fn g_path_get_dirname(file_name: *const c_char) -> *mut c_char;
    pub fn g_path_is_absolute(file_name: *const c_char) -> gboolean;
    pub fn g_path_skip_root(file_name: *const c_char) -> *const c_char;
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: c_uint,
        string: *const c_char,
        string_reversed: *const c_char,
    ) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const c_char, string: *const c_char) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const c_char) -> gboolean;
    pub fn g_pointer_bit_lock(address: *mut c_void, lock_bit: c_int);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_pointer_bit_lock_and_get(address: gpointer, lock_bit: c_uint, out_ptr: *mut uintptr_t);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_pointer_bit_lock_mask_ptr(
        ptr: gpointer,
        lock_bit: c_uint,
        set: gboolean,
        preserve_mask: uintptr_t,
        preserve_ptr: gpointer,
    ) -> gpointer;
    pub fn g_pointer_bit_trylock(address: *mut c_void, lock_bit: c_int) -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut c_void, lock_bit: c_int);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_pointer_bit_unlock_and_set(
        address: *mut c_void,
        lock_bit: c_uint,
        ptr: gpointer,
        preserve_mask: uintptr_t,
    );
    pub fn g_poll(fds: *mut GPollFD, nfds: c_uint, timeout: c_int) -> c_int;
    pub fn g_prefix_error(err: *mut *mut GError, format: *const c_char, ...);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const c_char);
    pub fn g_print(format: *const c_char, ...);
    pub fn g_printerr(format: *const c_char, ...);
    pub fn g_printf(format: *const c_char, ...) -> c_int;
    //pub fn g_printf_string_upper_bound(format: *const c_char, args: /*Unimplemented*/va_list) -> size_t;
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const c_char,
        ...
    );
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: c_int,
        size: size_t,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_quark_from_static_string(string: *const c_char) -> GQuark;
    pub fn g_quark_from_string(string: *const c_char) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const c_char;
    pub fn g_quark_try_string(string: *const c_char) -> GQuark;
    pub fn g_random_double() -> c_double;
    pub fn g_random_double_range(begin: c_double, end: c_double) -> c_double;
    pub fn g_random_int() -> u32;
    pub fn g_random_int_range(begin: i32, end: i32) -> i32;
    pub fn g_random_set_seed(seed: u32);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_alloc(block_size: size_t) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_alloc0(block_size: size_t) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_dup(block_size: size_t, mem_block: gconstpointer) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_get_size(mem_block: gpointer) -> size_t;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_release(mem_block: gpointer);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
    pub fn g_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_count_compare(rc: *mut c_int, val: c_int) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_count_dec(rc: *mut c_int) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_count_inc(rc: *mut c_int);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_count_init(rc: *mut c_int);
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_acquire(str: *mut c_char) -> *mut c_char;
    #[cfg(feature = "v2_84")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_84")))]
    pub fn g_ref_string_equal(str1: *const c_char, str2: *const c_char) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_length(str: *mut c_char) -> size_t;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_new(str: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_new_intern(str: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_new_len(str: *const c_char, len: ssize_t) -> *mut c_char;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_ref_string_release(str: *mut c_char);
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_return_if_fail_warning(
        log_domain: *const c_char,
        pretty_function: *const c_char,
        expression: *const c_char,
    );
    pub fn g_rmdir(filename: *const c_char) -> c_int;
    pub fn g_set_application_name(application_name: *const c_char);
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: c_int,
        format: *const c_char,
        ...
    );
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: c_int,
        message: *const c_char,
    );
    pub fn g_set_prgname(prgname: *const c_char);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_setenv(variable: *const c_char, value: *const c_char, overwrite: gboolean)
        -> gboolean;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_parse_argv(
        command_line: *const c_char,
        argcp: *mut c_int,
        argvp: *mut *mut *mut c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_shell_quote(unquoted_string: *const c_char) -> *mut c_char;
    pub fn g_shell_unquote(quoted_string: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_slice_alloc(block_size: size_t) -> gpointer;
    pub fn g_slice_alloc0(block_size: size_t) -> gpointer;
    pub fn g_slice_copy(block_size: size_t, mem_block: gconstpointer) -> gpointer;
    pub fn g_slice_free1(block_size: size_t, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(
        block_size: size_t,
        mem_chain: gpointer,
        next_offset: size_t,
    );
    pub fn g_slice_get_config(ckey: GSliceConfig) -> i64;
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: i64,
        n_values: *mut c_uint,
    ) -> *mut i64;
    pub fn g_slice_set_config(ckey: GSliceConfig, value: i64);
    pub fn g_snprintf(string: *mut c_char, n: c_ulong, format: *const c_char, ...) -> c_int;
    #[cfg(feature = "v2_82")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_82")))]
    pub fn g_sort_array(
        array: *mut c_void,
        n_elements: size_t,
        element_size: size_t,
        compare_func: GCompareDataFunc,
        user_data: *mut c_void,
    );
    pub fn g_spaced_primes_closest(num: c_uint) -> c_uint;
    pub fn g_spawn_async(
        working_directory: *const c_char,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_58")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_58")))]
    pub fn g_spawn_async_with_fds(
        working_directory: *const c_char,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: c_int,
        stdout_fd: c_int,
        stderr_fd: c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_async_with_pipes(
        working_directory: *const c_char,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut c_int,
        standard_output: *mut c_int,
        standard_error: *mut c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const c_char,
        argv: *const *const c_char,
        envp: *const *const c_char,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: c_int,
        stdout_fd: c_int,
        stderr_fd: c_int,
        source_fds: *const c_int,
        target_fds: *const c_int,
        n_fds: size_t,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut c_int,
        stdout_pipe_out: *mut c_int,
        stderr_pipe_out: *mut c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_check_exit_status(wait_status: c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_spawn_check_wait_status(wait_status: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub fn g_spawn_command_line_async(
        command_line: *const c_char,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_command_line_sync(
        command_line: *const c_char,
        standard_output: *mut *mut u8,
        standard_error: *mut *mut u8,
        wait_status: *mut c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_sync(
        working_directory: *const c_char,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut u8,
        standard_error: *mut *mut u8,
        wait_status: *mut c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_sprintf(string: *mut c_char, format: *const c_char, ...) -> c_int;
    pub fn g_stat(filename: *const c_char, buf: *mut GStatBuf) -> c_int;
    pub fn g_stpcpy(dest: *mut c_char, src: *const c_char) -> *mut c_char;
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_has_prefix(str: *const c_char, prefix: *const c_char) -> gboolean;
    pub fn g_str_has_suffix(str: *const c_char, suffix: *const c_char) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> c_uint;
    pub fn g_str_is_ascii(str: *const c_char) -> gboolean;
    pub fn g_str_match_string(
        search_term: *const c_char,
        potential_hit: *const c_char,
        accept_alternates: gboolean,
    ) -> gboolean;
    pub fn g_str_to_ascii(str: *const c_char, from_locale: *const c_char) -> *mut c_char;
    pub fn g_str_tokenize_and_fold(
        string: *const c_char,
        translit_locale: *const c_char,
        ascii_alternates: *mut *mut *mut c_char,
    ) -> *mut *mut c_char;
    pub fn g_strcanon(
        string: *mut c_char,
        valid_chars: *const c_char,
        substitutor: c_char,
    ) -> *mut c_char;
    pub fn g_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_strchomp(string: *mut c_char) -> *mut c_char;
    pub fn g_strchug(string: *mut c_char) -> *mut c_char;
    pub fn g_strcmp0(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_strcompress(source: *const c_char) -> *mut c_char;
    pub fn g_strconcat(string1: *const c_char, ...) -> *mut c_char;
    pub fn g_strdelimit(
        string: *mut c_char,
        delimiters: *const c_char,
        new_delimiter: c_char,
    ) -> *mut c_char;
    pub fn g_strdown(string: *mut c_char) -> *mut c_char;
    pub fn g_strdup(str: *const c_char) -> *mut c_char;
    pub fn g_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_strdupv(str_array: *mut *mut c_char) -> *mut *mut c_char;
    pub fn g_strerror(errnum: c_int) -> *const c_char;
    pub fn g_strescape(source: *const c_char, exceptions: *const c_char) -> *mut c_char;
    pub fn g_strfreev(str_array: *mut *mut c_char);
    pub fn g_strip_context(msgid: *const c_char, msgval: *const c_char) -> *const c_char;
    pub fn g_strjoin(separator: *const c_char, ...) -> *mut c_char;
    pub fn g_strjoinv(separator: *const c_char, str_array: *mut *mut c_char) -> *mut c_char;
    pub fn g_strlcat(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strlcpy(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strncasecmp(s1: *const c_char, s2: *const c_char, n: c_uint) -> c_int;
    pub fn g_strndup(str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_strnfill(length: size_t, fill_char: c_char) -> *mut c_char;
    pub fn g_strreverse(string: *mut c_char) -> *mut c_char;
    pub fn g_strrstr(haystack: *const c_char, needle: *const c_char) -> *mut c_char;
    pub fn g_strrstr_len(
        haystack: *const c_char,
        haystack_len: ssize_t,
        needle: *const c_char,
    ) -> *mut c_char;
    pub fn g_strsignal(signum: c_int) -> *const c_char;
    pub fn g_strsplit(
        string: *const c_char,
        delimiter: *const c_char,
        max_tokens: c_int,
    ) -> *mut *mut c_char;
    pub fn g_strsplit_set(
        string: *const c_char,
        delimiters: *const c_char,
        max_tokens: c_int,
    ) -> *mut *mut c_char;
    pub fn g_strstr_len(
        haystack: *const c_char,
        haystack_len: ssize_t,
        needle: *const c_char,
    ) -> *mut c_char;
    pub fn g_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_strup(string: *mut c_char) -> *mut c_char;
    pub fn g_strv_contains(strv: *const *const c_char, str: *const c_char) -> gboolean;
    #[cfg(feature = "v2_60")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_60")))]
    pub fn g_strv_equal(strv1: *const *const c_char, strv2: *const *const c_char) -> gboolean;
    pub fn g_strv_get_type() -> GType;
    pub fn g_strv_length(str_array: *mut *mut c_char) -> c_uint;
    pub fn g_test_add_data_func(
        testpath: *const c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
    pub fn g_test_add_data_func_full(
        testpath: *const c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
    pub fn g_test_add_func(testpath: *const c_char, test_func: GTestFunc);
    pub fn g_test_add_vtable(
        testpath: *const c_char,
        data_size: size_t,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
    pub fn g_test_assert_expected_messages_internal(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
    );
    pub fn g_test_bug(bug_uri_snippet: *const c_char);
    pub fn g_test_bug_base(uri_pattern: *const c_char);
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const c_char,
        ...
    ) -> *mut c_char;
    pub fn g_test_create_case(
        test_name: *const c_char,
        data_size: size_t,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const c_char) -> *mut GTestSuite;
    #[cfg(feature = "v2_78")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_78")))]
    pub fn g_test_disable_crash_reporting();
    pub fn g_test_expect_message(
        log_domain: *const c_char,
        log_level: GLogLevelFlags,
        pattern: *const c_char,
    );
    pub fn g_test_fail();
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_test_fail_printf(format: *const c_char, ...);
    pub fn g_test_failed() -> gboolean;
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const c_char;
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const c_char,
        ...
    ) -> *const c_char;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_test_get_path() -> *const c_char;
    pub fn g_test_get_root() -> *mut GTestSuite;
    pub fn g_test_incomplete(msg: *const c_char);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_test_incomplete_printf(format: *const c_char, ...);
    pub fn g_test_init(argc: *mut c_int, argv: *mut *mut *mut c_char, ...);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const c_char;
    pub fn g_test_maximized_result(maximized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_message(format: *const c_char, ...);
    pub fn g_test_minimized_result(minimized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_rand_double() -> c_double;
    pub fn g_test_rand_double_range(range_start: c_double, range_end: c_double) -> c_double;
    pub fn g_test_rand_int() -> i32;
    pub fn g_test_rand_int_range(begin: i32, end: i32) -> i32;
    pub fn g_test_run() -> c_int;
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> c_int;
    pub fn g_test_set_nonfatal_assertions();
    pub fn g_test_skip(msg: *const c_char);
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_test_skip_printf(format: *const c_char, ...);
    pub fn g_test_subprocess() -> gboolean;
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_test_summary(summary: *const c_char);
    pub fn g_test_timer_elapsed() -> c_double;
    pub fn g_test_timer_last() -> c_double;
    pub fn g_test_timer_start();
    pub fn g_test_trap_assertions(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        assertion_flags: u64,
        pattern: *const c_char,
    );
    pub fn g_test_trap_fork(usec_timeout: u64, test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    pub fn g_test_trap_subprocess(
        test_path: *const c_char,
        usec_timeout: u64,
        test_flags: GTestSubprocessFlags,
    );
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_test_trap_subprocess_with_envp(
        test_path: *const c_char,
        envp: *const *const c_char,
        usec_timeout: u64,
        test_flags: GTestSubprocessFlags,
    );
    pub fn g_timeout_add(interval: c_uint, function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_timeout_add_full(
        priority: c_int,
        interval: c_uint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_timeout_add_once(
        interval: c_uint,
        function: GSourceOnceFunc,
        data: gpointer,
    ) -> c_uint;
    pub fn g_timeout_add_seconds(interval: c_uint, function: GSourceFunc, data: gpointer)
        -> c_uint;
    pub fn g_timeout_add_seconds_full(
        priority: c_int,
        interval: c_uint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    #[cfg(feature = "v2_78")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_78")))]
    pub fn g_timeout_add_seconds_once(
        interval: c_uint,
        function: GSourceOnceFunc,
        data: gpointer,
    ) -> c_uint;
    pub fn g_timeout_source_new(interval: c_uint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: c_uint) -> *mut GSource;
    pub fn g_try_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_ucs4_to_utf16(
        str: *const u32,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut u16;
    pub fn g_ucs4_to_utf8(
        str: *const u32,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_unichar_break_type(c: u32) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: u32) -> c_int;
    pub fn g_unichar_compose(a: u32, b: u32, ch: *mut u32) -> gboolean;
    pub fn g_unichar_decompose(ch: u32, a: *mut u32, b: *mut u32) -> gboolean;
    pub fn g_unichar_digit_value(c: u32) -> c_int;
    pub fn g_unichar_fully_decompose(
        ch: u32,
        compat: gboolean,
        result: *mut u32,
        result_len: size_t,
    ) -> size_t;
    pub fn g_unichar_get_mirror_char(ch: u32, mirrored_ch: *mut u32) -> gboolean;
    pub fn g_unichar_get_script(ch: u32) -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: u32) -> gboolean;
    pub fn g_unichar_isalpha(c: u32) -> gboolean;
    pub fn g_unichar_iscntrl(c: u32) -> gboolean;
    pub fn g_unichar_isdefined(c: u32) -> gboolean;
    pub fn g_unichar_isdigit(c: u32) -> gboolean;
    pub fn g_unichar_isgraph(c: u32) -> gboolean;
    pub fn g_unichar_islower(c: u32) -> gboolean;
    pub fn g_unichar_ismark(c: u32) -> gboolean;
    pub fn g_unichar_isprint(c: u32) -> gboolean;
    pub fn g_unichar_ispunct(c: u32) -> gboolean;
    pub fn g_unichar_isspace(c: u32) -> gboolean;
    pub fn g_unichar_istitle(c: u32) -> gboolean;
    pub fn g_unichar_isupper(c: u32) -> gboolean;
    pub fn g_unichar_iswide(c: u32) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: u32) -> gboolean;
    pub fn g_unichar_isxdigit(c: u32) -> gboolean;
    pub fn g_unichar_iszerowidth(c: u32) -> gboolean;
    pub fn g_unichar_to_utf8(c: u32, outbuf: *mut c_char) -> c_int;
    pub fn g_unichar_tolower(c: u32) -> u32;
    pub fn g_unichar_totitle(c: u32) -> u32;
    pub fn g_unichar_toupper(c: u32) -> u32;
    pub fn g_unichar_type(c: u32) -> GUnicodeType;
    pub fn g_unichar_validate(ch: u32) -> gboolean;
    pub fn g_unichar_xdigit_value(c: u32) -> c_int;
    pub fn g_unicode_canonical_decomposition(ch: u32, result_len: *mut size_t) -> *mut u32;
    pub fn g_unicode_canonical_ordering(string: *mut u32, len: size_t);
    pub fn g_unix_error_quark() -> GQuark;
    pub fn g_unix_fd_add(
        fd: c_int,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_unix_fd_add_full(
        priority: c_int,
        fd: c_int,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    pub fn g_unix_fd_source_new(fd: c_int, condition: GIOCondition) -> *mut GSource;
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    #[cfg(unix)]
    #[cfg_attr(docsrs, doc(cfg(unix)))]
    pub fn g_unix_get_passwd_entry(
        user_name: *const c_char,
        error: *mut *mut GError,
    ) -> *mut passwd;
    pub fn g_unix_open_pipe(
        fds: *mut [c_int; 2],
        flags: c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_unix_set_fd_nonblocking(
        fd: c_int,
        nonblock: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_unix_signal_add(signum: c_int, handler: GSourceFunc, user_data: gpointer) -> c_uint;
    pub fn g_unix_signal_add_full(
        priority: c_int,
        signum: c_int,
        handler: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> c_uint;
    pub fn g_unix_signal_source_new(signum: c_int) -> *mut GSource;
    pub fn g_unlink(filename: *const c_char) -> c_int;
    pub fn g_unsetenv(variable: *const c_char);
    pub fn g_usleep(microseconds: c_ulong);
    pub fn g_utf16_to_ucs4(
        str: *const u16,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut u32;
    pub fn g_utf16_to_utf8(
        str: *const u16,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut c_char;
    pub fn g_utf8_casefold(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_utf8_collate_key(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate_key_for_filename(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_find_next_char(p: *const c_char, end: *const c_char) -> *mut c_char;
    pub fn g_utf8_find_prev_char(str: *const c_char, p: *const c_char) -> *mut c_char;
    pub fn g_utf8_get_char(p: *const c_char) -> u32;
    pub fn g_utf8_get_char_validated(p: *const c_char, max_len: ssize_t) -> u32;
    pub fn g_utf8_make_valid(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_normalize(str: *const c_char, len: ssize_t, mode: GNormalizeMode) -> *mut c_char;
    pub fn g_utf8_offset_to_pointer(str: *const c_char, offset: c_long) -> *mut c_char;
    pub fn g_utf8_pointer_to_offset(str: *const c_char, pos: *const c_char) -> c_long;
    pub fn g_utf8_prev_char(p: *const c_char) -> *mut c_char;
    pub fn g_utf8_strchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strlen(p: *const c_char, max: ssize_t) -> c_long;
    pub fn g_utf8_strncpy(dest: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_utf8_strrchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strreverse(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_substring(str: *const c_char, start_pos: c_long, end_pos: c_long) -> *mut c_char;
    pub fn g_utf8_to_ucs4(
        str: *const c_char,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut u32;
    pub fn g_utf8_to_ucs4_fast(
        str: *const c_char,
        len: c_long,
        items_written: *mut c_long,
    ) -> *mut u32;
    pub fn g_utf8_to_utf16(
        str: *const c_char,
        len: c_long,
        items_read: *mut c_long,
        items_written: *mut c_long,
        error: *mut *mut GError,
    ) -> *mut u16;
    #[cfg(feature = "v2_78")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_78")))]
    pub fn g_utf8_truncate_middle(string: *const c_char, truncate_length: size_t) -> *mut c_char;
    pub fn g_utf8_validate(str: *const u8, max_len: ssize_t, end: *mut *const u8) -> gboolean;
    #[cfg(feature = "v2_60")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_60")))]
    pub fn g_utf8_validate_len(str: *const u8, max_len: size_t, end: *mut *const u8) -> gboolean;
    pub fn g_uuid_string_is_valid(str: *const c_char) -> gboolean;
    pub fn g_uuid_string_random() -> *mut c_char;
    pub fn g_variant_get_gtype() -> GType;
    //pub fn g_vasprintf(string: *mut *mut c_char, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vfprintf(file: *mut FILE, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsnprintf(string: *mut c_char, n: c_ulong, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsprintf(string: *mut c_char, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn g_warn_message(
        domain: *const c_char,
        file: *const c_char,
        line: c_int,
        func: *const c_char,
        warnexpr: *const c_char,
    );

}
