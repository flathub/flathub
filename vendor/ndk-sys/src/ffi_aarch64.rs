/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BIONIC__: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __ANDROID_API_S__: u32 = 31;
pub const __ANDROID_API_T__: u32 = 33;
pub const __ANDROID_API_U__: u32 = 34;
pub const __ANDROID_API_V__: u32 = 35;
pub const WCHAR_MIN: u8 = 0u8;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __PRI_64_prefix: &[u8; 2] = b"l\0";
pub const __PRI_PTR_prefix: &[u8; 2] = b"l\0";
pub const __PRI_FAST_prefix: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIb8: &[u8; 2] = b"b\0";
pub const PRIb16: &[u8; 2] = b"b\0";
pub const PRIb32: &[u8; 2] = b"b\0";
pub const PRIb64: &[u8; 3] = b"lb\0";
pub const PRIbLEAST8: &[u8; 2] = b"b\0";
pub const PRIbLEAST16: &[u8; 2] = b"b\0";
pub const PRIbLEAST32: &[u8; 2] = b"b\0";
pub const PRIbLEAST64: &[u8; 3] = b"lb\0";
pub const PRIbFAST8: &[u8; 2] = b"b\0";
pub const PRIbFAST16: &[u8; 3] = b"lb\0";
pub const PRIbFAST32: &[u8; 3] = b"lb\0";
pub const PRIbFAST64: &[u8; 3] = b"lb\0";
pub const PRIbMAX: &[u8; 3] = b"jb\0";
pub const PRIbPTR: &[u8; 3] = b"lb\0";
pub const PRIB8: &[u8; 2] = b"B\0";
pub const PRIB16: &[u8; 2] = b"B\0";
pub const PRIB32: &[u8; 2] = b"B\0";
pub const PRIB64: &[u8; 3] = b"lB\0";
pub const PRIBLEAST8: &[u8; 2] = b"B\0";
pub const PRIBLEAST16: &[u8; 2] = b"B\0";
pub const PRIBLEAST32: &[u8; 2] = b"B\0";
pub const PRIBLEAST64: &[u8; 3] = b"lB\0";
pub const PRIBFAST8: &[u8; 2] = b"B\0";
pub const PRIBFAST16: &[u8; 3] = b"lB\0";
pub const PRIBFAST32: &[u8; 3] = b"lB\0";
pub const PRIBFAST64: &[u8; 3] = b"lB\0";
pub const PRIBMAX: &[u8; 3] = b"jB\0";
pub const PRIBPTR: &[u8; 3] = b"lB\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNb8: &[u8; 4] = b"hhb\0";
pub const SCNb16: &[u8; 3] = b"hb\0";
pub const SCNb32: &[u8; 2] = b"b\0";
pub const SCNb64: &[u8; 3] = b"lb\0";
pub const SCNbLEAST8: &[u8; 4] = b"hhb\0";
pub const SCNbLEAST16: &[u8; 3] = b"hb\0";
pub const SCNbLEAST32: &[u8; 2] = b"b\0";
pub const SCNbLEAST64: &[u8; 3] = b"lb\0";
pub const SCNbFAST8: &[u8; 4] = b"hhb\0";
pub const SCNbFAST16: &[u8; 3] = b"lb\0";
pub const SCNbFAST32: &[u8; 3] = b"lb\0";
pub const SCNbFAST64: &[u8; 3] = b"lb\0";
pub const SCNbMAX: &[u8; 3] = b"jb\0";
pub const SCNbPTR: &[u8; 3] = b"lb\0";
pub const SCNB8: &[u8; 4] = b"hhB\0";
pub const SCNB16: &[u8; 3] = b"hB\0";
pub const SCNB32: &[u8; 2] = b"B\0";
pub const SCNB64: &[u8; 3] = b"lB\0";
pub const SCNBLEAST8: &[u8; 4] = b"hhB\0";
pub const SCNBLEAST16: &[u8; 3] = b"hB\0";
pub const SCNBLEAST32: &[u8; 2] = b"B\0";
pub const SCNBLEAST64: &[u8; 3] = b"lB\0";
pub const SCNBFAST8: &[u8; 4] = b"hhB\0";
pub const SCNBFAST16: &[u8; 3] = b"lB\0";
pub const SCNBFAST32: &[u8; 3] = b"lB\0";
pub const SCNBFAST64: &[u8; 3] = b"lB\0";
pub const SCNBMAX: &[u8; 3] = b"jB\0";
pub const SCNBPTR: &[u8; 3] = b"lB\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT: u32 = 8;
pub const O_DIRECTORY: u32 = 16384;
pub const O_NOFOLLOW: u32 = 32768;
pub const O_DIRECT: u32 = 65536;
pub const O_LARGEFILE: u32 = 131072;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4210688;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const SOCK_IOC_TYPE: u32 = 137;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCETHTOOL: u32 = 35142;
pub const SIOCGMIIPHY: u32 = 35143;
pub const SIOCGMIIREG: u32 = 35144;
pub const SIOCSMIIREG: u32 = 35145;
pub const SIOCWANDEV: u32 = 35146;
pub const SIOCOUTQNSD: u32 = 35147;
pub const SIOCGSKNS: u32 = 35148;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCGIFVLAN: u32 = 35202;
pub const SIOCSIFVLAN: u32 = 35203;
pub const SIOCBONDENSLAVE: u32 = 35216;
pub const SIOCBONDRELEASE: u32 = 35217;
pub const SIOCBONDSETHWADDR: u32 = 35218;
pub const SIOCBONDSLAVEINFOQUERY: u32 = 35219;
pub const SIOCBONDINFOQUERY: u32 = 35220;
pub const SIOCBONDCHANGEACTIVE: u32 = 35221;
pub const SIOCBRADDBR: u32 = 35232;
pub const SIOCBRDELBR: u32 = 35233;
pub const SIOCBRADDIF: u32 = 35234;
pub const SIOCBRDELIF: u32 = 35235;
pub const SIOCSHWTSTAMP: u32 = 35248;
pub const SIOCGHWTSTAMP: u32 = 35249;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const UIO_FASTIOV: u32 = 8;
pub const UIO_MAXIOV: u32 = 1024;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SOCK_DCCP: u32 = 6;
pub const SOCK_PACKET: u32 = 10;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 2048;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_CREDENTIALS: u32 = 2;
pub const SCM_SECURITY: u32 = 3;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_MAX: u32 = 43;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_LOCAL: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_MAX: u32 = 43;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_TRYHARD: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const MSG_PROBE: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_DONTWAIT: u32 = 64;
pub const MSG_EOR: u32 = 128;
pub const MSG_WAITALL: u32 = 256;
pub const MSG_FIN: u32 = 512;
pub const MSG_SYN: u32 = 1024;
pub const MSG_CONFIRM: u32 = 2048;
pub const MSG_RST: u32 = 4096;
pub const MSG_ERRQUEUE: u32 = 8192;
pub const MSG_NOSIGNAL: u32 = 16384;
pub const MSG_MORE: u32 = 32768;
pub const MSG_WAITFORONE: u32 = 65536;
pub const MSG_BATCH: u32 = 262144;
pub const MSG_FASTOPEN: u32 = 536870912;
pub const MSG_CMSG_CLOEXEC: u32 = 1073741824;
pub const MSG_EOF: u32 = 512;
pub const MSG_CMSG_COMPAT: u32 = 0;
pub const SOL_IP: u32 = 0;
pub const SOL_TCP: u32 = 6;
pub const SOL_UDP: u32 = 17;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const SOL_SCTP: u32 = 132;
pub const SOL_RAW: u32 = 255;
pub const SOL_IPX: u32 = 256;
pub const SOL_AX25: u32 = 257;
pub const SOL_ATALK: u32 = 258;
pub const SOL_NETROM: u32 = 259;
pub const SOL_ROSE: u32 = 260;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const IPX_TYPE: u32 = 1;
pub const _PATH_HEQUIV: &[u8; 24] = b"/system/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 18] = b"/system/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 21] = b"/system/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 22] = b"/system/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 21] = b"/system/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 8;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const IPPORT_RESERVED: u32 = 1024;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const P_PIDFD: u32 = 3;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 4096;
pub const L_tmpnam: u32 = 4096;
pub const TMP_MAX: u32 = 308915776;
pub const P_tmpdir: &[u8; 6] = b"/tmp/\0";
pub const L_ctermid: u32 = 1024;
pub const STRUCT_MALLINFO_DECLARED: u32 = 1;
pub const M_DECAY_TIME: i32 = -100;
pub const M_PURGE: i32 = -101;
pub const M_PURGE_ALL: i32 = -104;
pub const M_MEMTAG_TUNING: i32 = -102;
pub const M_MEMTAG_TUNING_BUFFER_OVERFLOW: u32 = 0;
pub const M_MEMTAG_TUNING_UAF: u32 = 1;
pub const M_THREAD_DISABLE_MEM_INIT: i32 = -103;
pub const M_CACHE_COUNT_MAX: i32 = -200;
pub const M_CACHE_SIZE_MAX: i32 = -201;
pub const M_TSDS_COUNT_MAX: i32 = -202;
pub const M_BIONIC_ZERO_INIT: i32 = -203;
pub const M_BIONIC_SET_HEAP_TAGGING_LEVEL: i32 = -204;
pub const M_LOG_STATS: i32 = -205;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __NNAPI_FL5_MIN_ANDROID_API__: u32 = 31;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const FPSIMD_MAGIC: u32 = 1179680769;
pub const ESR_MAGIC: u32 = 1163088385;
pub const EXTRA_MAGIC: u32 = 1163416577;
pub const SVE_MAGIC: u32 = 1398162689;
pub const SVE_SIG_FLAG_SM: u32 = 1;
pub const TPIDR2_MAGIC: u32 = 1414547714;
pub const ZA_MAGIC: u32 = 1412850501;
pub const ZT_MAGIC: u32 = 1515474433;
pub const __SVE_VQ_BYTES: u32 = 16;
pub const __SVE_VQ_MIN: u32 = 1;
pub const __SVE_VQ_MAX: u32 = 512;
pub const __SVE_VL_MIN: u32 = 16;
pub const __SVE_VL_MAX: u32 = 8192;
pub const __SVE_NUM_ZREGS: u32 = 32;
pub const __SVE_NUM_PREGS: u32 = 16;
pub const __SVE_ZREGS_OFFSET: u32 = 0;
pub const SVE_VQ_BYTES: u32 = 16;
pub const SVE_VQ_MIN: u32 = 1;
pub const SVE_VQ_MAX: u32 = 512;
pub const SVE_VL_MIN: u32 = 16;
pub const SVE_VL_MAX: u32 = 8192;
pub const SVE_NUM_ZREGS: u32 = 32;
pub const SVE_NUM_PREGS: u32 = 16;
pub const ZT_SIG_REG_SIZE: u32 = 512;
pub const ZT_SIG_REG_BYTES: u32 = 64;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 255;
pub const CHAR_BIT: u32 = 8;
pub const LONG_BIT: u32 = 64;
pub const WORD_BIT: u32 = 32;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const CHAR_MAX: u32 = 255;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_LONG_MAX: i32 = -1;
pub const UID_MAX: u32 = 4294967295;
pub const GID_MAX: u32 = 4294967295;
pub const SIZE_T_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const MB_LEN_MAX: u32 = 4;
pub const NZERO: u32 = 20;
pub const IOV_MAX: u32 = 1024;
pub const SEM_VALUE_MAX: u32 = 1073741823;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const __BIONIC_POSIX_FEATURE_MISSING: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: i32 = -1;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: i32 = -1;
pub const _POSIX2_LOCALEDEF: i32 = -1;
pub const _POSIX2_SW_DEV: i32 = -1;
pub const _POSIX2_UPE: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: i32 = -1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const HOST_NAME_MAX: u32 = 255;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const TTY_NAME_MAX: u32 = 32;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const SA_RESTORER: u32 = 67108864;
pub const MINSIGSTKSZ: u32 = 5120;
pub const SIGSTKSZ: u32 = 16384;
pub const _KERNEL__NSIG: u32 = 64;
pub const _NSIG_BPW: u32 = 64;
pub const _NSIG_WORDS: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const SEGV_CPERR: u32 = 10;
pub const NSIGSEGV: u32 = 10;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const TRAP_PERF_FLAG_ASYNC: u32 = 1;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const _NSIG: u32 = 65;
pub const NSIG: u32 = 65;
pub const NGREG: u32 = 34;
pub const FD_SETSIZE: u32 = 1024;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_BC_BASE_MAX: u32 = 1;
pub const _SC_BC_DIM_MAX: u32 = 2;
pub const _SC_BC_SCALE_MAX: u32 = 3;
pub const _SC_BC_STRING_MAX: u32 = 4;
pub const _SC_CHILD_MAX: u32 = 5;
pub const _SC_CLK_TCK: u32 = 6;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 7;
pub const _SC_EXPR_NEST_MAX: u32 = 8;
pub const _SC_LINE_MAX: u32 = 9;
pub const _SC_NGROUPS_MAX: u32 = 10;
pub const _SC_OPEN_MAX: u32 = 11;
pub const _SC_PASS_MAX: u32 = 12;
pub const _SC_2_C_BIND: u32 = 13;
pub const _SC_2_C_DEV: u32 = 14;
pub const _SC_2_C_VERSION: u32 = 15;
pub const _SC_2_CHAR_TERM: u32 = 16;
pub const _SC_2_FORT_DEV: u32 = 17;
pub const _SC_2_FORT_RUN: u32 = 18;
pub const _SC_2_LOCALEDEF: u32 = 19;
pub const _SC_2_SW_DEV: u32 = 20;
pub const _SC_2_UPE: u32 = 21;
pub const _SC_2_VERSION: u32 = 22;
pub const _SC_JOB_CONTROL: u32 = 23;
pub const _SC_SAVED_IDS: u32 = 24;
pub const _SC_VERSION: u32 = 25;
pub const _SC_RE_DUP_MAX: u32 = 26;
pub const _SC_STREAM_MAX: u32 = 27;
pub const _SC_TZNAME_MAX: u32 = 28;
pub const _SC_XOPEN_CRYPT: u32 = 29;
pub const _SC_XOPEN_ENH_I18N: u32 = 30;
pub const _SC_XOPEN_SHM: u32 = 31;
pub const _SC_XOPEN_VERSION: u32 = 32;
pub const _SC_XOPEN_XCU_VERSION: u32 = 33;
pub const _SC_XOPEN_REALTIME: u32 = 34;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 35;
pub const _SC_XOPEN_LEGACY: u32 = 36;
pub const _SC_ATEXIT_MAX: u32 = 37;
pub const _SC_IOV_MAX: u32 = 38;
pub const _SC_UIO_MAXIOV: u32 = 38;
pub const _SC_PAGESIZE: u32 = 39;
pub const _SC_PAGE_SIZE: u32 = 40;
pub const _SC_XOPEN_UNIX: u32 = 41;
pub const _SC_XBS5_ILP32_OFF32: u32 = 42;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 43;
pub const _SC_XBS5_LP64_OFF64: u32 = 44;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 45;
pub const _SC_AIO_LISTIO_MAX: u32 = 46;
pub const _SC_AIO_MAX: u32 = 47;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 48;
pub const _SC_DELAYTIMER_MAX: u32 = 49;
pub const _SC_MQ_OPEN_MAX: u32 = 50;
pub const _SC_MQ_PRIO_MAX: u32 = 51;
pub const _SC_RTSIG_MAX: u32 = 52;
pub const _SC_SEM_NSEMS_MAX: u32 = 53;
pub const _SC_SEM_VALUE_MAX: u32 = 54;
pub const _SC_SIGQUEUE_MAX: u32 = 55;
pub const _SC_TIMER_MAX: u32 = 56;
pub const _SC_ASYNCHRONOUS_IO: u32 = 57;
pub const _SC_FSYNC: u32 = 58;
pub const _SC_MAPPED_FILES: u32 = 59;
pub const _SC_MEMLOCK: u32 = 60;
pub const _SC_MEMLOCK_RANGE: u32 = 61;
pub const _SC_MEMORY_PROTECTION: u32 = 62;
pub const _SC_MESSAGE_PASSING: u32 = 63;
pub const _SC_PRIORITIZED_IO: u32 = 64;
pub const _SC_PRIORITY_SCHEDULING: u32 = 65;
pub const _SC_REALTIME_SIGNALS: u32 = 66;
pub const _SC_SEMAPHORES: u32 = 67;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 68;
pub const _SC_SYNCHRONIZED_IO: u32 = 69;
pub const _SC_TIMERS: u32 = 70;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 71;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 74;
pub const _SC_THREAD_KEYS_MAX: u32 = 75;
pub const _SC_THREAD_STACK_MIN: u32 = 76;
pub const _SC_THREAD_THREADS_MAX: u32 = 77;
pub const _SC_TTY_NAME_MAX: u32 = 78;
pub const _SC_THREADS: u32 = 79;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 80;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 81;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 82;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 83;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 84;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 85;
pub const _SC_NPROCESSORS_CONF: u32 = 96;
pub const _SC_NPROCESSORS_ONLN: u32 = 97;
pub const _SC_PHYS_PAGES: u32 = 98;
pub const _SC_AVPHYS_PAGES: u32 = 99;
pub const _SC_MONOTONIC_CLOCK: u32 = 100;
pub const _SC_2_PBS: u32 = 101;
pub const _SC_2_PBS_ACCOUNTING: u32 = 102;
pub const _SC_2_PBS_CHECKPOINT: u32 = 103;
pub const _SC_2_PBS_LOCATE: u32 = 104;
pub const _SC_2_PBS_MESSAGE: u32 = 105;
pub const _SC_2_PBS_TRACK: u32 = 106;
pub const _SC_ADVISORY_INFO: u32 = 107;
pub const _SC_BARRIERS: u32 = 108;
pub const _SC_CLOCK_SELECTION: u32 = 109;
pub const _SC_CPUTIME: u32 = 110;
pub const _SC_HOST_NAME_MAX: u32 = 111;
pub const _SC_IPV6: u32 = 112;
pub const _SC_RAW_SOCKETS: u32 = 113;
pub const _SC_READER_WRITER_LOCKS: u32 = 114;
pub const _SC_REGEXP: u32 = 115;
pub const _SC_SHELL: u32 = 116;
pub const _SC_SPAWN: u32 = 117;
pub const _SC_SPIN_LOCKS: u32 = 118;
pub const _SC_SPORADIC_SERVER: u32 = 119;
pub const _SC_SS_REPL_MAX: u32 = 120;
pub const _SC_SYMLOOP_MAX: u32 = 121;
pub const _SC_THREAD_CPUTIME: u32 = 122;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 123;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 124;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 125;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 126;
pub const _SC_TIMEOUTS: u32 = 127;
pub const _SC_TRACE: u32 = 128;
pub const _SC_TRACE_EVENT_FILTER: u32 = 129;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 130;
pub const _SC_TRACE_INHERIT: u32 = 131;
pub const _SC_TRACE_LOG: u32 = 132;
pub const _SC_TRACE_NAME_MAX: u32 = 133;
pub const _SC_TRACE_SYS_MAX: u32 = 134;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 135;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 136;
pub const _SC_V7_ILP32_OFF32: u32 = 137;
pub const _SC_V7_ILP32_OFFBIG: u32 = 138;
pub const _SC_V7_LP64_OFF64: u32 = 139;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 140;
pub const _SC_XOPEN_STREAMS: u32 = 141;
pub const _SC_XOPEN_UUCP: u32 = 142;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 143;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 144;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 145;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 146;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 147;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 148;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 149;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 150;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 151;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 152;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 153;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 154;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 155;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 156;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 157;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _PC_FILESIZEBITS: u32 = 0;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_2_SYMLINKS: u32 = 7;
pub const _PC_ALLOC_SIZE_MIN: u32 = 8;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 9;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 10;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 11;
pub const _PC_REC_XFER_ALIGN: u32 = 12;
pub const _PC_SYMLINK_MAX: u32 = 13;
pub const _PC_CHOWN_RESTRICTED: u32 = 14;
pub const _PC_NO_TRUNC: u32 = 15;
pub const _PC_VDISABLE: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_PRIO_IO: u32 = 18;
pub const _PC_SYNC_IO: u32 = 19;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 8;
pub const FP_ZERO: u32 = 16;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483647;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const ASENSOR_FIFO_COUNT_INVALID: i32 = -1;
pub const ASENSOR_DELAY_INVALID: i32 = -2147483648;
pub const ASENSOR_INVALID: i32 = -1;
pub const ASENSOR_STANDARD_GRAVITY: f64 = 9.80665;
pub const ASENSOR_MAGNETIC_FIELD_EARTH_MAX: f64 = 60.0;
pub const ASENSOR_MAGNETIC_FIELD_EARTH_MIN: f64 = 30.0;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const SYNC_IOC_MAGIC: u8 = 62u8;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const TIME_MONOTONIC: u32 = 2;
pub const TIME_ACTIVE: u32 = 3;
pub const TIME_THREAD_ACTIVE: u32 = 4;
pub const AAUDIO_UNSPECIFIED: u32 = 0;
pub const AAUDIO_SYSTEM_USAGE_OFFSET: u32 = 1000;
pub const PROPERTY_VENDOR: &[u8; 7] = b"vendor\0";
pub const PROPERTY_VERSION: &[u8; 8] = b"version\0";
pub const PROPERTY_DESCRIPTION: &[u8; 12] = b"description\0";
pub const PROPERTY_ALGORITHMS: &[u8; 11] = b"algorithms\0";
pub const PROPERTY_DEVICE_UNIQUE_ID: &[u8; 15] = b"deviceUniqueId\0";
extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i64;
pub type uint_fast16_t = u64;
pub type int_fast32_t = i64;
pub type uint_fast32_t = u64;
pub type uintmax_t = u64;
pub type intmax_t = i64;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub flags: u32,
    pub stack_base: *mut ::std::os::raw::c_void,
    pub stack_size: usize,
    pub guard_size: usize,
    pub sched_policy: i32,
    pub sched_priority: i32,
    pub __reserved: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(guard_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_policy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_t {
    pub __private: [i64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_barrierattr_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t {
    pub __private: [i32; 12usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_condattr_t = ::std::os::raw::c_long;
pub type pthread_key_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t {
    pub __private: [i32; 10usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_mutexattr_t = ::std::os::raw::c_long;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __private: [i32; 14usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_rwlockattr_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock_t {
    pub __private: i64,
}
#[test]
fn bindgen_test_layout_pthread_spinlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_spinlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_spinlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_long;
pub type __gid_t = __kernel_gid32_t;
pub type gid_t = __gid_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __id_t = u32;
pub type id_t = __id_t;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type blksize_t = ::std::os::raw::c_ulong;
pub type caddr_t = __kernel_caddr_t;
pub type clock_t = __kernel_clock_t;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
pub type daddr_t = __kernel_daddr_t;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __mode_t = __kernel_mode_t;
pub type mode_t = __mode_t;
pub type __key_t = __kernel_key_t;
pub type key_t = __key_t;
pub type __ino_t = __kernel_ino_t;
pub type ino_t = __ino_t;
pub type ino64_t = u64;
pub type __nlink_t = u32;
pub type nlink_t = __nlink_t;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type timer_t = __timer_t;
pub type __suseconds_t = __kernel_suseconds_t;
pub type suseconds_t = __suseconds_t;
pub type __useconds_t = u32;
pub type useconds_t = __useconds_t;
pub type dev_t = u64;
pub type __time_t = __kernel_time_t;
pub type time_t = __time_t;
pub type off_t = i64;
pub type loff_t = off_t;
pub type off64_t = loff_t;
pub type __socklen_t = u32;
pub type socklen_t = __socklen_t;
pub type __va_list = [u64; 4usize];
pub type uint_t = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type u_int32_t = u32;
pub type u_int16_t = u16;
pub type u_int8_t = u8;
pub type u_int64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAssetManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAssetDir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAsset {
    _unused: [u8; 0],
}
pub const AASSET_MODE_UNKNOWN: _bindgen_ty_1 = 0;
pub const AASSET_MODE_RANDOM: _bindgen_ty_1 = 1;
pub const AASSET_MODE_STREAMING: _bindgen_ty_1 = 2;
pub const AASSET_MODE_BUFFER: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AAssetManager_openDir(
        mgr: *mut AAssetManager,
        dirName: *const ::std::os::raw::c_char,
    ) -> *mut AAssetDir;
}
extern "C" {
    pub fn AAssetManager_open(
        mgr: *mut AAssetManager,
        filename: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> *mut AAsset;
}
extern "C" {
    pub fn AAssetDir_getNextFileName(assetDir: *mut AAssetDir) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AAssetDir_rewind(assetDir: *mut AAssetDir);
}
extern "C" {
    pub fn AAssetDir_close(assetDir: *mut AAssetDir);
}
extern "C" {
    pub fn AAsset_read(
        asset: *mut AAsset,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AAsset_seek(asset: *mut AAsset, offset: off_t, whence: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn AAsset_seek64(
        asset: *mut AAsset,
        offset: off64_t,
        whence: ::std::os::raw::c_int,
    ) -> off64_t;
}
extern "C" {
    pub fn AAsset_close(asset: *mut AAsset);
}
extern "C" {
    pub fn AAsset_getBuffer(asset: *mut AAsset) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn AAsset_getLength(asset: *mut AAsset) -> off_t;
}
extern "C" {
    pub fn AAsset_getLength64(asset: *mut AAsset) -> off64_t;
}
extern "C" {
    pub fn AAsset_getRemainingLength(asset: *mut AAsset) -> off_t;
}
extern "C" {
    pub fn AAsset_getRemainingLength64(asset: *mut AAsset) -> off64_t;
}
extern "C" {
    pub fn AAsset_openFileDescriptor(
        asset: *mut AAsset,
        outStart: *mut off_t,
        outLength: *mut off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AAsset_openFileDescriptor64(
        asset: *mut AAsset,
        outStart: *mut off64_t,
        outLength: *mut off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AAsset_isAllocated(asset: *mut AAsset) -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = [u64; 4usize];
pub type va_list = [u64; 4usize];
#[repr(C)]
pub struct JavaVMAttachArgs {
    pub version: jint,
    pub name: *const ::std::os::raw::c_char,
    pub group: jobject,
}
#[test]
fn bindgen_test_layout_JavaVMAttachArgs() {
    const UNINIT: ::std::mem::MaybeUninit<JavaVMAttachArgs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JavaVMAttachArgs>(),
        24usize,
        concat!("Size of: ", stringify!(JavaVMAttachArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMAttachArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(JavaVMAttachArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JavaVMOption {
    pub optionString: *const ::std::os::raw::c_char,
    pub extraInfo: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_JavaVMOption() {
    const UNINIT: ::std::mem::MaybeUninit<JavaVMOption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JavaVMOption>(),
        16usize,
        concat!("Size of: ", stringify!(JavaVMOption))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMOption>(),
        8usize,
        concat!("Alignment of ", stringify!(JavaVMOption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optionString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMOption),
            "::",
            stringify!(optionString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extraInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMOption),
            "::",
            stringify!(extraInfo)
        )
    );
}
#[repr(C)]
pub struct JavaVMInitArgs {
    pub version: jint,
    pub nOptions: jint,
    pub options: *mut JavaVMOption,
    pub ignoreUnrecognized: jboolean,
}
#[test]
fn bindgen_test_layout_JavaVMInitArgs() {
    const UNINIT: ::std::mem::MaybeUninit<JavaVMInitArgs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JavaVMInitArgs>(),
        24usize,
        concat!("Size of: ", stringify!(JavaVMInitArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMInitArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(JavaVMInitArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nOptions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(nOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignoreUnrecognized) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(ignoreUnrecognized)
        )
    );
}
extern "C" {
    pub fn AAssetManager_fromJava(env: *mut JNIEnv, assetManager: jobject) -> *mut AAssetManager;
}
pub const ANDROID_BITMAP_RESULT_SUCCESS: _bindgen_ty_2 = 0;
pub const ANDROID_BITMAP_RESULT_BAD_PARAMETER: _bindgen_ty_2 = -1;
pub const ANDROID_BITMAP_RESULT_JNI_EXCEPTION: _bindgen_ty_2 = -2;
pub const ANDROID_BITMAP_RESULT_ALLOCATION_FAILED: _bindgen_ty_2 = -3;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_NONE: AndroidBitmapFormat = AndroidBitmapFormat(0);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_RGBA_8888: AndroidBitmapFormat = AndroidBitmapFormat(1);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_RGB_565: AndroidBitmapFormat = AndroidBitmapFormat(4);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_RGBA_4444: AndroidBitmapFormat = AndroidBitmapFormat(7);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_A_8: AndroidBitmapFormat = AndroidBitmapFormat(8);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_RGBA_F16: AndroidBitmapFormat = AndroidBitmapFormat(9);
}
impl AndroidBitmapFormat {
    pub const ANDROID_BITMAP_FORMAT_RGBA_1010102: AndroidBitmapFormat = AndroidBitmapFormat(10);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AndroidBitmapFormat(pub ::std::os::raw::c_uint);
pub const ANDROID_BITMAP_FLAGS_ALPHA_PREMUL: _bindgen_ty_3 = 0;
pub const ANDROID_BITMAP_FLAGS_ALPHA_OPAQUE: _bindgen_ty_3 = 1;
pub const ANDROID_BITMAP_FLAGS_ALPHA_UNPREMUL: _bindgen_ty_3 = 2;
pub const ANDROID_BITMAP_FLAGS_ALPHA_MASK: _bindgen_ty_3 = 3;
pub const ANDROID_BITMAP_FLAGS_ALPHA_SHIFT: _bindgen_ty_3 = 0;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const ANDROID_BITMAP_FLAGS_IS_HARDWARE: _bindgen_ty_4 = -2147483648;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndroidBitmapInfo {
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub format: i32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_AndroidBitmapInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AndroidBitmapInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AndroidBitmapInfo>(),
        20usize,
        concat!("Size of: ", stringify!(AndroidBitmapInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AndroidBitmapInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(AndroidBitmapInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AndroidBitmapInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AndroidBitmapInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AndroidBitmapInfo),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AndroidBitmapInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AndroidBitmapInfo),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn AndroidBitmap_getInfo(
        env: *mut JNIEnv,
        jbitmap: jobject,
        info: *mut AndroidBitmapInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AndroidBitmap_getDataSpace(env: *mut JNIEnv, jbitmap: jobject) -> i32;
}
extern "C" {
    pub fn AndroidBitmap_lockPixels(
        env: *mut JNIEnv,
        jbitmap: jobject,
        addrPtr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AndroidBitmap_unlockPixels(env: *mut JNIEnv, jbitmap: jobject) -> ::std::os::raw::c_int;
}
impl AndroidBitmapCompressFormat {
    pub const ANDROID_BITMAP_COMPRESS_FORMAT_JPEG: AndroidBitmapCompressFormat =
        AndroidBitmapCompressFormat(0);
}
impl AndroidBitmapCompressFormat {
    pub const ANDROID_BITMAP_COMPRESS_FORMAT_PNG: AndroidBitmapCompressFormat =
        AndroidBitmapCompressFormat(1);
}
impl AndroidBitmapCompressFormat {
    pub const ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSY: AndroidBitmapCompressFormat =
        AndroidBitmapCompressFormat(3);
}
impl AndroidBitmapCompressFormat {
    pub const ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSLESS: AndroidBitmapCompressFormat =
        AndroidBitmapCompressFormat(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AndroidBitmapCompressFormat(pub ::std::os::raw::c_uint);
pub type AndroidBitmap_CompressWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        userContext: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> bool,
>;
extern "C" {
    pub fn AndroidBitmap_compress(
        info: *const AndroidBitmapInfo,
        dataspace: i32,
        pixels: *const ::std::os::raw::c_void,
        format: i32,
        quality: i32,
        userContext: *mut ::std::os::raw::c_void,
        fn_: AndroidBitmap_CompressWriteFunc,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AndroidBitmap_getHardwareBuffer(
        env: *mut JNIEnv,
        bitmap: jobject,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AChoreographer {
    _unused: [u8; 0],
}
pub type AVsyncId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AChoreographerFrameCallbackData {
    _unused: [u8; 0],
}
pub type AChoreographer_frameCallback = ::std::option::Option<
    unsafe extern "C" fn(frameTimeNanos: ::std::os::raw::c_long, data: *mut ::std::os::raw::c_void),
>;
pub type AChoreographer_frameCallback64 = ::std::option::Option<
    unsafe extern "C" fn(frameTimeNanos: i64, data: *mut ::std::os::raw::c_void),
>;
pub type AChoreographer_vsyncCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callbackData: *const AChoreographerFrameCallbackData,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type AChoreographer_refreshRateCallback = ::std::option::Option<
    unsafe extern "C" fn(vsyncPeriodNanos: i64, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn AChoreographer_getInstance() -> *mut AChoreographer;
}
extern "C" {
    pub fn AChoreographer_postFrameCallback(
        choreographer: *mut AChoreographer,
        callback: AChoreographer_frameCallback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AChoreographer_postFrameCallbackDelayed(
        choreographer: *mut AChoreographer,
        callback: AChoreographer_frameCallback,
        data: *mut ::std::os::raw::c_void,
        delayMillis: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn AChoreographer_postFrameCallback64(
        choreographer: *mut AChoreographer,
        callback: AChoreographer_frameCallback64,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AChoreographer_postFrameCallbackDelayed64(
        choreographer: *mut AChoreographer,
        callback: AChoreographer_frameCallback64,
        data: *mut ::std::os::raw::c_void,
        delayMillis: u32,
    );
}
extern "C" {
    pub fn AChoreographer_postVsyncCallback(
        choreographer: *mut AChoreographer,
        callback: AChoreographer_vsyncCallback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AChoreographer_registerRefreshRateCallback(
        choreographer: *mut AChoreographer,
        arg1: AChoreographer_refreshRateCallback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AChoreographer_unregisterRefreshRateCallback(
        choreographer: *mut AChoreographer,
        arg1: AChoreographer_refreshRateCallback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getFrameTimeNanos(
        data: *const AChoreographerFrameCallbackData,
    ) -> i64;
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getFrameTimelinesLength(
        data: *const AChoreographerFrameCallbackData,
    ) -> usize;
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getPreferredFrameTimelineIndex(
        data: *const AChoreographerFrameCallbackData,
    ) -> usize;
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getFrameTimelineVsyncId(
        data: *const AChoreographerFrameCallbackData,
        index: usize,
    ) -> AVsyncId;
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getFrameTimelineExpectedPresentationTimeNanos(
        data: *const AChoreographerFrameCallbackData,
        index: usize,
    ) -> i64;
}
extern "C" {
    pub fn AChoreographerFrameCallbackData_getFrameTimelineDeadlineNanos(
        data: *const AChoreographerFrameCallbackData,
        index: usize,
    ) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AConfiguration {
    _unused: [u8; 0],
}
pub const ACONFIGURATION_ORIENTATION_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_ORIENTATION_PORT: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_ORIENTATION_LAND: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_ORIENTATION_SQUARE: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_TOUCHSCREEN_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_TOUCHSCREEN_NOTOUCH: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_TOUCHSCREEN_STYLUS: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_TOUCHSCREEN_FINGER: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_DENSITY_DEFAULT: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_DENSITY_LOW: _bindgen_ty_5 = 120;
pub const ACONFIGURATION_DENSITY_MEDIUM: _bindgen_ty_5 = 160;
pub const ACONFIGURATION_DENSITY_TV: _bindgen_ty_5 = 213;
pub const ACONFIGURATION_DENSITY_HIGH: _bindgen_ty_5 = 240;
pub const ACONFIGURATION_DENSITY_XHIGH: _bindgen_ty_5 = 320;
pub const ACONFIGURATION_DENSITY_XXHIGH: _bindgen_ty_5 = 480;
pub const ACONFIGURATION_DENSITY_XXXHIGH: _bindgen_ty_5 = 640;
pub const ACONFIGURATION_DENSITY_ANY: _bindgen_ty_5 = 65534;
pub const ACONFIGURATION_DENSITY_NONE: _bindgen_ty_5 = 65535;
pub const ACONFIGURATION_KEYBOARD_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_KEYBOARD_NOKEYS: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_KEYBOARD_QWERTY: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_KEYBOARD_12KEY: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_NAVIGATION_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_NAVIGATION_NONAV: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_NAVIGATION_DPAD: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_NAVIGATION_TRACKBALL: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_NAVIGATION_WHEEL: _bindgen_ty_5 = 4;
pub const ACONFIGURATION_KEYSHIDDEN_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_KEYSHIDDEN_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_KEYSHIDDEN_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_KEYSHIDDEN_SOFT: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_NAVHIDDEN_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_NAVHIDDEN_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_NAVHIDDEN_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_SCREENSIZE_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_SCREENSIZE_SMALL: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_SCREENSIZE_NORMAL: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_SCREENSIZE_LARGE: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_SCREENSIZE_XLARGE: _bindgen_ty_5 = 4;
pub const ACONFIGURATION_SCREENLONG_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_SCREENLONG_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_SCREENLONG_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_SCREENROUND_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_SCREENROUND_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_SCREENROUND_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_HDR_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_HDR_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_HDR_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_UI_MODE_TYPE_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_UI_MODE_TYPE_NORMAL: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_UI_MODE_TYPE_DESK: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_UI_MODE_TYPE_CAR: _bindgen_ty_5 = 3;
pub const ACONFIGURATION_UI_MODE_TYPE_TELEVISION: _bindgen_ty_5 = 4;
pub const ACONFIGURATION_UI_MODE_TYPE_APPLIANCE: _bindgen_ty_5 = 5;
pub const ACONFIGURATION_UI_MODE_TYPE_WATCH: _bindgen_ty_5 = 6;
pub const ACONFIGURATION_UI_MODE_TYPE_VR_HEADSET: _bindgen_ty_5 = 7;
pub const ACONFIGURATION_UI_MODE_NIGHT_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_UI_MODE_NIGHT_NO: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_UI_MODE_NIGHT_YES: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_SCREEN_WIDTH_DP_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_SCREEN_HEIGHT_DP_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_SMALLEST_SCREEN_WIDTH_DP_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_LAYOUTDIR_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_LAYOUTDIR_LTR: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_LAYOUTDIR_RTL: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_MCC: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_MNC: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_LOCALE: _bindgen_ty_5 = 4;
pub const ACONFIGURATION_TOUCHSCREEN: _bindgen_ty_5 = 8;
pub const ACONFIGURATION_KEYBOARD: _bindgen_ty_5 = 16;
pub const ACONFIGURATION_KEYBOARD_HIDDEN: _bindgen_ty_5 = 32;
pub const ACONFIGURATION_NAVIGATION: _bindgen_ty_5 = 64;
pub const ACONFIGURATION_ORIENTATION: _bindgen_ty_5 = 128;
pub const ACONFIGURATION_DENSITY: _bindgen_ty_5 = 256;
pub const ACONFIGURATION_SCREEN_SIZE: _bindgen_ty_5 = 512;
pub const ACONFIGURATION_VERSION: _bindgen_ty_5 = 1024;
pub const ACONFIGURATION_SCREEN_LAYOUT: _bindgen_ty_5 = 2048;
pub const ACONFIGURATION_UI_MODE: _bindgen_ty_5 = 4096;
pub const ACONFIGURATION_SMALLEST_SCREEN_SIZE: _bindgen_ty_5 = 8192;
pub const ACONFIGURATION_LAYOUTDIR: _bindgen_ty_5 = 16384;
pub const ACONFIGURATION_SCREEN_ROUND: _bindgen_ty_5 = 32768;
pub const ACONFIGURATION_COLOR_MODE: _bindgen_ty_5 = 65536;
pub const ACONFIGURATION_GRAMMATICAL_GENDER: _bindgen_ty_5 = 131072;
pub const ACONFIGURATION_MNC_ZERO: _bindgen_ty_5 = 65535;
pub const ACONFIGURATION_GRAMMATICAL_GENDER_ANY: _bindgen_ty_5 = 0;
pub const ACONFIGURATION_GRAMMATICAL_GENDER_NEUTER: _bindgen_ty_5 = 1;
pub const ACONFIGURATION_GRAMMATICAL_GENDER_FEMININE: _bindgen_ty_5 = 2;
pub const ACONFIGURATION_GRAMMATICAL_GENDER_MASCULINE: _bindgen_ty_5 = 3;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AConfiguration_new() -> *mut AConfiguration;
}
extern "C" {
    pub fn AConfiguration_delete(config: *mut AConfiguration);
}
extern "C" {
    pub fn AConfiguration_fromAssetManager(out: *mut AConfiguration, am: *mut AAssetManager);
}
extern "C" {
    pub fn AConfiguration_copy(dest: *mut AConfiguration, src: *mut AConfiguration);
}
extern "C" {
    pub fn AConfiguration_getMcc(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setMcc(config: *mut AConfiguration, mcc: i32);
}
extern "C" {
    pub fn AConfiguration_getMnc(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setMnc(config: *mut AConfiguration, mnc: i32);
}
extern "C" {
    pub fn AConfiguration_getLanguage(
        config: *mut AConfiguration,
        outLanguage: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AConfiguration_setLanguage(
        config: *mut AConfiguration,
        language: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AConfiguration_getCountry(
        config: *mut AConfiguration,
        outCountry: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AConfiguration_setCountry(
        config: *mut AConfiguration,
        country: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AConfiguration_getOrientation(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setOrientation(config: *mut AConfiguration, orientation: i32);
}
extern "C" {
    pub fn AConfiguration_getTouchscreen(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setTouchscreen(config: *mut AConfiguration, touchscreen: i32);
}
extern "C" {
    pub fn AConfiguration_getDensity(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setDensity(config: *mut AConfiguration, density: i32);
}
extern "C" {
    pub fn AConfiguration_getKeyboard(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setKeyboard(config: *mut AConfiguration, keyboard: i32);
}
extern "C" {
    pub fn AConfiguration_getNavigation(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setNavigation(config: *mut AConfiguration, navigation: i32);
}
extern "C" {
    pub fn AConfiguration_getKeysHidden(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setKeysHidden(config: *mut AConfiguration, keysHidden: i32);
}
extern "C" {
    pub fn AConfiguration_getNavHidden(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setNavHidden(config: *mut AConfiguration, navHidden: i32);
}
extern "C" {
    pub fn AConfiguration_getSdkVersion(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setSdkVersion(config: *mut AConfiguration, sdkVersion: i32);
}
extern "C" {
    pub fn AConfiguration_getScreenSize(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setScreenSize(config: *mut AConfiguration, screenSize: i32);
}
extern "C" {
    pub fn AConfiguration_getScreenLong(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setScreenLong(config: *mut AConfiguration, screenLong: i32);
}
extern "C" {
    pub fn AConfiguration_getScreenRound(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setScreenRound(config: *mut AConfiguration, screenRound: i32);
}
extern "C" {
    pub fn AConfiguration_getUiModeType(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setUiModeType(config: *mut AConfiguration, uiModeType: i32);
}
extern "C" {
    pub fn AConfiguration_getUiModeNight(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setUiModeNight(config: *mut AConfiguration, uiModeNight: i32);
}
extern "C" {
    pub fn AConfiguration_getScreenWidthDp(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setScreenWidthDp(config: *mut AConfiguration, value: i32);
}
extern "C" {
    pub fn AConfiguration_getScreenHeightDp(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setScreenHeightDp(config: *mut AConfiguration, value: i32);
}
extern "C" {
    pub fn AConfiguration_getSmallestScreenWidthDp(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setSmallestScreenWidthDp(config: *mut AConfiguration, value: i32);
}
extern "C" {
    pub fn AConfiguration_getLayoutDirection(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setLayoutDirection(config: *mut AConfiguration, value: i32);
}
extern "C" {
    pub fn AConfiguration_getGrammaticalGender(config: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_setGrammaticalGender(config: *mut AConfiguration, value: i32);
}
extern "C" {
    pub fn AConfiguration_diff(config1: *mut AConfiguration, config2: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_match(base: *mut AConfiguration, requested: *mut AConfiguration) -> i32;
}
extern "C" {
    pub fn AConfiguration_isBetterThan(
        base: *mut AConfiguration,
        test: *mut AConfiguration,
        requested: *mut AConfiguration,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__i: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numerator: intmax_t, __denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
impl ADataSpace {
    pub const ADATASPACE_UNKNOWN: ADataSpace = ADataSpace(0);
}
impl ADataSpace {
    pub const STANDARD_MASK: ADataSpace = ADataSpace(4128768);
}
impl ADataSpace {
    pub const STANDARD_UNSPECIFIED: ADataSpace = ADataSpace(0);
}
impl ADataSpace {
    pub const STANDARD_BT709: ADataSpace = ADataSpace(65536);
}
impl ADataSpace {
    pub const STANDARD_BT601_625: ADataSpace = ADataSpace(131072);
}
impl ADataSpace {
    pub const STANDARD_BT601_625_UNADJUSTED: ADataSpace = ADataSpace(196608);
}
impl ADataSpace {
    pub const STANDARD_BT601_525: ADataSpace = ADataSpace(262144);
}
impl ADataSpace {
    pub const STANDARD_BT601_525_UNADJUSTED: ADataSpace = ADataSpace(327680);
}
impl ADataSpace {
    pub const STANDARD_BT2020: ADataSpace = ADataSpace(393216);
}
impl ADataSpace {
    pub const STANDARD_BT2020_CONSTANT_LUMINANCE: ADataSpace = ADataSpace(458752);
}
impl ADataSpace {
    pub const STANDARD_BT470M: ADataSpace = ADataSpace(524288);
}
impl ADataSpace {
    pub const STANDARD_FILM: ADataSpace = ADataSpace(589824);
}
impl ADataSpace {
    pub const STANDARD_DCI_P3: ADataSpace = ADataSpace(655360);
}
impl ADataSpace {
    pub const STANDARD_ADOBE_RGB: ADataSpace = ADataSpace(720896);
}
impl ADataSpace {
    pub const TRANSFER_MASK: ADataSpace = ADataSpace(130023424);
}
impl ADataSpace {
    pub const TRANSFER_UNSPECIFIED: ADataSpace = ADataSpace(0);
}
impl ADataSpace {
    pub const TRANSFER_LINEAR: ADataSpace = ADataSpace(4194304);
}
impl ADataSpace {
    pub const TRANSFER_SRGB: ADataSpace = ADataSpace(8388608);
}
impl ADataSpace {
    pub const TRANSFER_SMPTE_170M: ADataSpace = ADataSpace(12582912);
}
impl ADataSpace {
    pub const TRANSFER_GAMMA2_2: ADataSpace = ADataSpace(16777216);
}
impl ADataSpace {
    pub const TRANSFER_GAMMA2_6: ADataSpace = ADataSpace(20971520);
}
impl ADataSpace {
    pub const TRANSFER_GAMMA2_8: ADataSpace = ADataSpace(25165824);
}
impl ADataSpace {
    pub const TRANSFER_ST2084: ADataSpace = ADataSpace(29360128);
}
impl ADataSpace {
    pub const TRANSFER_HLG: ADataSpace = ADataSpace(33554432);
}
impl ADataSpace {
    pub const RANGE_MASK: ADataSpace = ADataSpace(939524096);
}
impl ADataSpace {
    pub const RANGE_UNSPECIFIED: ADataSpace = ADataSpace(0);
}
impl ADataSpace {
    pub const RANGE_FULL: ADataSpace = ADataSpace(134217728);
}
impl ADataSpace {
    pub const RANGE_LIMITED: ADataSpace = ADataSpace(268435456);
}
impl ADataSpace {
    pub const RANGE_EXTENDED: ADataSpace = ADataSpace(402653184);
}
impl ADataSpace {
    pub const ADATASPACE_SCRGB_LINEAR: ADataSpace = ADataSpace(406913024);
}
impl ADataSpace {
    pub const ADATASPACE_SRGB: ADataSpace = ADataSpace(142671872);
}
impl ADataSpace {
    pub const ADATASPACE_SCRGB: ADataSpace = ADataSpace(411107328);
}
impl ADataSpace {
    pub const ADATASPACE_DISPLAY_P3: ADataSpace = ADataSpace(143261696);
}
impl ADataSpace {
    pub const ADATASPACE_BT2020_PQ: ADataSpace = ADataSpace(163971072);
}
impl ADataSpace {
    pub const ADATASPACE_BT2020_ITU_PQ: ADataSpace = ADataSpace(298188800);
}
impl ADataSpace {
    pub const ADATASPACE_ADOBE_RGB: ADataSpace = ADataSpace(151715840);
}
impl ADataSpace {
    pub const ADATASPACE_JFIF: ADataSpace = ADataSpace(146931712);
}
impl ADataSpace {
    pub const ADATASPACE_BT601_625: ADataSpace = ADataSpace(281149440);
}
impl ADataSpace {
    pub const ADATASPACE_BT601_525: ADataSpace = ADataSpace(281280512);
}
impl ADataSpace {
    pub const ADATASPACE_BT2020: ADataSpace = ADataSpace(147193856);
}
impl ADataSpace {
    pub const ADATASPACE_BT709: ADataSpace = ADataSpace(281083904);
}
impl ADataSpace {
    pub const ADATASPACE_DCI_P3: ADataSpace = ADataSpace(155844608);
}
impl ADataSpace {
    pub const ADATASPACE_SRGB_LINEAR: ADataSpace = ADataSpace(138477568);
}
impl ADataSpace {
    pub const ADATASPACE_BT2020_HLG: ADataSpace = ADataSpace(168165376);
}
impl ADataSpace {
    pub const ADATASPACE_BT2020_ITU_HLG: ADataSpace = ADataSpace(302383104);
}
impl ADataSpace {
    pub const ADATASPACE_DEPTH: ADataSpace = ADataSpace(4096);
}
impl ADataSpace {
    pub const ADATASPACE_DYNAMIC_DEPTH: ADataSpace = ADataSpace(4098);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADataSpace(pub i32);
pub const ANDROID_DLEXT_RESERVED_ADDRESS: _bindgen_ty_6 = 1;
pub const ANDROID_DLEXT_RESERVED_ADDRESS_HINT: _bindgen_ty_6 = 2;
pub const ANDROID_DLEXT_WRITE_RELRO: _bindgen_ty_6 = 4;
pub const ANDROID_DLEXT_USE_RELRO: _bindgen_ty_6 = 8;
pub const ANDROID_DLEXT_USE_LIBRARY_FD: _bindgen_ty_6 = 16;
pub const ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET: _bindgen_ty_6 = 32;
pub const ANDROID_DLEXT_FORCE_LOAD: _bindgen_ty_6 = 64;
pub const ANDROID_DLEXT_USE_NAMESPACE: _bindgen_ty_6 = 512;
pub const ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE: _bindgen_ty_6 = 1024;
pub const ANDROID_DLEXT_VALID_FLAG_BITS: _bindgen_ty_6 = 1663;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct android_namespace_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct android_dlextinfo {
    pub flags: u64,
    pub reserved_addr: *mut ::std::os::raw::c_void,
    pub reserved_size: usize,
    pub relro_fd: ::std::os::raw::c_int,
    pub library_fd: ::std::os::raw::c_int,
    pub library_fd_offset: off64_t,
    pub library_namespace: *mut android_namespace_t,
}
#[test]
fn bindgen_test_layout_android_dlextinfo() {
    const UNINIT: ::std::mem::MaybeUninit<android_dlextinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<android_dlextinfo>(),
        48usize,
        concat!("Size of: ", stringify!(android_dlextinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<android_dlextinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(android_dlextinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(reserved_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(reserved_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relro_fd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(relro_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_fd) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(library_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_fd_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(library_fd_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_namespace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(android_dlextinfo),
            "::",
            stringify!(library_namespace)
        )
    );
}
extern "C" {
    pub fn android_dlopen_ext(
        __filename: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
        __info: *const android_dlextinfo,
    ) -> *mut ::std::os::raw::c_void;
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_GENERIC_00: android_fdsan_owner_type =
        android_fdsan_owner_type(0);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_GENERIC_FF: android_fdsan_owner_type =
        android_fdsan_owner_type(255);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_FILE: android_fdsan_owner_type = android_fdsan_owner_type(1);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_DIR: android_fdsan_owner_type = android_fdsan_owner_type(2);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD: android_fdsan_owner_type =
        android_fdsan_owner_type(3);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_SQLITE: android_fdsan_owner_type =
        android_fdsan_owner_type(4);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_FILEINPUTSTREAM: android_fdsan_owner_type =
        android_fdsan_owner_type(5);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_FILEOUTPUTSTREAM: android_fdsan_owner_type =
        android_fdsan_owner_type(6);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_RANDOMACCESSFILE: android_fdsan_owner_type =
        android_fdsan_owner_type(7);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_PARCELFILEDESCRIPTOR: android_fdsan_owner_type =
        android_fdsan_owner_type(8);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_ART_FDFILE: android_fdsan_owner_type =
        android_fdsan_owner_type(9);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_DATAGRAMSOCKETIMPL: android_fdsan_owner_type =
        android_fdsan_owner_type(10);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_SOCKETIMPL: android_fdsan_owner_type =
        android_fdsan_owner_type(11);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_ZIPARCHIVE: android_fdsan_owner_type =
        android_fdsan_owner_type(12);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_NATIVE_HANDLE: android_fdsan_owner_type =
        android_fdsan_owner_type(13);
}
impl android_fdsan_owner_type {
    pub const ANDROID_FDSAN_OWNER_TYPE_PARCEL: android_fdsan_owner_type =
        android_fdsan_owner_type(14);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct android_fdsan_owner_type(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn android_fdsan_create_owner_tag(type_: android_fdsan_owner_type, tag: u64) -> u64;
}
extern "C" {
    pub fn android_fdsan_exchange_owner_tag(
        fd: ::std::os::raw::c_int,
        expected_tag: u64,
        new_tag: u64,
    );
}
extern "C" {
    pub fn android_fdsan_close_with_tag(
        fd: ::std::os::raw::c_int,
        tag: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_fdsan_get_owner_tag(fd: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    pub fn android_fdsan_get_tag_type(tag: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn android_fdsan_get_tag_value(tag: u64) -> u64;
}
impl android_fdsan_error_level {
    pub const ANDROID_FDSAN_ERROR_LEVEL_DISABLED: android_fdsan_error_level =
        android_fdsan_error_level(0);
}
impl android_fdsan_error_level {
    pub const ANDROID_FDSAN_ERROR_LEVEL_WARN_ONCE: android_fdsan_error_level =
        android_fdsan_error_level(1);
}
impl android_fdsan_error_level {
    pub const ANDROID_FDSAN_ERROR_LEVEL_WARN_ALWAYS: android_fdsan_error_level =
        android_fdsan_error_level(2);
}
impl android_fdsan_error_level {
    pub const ANDROID_FDSAN_ERROR_LEVEL_FATAL: android_fdsan_error_level =
        android_fdsan_error_level(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct android_fdsan_error_level(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn android_fdsan_get_error_level() -> android_fdsan_error_level;
}
extern "C" {
    pub fn android_fdsan_set_error_level(
        new_level: android_fdsan_error_level,
    ) -> android_fdsan_error_level;
}
extern "C" {
    pub fn android_fdsan_set_error_level_from_property(
        default_level: android_fdsan_error_level,
    ) -> android_fdsan_error_level;
}
extern "C" {
    pub fn AFileDescriptor_create(env: *mut JNIEnv) -> jobject;
}
extern "C" {
    pub fn AFileDescriptor_getFd(
        env: *mut JNIEnv,
        fileDescriptor: jobject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AFileDescriptor_setFd(
        env: *mut JNIEnv,
        fileDescriptor: jobject,
        fd: ::std::os::raw::c_int,
    );
}
pub const AFONT_WEIGHT_MIN: _bindgen_ty_7 = 0;
pub const AFONT_WEIGHT_THIN: _bindgen_ty_7 = 100;
pub const AFONT_WEIGHT_EXTRA_LIGHT: _bindgen_ty_7 = 200;
pub const AFONT_WEIGHT_LIGHT: _bindgen_ty_7 = 300;
pub const AFONT_WEIGHT_NORMAL: _bindgen_ty_7 = 400;
pub const AFONT_WEIGHT_MEDIUM: _bindgen_ty_7 = 500;
pub const AFONT_WEIGHT_SEMI_BOLD: _bindgen_ty_7 = 600;
pub const AFONT_WEIGHT_BOLD: _bindgen_ty_7 = 700;
pub const AFONT_WEIGHT_EXTRA_BOLD: _bindgen_ty_7 = 800;
pub const AFONT_WEIGHT_BLACK: _bindgen_ty_7 = 900;
pub const AFONT_WEIGHT_MAX: _bindgen_ty_7 = 1000;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AFont {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AFont_close(font: *mut AFont);
}
extern "C" {
    pub fn AFont_getFontFilePath(font: *const AFont) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AFont_getWeight(font: *const AFont) -> u16;
}
extern "C" {
    pub fn AFont_isItalic(font: *const AFont) -> bool;
}
extern "C" {
    pub fn AFont_getLocale(font: *const AFont) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AFont_getCollectionIndex(font: *const AFont) -> usize;
}
extern "C" {
    pub fn AFont_getAxisCount(font: *const AFont) -> usize;
}
extern "C" {
    pub fn AFont_getAxisTag(font: *const AFont, axisIndex: u32) -> u32;
}
extern "C" {
    pub fn AFont_getAxisValue(font: *const AFont, axisIndex: u32) -> f32;
}
pub const AFAMILY_VARIANT_DEFAULT: _bindgen_ty_8 = 0;
pub const AFAMILY_VARIANT_COMPACT: _bindgen_ty_8 = 1;
pub const AFAMILY_VARIANT_ELEGANT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AFontMatcher {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AFontMatcher_create() -> *mut AFontMatcher;
}
extern "C" {
    pub fn AFontMatcher_destroy(matcher: *mut AFontMatcher);
}
extern "C" {
    pub fn AFontMatcher_setStyle(matcher: *mut AFontMatcher, weight: u16, italic: bool);
}
extern "C" {
    pub fn AFontMatcher_setLocales(
        matcher: *mut AFontMatcher,
        languageTags: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AFontMatcher_setFamilyVariant(matcher: *mut AFontMatcher, familyVariant: u32);
}
extern "C" {
    pub fn AFontMatcher_match(
        matcher: *const AFontMatcher,
        familyName: *const ::std::os::raw::c_char,
        text: *const u16,
        textLength: u32,
        runLengthOut: *mut u32,
    ) -> *mut AFont;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_ARect() {
    const UNINIT: ::std::mem::MaybeUninit<ARect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ARect>(),
        16usize,
        concat!("Size of: ", stringify!(ARect))
    );
    assert_eq!(
        ::std::mem::align_of::<ARect>(),
        4usize,
        concat!("Alignment of ", stringify!(ARect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(bottom)
        )
    );
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(1);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(2);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(3);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(4);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(22);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R10G10B10A2_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(43);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_BLOB: AHardwareBuffer_Format = AHardwareBuffer_Format(33);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D16_UNORM: AHardwareBuffer_Format = AHardwareBuffer_Format(48);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D24_UNORM: AHardwareBuffer_Format = AHardwareBuffer_Format(49);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D24_UNORM_S8_UINT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(50);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D32_FLOAT: AHardwareBuffer_Format = AHardwareBuffer_Format(51);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D32_FLOAT_S8_UINT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(52);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_S8_UINT: AHardwareBuffer_Format = AHardwareBuffer_Format(53);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_420: AHardwareBuffer_Format =
        AHardwareBuffer_Format(35);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_YCbCr_P010: AHardwareBuffer_Format =
        AHardwareBuffer_Format(54);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8_UNORM: AHardwareBuffer_Format = AHardwareBuffer_Format(56);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R16_UINT: AHardwareBuffer_Format = AHardwareBuffer_Format(57);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R16G16_UINT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(58);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R10G10B10A10_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(59);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AHardwareBuffer_Format(pub ::std::os::raw::c_uint);
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_NEVER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(0);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_RARELY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_OFTEN: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(3);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_MASK: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(15);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_NEVER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(0);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_RARELY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(32);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_OFTEN: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(48);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_MASK: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(240);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(256);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(512);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(512);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_COMPOSER_OVERLAY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2048);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_PROTECTED_CONTENT: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(16384);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VIDEO_ENCODE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(65536);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_SENSOR_DIRECT_DATA: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(8388608);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(16777216);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_CUBE_MAP: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(33554432);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(67108864);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_FRONT_BUFFER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(4294967296);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_0: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(268435456);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_1: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(536870912);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_2: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1073741824);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_3: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2147483648);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_4: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(281474976710656);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_5: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(562949953421312);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_6: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1125899906842624);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_7: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2251799813685248);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_8: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(4503599627370496);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_9: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(9007199254740992);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_10: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(18014398509481984);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_11: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(36028797018963968);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_12: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(72057594037927936);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_13: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(144115188075855872);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_14: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(288230376151711744);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_15: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(576460752303423488);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_16: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1152921504606846976);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_17: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2305843009213693952);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_18: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(4611686018427387904);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_19: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(9223372036854775808);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AHardwareBuffer_UsageFlags(pub ::std::os::raw::c_ulong);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Desc {
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    pub format: u32,
    pub usage: u64,
    pub stride: u32,
    pub rfu0: u32,
    pub rfu1: u64,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Desc() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Desc>(),
        40usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Desc>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu0) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Plane {
    pub data: *mut ::std::os::raw::c_void,
    pub pixelStride: u32,
    pub rowStride: u32,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Plane() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Plane> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Plane>(),
        16usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Plane>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelStride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(pixelStride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowStride) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(rowStride)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Planes {
    pub planeCount: u32,
    pub planes: [AHardwareBuffer_Plane; 4usize],
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Planes() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Planes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Planes>(),
        72usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Planes>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planes)
        )
    );
}
extern "C" {
    pub fn AHardwareBuffer_allocate(
        desc: *const AHardwareBuffer_Desc,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_acquire(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_release(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_describe(
        buffer: *const AHardwareBuffer,
        outDesc: *mut AHardwareBuffer_Desc,
    );
}
extern "C" {
    pub fn AHardwareBuffer_lock(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_unlock(
        buffer: *mut AHardwareBuffer,
        fence: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_sendHandleToUnixSocket(
        buffer: *const AHardwareBuffer,
        socketFd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_recvHandleFromUnixSocket(
        socketFd: ::std::os::raw::c_int,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockPlanes(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outPlanes: *mut AHardwareBuffer_Planes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_isSupported(desc: *const AHardwareBuffer_Desc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockAndGetInfo(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
        outBytesPerPixel: *mut i32,
        outBytesPerStride: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_getId(
        buffer: *const AHardwareBuffer,
        outId: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_fromHardwareBuffer(
        env: *mut JNIEnv,
        hardwareBufferObj: jobject,
    ) -> *mut AHardwareBuffer;
}
extern "C" {
    pub fn AHardwareBuffer_toHardwareBuffer(
        env: *mut JNIEnv,
        hardwareBuffer: *mut AHardwareBuffer,
    ) -> jobject;
}
impl AHdrMetadataType {
    pub const HDR10_SMPTE2086: AHdrMetadataType = AHdrMetadataType(1);
}
impl AHdrMetadataType {
    pub const HDR10_CTA861_3: AHdrMetadataType = AHdrMetadataType(2);
}
impl AHdrMetadataType {
    pub const HDR10PLUS_SEI: AHdrMetadataType = AHdrMetadataType(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AHdrMetadataType(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AColor_xy {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_AColor_xy() {
    const UNINIT: ::std::mem::MaybeUninit<AColor_xy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AColor_xy>(),
        8usize,
        concat!("Size of: ", stringify!(AColor_xy))
    );
    assert_eq!(
        ::std::mem::align_of::<AColor_xy>(),
        4usize,
        concat!("Alignment of ", stringify!(AColor_xy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AColor_xy),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AColor_xy),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHdrMetadata_smpte2086 {
    pub displayPrimaryRed: AColor_xy,
    pub displayPrimaryGreen: AColor_xy,
    pub displayPrimaryBlue: AColor_xy,
    pub whitePoint: AColor_xy,
    pub maxLuminance: f32,
    pub minLuminance: f32,
}
#[test]
fn bindgen_test_layout_AHdrMetadata_smpte2086() {
    const UNINIT: ::std::mem::MaybeUninit<AHdrMetadata_smpte2086> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHdrMetadata_smpte2086>(),
        40usize,
        concat!("Size of: ", stringify!(AHdrMetadata_smpte2086))
    );
    assert_eq!(
        ::std::mem::align_of::<AHdrMetadata_smpte2086>(),
        4usize,
        concat!("Alignment of ", stringify!(AHdrMetadata_smpte2086))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimaryRed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(displayPrimaryRed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimaryGreen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(displayPrimaryGreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimaryBlue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(displayPrimaryBlue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).whitePoint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(whitePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxLuminance) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(maxLuminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minLuminance) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_smpte2086),
            "::",
            stringify!(minLuminance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHdrMetadata_cta861_3 {
    pub maxContentLightLevel: f32,
    pub maxFrameAverageLightLevel: f32,
}
#[test]
fn bindgen_test_layout_AHdrMetadata_cta861_3() {
    const UNINIT: ::std::mem::MaybeUninit<AHdrMetadata_cta861_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHdrMetadata_cta861_3>(),
        8usize,
        concat!("Size of: ", stringify!(AHdrMetadata_cta861_3))
    );
    assert_eq!(
        ::std::mem::align_of::<AHdrMetadata_cta861_3>(),
        4usize,
        concat!("Alignment of ", stringify!(AHdrMetadata_cta861_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxContentLightLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_cta861_3),
            "::",
            stringify!(maxContentLightLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFrameAverageLightLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHdrMetadata_cta861_3),
            "::",
            stringify!(maxFrameAverageLightLevel)
        )
    );
}
pub const ANDROID_IMAGE_DECODER_SUCCESS: _bindgen_ty_9 = 0;
pub const ANDROID_IMAGE_DECODER_INCOMPLETE: _bindgen_ty_9 = -1;
pub const ANDROID_IMAGE_DECODER_ERROR: _bindgen_ty_9 = -2;
pub const ANDROID_IMAGE_DECODER_INVALID_CONVERSION: _bindgen_ty_9 = -3;
pub const ANDROID_IMAGE_DECODER_INVALID_SCALE: _bindgen_ty_9 = -4;
pub const ANDROID_IMAGE_DECODER_BAD_PARAMETER: _bindgen_ty_9 = -5;
pub const ANDROID_IMAGE_DECODER_INVALID_INPUT: _bindgen_ty_9 = -6;
pub const ANDROID_IMAGE_DECODER_SEEK_ERROR: _bindgen_ty_9 = -7;
pub const ANDROID_IMAGE_DECODER_INTERNAL_ERROR: _bindgen_ty_9 = -8;
pub const ANDROID_IMAGE_DECODER_UNSUPPORTED_FORMAT: _bindgen_ty_9 = -9;
pub const ANDROID_IMAGE_DECODER_FINISHED: _bindgen_ty_9 = -10;
pub const ANDROID_IMAGE_DECODER_INVALID_STATE: _bindgen_ty_9 = -11;
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
extern "C" {
    pub fn AImageDecoder_resultToString(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageDecoder {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AImageDecoder_createFromAAsset(
        asset: *mut AAsset,
        outDecoder: *mut *mut AImageDecoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_createFromFd(
        fd: ::std::os::raw::c_int,
        outDecoder: *mut *mut AImageDecoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_createFromBuffer(
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        outDecoder: *mut *mut AImageDecoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_delete(decoder: *mut AImageDecoder);
}
extern "C" {
    pub fn AImageDecoder_setAndroidBitmapFormat(
        decoder: *mut AImageDecoder,
        format: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_setUnpremultipliedRequired(
        decoder: *mut AImageDecoder,
        unpremultipliedRequired: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_setDataSpace(
        decoder: *mut AImageDecoder,
        dataspace: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_setTargetSize(
        decoder: *mut AImageDecoder,
        width: i32,
        height: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_computeSampledSize(
        decoder: *const AImageDecoder,
        sampleSize: ::std::os::raw::c_int,
        width: *mut i32,
        height: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_setCrop(decoder: *mut AImageDecoder, crop: ARect)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageDecoderHeaderInfo {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AImageDecoder_getHeaderInfo(
        decoder: *const AImageDecoder,
    ) -> *const AImageDecoderHeaderInfo;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getWidth(arg1: *const AImageDecoderHeaderInfo) -> i32;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getHeight(arg1: *const AImageDecoderHeaderInfo) -> i32;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getMimeType(
        arg1: *const AImageDecoderHeaderInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getAndroidBitmapFormat(
        arg1: *const AImageDecoderHeaderInfo,
    ) -> i32;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getAlphaFlags(
        arg1: *const AImageDecoderHeaderInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoderHeaderInfo_getDataSpace(arg1: *const AImageDecoderHeaderInfo) -> i32;
}
extern "C" {
    pub fn AImageDecoder_getMinimumStride(decoder: *mut AImageDecoder) -> usize;
}
extern "C" {
    pub fn AImageDecoder_decodeImage(
        decoder: *mut AImageDecoder,
        pixels: *mut ::std::os::raw::c_void,
        stride: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_isAnimated(decoder: *mut AImageDecoder) -> bool;
}
pub const ANDROID_IMAGE_DECODER_INFINITE: _bindgen_ty_10 = 2147483647;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AImageDecoder_getRepeatCount(decoder: *mut AImageDecoder) -> i32;
}
extern "C" {
    pub fn AImageDecoder_advanceFrame(decoder: *mut AImageDecoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoder_rewind(decoder: *mut AImageDecoder) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageDecoderFrameInfo {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AImageDecoderFrameInfo_create() -> *mut AImageDecoderFrameInfo;
}
extern "C" {
    pub fn AImageDecoderFrameInfo_delete(info: *mut AImageDecoderFrameInfo);
}
extern "C" {
    pub fn AImageDecoder_getFrameInfo(
        decoder: *mut AImageDecoder,
        info: *mut AImageDecoderFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AImageDecoderFrameInfo_getDuration(info: *const AImageDecoderFrameInfo) -> i64;
}
extern "C" {
    pub fn AImageDecoderFrameInfo_getFrameRect(info: *const AImageDecoderFrameInfo) -> ARect;
}
extern "C" {
    pub fn AImageDecoderFrameInfo_hasAlphaWithinBounds(info: *const AImageDecoderFrameInfo)
        -> bool;
}
pub const ANDROID_IMAGE_DECODER_DISPOSE_OP_NONE: _bindgen_ty_11 = 1;
pub const ANDROID_IMAGE_DECODER_DISPOSE_OP_BACKGROUND: _bindgen_ty_11 = 2;
pub const ANDROID_IMAGE_DECODER_DISPOSE_OP_PREVIOUS: _bindgen_ty_11 = 3;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AImageDecoderFrameInfo_getDisposeOp(info: *const AImageDecoderFrameInfo) -> i32;
}
pub const ANDROID_IMAGE_DECODER_BLEND_OP_SRC: _bindgen_ty_12 = 1;
pub const ANDROID_IMAGE_DECODER_BLEND_OP_SRC_OVER: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AImageDecoderFrameInfo_getBlendOp(info: *const AImageDecoderFrameInfo) -> i32;
}
extern "C" {
    pub fn AImageDecoder_setInternallyHandleDisposePrevious(
        decoder: *mut AImageDecoder,
        handleInternally: bool,
    );
}
pub const AKEYCODE_UNKNOWN: _bindgen_ty_13 = 0;
pub const AKEYCODE_SOFT_LEFT: _bindgen_ty_13 = 1;
pub const AKEYCODE_SOFT_RIGHT: _bindgen_ty_13 = 2;
pub const AKEYCODE_HOME: _bindgen_ty_13 = 3;
pub const AKEYCODE_BACK: _bindgen_ty_13 = 4;
pub const AKEYCODE_CALL: _bindgen_ty_13 = 5;
pub const AKEYCODE_ENDCALL: _bindgen_ty_13 = 6;
pub const AKEYCODE_0: _bindgen_ty_13 = 7;
pub const AKEYCODE_1: _bindgen_ty_13 = 8;
pub const AKEYCODE_2: _bindgen_ty_13 = 9;
pub const AKEYCODE_3: _bindgen_ty_13 = 10;
pub const AKEYCODE_4: _bindgen_ty_13 = 11;
pub const AKEYCODE_5: _bindgen_ty_13 = 12;
pub const AKEYCODE_6: _bindgen_ty_13 = 13;
pub const AKEYCODE_7: _bindgen_ty_13 = 14;
pub const AKEYCODE_8: _bindgen_ty_13 = 15;
pub const AKEYCODE_9: _bindgen_ty_13 = 16;
pub const AKEYCODE_STAR: _bindgen_ty_13 = 17;
pub const AKEYCODE_POUND: _bindgen_ty_13 = 18;
pub const AKEYCODE_DPAD_UP: _bindgen_ty_13 = 19;
pub const AKEYCODE_DPAD_DOWN: _bindgen_ty_13 = 20;
pub const AKEYCODE_DPAD_LEFT: _bindgen_ty_13 = 21;
pub const AKEYCODE_DPAD_RIGHT: _bindgen_ty_13 = 22;
pub const AKEYCODE_DPAD_CENTER: _bindgen_ty_13 = 23;
pub const AKEYCODE_VOLUME_UP: _bindgen_ty_13 = 24;
pub const AKEYCODE_VOLUME_DOWN: _bindgen_ty_13 = 25;
pub const AKEYCODE_POWER: _bindgen_ty_13 = 26;
pub const AKEYCODE_CAMERA: _bindgen_ty_13 = 27;
pub const AKEYCODE_CLEAR: _bindgen_ty_13 = 28;
pub const AKEYCODE_A: _bindgen_ty_13 = 29;
pub const AKEYCODE_B: _bindgen_ty_13 = 30;
pub const AKEYCODE_C: _bindgen_ty_13 = 31;
pub const AKEYCODE_D: _bindgen_ty_13 = 32;
pub const AKEYCODE_E: _bindgen_ty_13 = 33;
pub const AKEYCODE_F: _bindgen_ty_13 = 34;
pub const AKEYCODE_G: _bindgen_ty_13 = 35;
pub const AKEYCODE_H: _bindgen_ty_13 = 36;
pub const AKEYCODE_I: _bindgen_ty_13 = 37;
pub const AKEYCODE_J: _bindgen_ty_13 = 38;
pub const AKEYCODE_K: _bindgen_ty_13 = 39;
pub const AKEYCODE_L: _bindgen_ty_13 = 40;
pub const AKEYCODE_M: _bindgen_ty_13 = 41;
pub const AKEYCODE_N: _bindgen_ty_13 = 42;
pub const AKEYCODE_O: _bindgen_ty_13 = 43;
pub const AKEYCODE_P: _bindgen_ty_13 = 44;
pub const AKEYCODE_Q: _bindgen_ty_13 = 45;
pub const AKEYCODE_R: _bindgen_ty_13 = 46;
pub const AKEYCODE_S: _bindgen_ty_13 = 47;
pub const AKEYCODE_T: _bindgen_ty_13 = 48;
pub const AKEYCODE_U: _bindgen_ty_13 = 49;
pub const AKEYCODE_V: _bindgen_ty_13 = 50;
pub const AKEYCODE_W: _bindgen_ty_13 = 51;
pub const AKEYCODE_X: _bindgen_ty_13 = 52;
pub const AKEYCODE_Y: _bindgen_ty_13 = 53;
pub const AKEYCODE_Z: _bindgen_ty_13 = 54;
pub const AKEYCODE_COMMA: _bindgen_ty_13 = 55;
pub const AKEYCODE_PERIOD: _bindgen_ty_13 = 56;
pub const AKEYCODE_ALT_LEFT: _bindgen_ty_13 = 57;
pub const AKEYCODE_ALT_RIGHT: _bindgen_ty_13 = 58;
pub const AKEYCODE_SHIFT_LEFT: _bindgen_ty_13 = 59;
pub const AKEYCODE_SHIFT_RIGHT: _bindgen_ty_13 = 60;
pub const AKEYCODE_TAB: _bindgen_ty_13 = 61;
pub const AKEYCODE_SPACE: _bindgen_ty_13 = 62;
pub const AKEYCODE_SYM: _bindgen_ty_13 = 63;
pub const AKEYCODE_EXPLORER: _bindgen_ty_13 = 64;
pub const AKEYCODE_ENVELOPE: _bindgen_ty_13 = 65;
pub const AKEYCODE_ENTER: _bindgen_ty_13 = 66;
pub const AKEYCODE_DEL: _bindgen_ty_13 = 67;
pub const AKEYCODE_GRAVE: _bindgen_ty_13 = 68;
pub const AKEYCODE_MINUS: _bindgen_ty_13 = 69;
pub const AKEYCODE_EQUALS: _bindgen_ty_13 = 70;
pub const AKEYCODE_LEFT_BRACKET: _bindgen_ty_13 = 71;
pub const AKEYCODE_RIGHT_BRACKET: _bindgen_ty_13 = 72;
pub const AKEYCODE_BACKSLASH: _bindgen_ty_13 = 73;
pub const AKEYCODE_SEMICOLON: _bindgen_ty_13 = 74;
pub const AKEYCODE_APOSTROPHE: _bindgen_ty_13 = 75;
pub const AKEYCODE_SLASH: _bindgen_ty_13 = 76;
pub const AKEYCODE_AT: _bindgen_ty_13 = 77;
pub const AKEYCODE_NUM: _bindgen_ty_13 = 78;
pub const AKEYCODE_HEADSETHOOK: _bindgen_ty_13 = 79;
pub const AKEYCODE_FOCUS: _bindgen_ty_13 = 80;
pub const AKEYCODE_PLUS: _bindgen_ty_13 = 81;
pub const AKEYCODE_MENU: _bindgen_ty_13 = 82;
pub const AKEYCODE_NOTIFICATION: _bindgen_ty_13 = 83;
pub const AKEYCODE_SEARCH: _bindgen_ty_13 = 84;
pub const AKEYCODE_MEDIA_PLAY_PAUSE: _bindgen_ty_13 = 85;
pub const AKEYCODE_MEDIA_STOP: _bindgen_ty_13 = 86;
pub const AKEYCODE_MEDIA_NEXT: _bindgen_ty_13 = 87;
pub const AKEYCODE_MEDIA_PREVIOUS: _bindgen_ty_13 = 88;
pub const AKEYCODE_MEDIA_REWIND: _bindgen_ty_13 = 89;
pub const AKEYCODE_MEDIA_FAST_FORWARD: _bindgen_ty_13 = 90;
pub const AKEYCODE_MUTE: _bindgen_ty_13 = 91;
pub const AKEYCODE_PAGE_UP: _bindgen_ty_13 = 92;
pub const AKEYCODE_PAGE_DOWN: _bindgen_ty_13 = 93;
pub const AKEYCODE_PICTSYMBOLS: _bindgen_ty_13 = 94;
pub const AKEYCODE_SWITCH_CHARSET: _bindgen_ty_13 = 95;
pub const AKEYCODE_BUTTON_A: _bindgen_ty_13 = 96;
pub const AKEYCODE_BUTTON_B: _bindgen_ty_13 = 97;
pub const AKEYCODE_BUTTON_C: _bindgen_ty_13 = 98;
pub const AKEYCODE_BUTTON_X: _bindgen_ty_13 = 99;
pub const AKEYCODE_BUTTON_Y: _bindgen_ty_13 = 100;
pub const AKEYCODE_BUTTON_Z: _bindgen_ty_13 = 101;
pub const AKEYCODE_BUTTON_L1: _bindgen_ty_13 = 102;
pub const AKEYCODE_BUTTON_R1: _bindgen_ty_13 = 103;
pub const AKEYCODE_BUTTON_L2: _bindgen_ty_13 = 104;
pub const AKEYCODE_BUTTON_R2: _bindgen_ty_13 = 105;
pub const AKEYCODE_BUTTON_THUMBL: _bindgen_ty_13 = 106;
pub const AKEYCODE_BUTTON_THUMBR: _bindgen_ty_13 = 107;
pub const AKEYCODE_BUTTON_START: _bindgen_ty_13 = 108;
pub const AKEYCODE_BUTTON_SELECT: _bindgen_ty_13 = 109;
pub const AKEYCODE_BUTTON_MODE: _bindgen_ty_13 = 110;
pub const AKEYCODE_ESCAPE: _bindgen_ty_13 = 111;
pub const AKEYCODE_FORWARD_DEL: _bindgen_ty_13 = 112;
pub const AKEYCODE_CTRL_LEFT: _bindgen_ty_13 = 113;
pub const AKEYCODE_CTRL_RIGHT: _bindgen_ty_13 = 114;
pub const AKEYCODE_CAPS_LOCK: _bindgen_ty_13 = 115;
pub const AKEYCODE_SCROLL_LOCK: _bindgen_ty_13 = 116;
pub const AKEYCODE_META_LEFT: _bindgen_ty_13 = 117;
pub const AKEYCODE_META_RIGHT: _bindgen_ty_13 = 118;
pub const AKEYCODE_FUNCTION: _bindgen_ty_13 = 119;
pub const AKEYCODE_SYSRQ: _bindgen_ty_13 = 120;
pub const AKEYCODE_BREAK: _bindgen_ty_13 = 121;
pub const AKEYCODE_MOVE_HOME: _bindgen_ty_13 = 122;
pub const AKEYCODE_MOVE_END: _bindgen_ty_13 = 123;
pub const AKEYCODE_INSERT: _bindgen_ty_13 = 124;
pub const AKEYCODE_FORWARD: _bindgen_ty_13 = 125;
pub const AKEYCODE_MEDIA_PLAY: _bindgen_ty_13 = 126;
pub const AKEYCODE_MEDIA_PAUSE: _bindgen_ty_13 = 127;
pub const AKEYCODE_MEDIA_CLOSE: _bindgen_ty_13 = 128;
pub const AKEYCODE_MEDIA_EJECT: _bindgen_ty_13 = 129;
pub const AKEYCODE_MEDIA_RECORD: _bindgen_ty_13 = 130;
pub const AKEYCODE_F1: _bindgen_ty_13 = 131;
pub const AKEYCODE_F2: _bindgen_ty_13 = 132;
pub const AKEYCODE_F3: _bindgen_ty_13 = 133;
pub const AKEYCODE_F4: _bindgen_ty_13 = 134;
pub const AKEYCODE_F5: _bindgen_ty_13 = 135;
pub const AKEYCODE_F6: _bindgen_ty_13 = 136;
pub const AKEYCODE_F7: _bindgen_ty_13 = 137;
pub const AKEYCODE_F8: _bindgen_ty_13 = 138;
pub const AKEYCODE_F9: _bindgen_ty_13 = 139;
pub const AKEYCODE_F10: _bindgen_ty_13 = 140;
pub const AKEYCODE_F11: _bindgen_ty_13 = 141;
pub const AKEYCODE_F12: _bindgen_ty_13 = 142;
pub const AKEYCODE_NUM_LOCK: _bindgen_ty_13 = 143;
pub const AKEYCODE_NUMPAD_0: _bindgen_ty_13 = 144;
pub const AKEYCODE_NUMPAD_1: _bindgen_ty_13 = 145;
pub const AKEYCODE_NUMPAD_2: _bindgen_ty_13 = 146;
pub const AKEYCODE_NUMPAD_3: _bindgen_ty_13 = 147;
pub const AKEYCODE_NUMPAD_4: _bindgen_ty_13 = 148;
pub const AKEYCODE_NUMPAD_5: _bindgen_ty_13 = 149;
pub const AKEYCODE_NUMPAD_6: _bindgen_ty_13 = 150;
pub const AKEYCODE_NUMPAD_7: _bindgen_ty_13 = 151;
pub const AKEYCODE_NUMPAD_8: _bindgen_ty_13 = 152;
pub const AKEYCODE_NUMPAD_9: _bindgen_ty_13 = 153;
pub const AKEYCODE_NUMPAD_DIVIDE: _bindgen_ty_13 = 154;
pub const AKEYCODE_NUMPAD_MULTIPLY: _bindgen_ty_13 = 155;
pub const AKEYCODE_NUMPAD_SUBTRACT: _bindgen_ty_13 = 156;
pub const AKEYCODE_NUMPAD_ADD: _bindgen_ty_13 = 157;
pub const AKEYCODE_NUMPAD_DOT: _bindgen_ty_13 = 158;
pub const AKEYCODE_NUMPAD_COMMA: _bindgen_ty_13 = 159;
pub const AKEYCODE_NUMPAD_ENTER: _bindgen_ty_13 = 160;
pub const AKEYCODE_NUMPAD_EQUALS: _bindgen_ty_13 = 161;
pub const AKEYCODE_NUMPAD_LEFT_PAREN: _bindgen_ty_13 = 162;
pub const AKEYCODE_NUMPAD_RIGHT_PAREN: _bindgen_ty_13 = 163;
pub const AKEYCODE_VOLUME_MUTE: _bindgen_ty_13 = 164;
pub const AKEYCODE_INFO: _bindgen_ty_13 = 165;
pub const AKEYCODE_CHANNEL_UP: _bindgen_ty_13 = 166;
pub const AKEYCODE_CHANNEL_DOWN: _bindgen_ty_13 = 167;
pub const AKEYCODE_ZOOM_IN: _bindgen_ty_13 = 168;
pub const AKEYCODE_ZOOM_OUT: _bindgen_ty_13 = 169;
pub const AKEYCODE_TV: _bindgen_ty_13 = 170;
pub const AKEYCODE_WINDOW: _bindgen_ty_13 = 171;
pub const AKEYCODE_GUIDE: _bindgen_ty_13 = 172;
pub const AKEYCODE_DVR: _bindgen_ty_13 = 173;
pub const AKEYCODE_BOOKMARK: _bindgen_ty_13 = 174;
pub const AKEYCODE_CAPTIONS: _bindgen_ty_13 = 175;
pub const AKEYCODE_SETTINGS: _bindgen_ty_13 = 176;
pub const AKEYCODE_TV_POWER: _bindgen_ty_13 = 177;
pub const AKEYCODE_TV_INPUT: _bindgen_ty_13 = 178;
pub const AKEYCODE_STB_POWER: _bindgen_ty_13 = 179;
pub const AKEYCODE_STB_INPUT: _bindgen_ty_13 = 180;
pub const AKEYCODE_AVR_POWER: _bindgen_ty_13 = 181;
pub const AKEYCODE_AVR_INPUT: _bindgen_ty_13 = 182;
pub const AKEYCODE_PROG_RED: _bindgen_ty_13 = 183;
pub const AKEYCODE_PROG_GREEN: _bindgen_ty_13 = 184;
pub const AKEYCODE_PROG_YELLOW: _bindgen_ty_13 = 185;
pub const AKEYCODE_PROG_BLUE: _bindgen_ty_13 = 186;
pub const AKEYCODE_APP_SWITCH: _bindgen_ty_13 = 187;
pub const AKEYCODE_BUTTON_1: _bindgen_ty_13 = 188;
pub const AKEYCODE_BUTTON_2: _bindgen_ty_13 = 189;
pub const AKEYCODE_BUTTON_3: _bindgen_ty_13 = 190;
pub const AKEYCODE_BUTTON_4: _bindgen_ty_13 = 191;
pub const AKEYCODE_BUTTON_5: _bindgen_ty_13 = 192;
pub const AKEYCODE_BUTTON_6: _bindgen_ty_13 = 193;
pub const AKEYCODE_BUTTON_7: _bindgen_ty_13 = 194;
pub const AKEYCODE_BUTTON_8: _bindgen_ty_13 = 195;
pub const AKEYCODE_BUTTON_9: _bindgen_ty_13 = 196;
pub const AKEYCODE_BUTTON_10: _bindgen_ty_13 = 197;
pub const AKEYCODE_BUTTON_11: _bindgen_ty_13 = 198;
pub const AKEYCODE_BUTTON_12: _bindgen_ty_13 = 199;
pub const AKEYCODE_BUTTON_13: _bindgen_ty_13 = 200;
pub const AKEYCODE_BUTTON_14: _bindgen_ty_13 = 201;
pub const AKEYCODE_BUTTON_15: _bindgen_ty_13 = 202;
pub const AKEYCODE_BUTTON_16: _bindgen_ty_13 = 203;
pub const AKEYCODE_LANGUAGE_SWITCH: _bindgen_ty_13 = 204;
pub const AKEYCODE_MANNER_MODE: _bindgen_ty_13 = 205;
pub const AKEYCODE_3D_MODE: _bindgen_ty_13 = 206;
pub const AKEYCODE_CONTACTS: _bindgen_ty_13 = 207;
pub const AKEYCODE_CALENDAR: _bindgen_ty_13 = 208;
pub const AKEYCODE_MUSIC: _bindgen_ty_13 = 209;
pub const AKEYCODE_CALCULATOR: _bindgen_ty_13 = 210;
pub const AKEYCODE_ZENKAKU_HANKAKU: _bindgen_ty_13 = 211;
pub const AKEYCODE_EISU: _bindgen_ty_13 = 212;
pub const AKEYCODE_MUHENKAN: _bindgen_ty_13 = 213;
pub const AKEYCODE_HENKAN: _bindgen_ty_13 = 214;
pub const AKEYCODE_KATAKANA_HIRAGANA: _bindgen_ty_13 = 215;
pub const AKEYCODE_YEN: _bindgen_ty_13 = 216;
pub const AKEYCODE_RO: _bindgen_ty_13 = 217;
pub const AKEYCODE_KANA: _bindgen_ty_13 = 218;
pub const AKEYCODE_ASSIST: _bindgen_ty_13 = 219;
pub const AKEYCODE_BRIGHTNESS_DOWN: _bindgen_ty_13 = 220;
pub const AKEYCODE_BRIGHTNESS_UP: _bindgen_ty_13 = 221;
pub const AKEYCODE_MEDIA_AUDIO_TRACK: _bindgen_ty_13 = 222;
pub const AKEYCODE_SLEEP: _bindgen_ty_13 = 223;
pub const AKEYCODE_WAKEUP: _bindgen_ty_13 = 224;
pub const AKEYCODE_PAIRING: _bindgen_ty_13 = 225;
pub const AKEYCODE_MEDIA_TOP_MENU: _bindgen_ty_13 = 226;
pub const AKEYCODE_11: _bindgen_ty_13 = 227;
pub const AKEYCODE_12: _bindgen_ty_13 = 228;
pub const AKEYCODE_LAST_CHANNEL: _bindgen_ty_13 = 229;
pub const AKEYCODE_TV_DATA_SERVICE: _bindgen_ty_13 = 230;
pub const AKEYCODE_VOICE_ASSIST: _bindgen_ty_13 = 231;
pub const AKEYCODE_TV_RADIO_SERVICE: _bindgen_ty_13 = 232;
pub const AKEYCODE_TV_TELETEXT: _bindgen_ty_13 = 233;
pub const AKEYCODE_TV_NUMBER_ENTRY: _bindgen_ty_13 = 234;
pub const AKEYCODE_TV_TERRESTRIAL_ANALOG: _bindgen_ty_13 = 235;
pub const AKEYCODE_TV_TERRESTRIAL_DIGITAL: _bindgen_ty_13 = 236;
pub const AKEYCODE_TV_SATELLITE: _bindgen_ty_13 = 237;
pub const AKEYCODE_TV_SATELLITE_BS: _bindgen_ty_13 = 238;
pub const AKEYCODE_TV_SATELLITE_CS: _bindgen_ty_13 = 239;
pub const AKEYCODE_TV_SATELLITE_SERVICE: _bindgen_ty_13 = 240;
pub const AKEYCODE_TV_NETWORK: _bindgen_ty_13 = 241;
pub const AKEYCODE_TV_ANTENNA_CABLE: _bindgen_ty_13 = 242;
pub const AKEYCODE_TV_INPUT_HDMI_1: _bindgen_ty_13 = 243;
pub const AKEYCODE_TV_INPUT_HDMI_2: _bindgen_ty_13 = 244;
pub const AKEYCODE_TV_INPUT_HDMI_3: _bindgen_ty_13 = 245;
pub const AKEYCODE_TV_INPUT_HDMI_4: _bindgen_ty_13 = 246;
pub const AKEYCODE_TV_INPUT_COMPOSITE_1: _bindgen_ty_13 = 247;
pub const AKEYCODE_TV_INPUT_COMPOSITE_2: _bindgen_ty_13 = 248;
pub const AKEYCODE_TV_INPUT_COMPONENT_1: _bindgen_ty_13 = 249;
pub const AKEYCODE_TV_INPUT_COMPONENT_2: _bindgen_ty_13 = 250;
pub const AKEYCODE_TV_INPUT_VGA_1: _bindgen_ty_13 = 251;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION: _bindgen_ty_13 = 252;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP: _bindgen_ty_13 = 253;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN: _bindgen_ty_13 = 254;
pub const AKEYCODE_TV_ZOOM_MODE: _bindgen_ty_13 = 255;
pub const AKEYCODE_TV_CONTENTS_MENU: _bindgen_ty_13 = 256;
pub const AKEYCODE_TV_MEDIA_CONTEXT_MENU: _bindgen_ty_13 = 257;
pub const AKEYCODE_TV_TIMER_PROGRAMMING: _bindgen_ty_13 = 258;
pub const AKEYCODE_HELP: _bindgen_ty_13 = 259;
pub const AKEYCODE_NAVIGATE_PREVIOUS: _bindgen_ty_13 = 260;
pub const AKEYCODE_NAVIGATE_NEXT: _bindgen_ty_13 = 261;
pub const AKEYCODE_NAVIGATE_IN: _bindgen_ty_13 = 262;
pub const AKEYCODE_NAVIGATE_OUT: _bindgen_ty_13 = 263;
pub const AKEYCODE_STEM_PRIMARY: _bindgen_ty_13 = 264;
pub const AKEYCODE_STEM_1: _bindgen_ty_13 = 265;
pub const AKEYCODE_STEM_2: _bindgen_ty_13 = 266;
pub const AKEYCODE_STEM_3: _bindgen_ty_13 = 267;
pub const AKEYCODE_DPAD_UP_LEFT: _bindgen_ty_13 = 268;
pub const AKEYCODE_DPAD_DOWN_LEFT: _bindgen_ty_13 = 269;
pub const AKEYCODE_DPAD_UP_RIGHT: _bindgen_ty_13 = 270;
pub const AKEYCODE_DPAD_DOWN_RIGHT: _bindgen_ty_13 = 271;
pub const AKEYCODE_MEDIA_SKIP_FORWARD: _bindgen_ty_13 = 272;
pub const AKEYCODE_MEDIA_SKIP_BACKWARD: _bindgen_ty_13 = 273;
pub const AKEYCODE_MEDIA_STEP_FORWARD: _bindgen_ty_13 = 274;
pub const AKEYCODE_MEDIA_STEP_BACKWARD: _bindgen_ty_13 = 275;
pub const AKEYCODE_SOFT_SLEEP: _bindgen_ty_13 = 276;
pub const AKEYCODE_CUT: _bindgen_ty_13 = 277;
pub const AKEYCODE_COPY: _bindgen_ty_13 = 278;
pub const AKEYCODE_PASTE: _bindgen_ty_13 = 279;
pub const AKEYCODE_SYSTEM_NAVIGATION_UP: _bindgen_ty_13 = 280;
pub const AKEYCODE_SYSTEM_NAVIGATION_DOWN: _bindgen_ty_13 = 281;
pub const AKEYCODE_SYSTEM_NAVIGATION_LEFT: _bindgen_ty_13 = 282;
pub const AKEYCODE_SYSTEM_NAVIGATION_RIGHT: _bindgen_ty_13 = 283;
pub const AKEYCODE_ALL_APPS: _bindgen_ty_13 = 284;
pub const AKEYCODE_REFRESH: _bindgen_ty_13 = 285;
pub const AKEYCODE_THUMBS_UP: _bindgen_ty_13 = 286;
pub const AKEYCODE_THUMBS_DOWN: _bindgen_ty_13 = 287;
pub const AKEYCODE_PROFILE_SWITCH: _bindgen_ty_13 = 288;
pub const AKEYCODE_VIDEO_APP_1: _bindgen_ty_13 = 289;
pub const AKEYCODE_VIDEO_APP_2: _bindgen_ty_13 = 290;
pub const AKEYCODE_VIDEO_APP_3: _bindgen_ty_13 = 291;
pub const AKEYCODE_VIDEO_APP_4: _bindgen_ty_13 = 292;
pub const AKEYCODE_VIDEO_APP_5: _bindgen_ty_13 = 293;
pub const AKEYCODE_VIDEO_APP_6: _bindgen_ty_13 = 294;
pub const AKEYCODE_VIDEO_APP_7: _bindgen_ty_13 = 295;
pub const AKEYCODE_VIDEO_APP_8: _bindgen_ty_13 = 296;
pub const AKEYCODE_FEATURED_APP_1: _bindgen_ty_13 = 297;
pub const AKEYCODE_FEATURED_APP_2: _bindgen_ty_13 = 298;
pub const AKEYCODE_FEATURED_APP_3: _bindgen_ty_13 = 299;
pub const AKEYCODE_FEATURED_APP_4: _bindgen_ty_13 = 300;
pub const AKEYCODE_DEMO_APP_1: _bindgen_ty_13 = 301;
pub const AKEYCODE_DEMO_APP_2: _bindgen_ty_13 = 302;
pub const AKEYCODE_DEMO_APP_3: _bindgen_ty_13 = 303;
pub const AKEYCODE_DEMO_APP_4: _bindgen_ty_13 = 304;
pub const AKEYCODE_KEYBOARD_BACKLIGHT_DOWN: _bindgen_ty_13 = 305;
pub const AKEYCODE_KEYBOARD_BACKLIGHT_UP: _bindgen_ty_13 = 306;
pub const AKEYCODE_KEYBOARD_BACKLIGHT_TOGGLE: _bindgen_ty_13 = 307;
pub const AKEYCODE_STYLUS_BUTTON_PRIMARY: _bindgen_ty_13 = 308;
pub const AKEYCODE_STYLUS_BUTTON_SECONDARY: _bindgen_ty_13 = 309;
pub const AKEYCODE_STYLUS_BUTTON_TERTIARY: _bindgen_ty_13 = 310;
pub const AKEYCODE_STYLUS_BUTTON_TAIL: _bindgen_ty_13 = 311;
pub const AKEYCODE_RECENT_APPS: _bindgen_ty_13 = 312;
pub const AKEYCODE_MACRO_1: _bindgen_ty_13 = 313;
pub const AKEYCODE_MACRO_2: _bindgen_ty_13 = 314;
pub const AKEYCODE_MACRO_3: _bindgen_ty_13 = 315;
pub const AKEYCODE_MACRO_4: _bindgen_ty_13 = 316;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALooper {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ALooper_forThread() -> *mut ALooper;
}
pub const ALOOPER_PREPARE_ALLOW_NON_CALLBACKS: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn ALooper_prepare(opts: ::std::os::raw::c_int) -> *mut ALooper;
}
pub const ALOOPER_POLL_WAKE: _bindgen_ty_15 = -1;
pub const ALOOPER_POLL_CALLBACK: _bindgen_ty_15 = -2;
pub const ALOOPER_POLL_TIMEOUT: _bindgen_ty_15 = -3;
pub const ALOOPER_POLL_ERROR: _bindgen_ty_15 = -4;
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
extern "C" {
    pub fn ALooper_acquire(looper: *mut ALooper);
}
extern "C" {
    pub fn ALooper_release(looper: *mut ALooper);
}
pub const ALOOPER_EVENT_INPUT: _bindgen_ty_16 = 1;
pub const ALOOPER_EVENT_OUTPUT: _bindgen_ty_16 = 2;
pub const ALOOPER_EVENT_ERROR: _bindgen_ty_16 = 4;
pub const ALOOPER_EVENT_HANGUP: _bindgen_ty_16 = 8;
pub const ALOOPER_EVENT_INVALID: _bindgen_ty_16 = 16;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub type ALooper_callbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        events: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ALooper_pollOnce(
        timeoutMillis: ::std::os::raw::c_int,
        outFd: *mut ::std::os::raw::c_int,
        outEvents: *mut ::std::os::raw::c_int,
        outData: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ALooper_pollAll(
        timeoutMillis: ::std::os::raw::c_int,
        outFd: *mut ::std::os::raw::c_int,
        outEvents: *mut ::std::os::raw::c_int,
        outData: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ALooper_wake(looper: *mut ALooper);
}
extern "C" {
    pub fn ALooper_addFd(
        looper: *mut ALooper,
        fd: ::std::os::raw::c_int,
        ident: ::std::os::raw::c_int,
        events: ::std::os::raw::c_int,
        callback: ALooper_callbackFunc,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ALooper_removeFd(
        looper: *mut ALooper,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AKEY_STATE_UNKNOWN: _bindgen_ty_17 = -1;
pub const AKEY_STATE_UP: _bindgen_ty_17 = 0;
pub const AKEY_STATE_DOWN: _bindgen_ty_17 = 1;
pub const AKEY_STATE_VIRTUAL: _bindgen_ty_17 = 2;
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
pub const AMETA_NONE: _bindgen_ty_18 = 0;
pub const AMETA_ALT_ON: _bindgen_ty_18 = 2;
pub const AMETA_ALT_LEFT_ON: _bindgen_ty_18 = 16;
pub const AMETA_ALT_RIGHT_ON: _bindgen_ty_18 = 32;
pub const AMETA_SHIFT_ON: _bindgen_ty_18 = 1;
pub const AMETA_SHIFT_LEFT_ON: _bindgen_ty_18 = 64;
pub const AMETA_SHIFT_RIGHT_ON: _bindgen_ty_18 = 128;
pub const AMETA_SYM_ON: _bindgen_ty_18 = 4;
pub const AMETA_FUNCTION_ON: _bindgen_ty_18 = 8;
pub const AMETA_CTRL_ON: _bindgen_ty_18 = 4096;
pub const AMETA_CTRL_LEFT_ON: _bindgen_ty_18 = 8192;
pub const AMETA_CTRL_RIGHT_ON: _bindgen_ty_18 = 16384;
pub const AMETA_META_ON: _bindgen_ty_18 = 65536;
pub const AMETA_META_LEFT_ON: _bindgen_ty_18 = 131072;
pub const AMETA_META_RIGHT_ON: _bindgen_ty_18 = 262144;
pub const AMETA_CAPS_LOCK_ON: _bindgen_ty_18 = 1048576;
pub const AMETA_NUM_LOCK_ON: _bindgen_ty_18 = 2097152;
pub const AMETA_SCROLL_LOCK_ON: _bindgen_ty_18 = 4194304;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AInputEvent {
    _unused: [u8; 0],
}
pub const AINPUT_EVENT_TYPE_KEY: _bindgen_ty_19 = 1;
pub const AINPUT_EVENT_TYPE_MOTION: _bindgen_ty_19 = 2;
pub const AINPUT_EVENT_TYPE_FOCUS: _bindgen_ty_19 = 3;
pub const AINPUT_EVENT_TYPE_CAPTURE: _bindgen_ty_19 = 4;
pub const AINPUT_EVENT_TYPE_DRAG: _bindgen_ty_19 = 5;
pub const AINPUT_EVENT_TYPE_TOUCH_MODE: _bindgen_ty_19 = 6;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const AKEY_EVENT_ACTION_DOWN: _bindgen_ty_20 = 0;
pub const AKEY_EVENT_ACTION_UP: _bindgen_ty_20 = 1;
pub const AKEY_EVENT_ACTION_MULTIPLE: _bindgen_ty_20 = 2;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const AKEY_EVENT_FLAG_WOKE_HERE: _bindgen_ty_21 = 1;
pub const AKEY_EVENT_FLAG_SOFT_KEYBOARD: _bindgen_ty_21 = 2;
pub const AKEY_EVENT_FLAG_KEEP_TOUCH_MODE: _bindgen_ty_21 = 4;
pub const AKEY_EVENT_FLAG_FROM_SYSTEM: _bindgen_ty_21 = 8;
pub const AKEY_EVENT_FLAG_EDITOR_ACTION: _bindgen_ty_21 = 16;
pub const AKEY_EVENT_FLAG_CANCELED: _bindgen_ty_21 = 32;
pub const AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY: _bindgen_ty_21 = 64;
pub const AKEY_EVENT_FLAG_LONG_PRESS: _bindgen_ty_21 = 128;
pub const AKEY_EVENT_FLAG_CANCELED_LONG_PRESS: _bindgen_ty_21 = 256;
pub const AKEY_EVENT_FLAG_TRACKING: _bindgen_ty_21 = 512;
pub const AKEY_EVENT_FLAG_FALLBACK: _bindgen_ty_21 = 1024;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_ACTION_MASK: _bindgen_ty_22 = 255;
pub const AMOTION_EVENT_ACTION_POINTER_INDEX_MASK: _bindgen_ty_22 = 65280;
pub const AMOTION_EVENT_ACTION_DOWN: _bindgen_ty_22 = 0;
pub const AMOTION_EVENT_ACTION_UP: _bindgen_ty_22 = 1;
pub const AMOTION_EVENT_ACTION_MOVE: _bindgen_ty_22 = 2;
pub const AMOTION_EVENT_ACTION_CANCEL: _bindgen_ty_22 = 3;
pub const AMOTION_EVENT_ACTION_OUTSIDE: _bindgen_ty_22 = 4;
pub const AMOTION_EVENT_ACTION_POINTER_DOWN: _bindgen_ty_22 = 5;
pub const AMOTION_EVENT_ACTION_POINTER_UP: _bindgen_ty_22 = 6;
pub const AMOTION_EVENT_ACTION_HOVER_MOVE: _bindgen_ty_22 = 7;
pub const AMOTION_EVENT_ACTION_SCROLL: _bindgen_ty_22 = 8;
pub const AMOTION_EVENT_ACTION_HOVER_ENTER: _bindgen_ty_22 = 9;
pub const AMOTION_EVENT_ACTION_HOVER_EXIT: _bindgen_ty_22 = 10;
pub const AMOTION_EVENT_ACTION_BUTTON_PRESS: _bindgen_ty_22 = 11;
pub const AMOTION_EVENT_ACTION_BUTTON_RELEASE: _bindgen_ty_22 = 12;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_EDGE_FLAG_NONE: _bindgen_ty_24 = 0;
pub const AMOTION_EVENT_EDGE_FLAG_TOP: _bindgen_ty_24 = 1;
pub const AMOTION_EVENT_EDGE_FLAG_BOTTOM: _bindgen_ty_24 = 2;
pub const AMOTION_EVENT_EDGE_FLAG_LEFT: _bindgen_ty_24 = 4;
pub const AMOTION_EVENT_EDGE_FLAG_RIGHT: _bindgen_ty_24 = 8;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_AXIS_X: _bindgen_ty_25 = 0;
pub const AMOTION_EVENT_AXIS_Y: _bindgen_ty_25 = 1;
pub const AMOTION_EVENT_AXIS_PRESSURE: _bindgen_ty_25 = 2;
pub const AMOTION_EVENT_AXIS_SIZE: _bindgen_ty_25 = 3;
pub const AMOTION_EVENT_AXIS_TOUCH_MAJOR: _bindgen_ty_25 = 4;
pub const AMOTION_EVENT_AXIS_TOUCH_MINOR: _bindgen_ty_25 = 5;
pub const AMOTION_EVENT_AXIS_TOOL_MAJOR: _bindgen_ty_25 = 6;
pub const AMOTION_EVENT_AXIS_TOOL_MINOR: _bindgen_ty_25 = 7;
pub const AMOTION_EVENT_AXIS_ORIENTATION: _bindgen_ty_25 = 8;
pub const AMOTION_EVENT_AXIS_VSCROLL: _bindgen_ty_25 = 9;
pub const AMOTION_EVENT_AXIS_HSCROLL: _bindgen_ty_25 = 10;
pub const AMOTION_EVENT_AXIS_Z: _bindgen_ty_25 = 11;
pub const AMOTION_EVENT_AXIS_RX: _bindgen_ty_25 = 12;
pub const AMOTION_EVENT_AXIS_RY: _bindgen_ty_25 = 13;
pub const AMOTION_EVENT_AXIS_RZ: _bindgen_ty_25 = 14;
pub const AMOTION_EVENT_AXIS_HAT_X: _bindgen_ty_25 = 15;
pub const AMOTION_EVENT_AXIS_HAT_Y: _bindgen_ty_25 = 16;
pub const AMOTION_EVENT_AXIS_LTRIGGER: _bindgen_ty_25 = 17;
pub const AMOTION_EVENT_AXIS_RTRIGGER: _bindgen_ty_25 = 18;
pub const AMOTION_EVENT_AXIS_THROTTLE: _bindgen_ty_25 = 19;
pub const AMOTION_EVENT_AXIS_RUDDER: _bindgen_ty_25 = 20;
pub const AMOTION_EVENT_AXIS_WHEEL: _bindgen_ty_25 = 21;
pub const AMOTION_EVENT_AXIS_GAS: _bindgen_ty_25 = 22;
pub const AMOTION_EVENT_AXIS_BRAKE: _bindgen_ty_25 = 23;
pub const AMOTION_EVENT_AXIS_DISTANCE: _bindgen_ty_25 = 24;
pub const AMOTION_EVENT_AXIS_TILT: _bindgen_ty_25 = 25;
pub const AMOTION_EVENT_AXIS_SCROLL: _bindgen_ty_25 = 26;
pub const AMOTION_EVENT_AXIS_RELATIVE_X: _bindgen_ty_25 = 27;
pub const AMOTION_EVENT_AXIS_RELATIVE_Y: _bindgen_ty_25 = 28;
pub const AMOTION_EVENT_AXIS_GENERIC_1: _bindgen_ty_25 = 32;
pub const AMOTION_EVENT_AXIS_GENERIC_2: _bindgen_ty_25 = 33;
pub const AMOTION_EVENT_AXIS_GENERIC_3: _bindgen_ty_25 = 34;
pub const AMOTION_EVENT_AXIS_GENERIC_4: _bindgen_ty_25 = 35;
pub const AMOTION_EVENT_AXIS_GENERIC_5: _bindgen_ty_25 = 36;
pub const AMOTION_EVENT_AXIS_GENERIC_6: _bindgen_ty_25 = 37;
pub const AMOTION_EVENT_AXIS_GENERIC_7: _bindgen_ty_25 = 38;
pub const AMOTION_EVENT_AXIS_GENERIC_8: _bindgen_ty_25 = 39;
pub const AMOTION_EVENT_AXIS_GENERIC_9: _bindgen_ty_25 = 40;
pub const AMOTION_EVENT_AXIS_GENERIC_10: _bindgen_ty_25 = 41;
pub const AMOTION_EVENT_AXIS_GENERIC_11: _bindgen_ty_25 = 42;
pub const AMOTION_EVENT_AXIS_GENERIC_12: _bindgen_ty_25 = 43;
pub const AMOTION_EVENT_AXIS_GENERIC_13: _bindgen_ty_25 = 44;
pub const AMOTION_EVENT_AXIS_GENERIC_14: _bindgen_ty_25 = 45;
pub const AMOTION_EVENT_AXIS_GENERIC_15: _bindgen_ty_25 = 46;
pub const AMOTION_EVENT_AXIS_GENERIC_16: _bindgen_ty_25 = 47;
pub const AMOTION_EVENT_AXIS_GESTURE_X_OFFSET: _bindgen_ty_25 = 48;
pub const AMOTION_EVENT_AXIS_GESTURE_Y_OFFSET: _bindgen_ty_25 = 49;
pub const AMOTION_EVENT_AXIS_GESTURE_SCROLL_X_DISTANCE: _bindgen_ty_25 = 50;
pub const AMOTION_EVENT_AXIS_GESTURE_SCROLL_Y_DISTANCE: _bindgen_ty_25 = 51;
pub const AMOTION_EVENT_AXIS_GESTURE_PINCH_SCALE_FACTOR: _bindgen_ty_25 = 52;
pub const AMOTION_EVENT_AXIS_GESTURE_SWIPE_FINGER_COUNT: _bindgen_ty_25 = 53;
pub const AMOTION_EVENT_MAXIMUM_VALID_AXIS_VALUE: _bindgen_ty_25 = 53;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_BUTTON_PRIMARY: _bindgen_ty_26 = 1;
pub const AMOTION_EVENT_BUTTON_SECONDARY: _bindgen_ty_26 = 2;
pub const AMOTION_EVENT_BUTTON_TERTIARY: _bindgen_ty_26 = 4;
pub const AMOTION_EVENT_BUTTON_BACK: _bindgen_ty_26 = 8;
pub const AMOTION_EVENT_BUTTON_FORWARD: _bindgen_ty_26 = 16;
pub const AMOTION_EVENT_BUTTON_STYLUS_PRIMARY: _bindgen_ty_26 = 32;
pub const AMOTION_EVENT_BUTTON_STYLUS_SECONDARY: _bindgen_ty_26 = 64;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_TOOL_TYPE_UNKNOWN: _bindgen_ty_27 = 0;
pub const AMOTION_EVENT_TOOL_TYPE_FINGER: _bindgen_ty_27 = 1;
pub const AMOTION_EVENT_TOOL_TYPE_STYLUS: _bindgen_ty_27 = 2;
pub const AMOTION_EVENT_TOOL_TYPE_MOUSE: _bindgen_ty_27 = 3;
pub const AMOTION_EVENT_TOOL_TYPE_ERASER: _bindgen_ty_27 = 4;
pub const AMOTION_EVENT_TOOL_TYPE_PALM: _bindgen_ty_27 = 5;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_NONE: AMotionClassification = AMotionClassification(0);
}
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_AMBIGUOUS_GESTURE: AMotionClassification =
        AMotionClassification(1);
}
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_DEEP_PRESS: AMotionClassification =
        AMotionClassification(2);
}
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_TWO_FINGER_SWIPE: AMotionClassification =
        AMotionClassification(3);
}
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_MULTI_FINGER_SWIPE: AMotionClassification =
        AMotionClassification(4);
}
impl AMotionClassification {
    pub const AMOTION_EVENT_CLASSIFICATION_PINCH: AMotionClassification = AMotionClassification(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMotionClassification(pub u32);
pub const AINPUT_SOURCE_CLASS_MASK: _bindgen_ty_28 = 255;
pub const AINPUT_SOURCE_CLASS_NONE: _bindgen_ty_28 = 0;
pub const AINPUT_SOURCE_CLASS_BUTTON: _bindgen_ty_28 = 1;
pub const AINPUT_SOURCE_CLASS_POINTER: _bindgen_ty_28 = 2;
pub const AINPUT_SOURCE_CLASS_NAVIGATION: _bindgen_ty_28 = 4;
pub const AINPUT_SOURCE_CLASS_POSITION: _bindgen_ty_28 = 8;
pub const AINPUT_SOURCE_CLASS_JOYSTICK: _bindgen_ty_28 = 16;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const AINPUT_SOURCE_UNKNOWN: _bindgen_ty_29 = 0;
pub const AINPUT_SOURCE_KEYBOARD: _bindgen_ty_29 = 257;
pub const AINPUT_SOURCE_DPAD: _bindgen_ty_29 = 513;
pub const AINPUT_SOURCE_GAMEPAD: _bindgen_ty_29 = 1025;
pub const AINPUT_SOURCE_TOUCHSCREEN: _bindgen_ty_29 = 4098;
pub const AINPUT_SOURCE_MOUSE: _bindgen_ty_29 = 8194;
pub const AINPUT_SOURCE_STYLUS: _bindgen_ty_29 = 16386;
pub const AINPUT_SOURCE_BLUETOOTH_STYLUS: _bindgen_ty_29 = 49154;
pub const AINPUT_SOURCE_TRACKBALL: _bindgen_ty_29 = 65540;
pub const AINPUT_SOURCE_MOUSE_RELATIVE: _bindgen_ty_29 = 131076;
pub const AINPUT_SOURCE_TOUCHPAD: _bindgen_ty_29 = 1048584;
pub const AINPUT_SOURCE_TOUCH_NAVIGATION: _bindgen_ty_29 = 2097152;
pub const AINPUT_SOURCE_JOYSTICK: _bindgen_ty_29 = 16777232;
pub const AINPUT_SOURCE_HDMI: _bindgen_ty_29 = 33554433;
pub const AINPUT_SOURCE_SENSOR: _bindgen_ty_29 = 67108864;
pub const AINPUT_SOURCE_ROTARY_ENCODER: _bindgen_ty_29 = 4194304;
pub const AINPUT_SOURCE_ANY: _bindgen_ty_29 = 4294967040;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const AINPUT_KEYBOARD_TYPE_NONE: _bindgen_ty_30 = 0;
pub const AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC: _bindgen_ty_30 = 1;
pub const AINPUT_KEYBOARD_TYPE_ALPHABETIC: _bindgen_ty_30 = 2;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const AINPUT_MOTION_RANGE_X: _bindgen_ty_31 = 0;
pub const AINPUT_MOTION_RANGE_Y: _bindgen_ty_31 = 1;
pub const AINPUT_MOTION_RANGE_PRESSURE: _bindgen_ty_31 = 2;
pub const AINPUT_MOTION_RANGE_SIZE: _bindgen_ty_31 = 3;
pub const AINPUT_MOTION_RANGE_TOUCH_MAJOR: _bindgen_ty_31 = 4;
pub const AINPUT_MOTION_RANGE_TOUCH_MINOR: _bindgen_ty_31 = 5;
pub const AINPUT_MOTION_RANGE_TOOL_MAJOR: _bindgen_ty_31 = 6;
pub const AINPUT_MOTION_RANGE_TOOL_MINOR: _bindgen_ty_31 = 7;
pub const AINPUT_MOTION_RANGE_ORIENTATION: _bindgen_ty_31 = 8;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AInputEvent_getType(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputEvent_getDeviceId(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputEvent_getSource(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputEvent_release(event: *const AInputEvent);
}
extern "C" {
    pub fn AKeyEvent_getAction(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getFlags(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getKeyCode(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getScanCode(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getMetaState(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getRepeatCount(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getDownTime(key_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AKeyEvent_getEventTime(key_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AKeyEvent_fromJava(env: *mut JNIEnv, keyEvent: jobject) -> *const AInputEvent;
}
extern "C" {
    pub fn AMotionEvent_getAction(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getFlags(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getMetaState(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getButtonState(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getEdgeFlags(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getDownTime(motion_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getEventTime(motion_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getXOffset(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getYOffset(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getXPrecision(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getYPrecision(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getPointerCount(motion_event: *const AInputEvent) -> usize;
}
extern "C" {
    pub fn AMotionEvent_getPointerId(motion_event: *const AInputEvent, pointer_index: usize)
        -> i32;
}
extern "C" {
    pub fn AMotionEvent_getToolType(motion_event: *const AInputEvent, pointer_index: usize) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getRawX(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getRawY(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getX(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getY(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getPressure(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getSize(motion_event: *const AInputEvent, pointer_index: usize) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getTouchMajor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getTouchMinor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getToolMajor(motion_event: *const AInputEvent, pointer_index: usize)
        -> f32;
}
extern "C" {
    pub fn AMotionEvent_getToolMinor(motion_event: *const AInputEvent, pointer_index: usize)
        -> f32;
}
extern "C" {
    pub fn AMotionEvent_getOrientation(
        motion_event: *const AInputEvent,
        pointer_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getAxisValue(
        motion_event: *const AInputEvent,
        axis: i32,
        pointer_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistorySize(motion_event: *const AInputEvent) -> usize;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalEventTime(
        motion_event: *const AInputEvent,
        history_index: usize,
    ) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalRawX(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalRawY(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalX(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalY(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalPressure(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalSize(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalTouchMajor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalTouchMinor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalToolMajor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalToolMinor(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalOrientation(
        motion_event: *const AInputEvent,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalAxisValue(
        motion_event: *const AInputEvent,
        axis: i32,
        pointer_index: usize,
        history_index: usize,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getActionButton(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getClassification(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_fromJava(env: *mut JNIEnv, motionEvent: jobject) -> *const AInputEvent;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AInputQueue {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AInputQueue_attachLooper(
        queue: *mut AInputQueue,
        looper: *mut ALooper,
        ident: ::std::os::raw::c_int,
        callback: ALooper_callbackFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AInputQueue_detachLooper(queue: *mut AInputQueue);
}
extern "C" {
    pub fn AInputQueue_hasEvents(queue: *mut AInputQueue) -> i32;
}
extern "C" {
    pub fn AInputQueue_getEvent(queue: *mut AInputQueue, outEvent: *mut *mut AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputQueue_preDispatchEvent(queue: *mut AInputQueue, event: *mut AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputQueue_finishEvent(
        queue: *mut AInputQueue,
        event: *mut AInputEvent,
        handled: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AInputQueue_fromJava(env: *mut JNIEnv, inputQueue: jobject) -> *mut AInputQueue;
}
impl android_LogPriority {
    pub const ANDROID_LOG_UNKNOWN: android_LogPriority = android_LogPriority(0);
}
impl android_LogPriority {
    pub const ANDROID_LOG_DEFAULT: android_LogPriority = android_LogPriority(1);
}
impl android_LogPriority {
    pub const ANDROID_LOG_VERBOSE: android_LogPriority = android_LogPriority(2);
}
impl android_LogPriority {
    pub const ANDROID_LOG_DEBUG: android_LogPriority = android_LogPriority(3);
}
impl android_LogPriority {
    pub const ANDROID_LOG_INFO: android_LogPriority = android_LogPriority(4);
}
impl android_LogPriority {
    pub const ANDROID_LOG_WARN: android_LogPriority = android_LogPriority(5);
}
impl android_LogPriority {
    pub const ANDROID_LOG_ERROR: android_LogPriority = android_LogPriority(6);
}
impl android_LogPriority {
    pub const ANDROID_LOG_FATAL: android_LogPriority = android_LogPriority(7);
}
impl android_LogPriority {
    pub const ANDROID_LOG_SILENT: android_LogPriority = android_LogPriority(8);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct android_LogPriority(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn __android_log_write(
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_print(
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_vprint(
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_assert(
        cond: *const ::std::os::raw::c_char,
        tag: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
impl log_id {
    pub const LOG_ID_MIN: log_id = log_id(0);
}
impl log_id {
    pub const LOG_ID_MAIN: log_id = log_id(0);
}
impl log_id {
    pub const LOG_ID_RADIO: log_id = log_id(1);
}
impl log_id {
    pub const LOG_ID_EVENTS: log_id = log_id(2);
}
impl log_id {
    pub const LOG_ID_SYSTEM: log_id = log_id(3);
}
impl log_id {
    pub const LOG_ID_CRASH: log_id = log_id(4);
}
impl log_id {
    pub const LOG_ID_STATS: log_id = log_id(5);
}
impl log_id {
    pub const LOG_ID_SECURITY: log_id = log_id(6);
}
impl log_id {
    pub const LOG_ID_KERNEL: log_id = log_id(7);
}
impl log_id {
    pub const LOG_ID_MAX: log_id = log_id(8);
}
impl log_id {
    pub const LOG_ID_DEFAULT: log_id = log_id(2147483647);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct log_id(pub ::std::os::raw::c_uint);
pub use self::log_id as log_id_t;
extern "C" {
    pub fn __android_log_buf_write(
        bufID: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_buf_print(
        bufID: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __android_log_message {
    pub struct_size: usize,
    pub buffer_id: i32,
    pub priority: i32,
    pub tag: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: u32,
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout___android_log_message() {
    const UNINIT: ::std::mem::MaybeUninit<__android_log_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__android_log_message>(),
        48usize,
        concat!("Size of: ", stringify!(__android_log_message))
    );
    assert_eq!(
        ::std::mem::align_of::<__android_log_message>(),
        8usize,
        concat!("Alignment of ", stringify!(__android_log_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(buffer_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__android_log_message),
            "::",
            stringify!(message)
        )
    );
}
pub type __android_logger_function =
    ::std::option::Option<unsafe extern "C" fn(log_message: *const __android_log_message)>;
pub type __android_aborter_function =
    ::std::option::Option<unsafe extern "C" fn(abort_message: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn __android_log_write_log_message(log_message: *mut __android_log_message);
}
extern "C" {
    pub fn __android_log_set_logger(logger: __android_logger_function);
}
extern "C" {
    pub fn __android_log_logd_logger(log_message: *const __android_log_message);
}
extern "C" {
    pub fn __android_log_stderr_logger(log_message: *const __android_log_message);
}
extern "C" {
    pub fn __android_log_set_aborter(aborter: __android_aborter_function);
}
extern "C" {
    pub fn __android_log_call_aborter(abort_message: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __android_log_default_aborter(abort_message: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    pub fn __android_log_is_loggable(
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        default_prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_is_loggable_len(
        prio: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        len: usize,
        default_prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __android_log_set_minimum_priority(priority: i32) -> i32;
}
extern "C" {
    pub fn __android_log_get_minimum_priority() -> i32;
}
extern "C" {
    pub fn __android_log_set_default_tag(tag: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off64_t,
    pub l_len: off64_t,
    pub l_pid: pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off64_t,
    pub l_len: off64_t,
    pub l_pid: pid_t,
}
#[test]
fn bindgen_test_layout_flock64() {
    const UNINIT: ::std::mem::MaybeUninit<flock64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock64>(),
        32usize,
        concat!("Size of: ", stringify!(flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<flock64>(),
        8usize,
        concat!("Alignment of ", stringify!(flock64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: ::std::os::raw::c_int,
    pub pid: __kernel_pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    const UNINIT: ::std::mem::MaybeUninit<f_owner_ex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub __bindgen_anon_1: sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__data)
        )
    );
}
#[test]
fn bindgen_test_layout_sockaddr_storage__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage__bindgen_ty_1),
            "::",
            stringify!(__align)
        )
    );
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
}
pub const SHUT_RD: _bindgen_ty_32 = 0;
pub const SHUT_WR: _bindgen_ty_32 = 1;
pub const SHUT_RDWR: _bindgen_ty_32 = 2;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<mmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__msg: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[test]
fn bindgen_test_layout_ucred() {
    const UNINIT: ::std::mem::MaybeUninit<ucred> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucred>(),
        12usize,
        concat!("Size of: ", stringify!(ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(ucred))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(gid)
        )
    );
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __option: ::std::os::raw::c_int,
        __value: *mut ::std::os::raw::c_void,
        __value_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        __fd: ::std::os::raw::c_int,
        __backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::std::os::raw::c_int,
        __msgs: *mut mmsghdr,
        __msg_count: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __msg: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::std::os::raw::c_int,
        __msgs: *const mmsghdr,
        __msg_count: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __msg: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __option: ::std::os::raw::c_int,
        __value: *const ::std::os::raw::c_void,
        __value_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        __af: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __af: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __dst_addr: *const sockaddr,
        __dst_addr_length: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __src_addr: *mut sockaddr,
        __src_addr_length: *mut socklen_t,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    const UNINIT: ::std::mem::MaybeUninit<hostent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    const UNINIT: ::std::mem::MaybeUninit<netent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    const UNINIT: ::std::mem::MaybeUninit<servent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    const UNINIT: ::std::mem::MaybeUninit<protoent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    const UNINIT: ::std::mem::MaybeUninit<addrinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
extern "C" {
    pub fn getaddrinfo(
        __node: *const ::std::os::raw::c_char,
        __service: *const ::std::os::raw::c_char,
        __hints: *const addrinfo,
        __result: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ptr: *mut addrinfo);
}
extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __sa_length: socklen_t,
        __host: *mut ::std::os::raw::c_char,
        __host_length: usize,
        __service: *mut ::std::os::raw::c_char,
        __service_length: usize,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gai_strerror(__error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __get_h_errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(__error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::std::os::raw::c_void,
        __length: socklen_t,
        __type: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::std::os::raw::c_void,
        __length: socklen_t,
        __type: ::std::os::raw::c_int,
        __ret: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
        __result: *mut *mut hostent,
        __h_errno_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::std::os::raw::c_char,
        __ret: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
        __result: *mut *mut hostent,
        __h_errno_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
        __ret: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
        __result: *mut *mut hostent,
        __h_errno_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservbyname(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        __port_in_network_order: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
pub type fpos_t = off_t;
pub type fpos64_t = off64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    _unused: [u8; 0],
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn clearerr(__fp: *mut FILE);
}
extern "C" {
    pub fn fclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fprintf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __buf: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fscanf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwrite(
        __buf: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut usize,
        __fp: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn perror(__msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(__fp: *mut FILE);
}
extern "C" {
    pub fn scanf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(__fp: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __fp: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __fp: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rename(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __old_dir_fd: ::std::os::raw::c_int,
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        __fp: *mut FILE,
        __offset: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__fp: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fgetpos(__fp: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__fp: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        __fp: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__fp: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fgetpos64(__fp: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__fp: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __fp: *mut FILE,
        __offset: off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__fp: *mut FILE) -> off64_t;
}
extern "C" {
    pub fn fopen(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn snprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn flockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __size_ptr: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn asprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(__fp: *mut FILE, __length_ptr: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        __fp: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__fp: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__byte_count: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __item_count: ::std::os::raw::c_ulong,
        __item_size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __item_count: usize,
        __item_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn memalign(
        __alignment: ::std::os::raw::c_ulong,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_usable_size(__ptr: *const ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo2 {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo2() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo2>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn malloc_info(
        __must_be_zero: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
impl HeapTaggingLevel {
    pub const M_HEAP_TAGGING_LEVEL_NONE: HeapTaggingLevel = HeapTaggingLevel(0);
}
impl HeapTaggingLevel {
    pub const M_HEAP_TAGGING_LEVEL_TBI: HeapTaggingLevel = HeapTaggingLevel(1);
}
impl HeapTaggingLevel {
    pub const M_HEAP_TAGGING_LEVEL_ASYNC: HeapTaggingLevel = HeapTaggingLevel(2);
}
impl HeapTaggingLevel {
    pub const M_HEAP_TAGGING_LEVEL_SYNC: HeapTaggingLevel = HeapTaggingLevel(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HeapTaggingLevel(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn mallopt(
        __option: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __malloc_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __byte_count: usize,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __realloc_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __byte_count: usize,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __free_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __caller: *const ::std::os::raw::c_void,
        ),
    >;
}
extern "C" {
    pub static mut __memalign_hook: ::std::option::Option<
        unsafe extern "C" fn(
            __alignment: usize,
            __byte_count: usize,
            __caller: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn atexit(__fn: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__assignment: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtod(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtoul_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn atoi(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn realpath(
        __path: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn rand_r(__seed_ptr: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(__seed: ::std::os::raw::c_long);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __state: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__state: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __option: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __value_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn div(__numerator: ::std::os::raw::c_int, __denominator: ::std::os::raw::c_int) -> div_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn ldiv(
        __numerator: ::std::os::raw::c_long,
        __denominator: ::std::os::raw::c_long,
    ) -> ldiv_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn lldiv(
        __numerator: ::std::os::raw::c_longlong,
        __denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn getloadavg(__averages: *mut f64, __n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(__name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__dst: *mut wchar_t, __src: *const ::std::os::raw::c_char, __n: usize)
        -> usize;
}
extern "C" {
    pub fn mbtowc(
        __wc_ptr: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__dst: *mut ::std::os::raw::c_char, __wc: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(__dst: *mut ::std::os::raw::c_char, __src: *const wchar_t, __n: usize)
        -> usize;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtof(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn atof(__s: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtoll_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtold_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtod_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtol_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        arg1: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_long;
}
pub type net_handle_t = u64;
extern "C" {
    pub fn android_setsocknetwork(
        network: net_handle_t,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_setprocnetwork(network: net_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_getprocnetwork(network: *mut net_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_setprocdns(network: net_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_getprocdns(network: *mut net_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_getaddrinfofornetwork(
        network: net_handle_t,
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
impl ResNsendFlags {
    pub const ANDROID_RESOLV_NO_RETRY: ResNsendFlags = ResNsendFlags(1);
}
impl ResNsendFlags {
    pub const ANDROID_RESOLV_NO_CACHE_STORE: ResNsendFlags = ResNsendFlags(2);
}
impl ResNsendFlags {
    pub const ANDROID_RESOLV_NO_CACHE_LOOKUP: ResNsendFlags = ResNsendFlags(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResNsendFlags(pub u32);
extern "C" {
    pub fn android_res_nquery(
        network: net_handle_t,
        dname: *const ::std::os::raw::c_char,
        ns_class: ::std::os::raw::c_int,
        ns_type: ::std::os::raw::c_int,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_res_nsend(
        network: net_handle_t,
        msg: *const u8,
        msglen: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_res_nresult(
        fd: ::std::os::raw::c_int,
        rcode: *mut ::std::os::raw::c_int,
        answer: *mut u8,
        anslen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_res_cancel(nsend_fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn android_tag_socket_with_uid(
        sockfd: ::std::os::raw::c_int,
        tag: u32,
        uid: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_tag_socket(sockfd: ::std::os::raw::c_int, tag: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_untag_socket(sockfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
impl ANativeWindow_LegacyFormat {
    pub const WINDOW_FORMAT_RGBA_8888: ANativeWindow_LegacyFormat = ANativeWindow_LegacyFormat(1);
}
impl ANativeWindow_LegacyFormat {
    pub const WINDOW_FORMAT_RGBX_8888: ANativeWindow_LegacyFormat = ANativeWindow_LegacyFormat(2);
}
impl ANativeWindow_LegacyFormat {
    pub const WINDOW_FORMAT_RGB_565: ANativeWindow_LegacyFormat = ANativeWindow_LegacyFormat(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ANativeWindow_LegacyFormat(pub ::std::os::raw::c_uint);
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_IDENTITY: ANativeWindowTransform = ANativeWindowTransform(0);
}
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_MIRROR_HORIZONTAL: ANativeWindowTransform =
        ANativeWindowTransform(1);
}
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_MIRROR_VERTICAL: ANativeWindowTransform =
        ANativeWindowTransform(2);
}
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_ROTATE_90: ANativeWindowTransform = ANativeWindowTransform(4);
}
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_ROTATE_180: ANativeWindowTransform =
        ANativeWindowTransform(3);
}
impl ANativeWindowTransform {
    pub const ANATIVEWINDOW_TRANSFORM_ROTATE_270: ANativeWindowTransform =
        ANativeWindowTransform(7);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ANativeWindowTransform(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANativeWindow {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANativeWindow_Buffer {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub format: i32,
    pub bits: *mut ::std::os::raw::c_void,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_ANativeWindow_Buffer() {
    const UNINIT: ::std::mem::MaybeUninit<ANativeWindow_Buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANativeWindow_Buffer>(),
        48usize,
        concat!("Size of: ", stringify!(ANativeWindow_Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<ANativeWindow_Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(ANativeWindow_Buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeWindow_Buffer),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn ANativeWindow_acquire(window: *mut ANativeWindow);
}
extern "C" {
    pub fn ANativeWindow_release(window: *mut ANativeWindow);
}
extern "C" {
    pub fn ANativeWindow_getWidth(window: *mut ANativeWindow) -> i32;
}
extern "C" {
    pub fn ANativeWindow_getHeight(window: *mut ANativeWindow) -> i32;
}
extern "C" {
    pub fn ANativeWindow_getFormat(window: *mut ANativeWindow) -> i32;
}
extern "C" {
    pub fn ANativeWindow_setBuffersGeometry(
        window: *mut ANativeWindow,
        width: i32,
        height: i32,
        format: i32,
    ) -> i32;
}
extern "C" {
    pub fn ANativeWindow_lock(
        window: *mut ANativeWindow,
        outBuffer: *mut ANativeWindow_Buffer,
        inOutDirtyBounds: *mut ARect,
    ) -> i32;
}
extern "C" {
    pub fn ANativeWindow_unlockAndPost(window: *mut ANativeWindow) -> i32;
}
extern "C" {
    pub fn ANativeWindow_setBuffersTransform(window: *mut ANativeWindow, transform: i32) -> i32;
}
extern "C" {
    pub fn ANativeWindow_setBuffersDataSpace(window: *mut ANativeWindow, dataSpace: i32) -> i32;
}
extern "C" {
    pub fn ANativeWindow_getBuffersDataSpace(window: *mut ANativeWindow) -> i32;
}
extern "C" {
    pub fn ANativeWindow_getBuffersDefaultDataSpace(window: *mut ANativeWindow) -> i32;
}
impl ANativeWindow_FrameRateCompatibility {
    pub const ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT: ANativeWindow_FrameRateCompatibility =
        ANativeWindow_FrameRateCompatibility(0);
}
impl ANativeWindow_FrameRateCompatibility {
    pub const ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE:
        ANativeWindow_FrameRateCompatibility = ANativeWindow_FrameRateCompatibility(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ANativeWindow_FrameRateCompatibility(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn ANativeWindow_setFrameRate(
        window: *mut ANativeWindow,
        frameRate: f32,
        compatibility: i8,
    ) -> i32;
}
extern "C" {
    pub fn ANativeWindow_tryAllocateBuffers(window: *mut ANativeWindow);
}
impl ANativeWindow_ChangeFrameRateStrategy {
    pub const ANATIVEWINDOW_CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS:
        ANativeWindow_ChangeFrameRateStrategy = ANativeWindow_ChangeFrameRateStrategy(0);
}
impl ANativeWindow_ChangeFrameRateStrategy {
    pub const ANATIVEWINDOW_CHANGE_FRAME_RATE_ALWAYS: ANativeWindow_ChangeFrameRateStrategy =
        ANativeWindow_ChangeFrameRateStrategy(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ANativeWindow_ChangeFrameRateStrategy(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn ANativeWindow_setFrameRateWithChangeStrategy(
        window: *mut ANativeWindow,
        frameRate: f32,
        compatibility: i8,
        changeFrameRateStrategy: i8,
    ) -> i32;
}
#[repr(C)]
pub struct ANativeActivity {
    pub callbacks: *mut ANativeActivityCallbacks,
    pub vm: *mut JavaVM,
    pub env: *mut JNIEnv,
    pub clazz: jobject,
    pub internalDataPath: *const ::std::os::raw::c_char,
    pub externalDataPath: *const ::std::os::raw::c_char,
    pub sdkVersion: i32,
    pub instance: *mut ::std::os::raw::c_void,
    pub assetManager: *mut AAssetManager,
    pub obbPath: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ANativeActivity() {
    const UNINIT: ::std::mem::MaybeUninit<ANativeActivity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANativeActivity>(),
        80usize,
        concat!("Size of: ", stringify!(ANativeActivity))
    );
    assert_eq!(
        ::std::mem::align_of::<ANativeActivity>(),
        8usize,
        concat!("Alignment of ", stringify!(ANativeActivity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clazz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(clazz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internalDataPath) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(internalDataPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).externalDataPath) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(externalDataPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdkVersion) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(sdkVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assetManager) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(assetManager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obbPath) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivity),
            "::",
            stringify!(obbPath)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANativeActivityCallbacks {
    pub onStart: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onResume: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onSaveInstanceState: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut ANativeActivity,
            outSize: *mut usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub onPause: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onStop: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onDestroy: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onWindowFocusChanged: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, hasFocus: ::std::os::raw::c_int),
    >,
    pub onNativeWindowCreated: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, window: *mut ANativeWindow),
    >,
    pub onNativeWindowResized: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, window: *mut ANativeWindow),
    >,
    pub onNativeWindowRedrawNeeded: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, window: *mut ANativeWindow),
    >,
    pub onNativeWindowDestroyed: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, window: *mut ANativeWindow),
    >,
    pub onInputQueueCreated: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, queue: *mut AInputQueue),
    >,
    pub onInputQueueDestroyed: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, queue: *mut AInputQueue),
    >,
    pub onContentRectChanged: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut ANativeActivity, rect: *const ARect),
    >,
    pub onConfigurationChanged:
        ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
    pub onLowMemory: ::std::option::Option<unsafe extern "C" fn(activity: *mut ANativeActivity)>,
}
#[test]
fn bindgen_test_layout_ANativeActivityCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ANativeActivityCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANativeActivityCallbacks>(),
        128usize,
        concat!("Size of: ", stringify!(ANativeActivityCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<ANativeActivityCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(ANativeActivityCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onStart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onResume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onResume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onSaveInstanceState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onSaveInstanceState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onPause) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onPause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onStop) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onStop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onDestroy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onDestroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onWindowFocusChanged) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onWindowFocusChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onNativeWindowCreated) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onNativeWindowCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onNativeWindowResized) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onNativeWindowResized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onNativeWindowRedrawNeeded) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onNativeWindowRedrawNeeded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onNativeWindowDestroyed) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onNativeWindowDestroyed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onInputQueueCreated) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onInputQueueCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onInputQueueDestroyed) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onInputQueueDestroyed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onContentRectChanged) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onContentRectChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onConfigurationChanged) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onConfigurationChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onLowMemory) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ANativeActivityCallbacks),
            "::",
            stringify!(onLowMemory)
        )
    );
}
pub type ANativeActivity_createFunc = ::std::option::Option<
    unsafe extern "C" fn(
        activity: *mut ANativeActivity,
        savedState: *mut ::std::os::raw::c_void,
        savedStateSize: usize,
    ),
>;
extern "C" {
    pub fn ANativeActivity_onCreate(
        activity: *mut ANativeActivity,
        savedState: *mut ::std::os::raw::c_void,
        savedStateSize: usize,
    );
}
extern "C" {
    pub fn ANativeActivity_finish(activity: *mut ANativeActivity);
}
extern "C" {
    pub fn ANativeActivity_setWindowFormat(activity: *mut ANativeActivity, format: i32);
}
extern "C" {
    pub fn ANativeActivity_setWindowFlags(
        activity: *mut ANativeActivity,
        addFlags: u32,
        removeFlags: u32,
    );
}
pub const ANATIVEACTIVITY_SHOW_SOFT_INPUT_IMPLICIT: _bindgen_ty_33 = 1;
pub const ANATIVEACTIVITY_SHOW_SOFT_INPUT_FORCED: _bindgen_ty_33 = 2;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
extern "C" {
    pub fn ANativeActivity_showSoftInput(activity: *mut ANativeActivity, flags: u32);
}
pub const ANATIVEACTIVITY_HIDE_SOFT_INPUT_IMPLICIT_ONLY: _bindgen_ty_34 = 1;
pub const ANATIVEACTIVITY_HIDE_SOFT_INPUT_NOT_ALWAYS: _bindgen_ty_34 = 2;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
extern "C" {
    pub fn ANativeActivity_hideSoftInput(activity: *mut ANativeActivity, flags: u32);
}
extern "C" {
    pub fn ANativeWindow_fromSurface(env: *mut JNIEnv, surface: jobject) -> *mut ANativeWindow;
}
extern "C" {
    pub fn ANativeWindow_toSurface(env: *mut JNIEnv, window: *mut ANativeWindow) -> jobject;
}
impl OperandCode {
    pub const ANEURALNETWORKS_FLOAT32: OperandCode = OperandCode(0);
}
impl OperandCode {
    pub const ANEURALNETWORKS_INT32: OperandCode = OperandCode(1);
}
impl OperandCode {
    pub const ANEURALNETWORKS_UINT32: OperandCode = OperandCode(2);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_FLOAT32: OperandCode = OperandCode(3);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_INT32: OperandCode = OperandCode(4);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT8_ASYMM: OperandCode = OperandCode(5);
}
impl OperandCode {
    pub const ANEURALNETWORKS_BOOL: OperandCode = OperandCode(6);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT16_SYMM: OperandCode = OperandCode(7);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_FLOAT16: OperandCode = OperandCode(8);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_BOOL8: OperandCode = OperandCode(9);
}
impl OperandCode {
    pub const ANEURALNETWORKS_FLOAT16: OperandCode = OperandCode(10);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT8_SYMM_PER_CHANNEL: OperandCode = OperandCode(11);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT16_ASYMM: OperandCode = OperandCode(12);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT8_SYMM: OperandCode = OperandCode(13);
}
impl OperandCode {
    pub const ANEURALNETWORKS_TENSOR_QUANT8_ASYMM_SIGNED: OperandCode = OperandCode(14);
}
impl OperandCode {
    pub const ANEURALNETWORKS_MODEL: OperandCode = OperandCode(15);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OperandCode(pub ::std::os::raw::c_uint);
impl OperationCode {
    pub const ANEURALNETWORKS_ADD: OperationCode = OperationCode(0);
}
impl OperationCode {
    pub const ANEURALNETWORKS_AVERAGE_POOL_2D: OperationCode = OperationCode(1);
}
impl OperationCode {
    pub const ANEURALNETWORKS_CONCATENATION: OperationCode = OperationCode(2);
}
impl OperationCode {
    pub const ANEURALNETWORKS_CONV_2D: OperationCode = OperationCode(3);
}
impl OperationCode {
    pub const ANEURALNETWORKS_DEPTHWISE_CONV_2D: OperationCode = OperationCode(4);
}
impl OperationCode {
    pub const ANEURALNETWORKS_DEPTH_TO_SPACE: OperationCode = OperationCode(5);
}
impl OperationCode {
    pub const ANEURALNETWORKS_DEQUANTIZE: OperationCode = OperationCode(6);
}
impl OperationCode {
    pub const ANEURALNETWORKS_EMBEDDING_LOOKUP: OperationCode = OperationCode(7);
}
impl OperationCode {
    pub const ANEURALNETWORKS_FLOOR: OperationCode = OperationCode(8);
}
impl OperationCode {
    pub const ANEURALNETWORKS_FULLY_CONNECTED: OperationCode = OperationCode(9);
}
impl OperationCode {
    pub const ANEURALNETWORKS_HASHTABLE_LOOKUP: OperationCode = OperationCode(10);
}
impl OperationCode {
    pub const ANEURALNETWORKS_L2_NORMALIZATION: OperationCode = OperationCode(11);
}
impl OperationCode {
    pub const ANEURALNETWORKS_L2_POOL_2D: OperationCode = OperationCode(12);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOCAL_RESPONSE_NORMALIZATION: OperationCode = OperationCode(13);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOGISTIC: OperationCode = OperationCode(14);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LSH_PROJECTION: OperationCode = OperationCode(15);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LSTM: OperationCode = OperationCode(16);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MAX_POOL_2D: OperationCode = OperationCode(17);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MUL: OperationCode = OperationCode(18);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RELU: OperationCode = OperationCode(19);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RELU1: OperationCode = OperationCode(20);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RELU6: OperationCode = OperationCode(21);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RESHAPE: OperationCode = OperationCode(22);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RESIZE_BILINEAR: OperationCode = OperationCode(23);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RNN: OperationCode = OperationCode(24);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SOFTMAX: OperationCode = OperationCode(25);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SPACE_TO_DEPTH: OperationCode = OperationCode(26);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SVDF: OperationCode = OperationCode(27);
}
impl OperationCode {
    pub const ANEURALNETWORKS_TANH: OperationCode = OperationCode(28);
}
impl OperationCode {
    pub const ANEURALNETWORKS_BATCH_TO_SPACE_ND: OperationCode = OperationCode(29);
}
impl OperationCode {
    pub const ANEURALNETWORKS_DIV: OperationCode = OperationCode(30);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MEAN: OperationCode = OperationCode(31);
}
impl OperationCode {
    pub const ANEURALNETWORKS_PAD: OperationCode = OperationCode(32);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SPACE_TO_BATCH_ND: OperationCode = OperationCode(33);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SQUEEZE: OperationCode = OperationCode(34);
}
impl OperationCode {
    pub const ANEURALNETWORKS_STRIDED_SLICE: OperationCode = OperationCode(35);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SUB: OperationCode = OperationCode(36);
}
impl OperationCode {
    pub const ANEURALNETWORKS_TRANSPOSE: OperationCode = OperationCode(37);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ABS: OperationCode = OperationCode(38);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ARGMAX: OperationCode = OperationCode(39);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ARGMIN: OperationCode = OperationCode(40);
}
impl OperationCode {
    pub const ANEURALNETWORKS_AXIS_ALIGNED_BBOX_TRANSFORM: OperationCode = OperationCode(41);
}
impl OperationCode {
    pub const ANEURALNETWORKS_BIDIRECTIONAL_SEQUENCE_LSTM: OperationCode = OperationCode(42);
}
impl OperationCode {
    pub const ANEURALNETWORKS_BIDIRECTIONAL_SEQUENCE_RNN: OperationCode = OperationCode(43);
}
impl OperationCode {
    pub const ANEURALNETWORKS_BOX_WITH_NMS_LIMIT: OperationCode = OperationCode(44);
}
impl OperationCode {
    pub const ANEURALNETWORKS_CAST: OperationCode = OperationCode(45);
}
impl OperationCode {
    pub const ANEURALNETWORKS_CHANNEL_SHUFFLE: OperationCode = OperationCode(46);
}
impl OperationCode {
    pub const ANEURALNETWORKS_DETECTION_POSTPROCESSING: OperationCode = OperationCode(47);
}
impl OperationCode {
    pub const ANEURALNETWORKS_EQUAL: OperationCode = OperationCode(48);
}
impl OperationCode {
    pub const ANEURALNETWORKS_EXP: OperationCode = OperationCode(49);
}
impl OperationCode {
    pub const ANEURALNETWORKS_EXPAND_DIMS: OperationCode = OperationCode(50);
}
impl OperationCode {
    pub const ANEURALNETWORKS_GATHER: OperationCode = OperationCode(51);
}
impl OperationCode {
    pub const ANEURALNETWORKS_GENERATE_PROPOSALS: OperationCode = OperationCode(52);
}
impl OperationCode {
    pub const ANEURALNETWORKS_GREATER: OperationCode = OperationCode(53);
}
impl OperationCode {
    pub const ANEURALNETWORKS_GREATER_EQUAL: OperationCode = OperationCode(54);
}
impl OperationCode {
    pub const ANEURALNETWORKS_GROUPED_CONV_2D: OperationCode = OperationCode(55);
}
impl OperationCode {
    pub const ANEURALNETWORKS_HEATMAP_MAX_KEYPOINT: OperationCode = OperationCode(56);
}
impl OperationCode {
    pub const ANEURALNETWORKS_INSTANCE_NORMALIZATION: OperationCode = OperationCode(57);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LESS: OperationCode = OperationCode(58);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LESS_EQUAL: OperationCode = OperationCode(59);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOG: OperationCode = OperationCode(60);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOGICAL_AND: OperationCode = OperationCode(61);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOGICAL_NOT: OperationCode = OperationCode(62);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOGICAL_OR: OperationCode = OperationCode(63);
}
impl OperationCode {
    pub const ANEURALNETWORKS_LOG_SOFTMAX: OperationCode = OperationCode(64);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MAXIMUM: OperationCode = OperationCode(65);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MINIMUM: OperationCode = OperationCode(66);
}
impl OperationCode {
    pub const ANEURALNETWORKS_NEG: OperationCode = OperationCode(67);
}
impl OperationCode {
    pub const ANEURALNETWORKS_NOT_EQUAL: OperationCode = OperationCode(68);
}
impl OperationCode {
    pub const ANEURALNETWORKS_PAD_V2: OperationCode = OperationCode(69);
}
impl OperationCode {
    pub const ANEURALNETWORKS_POW: OperationCode = OperationCode(70);
}
impl OperationCode {
    pub const ANEURALNETWORKS_PRELU: OperationCode = OperationCode(71);
}
impl OperationCode {
    pub const ANEURALNETWORKS_QUANTIZE: OperationCode = OperationCode(72);
}
impl OperationCode {
    pub const ANEURALNETWORKS_QUANTIZED_16BIT_LSTM: OperationCode = OperationCode(73);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RANDOM_MULTINOMIAL: OperationCode = OperationCode(74);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_ALL: OperationCode = OperationCode(75);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_ANY: OperationCode = OperationCode(76);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_MAX: OperationCode = OperationCode(77);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_MIN: OperationCode = OperationCode(78);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_PROD: OperationCode = OperationCode(79);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REDUCE_SUM: OperationCode = OperationCode(80);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ROI_ALIGN: OperationCode = OperationCode(81);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ROI_POOLING: OperationCode = OperationCode(82);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RSQRT: OperationCode = OperationCode(83);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SELECT: OperationCode = OperationCode(84);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SIN: OperationCode = OperationCode(85);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SLICE: OperationCode = OperationCode(86);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SPLIT: OperationCode = OperationCode(87);
}
impl OperationCode {
    pub const ANEURALNETWORKS_SQRT: OperationCode = OperationCode(88);
}
impl OperationCode {
    pub const ANEURALNETWORKS_TILE: OperationCode = OperationCode(89);
}
impl OperationCode {
    pub const ANEURALNETWORKS_TOPK_V2: OperationCode = OperationCode(90);
}
impl OperationCode {
    pub const ANEURALNETWORKS_TRANSPOSE_CONV_2D: OperationCode = OperationCode(91);
}
impl OperationCode {
    pub const ANEURALNETWORKS_UNIDIRECTIONAL_SEQUENCE_LSTM: OperationCode = OperationCode(92);
}
impl OperationCode {
    pub const ANEURALNETWORKS_UNIDIRECTIONAL_SEQUENCE_RNN: OperationCode = OperationCode(93);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RESIZE_NEAREST_NEIGHBOR: OperationCode = OperationCode(94);
}
impl OperationCode {
    pub const ANEURALNETWORKS_QUANTIZED_LSTM: OperationCode = OperationCode(95);
}
impl OperationCode {
    pub const ANEURALNETWORKS_IF: OperationCode = OperationCode(96);
}
impl OperationCode {
    pub const ANEURALNETWORKS_WHILE: OperationCode = OperationCode(97);
}
impl OperationCode {
    pub const ANEURALNETWORKS_ELU: OperationCode = OperationCode(98);
}
impl OperationCode {
    pub const ANEURALNETWORKS_HARD_SWISH: OperationCode = OperationCode(99);
}
impl OperationCode {
    pub const ANEURALNETWORKS_FILL: OperationCode = OperationCode(100);
}
impl OperationCode {
    pub const ANEURALNETWORKS_RANK: OperationCode = OperationCode(101);
}
impl OperationCode {
    pub const ANEURALNETWORKS_BATCH_MATMUL: OperationCode = OperationCode(102);
}
impl OperationCode {
    pub const ANEURALNETWORKS_PACK: OperationCode = OperationCode(103);
}
impl OperationCode {
    pub const ANEURALNETWORKS_MIRROR_PAD: OperationCode = OperationCode(104);
}
impl OperationCode {
    pub const ANEURALNETWORKS_REVERSE: OperationCode = OperationCode(105);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OperationCode(pub ::std::os::raw::c_uint);
impl FuseCode {
    pub const ANEURALNETWORKS_FUSED_NONE: FuseCode = FuseCode(0);
}
impl FuseCode {
    pub const ANEURALNETWORKS_FUSED_RELU: FuseCode = FuseCode(1);
}
impl FuseCode {
    pub const ANEURALNETWORKS_FUSED_RELU1: FuseCode = FuseCode(2);
}
impl FuseCode {
    pub const ANEURALNETWORKS_FUSED_RELU6: FuseCode = FuseCode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuseCode(pub ::std::os::raw::c_uint);
impl PaddingCode {
    pub const ANEURALNETWORKS_PADDING_SAME: PaddingCode = PaddingCode(1);
}
impl PaddingCode {
    pub const ANEURALNETWORKS_PADDING_VALID: PaddingCode = PaddingCode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PaddingCode(pub ::std::os::raw::c_uint);
impl PreferenceCode {
    pub const ANEURALNETWORKS_PREFER_LOW_POWER: PreferenceCode = PreferenceCode(0);
}
impl PreferenceCode {
    pub const ANEURALNETWORKS_PREFER_FAST_SINGLE_ANSWER: PreferenceCode = PreferenceCode(1);
}
impl PreferenceCode {
    pub const ANEURALNETWORKS_PREFER_SUSTAINED_SPEED: PreferenceCode = PreferenceCode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PreferenceCode(pub ::std::os::raw::c_uint);
impl DeviceTypeCode {
    pub const ANEURALNETWORKS_DEVICE_UNKNOWN: DeviceTypeCode = DeviceTypeCode(0);
}
impl DeviceTypeCode {
    pub const ANEURALNETWORKS_DEVICE_OTHER: DeviceTypeCode = DeviceTypeCode(1);
}
impl DeviceTypeCode {
    pub const ANEURALNETWORKS_DEVICE_CPU: DeviceTypeCode = DeviceTypeCode(2);
}
impl DeviceTypeCode {
    pub const ANEURALNETWORKS_DEVICE_GPU: DeviceTypeCode = DeviceTypeCode(3);
}
impl DeviceTypeCode {
    pub const ANEURALNETWORKS_DEVICE_ACCELERATOR: DeviceTypeCode = DeviceTypeCode(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DeviceTypeCode(pub ::std::os::raw::c_uint);
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_1: FeatureLevelCode = FeatureLevelCode(27);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_2: FeatureLevelCode = FeatureLevelCode(28);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_3: FeatureLevelCode = FeatureLevelCode(29);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_4: FeatureLevelCode = FeatureLevelCode(30);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_5: FeatureLevelCode = FeatureLevelCode(31);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_6: FeatureLevelCode = FeatureLevelCode(1000006);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_7: FeatureLevelCode = FeatureLevelCode(1000007);
}
impl FeatureLevelCode {
    pub const ANEURALNETWORKS_FEATURE_LEVEL_8: FeatureLevelCode = FeatureLevelCode(1000008);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FeatureLevelCode(pub ::std::os::raw::c_uint);
impl ResultCode {
    pub const ANEURALNETWORKS_NO_ERROR: ResultCode = ResultCode(0);
}
impl ResultCode {
    pub const ANEURALNETWORKS_OUT_OF_MEMORY: ResultCode = ResultCode(1);
}
impl ResultCode {
    pub const ANEURALNETWORKS_INCOMPLETE: ResultCode = ResultCode(2);
}
impl ResultCode {
    pub const ANEURALNETWORKS_UNEXPECTED_NULL: ResultCode = ResultCode(3);
}
impl ResultCode {
    pub const ANEURALNETWORKS_BAD_DATA: ResultCode = ResultCode(4);
}
impl ResultCode {
    pub const ANEURALNETWORKS_OP_FAILED: ResultCode = ResultCode(5);
}
impl ResultCode {
    pub const ANEURALNETWORKS_BAD_STATE: ResultCode = ResultCode(6);
}
impl ResultCode {
    pub const ANEURALNETWORKS_UNMAPPABLE: ResultCode = ResultCode(7);
}
impl ResultCode {
    pub const ANEURALNETWORKS_OUTPUT_INSUFFICIENT_SIZE: ResultCode = ResultCode(8);
}
impl ResultCode {
    pub const ANEURALNETWORKS_UNAVAILABLE_DEVICE: ResultCode = ResultCode(9);
}
impl ResultCode {
    pub const ANEURALNETWORKS_MISSED_DEADLINE_TRANSIENT: ResultCode = ResultCode(10);
}
impl ResultCode {
    pub const ANEURALNETWORKS_MISSED_DEADLINE_PERSISTENT: ResultCode = ResultCode(11);
}
impl ResultCode {
    pub const ANEURALNETWORKS_RESOURCE_EXHAUSTED_TRANSIENT: ResultCode = ResultCode(12);
}
impl ResultCode {
    pub const ANEURALNETWORKS_RESOURCE_EXHAUSTED_PERSISTENT: ResultCode = ResultCode(13);
}
impl ResultCode {
    pub const ANEURALNETWORKS_DEAD_OBJECT: ResultCode = ResultCode(14);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResultCode(pub ::std::os::raw::c_uint);
pub const ANEURALNETWORKS_MAX_SIZE_OF_IMMEDIATELY_COPIED_VALUES: _bindgen_ty_35 = 128;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const ANEURALNETWORKS_BYTE_SIZE_OF_CACHE_TOKEN: _bindgen_ty_36 = 32;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
impl DurationCode {
    pub const ANEURALNETWORKS_DURATION_ON_HARDWARE: DurationCode = DurationCode(0);
}
impl DurationCode {
    pub const ANEURALNETWORKS_DURATION_IN_DRIVER: DurationCode = DurationCode(1);
}
impl DurationCode {
    pub const ANEURALNETWORKS_FENCED_DURATION_ON_HARDWARE: DurationCode = DurationCode(2);
}
impl DurationCode {
    pub const ANEURALNETWORKS_FENCED_DURATION_IN_DRIVER: DurationCode = DurationCode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DurationCode(pub ::std::os::raw::c_uint);
impl PriorityCode {
    pub const ANEURALNETWORKS_PRIORITY_LOW: PriorityCode = PriorityCode(90);
}
impl PriorityCode {
    pub const ANEURALNETWORKS_PRIORITY_MEDIUM: PriorityCode = PriorityCode(100);
}
impl PriorityCode {
    pub const ANEURALNETWORKS_PRIORITY_HIGH: PriorityCode = PriorityCode(110);
}
impl PriorityCode {
    pub const ANEURALNETWORKS_PRIORITY_DEFAULT: PriorityCode = PriorityCode(100);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PriorityCode(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksMemory {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksCompilation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksExecution {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksSymmPerChannelQuantParams {
    pub channelDim: u32,
    pub scaleCount: u32,
    pub scales: *const f32,
}
#[test]
fn bindgen_test_layout_ANeuralNetworksSymmPerChannelQuantParams() {
    const UNINIT: ::std::mem::MaybeUninit<ANeuralNetworksSymmPerChannelQuantParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANeuralNetworksSymmPerChannelQuantParams>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ANeuralNetworksSymmPerChannelQuantParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ANeuralNetworksSymmPerChannelQuantParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ANeuralNetworksSymmPerChannelQuantParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channelDim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksSymmPerChannelQuantParams),
            "::",
            stringify!(channelDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksSymmPerChannelQuantParams),
            "::",
            stringify!(scaleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scales) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksSymmPerChannelQuantParams),
            "::",
            stringify!(scales)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksBurst {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksOperandType {
    pub type_: i32,
    pub dimensionCount: u32,
    pub dimensions: *const u32,
    pub scale: f32,
    pub zeroPoint: i32,
}
#[test]
fn bindgen_test_layout_ANeuralNetworksOperandType() {
    const UNINIT: ::std::mem::MaybeUninit<ANeuralNetworksOperandType> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANeuralNetworksOperandType>(),
        24usize,
        concat!("Size of: ", stringify!(ANeuralNetworksOperandType))
    );
    assert_eq!(
        ::std::mem::align_of::<ANeuralNetworksOperandType>(),
        8usize,
        concat!("Alignment of ", stringify!(ANeuralNetworksOperandType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksOperandType),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dimensionCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksOperandType),
            "::",
            stringify!(dimensionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dimensions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksOperandType),
            "::",
            stringify!(dimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksOperandType),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zeroPoint) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ANeuralNetworksOperandType),
            "::",
            stringify!(zeroPoint)
        )
    );
}
pub type ANeuralNetworksOperationType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANeuralNetworksMemoryDesc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_create(
        desc: *mut *mut ANeuralNetworksMemoryDesc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_free(desc: *mut ANeuralNetworksMemoryDesc);
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_addInputRole(
        desc: *mut ANeuralNetworksMemoryDesc,
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        frequency: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_addOutputRole(
        desc: *mut ANeuralNetworksMemoryDesc,
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        frequency: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_setDimensions(
        desc: *mut ANeuralNetworksMemoryDesc,
        rank: u32,
        dimensions: *const u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemoryDesc_finish(
        desc: *mut ANeuralNetworksMemoryDesc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemory_createFromDesc(
        desc: *const ANeuralNetworksMemoryDesc,
        memory: *mut *mut ANeuralNetworksMemory,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemory_copy(
        src: *const ANeuralNetworksMemory,
        dst: *const ANeuralNetworksMemory,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworks_getDeviceCount(numDevices: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworks_getDevice(
        devIndex: u32,
        device: *mut *mut ANeuralNetworksDevice,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksDevice_getName(
        device: *const ANeuralNetworksDevice,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksDevice_getType(
        device: *const ANeuralNetworksDevice,
        type_: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksDevice_getVersion(
        device: *const ANeuralNetworksDevice,
        version: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksDevice_getFeatureLevel(
        device: *const ANeuralNetworksDevice,
        featureLevel: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksDevice_wait(
        device: *const ANeuralNetworksDevice,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_getSupportedOperationsForDevices(
        model: *const ANeuralNetworksModel,
        devices: *const *const ANeuralNetworksDevice,
        numDevices: u32,
        supportedOps: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_createForDevices(
        model: *mut ANeuralNetworksModel,
        devices: *const *const ANeuralNetworksDevice,
        numDevices: u32,
        compilation: *mut *mut ANeuralNetworksCompilation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_setCaching(
        compilation: *mut ANeuralNetworksCompilation,
        cacheDir: *const ::std::os::raw::c_char,
        token: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_compute(
        execution: *mut ANeuralNetworksExecution,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_getOutputOperandRank(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        rank: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_getOutputOperandDimensions(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        dimensions: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksBurst_create(
        compilation: *mut ANeuralNetworksCompilation,
        burst: *mut *mut ANeuralNetworksBurst,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksBurst_free(burst: *mut ANeuralNetworksBurst);
}
extern "C" {
    pub fn ANeuralNetworksExecution_burstCompute(
        execution: *mut ANeuralNetworksExecution,
        burst: *mut ANeuralNetworksBurst,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemory_createFromAHardwareBuffer(
        ahwb: *const AHardwareBuffer,
        memory: *mut *mut ANeuralNetworksMemory,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setMeasureTiming(
        execution: *mut ANeuralNetworksExecution,
        measure: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_getDuration(
        execution: *const ANeuralNetworksExecution,
        durationCode: i32,
        duration: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemory_createFromFd(
        size: usize,
        protect: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        offset: usize,
        memory: *mut *mut ANeuralNetworksMemory,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksMemory_free(memory: *mut ANeuralNetworksMemory);
}
extern "C" {
    pub fn ANeuralNetworksModel_create(
        model: *mut *mut ANeuralNetworksModel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_free(model: *mut ANeuralNetworksModel);
}
extern "C" {
    pub fn ANeuralNetworksModel_finish(model: *mut ANeuralNetworksModel) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_addOperand(
        model: *mut ANeuralNetworksModel,
        type_: *const ANeuralNetworksOperandType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_setOperandValue(
        model: *mut ANeuralNetworksModel,
        index: i32,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_setOperandSymmPerChannelQuantParams(
        model: *mut ANeuralNetworksModel,
        index: i32,
        channelQuant: *const ANeuralNetworksSymmPerChannelQuantParams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_setOperandValueFromMemory(
        model: *mut ANeuralNetworksModel,
        index: i32,
        memory: *const ANeuralNetworksMemory,
        offset: usize,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_setOperandValueFromModel(
        model: *mut ANeuralNetworksModel,
        index: i32,
        value: *const ANeuralNetworksModel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_addOperation(
        model: *mut ANeuralNetworksModel,
        type_: ANeuralNetworksOperationType,
        inputCount: u32,
        inputs: *const u32,
        outputCount: u32,
        outputs: *const u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_identifyInputsAndOutputs(
        model: *mut ANeuralNetworksModel,
        inputCount: u32,
        inputs: *const u32,
        outputCount: u32,
        outputs: *const u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksModel_relaxComputationFloat32toFloat16(
        model: *mut ANeuralNetworksModel,
        allow: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_create(
        model: *mut ANeuralNetworksModel,
        compilation: *mut *mut ANeuralNetworksCompilation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_free(compilation: *mut ANeuralNetworksCompilation);
}
extern "C" {
    pub fn ANeuralNetworksCompilation_setPreference(
        compilation: *mut ANeuralNetworksCompilation,
        preference: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_finish(
        compilation: *mut ANeuralNetworksCompilation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_setPriority(
        compilation: *mut ANeuralNetworksCompilation,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_setTimeout(
        compilation: *mut ANeuralNetworksCompilation,
        duration: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_create(
        compilation: *mut ANeuralNetworksCompilation,
        execution: *mut *mut ANeuralNetworksExecution,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_free(execution: *mut ANeuralNetworksExecution);
}
extern "C" {
    pub fn ANeuralNetworksExecution_setInput(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        type_: *const ANeuralNetworksOperandType,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setInputFromMemory(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        type_: *const ANeuralNetworksOperandType,
        memory: *const ANeuralNetworksMemory,
        offset: usize,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setOutput(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        type_: *const ANeuralNetworksOperandType,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setOutputFromMemory(
        execution: *mut ANeuralNetworksExecution,
        index: i32,
        type_: *const ANeuralNetworksOperandType,
        memory: *const ANeuralNetworksMemory,
        offset: usize,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_startCompute(
        execution: *mut ANeuralNetworksExecution,
        event: *mut *mut ANeuralNetworksEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setTimeout(
        execution: *mut ANeuralNetworksExecution,
        duration: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setLoopTimeout(
        execution: *mut ANeuralNetworksExecution,
        duration: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworks_getDefaultLoopTimeout() -> u64;
}
extern "C" {
    pub fn ANeuralNetworks_getMaximumLoopTimeout() -> u64;
}
extern "C" {
    pub fn ANeuralNetworksEvent_wait(event: *mut ANeuralNetworksEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksEvent_free(event: *mut ANeuralNetworksEvent);
}
extern "C" {
    pub fn ANeuralNetworksEvent_createFromSyncFenceFd(
        sync_fence_fd: ::std::os::raw::c_int,
        event: *mut *mut ANeuralNetworksEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksEvent_getSyncFenceFd(
        event: *const ANeuralNetworksEvent,
        sync_fence_fd: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_startComputeWithDependencies(
        execution: *mut ANeuralNetworksExecution,
        dependencies: *const *const ANeuralNetworksEvent,
        num_dependencies: u32,
        duration: u64,
        event: *mut *mut ANeuralNetworksEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworks_getRuntimeFeatureLevel() -> i64;
}
extern "C" {
    pub fn ANeuralNetworksExecution_enableInputAndOutputPadding(
        execution: *mut ANeuralNetworksExecution,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_getPreferredMemoryAlignmentForInput(
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        alignment: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_getPreferredMemoryPaddingForInput(
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        padding: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_getPreferredMemoryAlignmentForOutput(
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        alignment: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksCompilation_getPreferredMemoryPaddingForOutput(
        compilation: *const ANeuralNetworksCompilation,
        index: u32,
        padding: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ANeuralNetworksExecution_setReusable(
        execution: *mut ANeuralNetworksExecution,
        reusable: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AObbInfo {
    _unused: [u8; 0],
}
pub const AOBBINFO_OVERLAY: _bindgen_ty_37 = 1;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AObbScanner_getObbInfo(filename: *const ::std::os::raw::c_char) -> *mut AObbInfo;
}
extern "C" {
    pub fn AObbInfo_delete(obbInfo: *mut AObbInfo);
}
extern "C" {
    pub fn AObbInfo_getPackageName(obbInfo: *mut AObbInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AObbInfo_getVersion(obbInfo: *mut AObbInfo) -> i32;
}
extern "C" {
    pub fn AObbInfo_getFlags(obbInfo: *mut AObbInfo) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[test]
fn bindgen_test_layout___kernel_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___kernel_old_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_old_timespec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[test]
fn bindgen_test_layout___kernel_sock_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_sock_timeval> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sock_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __kernel_old_time_t,
    pub tv_usec: __kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub fault_address: __u64,
    pub regs: [__u64; 31usize],
    pub sp: __u64,
    pub pc: __u64,
    pub pstate: __u64,
    pub __bindgen_padding_0: [u8; 8usize],
    pub __reserved: [__u8; 4096usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        4384usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        16usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fault_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fault_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aarch64_ctx {
    pub magic: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout__aarch64_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<_aarch64_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_aarch64_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<_aarch64_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpsimd_context {
    pub head: _aarch64_ctx,
    pub fpsr: __u32,
    pub fpcr: __u32,
    pub vregs: [__uint128_t; 32usize],
}
#[test]
fn bindgen_test_layout_fpsimd_context() {
    const UNINIT: ::std::mem::MaybeUninit<fpsimd_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fpsimd_context>(),
        528usize,
        concat!("Size of: ", stringify!(fpsimd_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fpsimd_context>(),
        16usize,
        concat!("Alignment of ", stringify!(fpsimd_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(vregs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esr_context {
    pub head: _aarch64_ctx,
    pub esr: __u64,
}
#[test]
fn bindgen_test_layout_esr_context() {
    const UNINIT: ::std::mem::MaybeUninit<esr_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<esr_context>(),
        16usize,
        concat!("Size of: ", stringify!(esr_context))
    );
    assert_eq!(
        ::std::mem::align_of::<esr_context>(),
        8usize,
        concat!("Alignment of ", stringify!(esr_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(esr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extra_context {
    pub head: _aarch64_ctx,
    pub datap: __u64,
    pub size: __u32,
    pub __reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_extra_context() {
    const UNINIT: ::std::mem::MaybeUninit<extra_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<extra_context>(),
        32usize,
        concat!("Size of: ", stringify!(extra_context))
    );
    assert_eq!(
        ::std::mem::align_of::<extra_context>(),
        8usize,
        concat!("Alignment of ", stringify!(extra_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(datap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sve_context {
    pub head: _aarch64_ctx,
    pub vl: __u16,
    pub flags: __u16,
    pub __reserved: [__u16; 2usize],
}
#[test]
fn bindgen_test_layout_sve_context() {
    const UNINIT: ::std::mem::MaybeUninit<sve_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sve_context>(),
        16usize,
        concat!("Size of: ", stringify!(sve_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sve_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sve_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(vl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tpidr2_context {
    pub head: _aarch64_ctx,
    pub tpidr2: __u64,
}
#[test]
fn bindgen_test_layout_tpidr2_context() {
    const UNINIT: ::std::mem::MaybeUninit<tpidr2_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tpidr2_context>(),
        16usize,
        concat!("Size of: ", stringify!(tpidr2_context))
    );
    assert_eq!(
        ::std::mem::align_of::<tpidr2_context>(),
        8usize,
        concat!("Alignment of ", stringify!(tpidr2_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tpidr2_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpidr2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tpidr2_context),
            "::",
            stringify!(tpidr2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct za_context {
    pub head: _aarch64_ctx,
    pub vl: __u16,
    pub __reserved: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_za_context() {
    const UNINIT: ::std::mem::MaybeUninit<za_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<za_context>(),
        16usize,
        concat!("Size of: ", stringify!(za_context))
    );
    assert_eq!(
        ::std::mem::align_of::<za_context>(),
        4usize,
        concat!("Alignment of ", stringify!(za_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(za_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(za_context),
            "::",
            stringify!(vl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(za_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zt_context {
    pub head: _aarch64_ctx,
    pub nregs: __u16,
    pub __reserved: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_zt_context() {
    const UNINIT: ::std::mem::MaybeUninit<zt_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zt_context>(),
        16usize,
        concat!("Size of: ", stringify!(zt_context))
    );
    assert_eq!(
        ::std::mem::align_of::<zt_context>(),
        4usize,
        concat!("Alignment of ", stringify!(zt_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zt_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nregs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zt_context),
            "::",
            stringify!(nregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(zt_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub sig: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
pub type old_sigset_t = ::std::os::raw::c_ulong;
pub type __signalfn_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ::std::os::raw::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[test]
fn bindgen_test_layout___kernel_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::std::os::raw::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._overrun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sys_private) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::std::os::raw::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._utime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._stime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ::std::os::raw::c_int,
    pub _addr_lsb: ::std::os::raw::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::std::os::raw::c_char; 8usize],
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dummy_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::std::os::raw::c_char; 8usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dummy_pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ::std::os::raw::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_flags)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_5__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._trapno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_trapno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr_lsb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr_pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._perf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_perf)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::std::os::raw::c_long,
    pub _fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields() {
    const UNINIT: ::std::mem::MaybeUninit<__sifields> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sifields>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [::std::os::raw::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._si_pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_si_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: ::std::os::raw::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type sig_t = __sighandler_t;
pub type sighandler_t = __sighandler_t;
pub type sigset64_t = sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_flags: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction64 {
    pub sa_flags: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sigaction64__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction64__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction64__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction64__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction64() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction64>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_regs_struct {
    pub regs: [u64; 31usize],
    pub sp: u64,
    pub pc: u64,
    pub pstate: u64,
}
#[test]
fn bindgen_test_layout_user_regs_struct() {
    const UNINIT: ::std::mem::MaybeUninit<user_regs_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<user_regs_struct>(),
        272usize,
        concat!("Size of: ", stringify!(user_regs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_regs_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_regs_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(pstate)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct user_fpsimd_struct {
    pub vregs: [__uint128_t; 32usize],
    pub fpsr: u32,
    pub fpcr: u32,
}
#[test]
fn bindgen_test_layout_user_fpsimd_struct() {
    const UNINIT: ::std::mem::MaybeUninit<user_fpsimd_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<user_fpsimd_struct>(),
        528usize,
        concat!("Size of: ", stringify!(user_fpsimd_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_fpsimd_struct>(),
        16usize,
        concat!("Alignment of ", stringify!(user_fpsimd_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(vregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpsimd_struct),
            "::",
            stringify!(fpcr)
        )
    );
}
pub type greg_t = ::std::os::raw::c_ulong;
pub type gregset_t = [greg_t; 34usize];
pub type fpregset_t = user_fpsimd_struct;
pub type mcontext_t = sigcontext;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub __bindgen_anon_1: ucontext__bindgen_ty_1,
    pub __padding: [::std::os::raw::c_char; 120usize],
    pub __bindgen_padding_0: u64,
    pub uc_mcontext: mcontext_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucontext__bindgen_ty_1 {
    pub uc_sigmask: sigset_t,
    pub uc_sigmask64: sigset64_t,
}
#[test]
fn bindgen_test_layout_ucontext__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ucontext__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask64)
        )
    );
}
#[test]
fn bindgen_test_layout_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        4560usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        16usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__padding) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub fn sigaction(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction,
        __old_action: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction64(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction64,
        __old_action: *mut sigaction64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        __signal: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn sigaddset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember64(
        __set: *const sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset_t,
        __old_set: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask64(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset64_t,
        __old_set: *mut sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__mask: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend64(__mask: *const sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait64(
        __set: *const sigset64_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn raise(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill(__pid: pid_t, __signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(
        __pgrp: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tgkill(
        __tgid: ::std::os::raw::c_int,
        __tid: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(
        __new_signal_stack: *const stack_t,
        __old_signal_stack: *mut stack_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psiginfo(__info: *const siginfo_t, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psignal(__signal: ::std::os::raw::c_int, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn pthread_kill(
        __pthread: pthread_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset_t,
        __old_set: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask64(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset64_t,
        __old_set: *mut sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: pid_t,
        __signal: ::std::os::raw::c_int,
        __value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait64(
        __set: *const sigset64_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo64(__set: *const sigset64_t, __info: *mut siginfo_t)
        -> ::std::os::raw::c_int;
}
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __FD_CLR_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: usize);
}
extern "C" {
    pub fn __FD_SET_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: usize);
}
extern "C" {
    pub fn __FD_ISSET_chk(
        arg1: ::std::os::raw::c_int,
        arg2: *const fd_set,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect64(
        __max_fd_plus_one: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __op: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        __argc: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __options: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioctl(
        __fd: ::std::os::raw::c_int,
        __op: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __op: ::std::os::raw::c_int,
        __length: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf64(
        __fd: ::std::os::raw::c_int,
        __op: ::std::os::raw::c_int,
        __length: off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn _Fork() -> pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn gettid() -> pid_t;
}
extern "C" {
    pub fn getpgid(__pid: pid_t) -> pid_t;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsid(__pid: pid_t) -> pid_t;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__incr: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: gid_t, __egid: gid_t, __sgid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: uid_t, __euid: uid_t, __suid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(__size: usize, __list: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresuid(
        __ruid: *mut uid_t,
        __euid: *mut uid_t,
        __suid: *mut uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresgid(
        __rgid: *mut gid_t,
        __egid: *mut gid_t,
        __sgid: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __buffer: *mut ::std::os::raw::c_char,
        __buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn access(
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __old_dir_fd: ::std::os::raw::c_int,
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(__fds: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlinkat(
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn readlinkat(
        __dir_fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn chown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __dir_fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: usize,
    ) -> isize;
}
extern "C" {
    pub fn dup(__old_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(
        __old_fd: ::std::os::raw::c_int,
        __new_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup3(
        __old_fd: ::std::os::raw::c_int,
        __new_fd: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __path: *const ::std::os::raw::c_char,
        __length: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate64(
        __path: *const ::std::os::raw::c_char,
        __length: off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek64(
        __fd: ::std::os::raw::c_int,
        __offset: off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> off64_t;
}
extern "C" {
    pub fn pread64(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __count: usize,
        __offset: off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite64(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __count: usize,
        __offset: off64_t,
    ) -> isize;
}
extern "C" {
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: off64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn usleep(__microseconds: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(
        _buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__increment: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(__number: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn daemon(
        __no_chdir: ::std::os::raw::c_int,
        __no_close: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __buf: *mut ::std::os::raw::c_char,
        __buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_file_range(
        __fd_in: ::std::os::raw::c_int,
        __off_in: *mut off64_t,
        __fd_out: ::std::os::raw::c_int,
        __off_out: *mut off64_t,
        __length: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn swab(
        __src: *const ::std::os::raw::c_void,
        __dst: *mut ::std::os::raw::c_void,
        __byte_count: isize,
    );
}
extern "C" {
    pub fn close_range(
        __min_fd: ::std::os::raw::c_uint,
        __max_fd: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct APerformanceHintManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct APerformanceHintSession {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AWorkDuration {
    _unused: [u8; 0],
}
extern "C" {
    pub fn APerformanceHint_getManager() -> *mut APerformanceHintManager;
}
extern "C" {
    pub fn APerformanceHint_createSession(
        manager: *mut APerformanceHintManager,
        threadIds: *const i32,
        size: usize,
        initialTargetWorkDurationNanos: i64,
    ) -> *mut APerformanceHintSession;
}
extern "C" {
    pub fn APerformanceHint_getPreferredUpdateRateNanos(
        manager: *mut APerformanceHintManager,
    ) -> i64;
}
extern "C" {
    pub fn APerformanceHint_updateTargetWorkDuration(
        session: *mut APerformanceHintSession,
        targetDurationNanos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn APerformanceHint_reportActualWorkDuration(
        session: *mut APerformanceHintSession,
        actualDurationNanos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn APerformanceHint_closeSession(session: *mut APerformanceHintSession);
}
extern "C" {
    pub fn APerformanceHint_setThreads(
        session: *mut APerformanceHintSession,
        threadIds: *const pid_t,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn APerformanceHint_setPreferPowerEfficiency(
        session: *mut APerformanceHintSession,
        enabled: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn APerformanceHint_reportActualWorkDuration2(
        session: *mut APerformanceHintSession,
        workDuration: *mut AWorkDuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AWorkDuration_create() -> *mut AWorkDuration;
}
extern "C" {
    pub fn AWorkDuration_release(WorkDuration: *mut AWorkDuration);
}
extern "C" {
    pub fn AWorkDuration_setWorkPeriodStartTimestampNanos(
        aWorkDuration: *mut AWorkDuration,
        workPeriodStartTimestampNanos: i64,
    );
}
extern "C" {
    pub fn AWorkDuration_setActualTotalDurationNanos(
        aWorkDuration: *mut AWorkDuration,
        actualTotalDurationNanos: i64,
    );
}
extern "C" {
    pub fn AWorkDuration_setActualCpuDurationNanos(
        aWorkDuration: *mut AWorkDuration,
        actualCpuDurationNanos: i64,
    );
}
extern "C" {
    pub fn AWorkDuration_setActualGpuDurationNanos(
        aWorkDuration: *mut AWorkDuration,
        actualGpuDurationNanos: i64,
    );
}
pub const PERMISSION_MANAGER_PERMISSION_GRANTED: _bindgen_ty_38 = 0;
pub const PERMISSION_MANAGER_PERMISSION_DENIED: _bindgen_ty_38 = -1;
pub type _bindgen_ty_38 = ::std::os::raw::c_int;
pub const PERMISSION_MANAGER_STATUS_OK: _bindgen_ty_39 = 0;
pub const PERMISSION_MANAGER_STATUS_ERROR_UNKNOWN: _bindgen_ty_39 = -1;
pub const PERMISSION_MANAGER_STATUS_SERVICE_UNAVAILABLE: _bindgen_ty_39 = -2;
pub type _bindgen_ty_39 = ::std::os::raw::c_int;
extern "C" {
    pub fn APermissionManager_checkPermission(
        permission: *const ::std::os::raw::c_char,
        pid: pid_t,
        uid: uid_t,
        outResult: *mut i32,
    ) -> i32;
}
pub type __double_t = f64;
pub type double_t = __double_t;
pub type __float_t = f32;
pub type float_t = __float_t;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn modf(__x: f64, __integral_part: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(__x: f32, __integral_part: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(__x: u128, __integral_part: *mut u128) -> u128;
}
extern "C" {
    pub fn scalbn(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn scalbln(__x: f64, __exponent: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(__x: f32, __exponent: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(__x: u128, __exponent: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn erf(__x: f64) -> f64;
}
extern "C" {
    pub fn erff(__x: f32) -> f32;
}
extern "C" {
    pub fn erfl(__x: u128) -> u128;
}
extern "C" {
    pub fn erfc(__x: f64) -> f64;
}
extern "C" {
    pub fn erfcf(__x: f32) -> f32;
}
extern "C" {
    pub fn erfcl(__x: u128) -> u128;
}
extern "C" {
    pub fn lgamma(__x: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(__x: f32) -> f32;
}
extern "C" {
    pub fn lgammal(__x: u128) -> u128;
}
extern "C" {
    pub fn tgamma(__x: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(__x: f32) -> f32;
}
extern "C" {
    pub fn tgammal(__x: u128) -> u128;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quotient_bits: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quotient_bits: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quotient_bits: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn copysign(__value: f64, __sign: f64) -> f64;
}
extern "C" {
    pub fn copysignf(__value: f32, __sign: f32) -> f32;
}
extern "C" {
    pub fn copysignl(__value: u128, __sign: u128) -> u128;
}
extern "C" {
    pub fn nan(__kind: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(__kind: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(__kind: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn isinf(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn y0(__x: f64) -> f64;
}
extern "C" {
    pub fn y1(__x: f64) -> f64;
}
extern "C" {
    pub fn yn(__n: ::std::os::raw::c_int, __x: f64) -> f64;
}
pub const ASENSOR_TYPE_INVALID: _bindgen_ty_40 = -1;
pub const ASENSOR_TYPE_ACCELEROMETER: _bindgen_ty_40 = 1;
pub const ASENSOR_TYPE_MAGNETIC_FIELD: _bindgen_ty_40 = 2;
pub const ASENSOR_TYPE_GYROSCOPE: _bindgen_ty_40 = 4;
pub const ASENSOR_TYPE_LIGHT: _bindgen_ty_40 = 5;
pub const ASENSOR_TYPE_PRESSURE: _bindgen_ty_40 = 6;
pub const ASENSOR_TYPE_PROXIMITY: _bindgen_ty_40 = 8;
pub const ASENSOR_TYPE_GRAVITY: _bindgen_ty_40 = 9;
pub const ASENSOR_TYPE_LINEAR_ACCELERATION: _bindgen_ty_40 = 10;
pub const ASENSOR_TYPE_ROTATION_VECTOR: _bindgen_ty_40 = 11;
pub const ASENSOR_TYPE_RELATIVE_HUMIDITY: _bindgen_ty_40 = 12;
pub const ASENSOR_TYPE_AMBIENT_TEMPERATURE: _bindgen_ty_40 = 13;
pub const ASENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED: _bindgen_ty_40 = 14;
pub const ASENSOR_TYPE_GAME_ROTATION_VECTOR: _bindgen_ty_40 = 15;
pub const ASENSOR_TYPE_GYROSCOPE_UNCALIBRATED: _bindgen_ty_40 = 16;
pub const ASENSOR_TYPE_SIGNIFICANT_MOTION: _bindgen_ty_40 = 17;
pub const ASENSOR_TYPE_STEP_DETECTOR: _bindgen_ty_40 = 18;
pub const ASENSOR_TYPE_STEP_COUNTER: _bindgen_ty_40 = 19;
pub const ASENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR: _bindgen_ty_40 = 20;
pub const ASENSOR_TYPE_HEART_RATE: _bindgen_ty_40 = 21;
pub const ASENSOR_TYPE_POSE_6DOF: _bindgen_ty_40 = 28;
pub const ASENSOR_TYPE_STATIONARY_DETECT: _bindgen_ty_40 = 29;
pub const ASENSOR_TYPE_MOTION_DETECT: _bindgen_ty_40 = 30;
pub const ASENSOR_TYPE_HEART_BEAT: _bindgen_ty_40 = 31;
pub const ASENSOR_TYPE_DYNAMIC_SENSOR_META: _bindgen_ty_40 = 32;
pub const ASENSOR_TYPE_ADDITIONAL_INFO: _bindgen_ty_40 = 33;
pub const ASENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT: _bindgen_ty_40 = 34;
pub const ASENSOR_TYPE_ACCELEROMETER_UNCALIBRATED: _bindgen_ty_40 = 35;
pub const ASENSOR_TYPE_HINGE_ANGLE: _bindgen_ty_40 = 36;
pub const ASENSOR_TYPE_HEAD_TRACKER: _bindgen_ty_40 = 37;
pub const ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES: _bindgen_ty_40 = 38;
pub const ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES: _bindgen_ty_40 = 39;
pub const ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED: _bindgen_ty_40 = 40;
pub const ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED: _bindgen_ty_40 = 41;
pub const ASENSOR_TYPE_HEADING: _bindgen_ty_40 = 42;
pub type _bindgen_ty_40 = ::std::os::raw::c_int;
pub const ASENSOR_STATUS_NO_CONTACT: _bindgen_ty_41 = -1;
pub const ASENSOR_STATUS_UNRELIABLE: _bindgen_ty_41 = 0;
pub const ASENSOR_STATUS_ACCURACY_LOW: _bindgen_ty_41 = 1;
pub const ASENSOR_STATUS_ACCURACY_MEDIUM: _bindgen_ty_41 = 2;
pub const ASENSOR_STATUS_ACCURACY_HIGH: _bindgen_ty_41 = 3;
pub type _bindgen_ty_41 = ::std::os::raw::c_int;
pub const AREPORTING_MODE_INVALID: _bindgen_ty_42 = -1;
pub const AREPORTING_MODE_CONTINUOUS: _bindgen_ty_42 = 0;
pub const AREPORTING_MODE_ON_CHANGE: _bindgen_ty_42 = 1;
pub const AREPORTING_MODE_ONE_SHOT: _bindgen_ty_42 = 2;
pub const AREPORTING_MODE_SPECIAL_TRIGGER: _bindgen_ty_42 = 3;
pub type _bindgen_ty_42 = ::std::os::raw::c_int;
pub const ASENSOR_DIRECT_RATE_STOP: _bindgen_ty_43 = 0;
pub const ASENSOR_DIRECT_RATE_NORMAL: _bindgen_ty_43 = 1;
pub const ASENSOR_DIRECT_RATE_FAST: _bindgen_ty_43 = 2;
pub const ASENSOR_DIRECT_RATE_VERY_FAST: _bindgen_ty_43 = 3;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY: _bindgen_ty_44 = 1;
pub const ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER: _bindgen_ty_44 = 2;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const ASENSOR_ADDITIONAL_INFO_BEGIN: _bindgen_ty_45 = 0;
pub const ASENSOR_ADDITIONAL_INFO_END: _bindgen_ty_45 = 1;
pub const ASENSOR_ADDITIONAL_INFO_UNTRACKED_DELAY: _bindgen_ty_45 = 65536;
pub const ASENSOR_ADDITIONAL_INFO_INTERNAL_TEMPERATURE: _bindgen_ty_45 = 65537;
pub const ASENSOR_ADDITIONAL_INFO_VEC3_CALIBRATION: _bindgen_ty_45 = 65538;
pub const ASENSOR_ADDITIONAL_INFO_SENSOR_PLACEMENT: _bindgen_ty_45 = 65539;
pub const ASENSOR_ADDITIONAL_INFO_SAMPLING: _bindgen_ty_45 = 65540;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASensorVector {
    pub __bindgen_anon_1: ASensorVector__bindgen_ty_1,
    pub status: i8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorVector__bindgen_ty_1 {
    pub v: [f32; 3usize],
    pub __bindgen_anon_1: ASensorVector__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ASensorVector__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorVector__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ASensorVector__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorVector__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorVector__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorVector__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorVector__bindgen_ty_1__bindgen_ty_2 {
    pub azimuth: f32,
    pub pitch: f32,
    pub roll: f32,
}
#[test]
fn bindgen_test_layout_ASensorVector__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorVector__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorVector__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorVector__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).azimuth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(azimuth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(roll)
        )
    );
}
#[test]
fn bindgen_test_layout_ASensorVector__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorVector__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorVector__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ASensorVector__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorVector__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ASensorVector__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector__bindgen_ty_1),
            "::",
            stringify!(v)
        )
    );
}
#[test]
fn bindgen_test_layout_ASensorVector() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorVector>(),
        16usize,
        concat!("Size of: ", stringify!(ASensorVector))
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorVector>(),
        4usize,
        concat!("Alignment of ", stringify!(ASensorVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorVector),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMetaDataEvent {
    pub what: i32,
    pub sensor: i32,
}
#[test]
fn bindgen_test_layout_AMetaDataEvent() {
    const UNINIT: ::std::mem::MaybeUninit<AMetaDataEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMetaDataEvent>(),
        8usize,
        concat!("Size of: ", stringify!(AMetaDataEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AMetaDataEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AMetaDataEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).what) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMetaDataEvent),
            "::",
            stringify!(what)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AMetaDataEvent),
            "::",
            stringify!(sensor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AUncalibratedEvent {
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_1,
    pub __bindgen_anon_2: AUncalibratedEvent__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AUncalibratedEvent__bindgen_ty_1 {
    pub uncalib: [f32; 3usize],
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x_uncalib: f32,
    pub y_uncalib: f32,
    pub z_uncalib: f32,
}
#[test]
fn bindgen_test_layout_AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_uncalib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x_uncalib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_uncalib) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y_uncalib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_uncalib) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z_uncalib)
        )
    );
}
#[test]
fn bindgen_test_layout_AUncalibratedEvent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AUncalibratedEvent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AUncalibratedEvent__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(AUncalibratedEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AUncalibratedEvent__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AUncalibratedEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncalib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_1),
            "::",
            stringify!(uncalib)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AUncalibratedEvent__bindgen_ty_2 {
    pub bias: [f32; 3usize],
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_bias: f32,
    pub y_bias: f32,
    pub z_bias: f32,
}
#[test]
fn bindgen_test_layout_AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_bias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(x_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_bias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(y_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_bias) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(z_bias)
        )
    );
}
#[test]
fn bindgen_test_layout_AUncalibratedEvent__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<AUncalibratedEvent__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AUncalibratedEvent__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(AUncalibratedEvent__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<AUncalibratedEvent__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AUncalibratedEvent__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUncalibratedEvent__bindgen_ty_2),
            "::",
            stringify!(bias)
        )
    );
}
#[test]
fn bindgen_test_layout_AUncalibratedEvent() {
    assert_eq!(
        ::std::mem::size_of::<AUncalibratedEvent>(),
        24usize,
        concat!("Size of: ", stringify!(AUncalibratedEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AUncalibratedEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AUncalibratedEvent))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeartRateEvent {
    pub bpm: f32,
    pub status: i8,
}
#[test]
fn bindgen_test_layout_AHeartRateEvent() {
    const UNINIT: ::std::mem::MaybeUninit<AHeartRateEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHeartRateEvent>(),
        8usize,
        concat!("Size of: ", stringify!(AHeartRateEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AHeartRateEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AHeartRateEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeartRateEvent),
            "::",
            stringify!(bpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeartRateEvent),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADynamicSensorEvent {
    pub connected: i32,
    pub handle: i32,
}
#[test]
fn bindgen_test_layout_ADynamicSensorEvent() {
    const UNINIT: ::std::mem::MaybeUninit<ADynamicSensorEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ADynamicSensorEvent>(),
        8usize,
        concat!("Size of: ", stringify!(ADynamicSensorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<ADynamicSensorEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(ADynamicSensorEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADynamicSensorEvent),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADynamicSensorEvent),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AAdditionalInfoEvent {
    pub type_: i32,
    pub serial: i32,
    pub __bindgen_anon_1: AAdditionalInfoEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AAdditionalInfoEvent__bindgen_ty_1 {
    pub data_int32: [i32; 14usize],
    pub data_float: [f32; 14usize],
}
#[test]
fn bindgen_test_layout_AAdditionalInfoEvent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AAdditionalInfoEvent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AAdditionalInfoEvent__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(AAdditionalInfoEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AAdditionalInfoEvent__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AAdditionalInfoEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AAdditionalInfoEvent__bindgen_ty_1),
            "::",
            stringify!(data_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AAdditionalInfoEvent__bindgen_ty_1),
            "::",
            stringify!(data_float)
        )
    );
}
#[test]
fn bindgen_test_layout_AAdditionalInfoEvent() {
    const UNINIT: ::std::mem::MaybeUninit<AAdditionalInfoEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AAdditionalInfoEvent>(),
        64usize,
        concat!("Size of: ", stringify!(AAdditionalInfoEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AAdditionalInfoEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AAdditionalInfoEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AAdditionalInfoEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AAdditionalInfoEvent),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeadTrackerEvent {
    pub rx: f32,
    pub ry: f32,
    pub rz: f32,
    pub vx: f32,
    pub vy: f32,
    pub vz: f32,
    pub discontinuity_count: i32,
}
#[test]
fn bindgen_test_layout_AHeadTrackerEvent() {
    const UNINIT: ::std::mem::MaybeUninit<AHeadTrackerEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHeadTrackerEvent>(),
        28usize,
        concat!("Size of: ", stringify!(AHeadTrackerEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AHeadTrackerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AHeadTrackerEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(ry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(rz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(vx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(vy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vz) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(vz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discontinuity_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadTrackerEvent),
            "::",
            stringify!(discontinuity_count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ALimitedAxesImuEvent {
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_1,
    pub __bindgen_anon_2: ALimitedAxesImuEvent__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuEvent__bindgen_ty_1 {
    pub calib: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuEvent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuEvent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuEvent__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ALimitedAxesImuEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuEvent__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_1),
            "::",
            stringify!(calib)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuEvent__bindgen_ty_2 {
    pub supported: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_supported: f32,
    pub y_supported: f32,
    pub z_supported: f32,
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(x_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(y_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_supported) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(z_supported)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuEvent__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuEvent__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuEvent__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(ALimitedAxesImuEvent__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuEvent__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuEvent__bindgen_ty_2),
            "::",
            stringify!(supported)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuEvent() {
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuEvent>(),
        24usize,
        concat!("Size of: ", stringify!(ALimitedAxesImuEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(ALimitedAxesImuEvent))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent {
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_1,
    pub __bindgen_anon_2: ALimitedAxesImuUncalibratedEvent__bindgen_ty_2,
    pub __bindgen_anon_3: ALimitedAxesImuUncalibratedEvent__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_1 {
    pub uncalib: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x_uncalib: f32,
    pub y_uncalib: f32,
    pub z_uncalib: f32,
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_uncalib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x_uncalib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_uncalib) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y_uncalib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_uncalib) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z_uncalib)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuUncalibratedEvent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncalib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_1),
            "::",
            stringify!(uncalib)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_2 {
    pub bias: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_bias: f32,
    pub y_bias: f32,
    pub z_bias: f32,
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_bias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(x_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_bias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(y_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_bias) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(z_bias)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuUncalibratedEvent__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_2),
            "::",
            stringify!(bias)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_3 {
    pub supported: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1 {
    pub x_supported: f32,
    pub y_supported: f32,
    pub z_supported: f32,
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(x_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(y_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_supported) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(z_supported)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<ALimitedAxesImuUncalibratedEvent__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALimitedAxesImuUncalibratedEvent__bindgen_ty_3),
            "::",
            stringify!(supported)
        )
    );
}
#[test]
fn bindgen_test_layout_ALimitedAxesImuUncalibratedEvent() {
    assert_eq!(
        ::std::mem::size_of::<ALimitedAxesImuUncalibratedEvent>(),
        36usize,
        concat!("Size of: ", stringify!(ALimitedAxesImuUncalibratedEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<ALimitedAxesImuUncalibratedEvent>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ALimitedAxesImuUncalibratedEvent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeadingEvent {
    pub heading: f32,
    pub accuracy: f32,
}
#[test]
fn bindgen_test_layout_AHeadingEvent() {
    const UNINIT: ::std::mem::MaybeUninit<AHeadingEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHeadingEvent>(),
        8usize,
        concat!("Size of: ", stringify!(AHeadingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AHeadingEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AHeadingEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heading) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadingEvent),
            "::",
            stringify!(heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accuracy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHeadingEvent),
            "::",
            stringify!(accuracy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASensorEvent {
    pub version: i32,
    pub sensor: i32,
    pub type_: i32,
    pub reserved0: i32,
    pub timestamp: i64,
    pub __bindgen_anon_1: ASensorEvent__bindgen_ty_1,
    pub flags: u32,
    pub reserved1: [i32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1 {
    pub __bindgen_anon_1: ASensorEvent__bindgen_ty_1__bindgen_ty_1,
    pub u64_: ASensorEvent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1__bindgen_ty_1 {
    pub data: [f32; 16usize],
    pub vector: ASensorVector,
    pub acceleration: ASensorVector,
    pub gyro: ASensorVector,
    pub magnetic: ASensorVector,
    pub temperature: f32,
    pub distance: f32,
    pub light: f32,
    pub pressure: f32,
    pub relative_humidity: f32,
    pub uncalibrated_acceleration: AUncalibratedEvent,
    pub uncalibrated_gyro: AUncalibratedEvent,
    pub uncalibrated_magnetic: AUncalibratedEvent,
    pub meta_data: AMetaDataEvent,
    pub heart_rate: AHeartRateEvent,
    pub dynamic_sensor_meta: ADynamicSensorEvent,
    pub additional_info: AAdditionalInfoEvent,
    pub head_tracker: AHeadTrackerEvent,
    pub limited_axes_imu: ALimitedAxesImuEvent,
    pub limited_axes_imu_uncalibrated: ALimitedAxesImuUncalibratedEvent,
    pub heading: AHeadingEvent,
}
#[test]
fn bindgen_test_layout_ASensorEvent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorEvent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorEvent__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acceleration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(acceleration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gyro) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(gyro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magnetic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(magnetic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).light) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(light)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_humidity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(relative_humidity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncalibrated_acceleration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uncalibrated_acceleration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncalibrated_gyro) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uncalibrated_gyro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncalibrated_magnetic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uncalibrated_magnetic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heart_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(heart_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_sensor_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dynamic_sensor_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).additional_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(additional_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_tracker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(head_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limited_axes_imu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(limited_axes_imu)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).limited_axes_imu_uncalibrated) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(limited_axes_imu_uncalibrated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heading) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(heading)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1__bindgen_ty_2 {
    pub data: [u64; 8usize],
    pub step_counter: u64,
}
#[test]
fn bindgen_test_layout_ASensorEvent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorEvent__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorEvent__bindgen_ty_1__bindgen_ty_2>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorEvent__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(step_counter)
        )
    );
}
#[test]
fn bindgen_test_layout_ASensorEvent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorEvent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorEvent__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(ASensorEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorEvent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ASensorEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
}
#[test]
fn bindgen_test_layout_ASensorEvent() {
    const UNINIT: ::std::mem::MaybeUninit<ASensorEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASensorEvent>(),
        104usize,
        concat!("Size of: ", stringify!(ASensorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<ASensorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(ASensorEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ASensorEvent),
            "::",
            stringify!(reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorEventQueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensor {
    _unused: [u8; 0],
}
pub type ASensorRef = *const ASensor;
pub type ASensorList = *const ASensorRef;
extern "C" {
    pub fn ASensorManager_getInstance() -> *mut ASensorManager;
}
extern "C" {
    pub fn ASensorManager_getInstanceForPackage(
        packageName: *const ::std::os::raw::c_char,
    ) -> *mut ASensorManager;
}
extern "C" {
    pub fn ASensorManager_getSensorList(
        manager: *mut ASensorManager,
        list: *mut ASensorList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorManager_getDynamicSensorList(
        manager: *mut ASensorManager,
        list: *mut ASensorList,
    ) -> isize;
}
extern "C" {
    pub fn ASensorManager_getDefaultSensor(
        manager: *mut ASensorManager,
        type_: ::std::os::raw::c_int,
    ) -> *const ASensor;
}
extern "C" {
    pub fn ASensorManager_getDefaultSensorEx(
        manager: *mut ASensorManager,
        type_: ::std::os::raw::c_int,
        wakeUp: bool,
    ) -> *const ASensor;
}
extern "C" {
    pub fn ASensorManager_createEventQueue(
        manager: *mut ASensorManager,
        looper: *mut ALooper,
        ident: ::std::os::raw::c_int,
        callback: ALooper_callbackFunc,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ASensorEventQueue;
}
extern "C" {
    pub fn ASensorManager_destroyEventQueue(
        manager: *mut ASensorManager,
        queue: *mut ASensorEventQueue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorManager_createSharedMemoryDirectChannel(
        manager: *mut ASensorManager,
        fd: ::std::os::raw::c_int,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorManager_createHardwareBufferDirectChannel(
        manager: *mut ASensorManager,
        buffer: *const AHardwareBuffer,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorManager_destroyDirectChannel(
        manager: *mut ASensorManager,
        channelId: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASensorManager_configureDirectReport(
        manager: *mut ASensorManager,
        sensor: *const ASensor,
        channelId: ::std::os::raw::c_int,
        rate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_registerSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
        samplingPeriodUs: i32,
        maxBatchReportLatencyUs: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_enableSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_disableSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_setEventRate(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
        usec: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_hasEvents(queue: *mut ASensorEventQueue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensorEventQueue_getEvents(
        queue: *mut ASensorEventQueue,
        events: *mut ASensorEvent,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn ASensorEventQueue_requestAdditionalInfoEvents(
        queue: *mut ASensorEventQueue,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getName(sensor: *const ASensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASensor_getVendor(sensor: *const ASensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASensor_getType(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getResolution(sensor: *const ASensor) -> f32;
}
extern "C" {
    pub fn ASensor_getMinDelay(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getFifoMaxEventCount(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getFifoReservedEventCount(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getStringType(sensor: *const ASensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASensor_getReportingMode(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_isWakeUpSensor(sensor: *const ASensor) -> bool;
}
extern "C" {
    pub fn ASensor_isDirectChannelTypeSupported(
        sensor: *const ASensor,
        channelType: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn ASensor_getHighestDirectReportRateLevel(sensor: *const ASensor)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASensor_getHandle(sensor: *const ASensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __stop_char: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __lhs: *const ::std::os::raw::c_void,
        __rhs: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __dst: *mut ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_explicit(
        __dst: *mut ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystack_size: usize,
        __needle: *const ::std::os::raw::c_void,
        __needle_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strchr_chk(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strrchr_chk(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __strlen_chk(__s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strcmp(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
        __pos_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(__errno_value: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errno_value: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errno_value: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnlen(__s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strncat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strsignal(__signal: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crash_detail_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn android_set_abort_message(__msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ASharedMemory_create(
        name: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASharedMemory_getSize(fd: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn ASharedMemory_setProt(
        fd: ::std::os::raw::c_int,
        prot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASharedMemory_dupFromJava(
        env: *mut JNIEnv,
        sharedMemory: jobject,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AStorageManager {
    _unused: [u8; 0],
}
pub const AOBB_STATE_MOUNTED: _bindgen_ty_46 = 1;
pub const AOBB_STATE_UNMOUNTED: _bindgen_ty_46 = 2;
pub const AOBB_STATE_ERROR_INTERNAL: _bindgen_ty_46 = 20;
pub const AOBB_STATE_ERROR_COULD_NOT_MOUNT: _bindgen_ty_46 = 21;
pub const AOBB_STATE_ERROR_COULD_NOT_UNMOUNT: _bindgen_ty_46 = 22;
pub const AOBB_STATE_ERROR_NOT_MOUNTED: _bindgen_ty_46 = 23;
pub const AOBB_STATE_ERROR_ALREADY_MOUNTED: _bindgen_ty_46 = 24;
pub const AOBB_STATE_ERROR_PERMISSION_DENIED: _bindgen_ty_46 = 25;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AStorageManager_new() -> *mut AStorageManager;
}
extern "C" {
    pub fn AStorageManager_delete(mgr: *mut AStorageManager);
}
pub type AStorageManager_obbCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filename: *const ::std::os::raw::c_char,
        state: i32,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn AStorageManager_mountObb(
        mgr: *mut AStorageManager,
        filename: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        cb: AStorageManager_obbCallbackFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AStorageManager_unmountObb(
        mgr: *mut AStorageManager,
        filename: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
        cb: AStorageManager_obbCallbackFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AStorageManager_isObbMounted(
        mgr: *mut AStorageManager,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AStorageManager_getMountedObbPath(
        mgr: *mut AStorageManager,
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASurfaceTexture {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ASurfaceTexture_release(st: *mut ASurfaceTexture);
}
extern "C" {
    pub fn ASurfaceTexture_acquireANativeWindow(st: *mut ASurfaceTexture) -> *mut ANativeWindow;
}
extern "C" {
    pub fn ASurfaceTexture_attachToGLContext(
        st: *mut ASurfaceTexture,
        texName: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASurfaceTexture_detachFromGLContext(st: *mut ASurfaceTexture) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASurfaceTexture_updateTexImage(st: *mut ASurfaceTexture) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASurfaceTexture_getTransformMatrix(st: *mut ASurfaceTexture, mtx: *mut f32);
}
extern "C" {
    pub fn ASurfaceTexture_getTimestamp(st: *mut ASurfaceTexture) -> i64;
}
extern "C" {
    pub fn ASurfaceTexture_fromSurfaceTexture(
        env: *mut JNIEnv,
        surfacetexture: jobject,
    ) -> *mut ASurfaceTexture;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_merge_data {
    pub name: [::std::os::raw::c_char; 32usize],
    pub fd2: __s32,
    pub fence: __s32,
    pub flags: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_sync_merge_data() {
    const UNINIT: ::std::mem::MaybeUninit<sync_merge_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sync_merge_data>(),
        48usize,
        concat!("Size of: ", stringify!(sync_merge_data))
    );
    assert_eq!(
        ::std::mem::align_of::<sync_merge_data>(),
        4usize,
        concat!("Alignment of ", stringify!(sync_merge_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_merge_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_merge_data),
            "::",
            stringify!(fd2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_merge_data),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_merge_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_merge_data),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_fence_info {
    pub obj_name: [::std::os::raw::c_char; 32usize],
    pub driver_name: [::std::os::raw::c_char; 32usize],
    pub status: __s32,
    pub flags: __u32,
    pub timestamp_ns: __u64,
}
#[test]
fn bindgen_test_layout_sync_fence_info() {
    const UNINIT: ::std::mem::MaybeUninit<sync_fence_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sync_fence_info>(),
        80usize,
        concat!("Size of: ", stringify!(sync_fence_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sync_fence_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sync_fence_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_fence_info),
            "::",
            stringify!(obj_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_fence_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_fence_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_fence_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_ns) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_fence_info),
            "::",
            stringify!(timestamp_ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_file_info {
    pub name: [::std::os::raw::c_char; 32usize],
    pub status: __s32,
    pub flags: __u32,
    pub num_fences: __u32,
    pub pad: __u32,
    pub sync_fence_info: __u64,
}
#[test]
fn bindgen_test_layout_sync_file_info() {
    const UNINIT: ::std::mem::MaybeUninit<sync_file_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sync_file_info>(),
        56usize,
        concat!("Size of: ", stringify!(sync_file_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sync_file_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sync_file_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_fences) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(num_fences)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync_fence_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_file_info),
            "::",
            stringify!(sync_fence_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_set_deadline {
    pub deadline_ns: __u64,
    pub pad: __u64,
}
#[test]
fn bindgen_test_layout_sync_set_deadline() {
    const UNINIT: ::std::mem::MaybeUninit<sync_set_deadline> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sync_set_deadline>(),
        16usize,
        concat!("Size of: ", stringify!(sync_set_deadline))
    );
    assert_eq!(
        ::std::mem::align_of::<sync_set_deadline>(),
        8usize,
        concat!("Alignment of ", stringify!(sync_set_deadline))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadline_ns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_set_deadline),
            "::",
            stringify!(deadline_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_set_deadline),
            "::",
            stringify!(pad)
        )
    );
}
extern "C" {
    pub fn sync_merge(name: *const ::std::os::raw::c_char, fd1: i32, fd2: i32) -> i32;
}
extern "C" {
    pub fn sync_file_info(fd: i32) -> *mut sync_file_info;
}
extern "C" {
    pub fn sync_file_info_free(info: *mut sync_file_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASystemFontIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ASystemFontIterator_open() -> *mut ASystemFontIterator;
}
extern "C" {
    pub fn ASystemFontIterator_close(iterator: *mut ASystemFontIterator);
}
extern "C" {
    pub fn ASystemFontIterator_next(iterator: *mut ASystemFontIterator) -> *mut AFont;
}
extern "C" {
    pub fn ATrace_isEnabled() -> bool;
}
extern "C" {
    pub fn ATrace_beginSection(sectionName: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ATrace_endSection();
}
extern "C" {
    pub fn ATrace_beginAsyncSection(sectionName: *const ::std::os::raw::c_char, cookie: i32);
}
extern "C" {
    pub fn ATrace_endAsyncSection(sectionName: *const ::std::os::raw::c_char, cookie: i32);
}
extern "C" {
    pub fn ATrace_setCounter(counterName: *const ::std::os::raw::c_char, counterValue: i64);
}
pub const AWINDOW_FLAG_ALLOW_LOCK_WHILE_SCREEN_ON: _bindgen_ty_47 = 1;
pub const AWINDOW_FLAG_DIM_BEHIND: _bindgen_ty_47 = 2;
pub const AWINDOW_FLAG_BLUR_BEHIND: _bindgen_ty_47 = 4;
pub const AWINDOW_FLAG_NOT_FOCUSABLE: _bindgen_ty_47 = 8;
pub const AWINDOW_FLAG_NOT_TOUCHABLE: _bindgen_ty_47 = 16;
pub const AWINDOW_FLAG_NOT_TOUCH_MODAL: _bindgen_ty_47 = 32;
pub const AWINDOW_FLAG_TOUCHABLE_WHEN_WAKING: _bindgen_ty_47 = 64;
pub const AWINDOW_FLAG_KEEP_SCREEN_ON: _bindgen_ty_47 = 128;
pub const AWINDOW_FLAG_LAYOUT_IN_SCREEN: _bindgen_ty_47 = 256;
pub const AWINDOW_FLAG_LAYOUT_NO_LIMITS: _bindgen_ty_47 = 512;
pub const AWINDOW_FLAG_FULLSCREEN: _bindgen_ty_47 = 1024;
pub const AWINDOW_FLAG_FORCE_NOT_FULLSCREEN: _bindgen_ty_47 = 2048;
pub const AWINDOW_FLAG_DITHER: _bindgen_ty_47 = 4096;
pub const AWINDOW_FLAG_SECURE: _bindgen_ty_47 = 8192;
pub const AWINDOW_FLAG_SCALED: _bindgen_ty_47 = 16384;
pub const AWINDOW_FLAG_IGNORE_CHEEK_PRESSES: _bindgen_ty_47 = 32768;
pub const AWINDOW_FLAG_LAYOUT_INSET_DECOR: _bindgen_ty_47 = 65536;
pub const AWINDOW_FLAG_ALT_FOCUSABLE_IM: _bindgen_ty_47 = 131072;
pub const AWINDOW_FLAG_WATCH_OUTSIDE_TOUCH: _bindgen_ty_47 = 262144;
pub const AWINDOW_FLAG_SHOW_WHEN_LOCKED: _bindgen_ty_47 = 524288;
pub const AWINDOW_FLAG_SHOW_WALLPAPER: _bindgen_ty_47 = 1048576;
pub const AWINDOW_FLAG_TURN_SCREEN_ON: _bindgen_ty_47 = 2097152;
pub const AWINDOW_FLAG_DISMISS_KEYGUARD: _bindgen_ty_47 = 4194304;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(
        __which: ::std::os::raw::c_int,
        __current_value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::std::os::raw::c_int,
        __new_value: *const itimerval,
        __old_value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __path: *const ::std::os::raw::c_char,
        __times: *const timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timezone_t {
    _unused: [u8; 0],
}
pub type timezone_t = *mut __timezone_t;
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub fn time(__t: *mut time_t) -> time_t;
}
extern "C" {
    pub fn nanosleep(
        __duration: *const timespec,
        __remainder: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(__tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tm: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(__lhs: time_t, __rhs: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn mktime_z(__tz: timezone_t, __tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn localtime(__t: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__t: *const time_t, __tm: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_rz(__tz: timezone_t, __t: *const time_t, __tm: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn timelocal(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn gmtime(__t: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__t: *const time_t, __tm: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn timegm(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *mut tm,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strftime(
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *const tm,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn ctime(__t: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __t: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn tzalloc(__id: *const ::std::os::raw::c_char) -> timezone_t;
}
extern "C" {
    pub fn tzfree(__tz: timezone_t);
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock: clockid_t, __resolution: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock: clockid_t, __ts: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock: clockid_t,
        __flags: ::std::os::raw::c_int,
        __time: *const timespec,
        __remainder: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock: clockid_t, __ts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock: clockid_t,
        __event: *mut sigevent,
        __timer_ptr: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timer: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timer: timer_t,
        __flags: ::std::os::raw::c_int,
        __new_value: *const itimerspec,
        __old_value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(_timer: timer_t, __ts: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timer: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_getres(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AAUDIO_DIRECTION_OUTPUT: _bindgen_ty_48 = 0;
pub const AAUDIO_DIRECTION_INPUT: _bindgen_ty_48 = 1;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub type aaudio_direction_t = i32;
pub const AAUDIO_FORMAT_INVALID: _bindgen_ty_49 = -1;
pub const AAUDIO_FORMAT_UNSPECIFIED: _bindgen_ty_49 = 0;
pub const AAUDIO_FORMAT_PCM_I16: _bindgen_ty_49 = 1;
pub const AAUDIO_FORMAT_PCM_FLOAT: _bindgen_ty_49 = 2;
pub const AAUDIO_FORMAT_PCM_I24_PACKED: _bindgen_ty_49 = 3;
pub const AAUDIO_FORMAT_PCM_I32: _bindgen_ty_49 = 4;
pub const AAUDIO_FORMAT_IEC61937: _bindgen_ty_49 = 5;
pub type _bindgen_ty_49 = ::std::os::raw::c_int;
pub type aaudio_format_t = i32;
pub const AAUDIO_OK: _bindgen_ty_50 = 0;
pub const AAUDIO_ERROR_BASE: _bindgen_ty_50 = -900;
pub const AAUDIO_ERROR_DISCONNECTED: _bindgen_ty_50 = -899;
pub const AAUDIO_ERROR_ILLEGAL_ARGUMENT: _bindgen_ty_50 = -898;
pub const AAUDIO_ERROR_INTERNAL: _bindgen_ty_50 = -896;
pub const AAUDIO_ERROR_INVALID_STATE: _bindgen_ty_50 = -895;
pub const AAUDIO_ERROR_INVALID_HANDLE: _bindgen_ty_50 = -892;
pub const AAUDIO_ERROR_UNIMPLEMENTED: _bindgen_ty_50 = -890;
pub const AAUDIO_ERROR_UNAVAILABLE: _bindgen_ty_50 = -889;
pub const AAUDIO_ERROR_NO_FREE_HANDLES: _bindgen_ty_50 = -888;
pub const AAUDIO_ERROR_NO_MEMORY: _bindgen_ty_50 = -887;
pub const AAUDIO_ERROR_NULL: _bindgen_ty_50 = -886;
pub const AAUDIO_ERROR_TIMEOUT: _bindgen_ty_50 = -885;
pub const AAUDIO_ERROR_WOULD_BLOCK: _bindgen_ty_50 = -884;
pub const AAUDIO_ERROR_INVALID_FORMAT: _bindgen_ty_50 = -883;
pub const AAUDIO_ERROR_OUT_OF_RANGE: _bindgen_ty_50 = -882;
pub const AAUDIO_ERROR_NO_SERVICE: _bindgen_ty_50 = -881;
pub const AAUDIO_ERROR_INVALID_RATE: _bindgen_ty_50 = -880;
pub type _bindgen_ty_50 = ::std::os::raw::c_int;
pub type aaudio_result_t = i32;
pub const AAUDIO_STREAM_STATE_UNINITIALIZED: _bindgen_ty_51 = 0;
pub const AAUDIO_STREAM_STATE_UNKNOWN: _bindgen_ty_51 = 1;
pub const AAUDIO_STREAM_STATE_OPEN: _bindgen_ty_51 = 2;
pub const AAUDIO_STREAM_STATE_STARTING: _bindgen_ty_51 = 3;
pub const AAUDIO_STREAM_STATE_STARTED: _bindgen_ty_51 = 4;
pub const AAUDIO_STREAM_STATE_PAUSING: _bindgen_ty_51 = 5;
pub const AAUDIO_STREAM_STATE_PAUSED: _bindgen_ty_51 = 6;
pub const AAUDIO_STREAM_STATE_FLUSHING: _bindgen_ty_51 = 7;
pub const AAUDIO_STREAM_STATE_FLUSHED: _bindgen_ty_51 = 8;
pub const AAUDIO_STREAM_STATE_STOPPING: _bindgen_ty_51 = 9;
pub const AAUDIO_STREAM_STATE_STOPPED: _bindgen_ty_51 = 10;
pub const AAUDIO_STREAM_STATE_CLOSING: _bindgen_ty_51 = 11;
pub const AAUDIO_STREAM_STATE_CLOSED: _bindgen_ty_51 = 12;
pub const AAUDIO_STREAM_STATE_DISCONNECTED: _bindgen_ty_51 = 13;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub type aaudio_stream_state_t = i32;
pub const AAUDIO_SHARING_MODE_EXCLUSIVE: _bindgen_ty_52 = 0;
pub const AAUDIO_SHARING_MODE_SHARED: _bindgen_ty_52 = 1;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub type aaudio_sharing_mode_t = i32;
pub const AAUDIO_PERFORMANCE_MODE_NONE: _bindgen_ty_53 = 10;
pub const AAUDIO_PERFORMANCE_MODE_POWER_SAVING: _bindgen_ty_53 = 11;
pub const AAUDIO_PERFORMANCE_MODE_LOW_LATENCY: _bindgen_ty_53 = 12;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub type aaudio_performance_mode_t = i32;
pub const AAUDIO_USAGE_MEDIA: _bindgen_ty_54 = 1;
pub const AAUDIO_USAGE_VOICE_COMMUNICATION: _bindgen_ty_54 = 2;
pub const AAUDIO_USAGE_VOICE_COMMUNICATION_SIGNALLING: _bindgen_ty_54 = 3;
pub const AAUDIO_USAGE_ALARM: _bindgen_ty_54 = 4;
pub const AAUDIO_USAGE_NOTIFICATION: _bindgen_ty_54 = 5;
pub const AAUDIO_USAGE_NOTIFICATION_RINGTONE: _bindgen_ty_54 = 6;
pub const AAUDIO_USAGE_NOTIFICATION_EVENT: _bindgen_ty_54 = 10;
pub const AAUDIO_USAGE_ASSISTANCE_ACCESSIBILITY: _bindgen_ty_54 = 11;
pub const AAUDIO_USAGE_ASSISTANCE_NAVIGATION_GUIDANCE: _bindgen_ty_54 = 12;
pub const AAUDIO_USAGE_ASSISTANCE_SONIFICATION: _bindgen_ty_54 = 13;
pub const AAUDIO_USAGE_GAME: _bindgen_ty_54 = 14;
pub const AAUDIO_USAGE_ASSISTANT: _bindgen_ty_54 = 16;
pub const AAUDIO_SYSTEM_USAGE_EMERGENCY: _bindgen_ty_54 = 1000;
pub const AAUDIO_SYSTEM_USAGE_SAFETY: _bindgen_ty_54 = 1001;
pub const AAUDIO_SYSTEM_USAGE_VEHICLE_STATUS: _bindgen_ty_54 = 1002;
pub const AAUDIO_SYSTEM_USAGE_ANNOUNCEMENT: _bindgen_ty_54 = 1003;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub type aaudio_usage_t = i32;
pub const AAUDIO_CONTENT_TYPE_SPEECH: _bindgen_ty_55 = 1;
pub const AAUDIO_CONTENT_TYPE_MUSIC: _bindgen_ty_55 = 2;
pub const AAUDIO_CONTENT_TYPE_MOVIE: _bindgen_ty_55 = 3;
pub const AAUDIO_CONTENT_TYPE_SONIFICATION: _bindgen_ty_55 = 4;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub type aaudio_content_type_t = i32;
pub const AAUDIO_SPATIALIZATION_BEHAVIOR_AUTO: _bindgen_ty_56 = 1;
pub const AAUDIO_SPATIALIZATION_BEHAVIOR_NEVER: _bindgen_ty_56 = 2;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub type aaudio_spatialization_behavior_t = i32;
pub const AAUDIO_INPUT_PRESET_GENERIC: _bindgen_ty_57 = 1;
pub const AAUDIO_INPUT_PRESET_CAMCORDER: _bindgen_ty_57 = 5;
pub const AAUDIO_INPUT_PRESET_VOICE_RECOGNITION: _bindgen_ty_57 = 6;
pub const AAUDIO_INPUT_PRESET_VOICE_COMMUNICATION: _bindgen_ty_57 = 7;
pub const AAUDIO_INPUT_PRESET_UNPROCESSED: _bindgen_ty_57 = 9;
pub const AAUDIO_INPUT_PRESET_VOICE_PERFORMANCE: _bindgen_ty_57 = 10;
pub const AAUDIO_INPUT_PRESET_SYSTEM_ECHO_REFERENCE: _bindgen_ty_57 = 1997;
pub const AAUDIO_INPUT_PRESET_SYSTEM_HOTWORD: _bindgen_ty_57 = 1999;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub type aaudio_input_preset_t = i32;
pub const AAUDIO_ALLOW_CAPTURE_BY_ALL: _bindgen_ty_58 = 1;
pub const AAUDIO_ALLOW_CAPTURE_BY_SYSTEM: _bindgen_ty_58 = 2;
pub const AAUDIO_ALLOW_CAPTURE_BY_NONE: _bindgen_ty_58 = 3;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub type aaudio_allowed_capture_policy_t = i32;
pub const AAUDIO_SESSION_ID_NONE: _bindgen_ty_59 = -1;
pub const AAUDIO_SESSION_ID_ALLOCATE: _bindgen_ty_59 = 0;
pub type _bindgen_ty_59 = ::std::os::raw::c_int;
pub type aaudio_session_id_t = i32;
pub const AAUDIO_CHANNEL_INVALID: _bindgen_ty_60 = -1;
pub const AAUDIO_CHANNEL_FRONT_LEFT: _bindgen_ty_60 = 1;
pub const AAUDIO_CHANNEL_FRONT_RIGHT: _bindgen_ty_60 = 2;
pub const AAUDIO_CHANNEL_FRONT_CENTER: _bindgen_ty_60 = 4;
pub const AAUDIO_CHANNEL_LOW_FREQUENCY: _bindgen_ty_60 = 8;
pub const AAUDIO_CHANNEL_BACK_LEFT: _bindgen_ty_60 = 16;
pub const AAUDIO_CHANNEL_BACK_RIGHT: _bindgen_ty_60 = 32;
pub const AAUDIO_CHANNEL_FRONT_LEFT_OF_CENTER: _bindgen_ty_60 = 64;
pub const AAUDIO_CHANNEL_FRONT_RIGHT_OF_CENTER: _bindgen_ty_60 = 128;
pub const AAUDIO_CHANNEL_BACK_CENTER: _bindgen_ty_60 = 256;
pub const AAUDIO_CHANNEL_SIDE_LEFT: _bindgen_ty_60 = 512;
pub const AAUDIO_CHANNEL_SIDE_RIGHT: _bindgen_ty_60 = 1024;
pub const AAUDIO_CHANNEL_TOP_CENTER: _bindgen_ty_60 = 2048;
pub const AAUDIO_CHANNEL_TOP_FRONT_LEFT: _bindgen_ty_60 = 4096;
pub const AAUDIO_CHANNEL_TOP_FRONT_CENTER: _bindgen_ty_60 = 8192;
pub const AAUDIO_CHANNEL_TOP_FRONT_RIGHT: _bindgen_ty_60 = 16384;
pub const AAUDIO_CHANNEL_TOP_BACK_LEFT: _bindgen_ty_60 = 32768;
pub const AAUDIO_CHANNEL_TOP_BACK_CENTER: _bindgen_ty_60 = 65536;
pub const AAUDIO_CHANNEL_TOP_BACK_RIGHT: _bindgen_ty_60 = 131072;
pub const AAUDIO_CHANNEL_TOP_SIDE_LEFT: _bindgen_ty_60 = 262144;
pub const AAUDIO_CHANNEL_TOP_SIDE_RIGHT: _bindgen_ty_60 = 524288;
pub const AAUDIO_CHANNEL_BOTTOM_FRONT_LEFT: _bindgen_ty_60 = 1048576;
pub const AAUDIO_CHANNEL_BOTTOM_FRONT_CENTER: _bindgen_ty_60 = 2097152;
pub const AAUDIO_CHANNEL_BOTTOM_FRONT_RIGHT: _bindgen_ty_60 = 4194304;
pub const AAUDIO_CHANNEL_LOW_FREQUENCY_2: _bindgen_ty_60 = 8388608;
pub const AAUDIO_CHANNEL_FRONT_WIDE_LEFT: _bindgen_ty_60 = 16777216;
pub const AAUDIO_CHANNEL_FRONT_WIDE_RIGHT: _bindgen_ty_60 = 33554432;
pub const AAUDIO_CHANNEL_MONO: _bindgen_ty_60 = 1;
pub const AAUDIO_CHANNEL_STEREO: _bindgen_ty_60 = 3;
pub const AAUDIO_CHANNEL_2POINT1: _bindgen_ty_60 = 11;
pub const AAUDIO_CHANNEL_TRI: _bindgen_ty_60 = 7;
pub const AAUDIO_CHANNEL_TRI_BACK: _bindgen_ty_60 = 259;
pub const AAUDIO_CHANNEL_3POINT1: _bindgen_ty_60 = 15;
pub const AAUDIO_CHANNEL_2POINT0POINT2: _bindgen_ty_60 = 786435;
pub const AAUDIO_CHANNEL_2POINT1POINT2: _bindgen_ty_60 = 786443;
pub const AAUDIO_CHANNEL_3POINT0POINT2: _bindgen_ty_60 = 786439;
pub const AAUDIO_CHANNEL_3POINT1POINT2: _bindgen_ty_60 = 786447;
pub const AAUDIO_CHANNEL_QUAD: _bindgen_ty_60 = 51;
pub const AAUDIO_CHANNEL_QUAD_SIDE: _bindgen_ty_60 = 1539;
pub const AAUDIO_CHANNEL_SURROUND: _bindgen_ty_60 = 263;
pub const AAUDIO_CHANNEL_PENTA: _bindgen_ty_60 = 55;
pub const AAUDIO_CHANNEL_5POINT1: _bindgen_ty_60 = 63;
pub const AAUDIO_CHANNEL_5POINT1_SIDE: _bindgen_ty_60 = 1551;
pub const AAUDIO_CHANNEL_6POINT1: _bindgen_ty_60 = 319;
pub const AAUDIO_CHANNEL_7POINT1: _bindgen_ty_60 = 1599;
pub const AAUDIO_CHANNEL_5POINT1POINT2: _bindgen_ty_60 = 786495;
pub const AAUDIO_CHANNEL_5POINT1POINT4: _bindgen_ty_60 = 184383;
pub const AAUDIO_CHANNEL_7POINT1POINT2: _bindgen_ty_60 = 788031;
pub const AAUDIO_CHANNEL_7POINT1POINT4: _bindgen_ty_60 = 185919;
pub const AAUDIO_CHANNEL_9POINT1POINT4: _bindgen_ty_60 = 50517567;
pub const AAUDIO_CHANNEL_9POINT1POINT6: _bindgen_ty_60 = 51303999;
pub const AAUDIO_CHANNEL_FRONT_BACK: _bindgen_ty_60 = 260;
pub type _bindgen_ty_60 = ::std::os::raw::c_int;
pub type aaudio_channel_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAudioStreamStruct {
    _unused: [u8; 0],
}
pub type AAudioStream = AAudioStreamStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AAudioStreamBuilderStruct {
    _unused: [u8; 0],
}
pub type AAudioStreamBuilder = AAudioStreamBuilderStruct;
extern "C" {
    pub fn AAudio_convertResultToText(returnCode: aaudio_result_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AAudio_convertStreamStateToText(
        state: aaudio_stream_state_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AAudio_createStreamBuilder(builder: *mut *mut AAudioStreamBuilder) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStreamBuilder_setDeviceId(builder: *mut AAudioStreamBuilder, deviceId: i32);
}
extern "C" {
    pub fn AAudioStreamBuilder_setPackageName(
        builder: *mut AAudioStreamBuilder,
        packageName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setAttributionTag(
        builder: *mut AAudioStreamBuilder,
        attributionTag: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setSampleRate(builder: *mut AAudioStreamBuilder, sampleRate: i32);
}
extern "C" {
    pub fn AAudioStreamBuilder_setChannelCount(
        builder: *mut AAudioStreamBuilder,
        channelCount: i32,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setSamplesPerFrame(
        builder: *mut AAudioStreamBuilder,
        samplesPerFrame: i32,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setFormat(
        builder: *mut AAudioStreamBuilder,
        format: aaudio_format_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setSharingMode(
        builder: *mut AAudioStreamBuilder,
        sharingMode: aaudio_sharing_mode_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setDirection(
        builder: *mut AAudioStreamBuilder,
        direction: aaudio_direction_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setBufferCapacityInFrames(
        builder: *mut AAudioStreamBuilder,
        numFrames: i32,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setPerformanceMode(
        builder: *mut AAudioStreamBuilder,
        mode: aaudio_performance_mode_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setUsage(builder: *mut AAudioStreamBuilder, usage: aaudio_usage_t);
}
extern "C" {
    pub fn AAudioStreamBuilder_setContentType(
        builder: *mut AAudioStreamBuilder,
        contentType: aaudio_content_type_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setSpatializationBehavior(
        builder: *mut AAudioStreamBuilder,
        spatializationBehavior: aaudio_spatialization_behavior_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setIsContentSpatialized(
        builder: *mut AAudioStreamBuilder,
        isSpatialized: bool,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setInputPreset(
        builder: *mut AAudioStreamBuilder,
        inputPreset: aaudio_input_preset_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setAllowedCapturePolicy(
        builder: *mut AAudioStreamBuilder,
        capturePolicy: aaudio_allowed_capture_policy_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setSessionId(
        builder: *mut AAudioStreamBuilder,
        sessionId: aaudio_session_id_t,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setPrivacySensitive(
        builder: *mut AAudioStreamBuilder,
        privacySensitive: bool,
    );
}
pub const AAUDIO_CALLBACK_RESULT_CONTINUE: _bindgen_ty_61 = 0;
pub const AAUDIO_CALLBACK_RESULT_STOP: _bindgen_ty_61 = 1;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub type aaudio_data_callback_result_t = i32;
pub type AAudioStream_dataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut AAudioStream,
        userData: *mut ::std::os::raw::c_void,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: i32,
    ) -> aaudio_data_callback_result_t,
>;
extern "C" {
    pub fn AAudioStreamBuilder_setDataCallback(
        builder: *mut AAudioStreamBuilder,
        callback: AAudioStream_dataCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_setFramesPerDataCallback(
        builder: *mut AAudioStreamBuilder,
        numFrames: i32,
    );
}
pub type AAudioStream_errorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut AAudioStream,
        userData: *mut ::std::os::raw::c_void,
        error: aaudio_result_t,
    ),
>;
extern "C" {
    pub fn AAudioStreamBuilder_setErrorCallback(
        builder: *mut AAudioStreamBuilder,
        callback: AAudioStream_errorCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AAudioStreamBuilder_openStream(
        builder: *mut AAudioStreamBuilder,
        stream: *mut *mut AAudioStream,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStreamBuilder_delete(builder: *mut AAudioStreamBuilder) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStreamBuilder_setChannelMask(
        builder: *mut AAudioStreamBuilder,
        channelMask: aaudio_channel_mask_t,
    );
}
extern "C" {
    pub fn AAudioStream_release(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_close(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_requestStart(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_requestPause(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_requestFlush(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_requestStop(stream: *mut AAudioStream) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_getState(stream: *mut AAudioStream) -> aaudio_stream_state_t;
}
extern "C" {
    pub fn AAudioStream_waitForStateChange(
        stream: *mut AAudioStream,
        inputState: aaudio_stream_state_t,
        nextState: *mut aaudio_stream_state_t,
        timeoutNanoseconds: i64,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_read(
        stream: *mut AAudioStream,
        buffer: *mut ::std::os::raw::c_void,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_write(
        stream: *mut AAudioStream,
        buffer: *const ::std::os::raw::c_void,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_setBufferSizeInFrames(
        stream: *mut AAudioStream,
        numFrames: i32,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_getBufferSizeInFrames(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getFramesPerBurst(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getBufferCapacityInFrames(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getFramesPerDataCallback(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getXRunCount(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getSampleRate(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getHardwareSampleRate(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getChannelCount(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getHardwareChannelCount(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getSamplesPerFrame(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getDeviceId(stream: *mut AAudioStream) -> i32;
}
extern "C" {
    pub fn AAudioStream_getFormat(stream: *mut AAudioStream) -> aaudio_format_t;
}
extern "C" {
    pub fn AAudioStream_getHardwareFormat(stream: *mut AAudioStream) -> aaudio_format_t;
}
extern "C" {
    pub fn AAudioStream_getSharingMode(stream: *mut AAudioStream) -> aaudio_sharing_mode_t;
}
extern "C" {
    pub fn AAudioStream_getPerformanceMode(stream: *mut AAudioStream) -> aaudio_performance_mode_t;
}
extern "C" {
    pub fn AAudioStream_getDirection(stream: *mut AAudioStream) -> aaudio_direction_t;
}
extern "C" {
    pub fn AAudioStream_getFramesWritten(stream: *mut AAudioStream) -> i64;
}
extern "C" {
    pub fn AAudioStream_getFramesRead(stream: *mut AAudioStream) -> i64;
}
extern "C" {
    pub fn AAudioStream_getSessionId(stream: *mut AAudioStream) -> aaudio_session_id_t;
}
extern "C" {
    pub fn AAudioStream_getTimestamp(
        stream: *mut AAudioStream,
        clockid: clockid_t,
        framePosition: *mut i64,
        timeNanoseconds: *mut i64,
    ) -> aaudio_result_t;
}
extern "C" {
    pub fn AAudioStream_getUsage(stream: *mut AAudioStream) -> aaudio_usage_t;
}
extern "C" {
    pub fn AAudioStream_getContentType(stream: *mut AAudioStream) -> aaudio_content_type_t;
}
extern "C" {
    pub fn AAudioStream_getSpatializationBehavior(
        stream: *mut AAudioStream,
    ) -> aaudio_spatialization_behavior_t;
}
extern "C" {
    pub fn AAudioStream_isContentSpatialized(stream: *mut AAudioStream) -> bool;
}
extern "C" {
    pub fn AAudioStream_getInputPreset(stream: *mut AAudioStream) -> aaudio_input_preset_t;
}
extern "C" {
    pub fn AAudioStream_getAllowedCapturePolicy(
        stream: *mut AAudioStream,
    ) -> aaudio_allowed_capture_policy_t;
}
extern "C" {
    pub fn AAudioStream_isPrivacySensitive(stream: *mut AAudioStream) -> bool;
}
extern "C" {
    pub fn AAudioStream_getChannelMask(stream: *mut AAudioStream) -> aaudio_channel_mask_t;
}
impl media_status_t {
    pub const AMEDIA_OK: media_status_t = media_status_t(0);
}
impl media_status_t {
    pub const AMEDIACODEC_ERROR_INSUFFICIENT_RESOURCE: media_status_t = media_status_t(1100);
}
impl media_status_t {
    pub const AMEDIACODEC_ERROR_RECLAIMED: media_status_t = media_status_t(1101);
}
impl media_status_t {
    pub const AMEDIA_ERROR_BASE: media_status_t = media_status_t(-10000);
}
impl media_status_t {
    pub const AMEDIA_ERROR_UNKNOWN: media_status_t = media_status_t(-10000);
}
impl media_status_t {
    pub const AMEDIA_ERROR_MALFORMED: media_status_t = media_status_t(-10001);
}
impl media_status_t {
    pub const AMEDIA_ERROR_UNSUPPORTED: media_status_t = media_status_t(-10002);
}
impl media_status_t {
    pub const AMEDIA_ERROR_INVALID_OBJECT: media_status_t = media_status_t(-10003);
}
impl media_status_t {
    pub const AMEDIA_ERROR_INVALID_PARAMETER: media_status_t = media_status_t(-10004);
}
impl media_status_t {
    pub const AMEDIA_ERROR_INVALID_OPERATION: media_status_t = media_status_t(-10005);
}
impl media_status_t {
    pub const AMEDIA_ERROR_END_OF_STREAM: media_status_t = media_status_t(-10006);
}
impl media_status_t {
    pub const AMEDIA_ERROR_IO: media_status_t = media_status_t(-10007);
}
impl media_status_t {
    pub const AMEDIA_ERROR_WOULD_BLOCK: media_status_t = media_status_t(-10008);
}
impl media_status_t {
    pub const AMEDIA_DRM_ERROR_BASE: media_status_t = media_status_t(-20000);
}
impl media_status_t {
    pub const AMEDIA_DRM_NOT_PROVISIONED: media_status_t = media_status_t(-20001);
}
impl media_status_t {
    pub const AMEDIA_DRM_RESOURCE_BUSY: media_status_t = media_status_t(-20002);
}
impl media_status_t {
    pub const AMEDIA_DRM_DEVICE_REVOKED: media_status_t = media_status_t(-20003);
}
impl media_status_t {
    pub const AMEDIA_DRM_SHORT_BUFFER: media_status_t = media_status_t(-20004);
}
impl media_status_t {
    pub const AMEDIA_DRM_SESSION_NOT_OPENED: media_status_t = media_status_t(-20005);
}
impl media_status_t {
    pub const AMEDIA_DRM_TAMPER_DETECTED: media_status_t = media_status_t(-20006);
}
impl media_status_t {
    pub const AMEDIA_DRM_VERIFY_FAILED: media_status_t = media_status_t(-20007);
}
impl media_status_t {
    pub const AMEDIA_DRM_NEED_KEY: media_status_t = media_status_t(-20008);
}
impl media_status_t {
    pub const AMEDIA_DRM_LICENSE_EXPIRED: media_status_t = media_status_t(-20009);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_ERROR_BASE: media_status_t = media_status_t(-30000);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_NO_BUFFER_AVAILABLE: media_status_t = media_status_t(-30001);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_MAX_IMAGES_ACQUIRED: media_status_t = media_status_t(-30002);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_CANNOT_LOCK_IMAGE: media_status_t = media_status_t(-30003);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_CANNOT_UNLOCK_IMAGE: media_status_t = media_status_t(-30004);
}
impl media_status_t {
    pub const AMEDIA_IMGREADER_IMAGE_NOT_LOCKED: media_status_t = media_status_t(-30005);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct media_status_t(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMidiDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMidiInputPort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMidiOutputPort {
    _unused: [u8; 0],
}
pub const AMIDI_OPCODE_DATA: _bindgen_ty_62 = 1;
pub const AMIDI_OPCODE_FLUSH: _bindgen_ty_62 = 2;
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub const AMIDI_DEVICE_TYPE_USB: _bindgen_ty_63 = 1;
pub const AMIDI_DEVICE_TYPE_VIRTUAL: _bindgen_ty_63 = 2;
pub const AMIDI_DEVICE_TYPE_BLUETOOTH: _bindgen_ty_63 = 3;
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_USE_MIDI_CI: AMidiDevice_Protocol = AMidiDevice_Protocol(0);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_1_0_UP_TO_64_BITS: AMidiDevice_Protocol =
        AMidiDevice_Protocol(1);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_1_0_UP_TO_64_BITS_AND_JRTS: AMidiDevice_Protocol =
        AMidiDevice_Protocol(2);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_1_0_UP_TO_128_BITS: AMidiDevice_Protocol =
        AMidiDevice_Protocol(3);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_1_0_UP_TO_128_BITS_AND_JRTS: AMidiDevice_Protocol =
        AMidiDevice_Protocol(4);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_2_0: AMidiDevice_Protocol = AMidiDevice_Protocol(17);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UMP_MIDI_2_0_AND_JRTS: AMidiDevice_Protocol =
        AMidiDevice_Protocol(18);
}
impl AMidiDevice_Protocol {
    pub const AMIDI_DEVICE_PROTOCOL_UNKNOWN: AMidiDevice_Protocol = AMidiDevice_Protocol(-1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMidiDevice_Protocol(pub i32);
extern "C" {
    pub fn AMidiDevice_fromJava(
        env: *mut JNIEnv,
        midiDeviceObj: jobject,
        outDevicePtrPtr: *mut *mut AMidiDevice,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMidiDevice_release(midiDevice: *const AMidiDevice) -> media_status_t;
}
extern "C" {
    pub fn AMidiDevice_getType(device: *const AMidiDevice) -> i32;
}
extern "C" {
    pub fn AMidiDevice_getNumInputPorts(device: *const AMidiDevice) -> isize;
}
extern "C" {
    pub fn AMidiDevice_getNumOutputPorts(device: *const AMidiDevice) -> isize;
}
extern "C" {
    pub fn AMidiDevice_getDefaultProtocol(device: *const AMidiDevice) -> AMidiDevice_Protocol;
}
extern "C" {
    pub fn AMidiOutputPort_open(
        device: *const AMidiDevice,
        portNumber: i32,
        outOutputPortPtr: *mut *mut AMidiOutputPort,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMidiOutputPort_close(outputPort: *const AMidiOutputPort);
}
extern "C" {
    pub fn AMidiOutputPort_receive(
        outputPort: *const AMidiOutputPort,
        opcodePtr: *mut i32,
        buffer: *mut u8,
        maxBytes: usize,
        numBytesReceivedPtr: *mut usize,
        outTimestampPtr: *mut i64,
    ) -> isize;
}
extern "C" {
    pub fn AMidiInputPort_open(
        device: *const AMidiDevice,
        portNumber: i32,
        outInputPortPtr: *mut *mut AMidiInputPort,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMidiInputPort_send(
        inputPort: *const AMidiInputPort,
        buffer: *const u8,
        numBytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn AMidiInputPort_sendWithTimestamp(
        inputPort: *const AMidiInputPort,
        buffer: *const u8,
        numBytes: usize,
        timestamp: i64,
    ) -> isize;
}
extern "C" {
    pub fn AMidiInputPort_sendFlush(inputPort: *const AMidiInputPort) -> media_status_t;
}
extern "C" {
    pub fn AMidiInputPort_close(inputPort: *const AMidiInputPort);
}
impl camera_status_t {
    pub const ACAMERA_OK: camera_status_t = camera_status_t(0);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_BASE: camera_status_t = camera_status_t(-10000);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_UNKNOWN: camera_status_t = camera_status_t(-10000);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_INVALID_PARAMETER: camera_status_t = camera_status_t(-10001);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_CAMERA_DISCONNECTED: camera_status_t = camera_status_t(-10002);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_NOT_ENOUGH_MEMORY: camera_status_t = camera_status_t(-10003);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_METADATA_NOT_FOUND: camera_status_t = camera_status_t(-10004);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_CAMERA_DEVICE: camera_status_t = camera_status_t(-10005);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_CAMERA_SERVICE: camera_status_t = camera_status_t(-10006);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_SESSION_CLOSED: camera_status_t = camera_status_t(-10007);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_INVALID_OPERATION: camera_status_t = camera_status_t(-10008);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_STREAM_CONFIGURE_FAIL: camera_status_t = camera_status_t(-10009);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_CAMERA_IN_USE: camera_status_t = camera_status_t(-10010);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_MAX_CAMERA_IN_USE: camera_status_t = camera_status_t(-10011);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_CAMERA_DISABLED: camera_status_t = camera_status_t(-10012);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_PERMISSION_DENIED: camera_status_t = camera_status_t(-10013);
}
impl camera_status_t {
    pub const ACAMERA_ERROR_UNSUPPORTED_OPERATION: camera_status_t = camera_status_t(-10014);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct camera_status_t(pub ::std::os::raw::c_int);
impl acamera_metadata_section {
    pub const ACAMERA_COLOR_CORRECTION: acamera_metadata_section = acamera_metadata_section(0);
}
impl acamera_metadata_section {
    pub const ACAMERA_CONTROL: acamera_metadata_section = acamera_metadata_section(1);
}
impl acamera_metadata_section {
    pub const ACAMERA_DEMOSAIC: acamera_metadata_section = acamera_metadata_section(2);
}
impl acamera_metadata_section {
    pub const ACAMERA_EDGE: acamera_metadata_section = acamera_metadata_section(3);
}
impl acamera_metadata_section {
    pub const ACAMERA_FLASH: acamera_metadata_section = acamera_metadata_section(4);
}
impl acamera_metadata_section {
    pub const ACAMERA_FLASH_INFO: acamera_metadata_section = acamera_metadata_section(5);
}
impl acamera_metadata_section {
    pub const ACAMERA_HOT_PIXEL: acamera_metadata_section = acamera_metadata_section(6);
}
impl acamera_metadata_section {
    pub const ACAMERA_JPEG: acamera_metadata_section = acamera_metadata_section(7);
}
impl acamera_metadata_section {
    pub const ACAMERA_LENS: acamera_metadata_section = acamera_metadata_section(8);
}
impl acamera_metadata_section {
    pub const ACAMERA_LENS_INFO: acamera_metadata_section = acamera_metadata_section(9);
}
impl acamera_metadata_section {
    pub const ACAMERA_NOISE_REDUCTION: acamera_metadata_section = acamera_metadata_section(10);
}
impl acamera_metadata_section {
    pub const ACAMERA_QUIRKS: acamera_metadata_section = acamera_metadata_section(11);
}
impl acamera_metadata_section {
    pub const ACAMERA_REQUEST: acamera_metadata_section = acamera_metadata_section(12);
}
impl acamera_metadata_section {
    pub const ACAMERA_SCALER: acamera_metadata_section = acamera_metadata_section(13);
}
impl acamera_metadata_section {
    pub const ACAMERA_SENSOR: acamera_metadata_section = acamera_metadata_section(14);
}
impl acamera_metadata_section {
    pub const ACAMERA_SENSOR_INFO: acamera_metadata_section = acamera_metadata_section(15);
}
impl acamera_metadata_section {
    pub const ACAMERA_SHADING: acamera_metadata_section = acamera_metadata_section(16);
}
impl acamera_metadata_section {
    pub const ACAMERA_STATISTICS: acamera_metadata_section = acamera_metadata_section(17);
}
impl acamera_metadata_section {
    pub const ACAMERA_STATISTICS_INFO: acamera_metadata_section = acamera_metadata_section(18);
}
impl acamera_metadata_section {
    pub const ACAMERA_TONEMAP: acamera_metadata_section = acamera_metadata_section(19);
}
impl acamera_metadata_section {
    pub const ACAMERA_LED: acamera_metadata_section = acamera_metadata_section(20);
}
impl acamera_metadata_section {
    pub const ACAMERA_INFO: acamera_metadata_section = acamera_metadata_section(21);
}
impl acamera_metadata_section {
    pub const ACAMERA_BLACK_LEVEL: acamera_metadata_section = acamera_metadata_section(22);
}
impl acamera_metadata_section {
    pub const ACAMERA_SYNC: acamera_metadata_section = acamera_metadata_section(23);
}
impl acamera_metadata_section {
    pub const ACAMERA_REPROCESS: acamera_metadata_section = acamera_metadata_section(24);
}
impl acamera_metadata_section {
    pub const ACAMERA_DEPTH: acamera_metadata_section = acamera_metadata_section(25);
}
impl acamera_metadata_section {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA: acamera_metadata_section = acamera_metadata_section(26);
}
impl acamera_metadata_section {
    pub const ACAMERA_DISTORTION_CORRECTION: acamera_metadata_section =
        acamera_metadata_section(27);
}
impl acamera_metadata_section {
    pub const ACAMERA_HEIC: acamera_metadata_section = acamera_metadata_section(28);
}
impl acamera_metadata_section {
    pub const ACAMERA_HEIC_INFO: acamera_metadata_section = acamera_metadata_section(29);
}
impl acamera_metadata_section {
    pub const ACAMERA_AUTOMOTIVE: acamera_metadata_section = acamera_metadata_section(30);
}
impl acamera_metadata_section {
    pub const ACAMERA_AUTOMOTIVE_LENS: acamera_metadata_section = acamera_metadata_section(31);
}
impl acamera_metadata_section {
    pub const ACAMERA_EXTENSION: acamera_metadata_section = acamera_metadata_section(32);
}
impl acamera_metadata_section {
    pub const ACAMERA_JPEGR: acamera_metadata_section = acamera_metadata_section(33);
}
impl acamera_metadata_section {
    pub const ACAMERA_SECTION_COUNT: acamera_metadata_section = acamera_metadata_section(34);
}
impl acamera_metadata_section {
    pub const ACAMERA_VENDOR: acamera_metadata_section = acamera_metadata_section(32768);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_section(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_section as acamera_metadata_section_t;
impl acamera_metadata_section_start {
    pub const ACAMERA_COLOR_CORRECTION_START: acamera_metadata_section_start =
        acamera_metadata_section_start(0);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_CONTROL_START: acamera_metadata_section_start =
        acamera_metadata_section_start(65536);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_DEMOSAIC_START: acamera_metadata_section_start =
        acamera_metadata_section_start(131072);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_EDGE_START: acamera_metadata_section_start =
        acamera_metadata_section_start(196608);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_FLASH_START: acamera_metadata_section_start =
        acamera_metadata_section_start(262144);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_FLASH_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(327680);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_HOT_PIXEL_START: acamera_metadata_section_start =
        acamera_metadata_section_start(393216);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_JPEG_START: acamera_metadata_section_start =
        acamera_metadata_section_start(458752);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_LENS_START: acamera_metadata_section_start =
        acamera_metadata_section_start(524288);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_LENS_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(589824);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_NOISE_REDUCTION_START: acamera_metadata_section_start =
        acamera_metadata_section_start(655360);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_QUIRKS_START: acamera_metadata_section_start =
        acamera_metadata_section_start(720896);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_REQUEST_START: acamera_metadata_section_start =
        acamera_metadata_section_start(786432);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_SCALER_START: acamera_metadata_section_start =
        acamera_metadata_section_start(851968);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_SENSOR_START: acamera_metadata_section_start =
        acamera_metadata_section_start(917504);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_SENSOR_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(983040);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_SHADING_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1048576);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_STATISTICS_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1114112);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_STATISTICS_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1179648);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_TONEMAP_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1245184);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_LED_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1310720);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1376256);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_BLACK_LEVEL_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1441792);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_SYNC_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1507328);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_REPROCESS_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1572864);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_DEPTH_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1638400);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1703936);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_DISTORTION_CORRECTION_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1769472);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_HEIC_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1835008);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_HEIC_INFO_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1900544);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_AUTOMOTIVE_START: acamera_metadata_section_start =
        acamera_metadata_section_start(1966080);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_AUTOMOTIVE_LENS_START: acamera_metadata_section_start =
        acamera_metadata_section_start(2031616);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_EXTENSION_START: acamera_metadata_section_start =
        acamera_metadata_section_start(2097152);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_JPEGR_START: acamera_metadata_section_start =
        acamera_metadata_section_start(2162688);
}
impl acamera_metadata_section_start {
    pub const ACAMERA_VENDOR_START: acamera_metadata_section_start =
        acamera_metadata_section_start(-2147483648);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_section_start(pub ::std::os::raw::c_int);
pub use self::acamera_metadata_section_start as acamera_metadata_section_start_t;
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_MODE: acamera_metadata_tag = acamera_metadata_tag(0);
}
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_TRANSFORM: acamera_metadata_tag = acamera_metadata_tag(1);
}
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_GAINS: acamera_metadata_tag = acamera_metadata_tag(2);
}
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_ABERRATION_MODE: acamera_metadata_tag =
        acamera_metadata_tag(3);
}
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES: acamera_metadata_tag =
        acamera_metadata_tag(4);
}
impl acamera_metadata_tag {
    pub const ACAMERA_COLOR_CORRECTION_END: acamera_metadata_tag = acamera_metadata_tag(5);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_ANTIBANDING_MODE: acamera_metadata_tag =
        acamera_metadata_tag(65536);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION: acamera_metadata_tag =
        acamera_metadata_tag(65537);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_LOCK: acamera_metadata_tag = acamera_metadata_tag(65538);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_MODE: acamera_metadata_tag = acamera_metadata_tag(65539);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_REGIONS: acamera_metadata_tag = acamera_metadata_tag(65540);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_TARGET_FPS_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(65541);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER: acamera_metadata_tag =
        acamera_metadata_tag(65542);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_MODE: acamera_metadata_tag = acamera_metadata_tag(65543);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_REGIONS: acamera_metadata_tag = acamera_metadata_tag(65544);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_TRIGGER: acamera_metadata_tag = acamera_metadata_tag(65545);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_LOCK: acamera_metadata_tag = acamera_metadata_tag(65546);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_MODE: acamera_metadata_tag = acamera_metadata_tag(65547);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_REGIONS: acamera_metadata_tag = acamera_metadata_tag(65548);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT: acamera_metadata_tag = acamera_metadata_tag(65549);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_EFFECT_MODE: acamera_metadata_tag = acamera_metadata_tag(65550);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_MODE: acamera_metadata_tag = acamera_metadata_tag(65551);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_SCENE_MODE: acamera_metadata_tag = acamera_metadata_tag(65552);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE: acamera_metadata_tag =
        acamera_metadata_tag(65553);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65554);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_AVAILABLE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65555);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES: acamera_metadata_tag =
        acamera_metadata_tag(65556);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_COMPENSATION_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(65557);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_COMPENSATION_STEP: acamera_metadata_tag =
        acamera_metadata_tag(65558);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_AVAILABLE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65559);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_EFFECTS: acamera_metadata_tag = acamera_metadata_tag(65560);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_SCENE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65561);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65562);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_AVAILABLE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(65563);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_MAX_REGIONS: acamera_metadata_tag = acamera_metadata_tag(65564);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_STATE: acamera_metadata_tag = acamera_metadata_tag(65567);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_STATE: acamera_metadata_tag = acamera_metadata_tag(65568);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_STATE: acamera_metadata_tag = acamera_metadata_tag(65570);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AE_LOCK_AVAILABLE: acamera_metadata_tag = acamera_metadata_tag(65572);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AWB_LOCK_AVAILABLE: acamera_metadata_tag =
        acamera_metadata_tag(65573);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_MODES: acamera_metadata_tag = acamera_metadata_tag(65574);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(65575);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST: acamera_metadata_tag =
        acamera_metadata_tag(65576);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_ENABLE_ZSL: acamera_metadata_tag = acamera_metadata_tag(65577);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AF_SCENE_CHANGE: acamera_metadata_tag = acamera_metadata_tag(65578);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_MAX_SIZES: acamera_metadata_tag =
        acamera_metadata_tag(65579);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_ZOOM_RATIO_RANGES:
        acamera_metadata_tag = acamera_metadata_tag(65580);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_EXTENDED_SCENE_MODE: acamera_metadata_tag =
        acamera_metadata_tag(65581);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_ZOOM_RATIO_RANGE: acamera_metadata_tag = acamera_metadata_tag(65582);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_ZOOM_RATIO: acamera_metadata_tag = acamera_metadata_tag(65583);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_SETTINGS_OVERRIDE: acamera_metadata_tag = acamera_metadata_tag(65588);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AVAILABLE_SETTINGS_OVERRIDES: acamera_metadata_tag =
        acamera_metadata_tag(65589);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AUTOFRAMING: acamera_metadata_tag = acamera_metadata_tag(65591);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AUTOFRAMING_AVAILABLE: acamera_metadata_tag =
        acamera_metadata_tag(65592);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_AUTOFRAMING_STATE: acamera_metadata_tag = acamera_metadata_tag(65593);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(65594);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_LOW_LIGHT_BOOST_STATE: acamera_metadata_tag =
        acamera_metadata_tag(65595);
}
impl acamera_metadata_tag {
    pub const ACAMERA_CONTROL_END: acamera_metadata_tag = acamera_metadata_tag(65596);
}
impl acamera_metadata_tag {
    pub const ACAMERA_EDGE_MODE: acamera_metadata_tag = acamera_metadata_tag(196608);
}
impl acamera_metadata_tag {
    pub const ACAMERA_EDGE_AVAILABLE_EDGE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(196610);
}
impl acamera_metadata_tag {
    pub const ACAMERA_EDGE_END: acamera_metadata_tag = acamera_metadata_tag(196611);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_MODE: acamera_metadata_tag = acamera_metadata_tag(262146);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_STATE: acamera_metadata_tag = acamera_metadata_tag(262149);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_STRENGTH_LEVEL: acamera_metadata_tag = acamera_metadata_tag(262150);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_SINGLE_STRENGTH_MAX_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(262151);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_SINGLE_STRENGTH_DEFAULT_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(262152);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_TORCH_STRENGTH_MAX_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(262153);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_TORCH_STRENGTH_DEFAULT_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(262154);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_END: acamera_metadata_tag = acamera_metadata_tag(262155);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_INFO_AVAILABLE: acamera_metadata_tag = acamera_metadata_tag(327680);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(327682);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(327683);
}
impl acamera_metadata_tag {
    pub const ACAMERA_FLASH_INFO_END: acamera_metadata_tag = acamera_metadata_tag(327684);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HOT_PIXEL_MODE: acamera_metadata_tag = acamera_metadata_tag(393216);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES: acamera_metadata_tag =
        acamera_metadata_tag(393217);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HOT_PIXEL_END: acamera_metadata_tag = acamera_metadata_tag(393218);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_GPS_COORDINATES: acamera_metadata_tag = acamera_metadata_tag(458752);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_GPS_PROCESSING_METHOD: acamera_metadata_tag =
        acamera_metadata_tag(458753);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_GPS_TIMESTAMP: acamera_metadata_tag = acamera_metadata_tag(458754);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_ORIENTATION: acamera_metadata_tag = acamera_metadata_tag(458755);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_QUALITY: acamera_metadata_tag = acamera_metadata_tag(458756);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_THUMBNAIL_QUALITY: acamera_metadata_tag = acamera_metadata_tag(458757);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_THUMBNAIL_SIZE: acamera_metadata_tag = acamera_metadata_tag(458758);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_AVAILABLE_THUMBNAIL_SIZES: acamera_metadata_tag =
        acamera_metadata_tag(458759);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEG_END: acamera_metadata_tag = acamera_metadata_tag(458760);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_APERTURE: acamera_metadata_tag = acamera_metadata_tag(524288);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_FILTER_DENSITY: acamera_metadata_tag = acamera_metadata_tag(524289);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_FOCAL_LENGTH: acamera_metadata_tag = acamera_metadata_tag(524290);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_FOCUS_DISTANCE: acamera_metadata_tag = acamera_metadata_tag(524291);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_OPTICAL_STABILIZATION_MODE: acamera_metadata_tag =
        acamera_metadata_tag(524292);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_FACING: acamera_metadata_tag = acamera_metadata_tag(524293);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_POSE_ROTATION: acamera_metadata_tag = acamera_metadata_tag(524294);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_POSE_TRANSLATION: acamera_metadata_tag = acamera_metadata_tag(524295);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_FOCUS_RANGE: acamera_metadata_tag = acamera_metadata_tag(524296);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_STATE: acamera_metadata_tag = acamera_metadata_tag(524297);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INTRINSIC_CALIBRATION: acamera_metadata_tag =
        acamera_metadata_tag(524298);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_RADIAL_DISTORTION: acamera_metadata_tag = acamera_metadata_tag(524299);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_POSE_REFERENCE: acamera_metadata_tag = acamera_metadata_tag(524300);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_DISTORTION: acamera_metadata_tag = acamera_metadata_tag(524301);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_DISTORTION_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(524302);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INTRINSIC_CALIBRATION_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(524303);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_END: acamera_metadata_tag = acamera_metadata_tag(524304);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_AVAILABLE_APERTURES: acamera_metadata_tag =
        acamera_metadata_tag(589824);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_AVAILABLE_FILTER_DENSITIES: acamera_metadata_tag =
        acamera_metadata_tag(589825);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_AVAILABLE_FOCAL_LENGTHS: acamera_metadata_tag =
        acamera_metadata_tag(589826);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION: acamera_metadata_tag =
        acamera_metadata_tag(589827);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE: acamera_metadata_tag =
        acamera_metadata_tag(589828);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE: acamera_metadata_tag =
        acamera_metadata_tag(589829);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_SHADING_MAP_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(589830);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION: acamera_metadata_tag =
        acamera_metadata_tag(589831);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LENS_INFO_END: acamera_metadata_tag = acamera_metadata_tag(589832);
}
impl acamera_metadata_tag {
    pub const ACAMERA_NOISE_REDUCTION_MODE: acamera_metadata_tag = acamera_metadata_tag(655360);
}
impl acamera_metadata_tag {
    pub const ACAMERA_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES: acamera_metadata_tag =
        acamera_metadata_tag(655362);
}
impl acamera_metadata_tag {
    pub const ACAMERA_NOISE_REDUCTION_END: acamera_metadata_tag = acamera_metadata_tag(655363);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_MAX_NUM_OUTPUT_STREAMS: acamera_metadata_tag =
        acamera_metadata_tag(786438);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_PIPELINE_DEPTH: acamera_metadata_tag = acamera_metadata_tag(786441);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_PIPELINE_MAX_DEPTH: acamera_metadata_tag =
        acamera_metadata_tag(786442);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_PARTIAL_RESULT_COUNT: acamera_metadata_tag =
        acamera_metadata_tag(786443);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES: acamera_metadata_tag =
        acamera_metadata_tag(786444);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS: acamera_metadata_tag =
        acamera_metadata_tag(786445);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS: acamera_metadata_tag =
        acamera_metadata_tag(786446);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_CHARACTERISTICS_KEYS: acamera_metadata_tag =
        acamera_metadata_tag(786447);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_SESSION_KEYS: acamera_metadata_tag =
        acamera_metadata_tag(786448);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS: acamera_metadata_tag =
        acamera_metadata_tag(786449);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP: acamera_metadata_tag =
        acamera_metadata_tag(786451);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP: acamera_metadata_tag =
        acamera_metadata_tag(786453);
}
impl acamera_metadata_tag {
    pub const ACAMERA_REQUEST_END: acamera_metadata_tag = acamera_metadata_tag(786454);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_CROP_REGION: acamera_metadata_tag = acamera_metadata_tag(851968);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM: acamera_metadata_tag =
        acamera_metadata_tag(851972);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(851978);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(851979);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(851980);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_CROPPING_TYPE: acamera_metadata_tag = acamera_metadata_tag(851981);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(851982);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_INPUT_OUTPUT_FORMATS_MAP: acamera_metadata_tag =
        acamera_metadata_tag(851983);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_ROTATE_AND_CROP_MODES: acamera_metadata_tag =
        acamera_metadata_tag(851984);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP: acamera_metadata_tag = acamera_metadata_tag(851985);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_DEFAULT_SECURE_IMAGE_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(851986);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS:
        acamera_metadata_tag = acamera_metadata_tag(851987);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(851988);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(851989);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(851990);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED: acamera_metadata_tag =
        acamera_metadata_tag(851992);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES: acamera_metadata_tag =
        acamera_metadata_tag(851994);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_RAW_CROP_REGION: acamera_metadata_tag = acamera_metadata_tag(851995);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SCALER_END: acamera_metadata_tag = acamera_metadata_tag(851996);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_EXPOSURE_TIME: acamera_metadata_tag = acamera_metadata_tag(917504);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_FRAME_DURATION: acamera_metadata_tag = acamera_metadata_tag(917505);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_SENSITIVITY: acamera_metadata_tag = acamera_metadata_tag(917506);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1: acamera_metadata_tag =
        acamera_metadata_tag(917507);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT2: acamera_metadata_tag =
        acamera_metadata_tag(917508);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_CALIBRATION_TRANSFORM1: acamera_metadata_tag =
        acamera_metadata_tag(917509);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_CALIBRATION_TRANSFORM2: acamera_metadata_tag =
        acamera_metadata_tag(917510);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_COLOR_TRANSFORM1: acamera_metadata_tag = acamera_metadata_tag(917511);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_COLOR_TRANSFORM2: acamera_metadata_tag = acamera_metadata_tag(917512);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_FORWARD_MATRIX1: acamera_metadata_tag = acamera_metadata_tag(917513);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_FORWARD_MATRIX2: acamera_metadata_tag = acamera_metadata_tag(917514);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_BLACK_LEVEL_PATTERN: acamera_metadata_tag =
        acamera_metadata_tag(917516);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY: acamera_metadata_tag =
        acamera_metadata_tag(917517);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_ORIENTATION: acamera_metadata_tag = acamera_metadata_tag(917518);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_TIMESTAMP: acamera_metadata_tag = acamera_metadata_tag(917520);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_NEUTRAL_COLOR_POINT: acamera_metadata_tag =
        acamera_metadata_tag(917522);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_NOISE_PROFILE: acamera_metadata_tag = acamera_metadata_tag(917523);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_GREEN_SPLIT: acamera_metadata_tag = acamera_metadata_tag(917526);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_TEST_PATTERN_DATA: acamera_metadata_tag = acamera_metadata_tag(917527);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE: acamera_metadata_tag = acamera_metadata_tag(917528);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_AVAILABLE_TEST_PATTERN_MODES: acamera_metadata_tag =
        acamera_metadata_tag(917529);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_ROLLING_SHUTTER_SKEW: acamera_metadata_tag =
        acamera_metadata_tag(917530);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS: acamera_metadata_tag =
        acamera_metadata_tag(917531);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(917532);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(917533);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_PIXEL_MODE: acamera_metadata_tag = acamera_metadata_tag(917536);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED: acamera_metadata_tag =
        acamera_metadata_tag(917537);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_END: acamera_metadata_tag = acamera_metadata_tag(917538);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(983040);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(983041);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT: acamera_metadata_tag =
        acamera_metadata_tag(983042);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE: acamera_metadata_tag =
        acamera_metadata_tag(983043);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION: acamera_metadata_tag =
        acamera_metadata_tag(983044);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_PHYSICAL_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(983045);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(983046);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_WHITE_LEVEL: acamera_metadata_tag = acamera_metadata_tag(983047);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE: acamera_metadata_tag =
        acamera_metadata_tag(983048);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED: acamera_metadata_tag =
        acamera_metadata_tag(983049);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE: acamera_metadata_tag =
        acamera_metadata_tag(983050);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(983051);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(983052);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(983053);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_BINNING_FACTOR: acamera_metadata_tag =
        acamera_metadata_tag(983054);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SENSOR_INFO_END: acamera_metadata_tag = acamera_metadata_tag(983055);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SHADING_MODE: acamera_metadata_tag = acamera_metadata_tag(1048576);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SHADING_AVAILABLE_MODES: acamera_metadata_tag = acamera_metadata_tag(1048578);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SHADING_END: acamera_metadata_tag = acamera_metadata_tag(1048579);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_FACE_DETECT_MODE: acamera_metadata_tag =
        acamera_metadata_tag(1114112);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE: acamera_metadata_tag =
        acamera_metadata_tag(1114115);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_FACE_IDS: acamera_metadata_tag = acamera_metadata_tag(1114116);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_FACE_LANDMARKS: acamera_metadata_tag =
        acamera_metadata_tag(1114117);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_FACE_RECTANGLES: acamera_metadata_tag =
        acamera_metadata_tag(1114118);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_FACE_SCORES: acamera_metadata_tag = acamera_metadata_tag(1114119);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_LENS_SHADING_MAP: acamera_metadata_tag =
        acamera_metadata_tag(1114123);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_SCENE_FLICKER: acamera_metadata_tag =
        acamera_metadata_tag(1114126);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_HOT_PIXEL_MAP: acamera_metadata_tag =
        acamera_metadata_tag(1114127);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE: acamera_metadata_tag =
        acamera_metadata_tag(1114128);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_OIS_DATA_MODE: acamera_metadata_tag =
        acamera_metadata_tag(1114129);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_OIS_TIMESTAMPS: acamera_metadata_tag =
        acamera_metadata_tag(1114130);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_OIS_X_SHIFTS: acamera_metadata_tag = acamera_metadata_tag(1114131);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_OIS_Y_SHIFTS: acamera_metadata_tag = acamera_metadata_tag(1114132);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_LENS_INTRINSIC_TIMESTAMPS: acamera_metadata_tag =
        acamera_metadata_tag(1114133);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_LENS_INTRINSIC_SAMPLES: acamera_metadata_tag =
        acamera_metadata_tag(1114134);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_END: acamera_metadata_tag = acamera_metadata_tag(1114135);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1179648);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_MAX_FACE_COUNT: acamera_metadata_tag =
        acamera_metadata_tag(1179650);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1179654);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1179655);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1179656);
}
impl acamera_metadata_tag {
    pub const ACAMERA_STATISTICS_INFO_END: acamera_metadata_tag = acamera_metadata_tag(1179657);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_CURVE_BLUE: acamera_metadata_tag = acamera_metadata_tag(1245184);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_CURVE_GREEN: acamera_metadata_tag = acamera_metadata_tag(1245185);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_CURVE_RED: acamera_metadata_tag = acamera_metadata_tag(1245186);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_MODE: acamera_metadata_tag = acamera_metadata_tag(1245187);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_MAX_CURVE_POINTS: acamera_metadata_tag =
        acamera_metadata_tag(1245188);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_AVAILABLE_TONE_MAP_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1245189);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_GAMMA: acamera_metadata_tag = acamera_metadata_tag(1245190);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_PRESET_CURVE: acamera_metadata_tag = acamera_metadata_tag(1245191);
}
impl acamera_metadata_tag {
    pub const ACAMERA_TONEMAP_END: acamera_metadata_tag = acamera_metadata_tag(1245192);
}
impl acamera_metadata_tag {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL: acamera_metadata_tag =
        acamera_metadata_tag(1376256);
}
impl acamera_metadata_tag {
    pub const ACAMERA_INFO_VERSION: acamera_metadata_tag = acamera_metadata_tag(1376257);
}
impl acamera_metadata_tag {
    pub const ACAMERA_INFO_DEVICE_STATE_ORIENTATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1376259);
}
impl acamera_metadata_tag {
    pub const ACAMERA_INFO_END: acamera_metadata_tag = acamera_metadata_tag(1376260);
}
impl acamera_metadata_tag {
    pub const ACAMERA_BLACK_LEVEL_LOCK: acamera_metadata_tag = acamera_metadata_tag(1441792);
}
impl acamera_metadata_tag {
    pub const ACAMERA_BLACK_LEVEL_END: acamera_metadata_tag = acamera_metadata_tag(1441793);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SYNC_FRAME_NUMBER: acamera_metadata_tag = acamera_metadata_tag(1507328);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SYNC_MAX_LATENCY: acamera_metadata_tag = acamera_metadata_tag(1507329);
}
impl acamera_metadata_tag {
    pub const ACAMERA_SYNC_END: acamera_metadata_tag = acamera_metadata_tag(1507330);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638401);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638402);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638403);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE: acamera_metadata_tag =
        acamera_metadata_tag(1638404);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_RECOMMENDED_DEPTH_STREAM_CONFIGURATIONS:
        acamera_metadata_tag = acamera_metadata_tag(1638405);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638406);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638407);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1638408);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638409);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638410);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638411);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638412);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638413);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1638414);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DEPTH_END: acamera_metadata_tag = acamera_metadata_tag(1638415);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_PHYSICAL_IDS: acamera_metadata_tag =
        acamera_metadata_tag(1703936);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE: acamera_metadata_tag =
        acamera_metadata_tag(1703937);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID: acamera_metadata_tag =
        acamera_metadata_tag(1703938);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_SENSOR_CROP_REGION:
        acamera_metadata_tag = acamera_metadata_tag(1703939);
}
impl acamera_metadata_tag {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_END: acamera_metadata_tag =
        acamera_metadata_tag(1703940);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DISTORTION_CORRECTION_MODE: acamera_metadata_tag =
        acamera_metadata_tag(1769472);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DISTORTION_CORRECTION_AVAILABLE_MODES: acamera_metadata_tag =
        acamera_metadata_tag(1769473);
}
impl acamera_metadata_tag {
    pub const ACAMERA_DISTORTION_CORRECTION_END: acamera_metadata_tag =
        acamera_metadata_tag(1769474);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1835008);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1835009);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(1835010);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1835011);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(1835012);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS_MAXIMUM_RESOLUTION: acamera_metadata_tag =
        acamera_metadata_tag(1835013);
}
impl acamera_metadata_tag {
    pub const ACAMERA_HEIC_END: acamera_metadata_tag = acamera_metadata_tag(1835014);
}
impl acamera_metadata_tag {
    pub const ACAMERA_AUTOMOTIVE_LOCATION: acamera_metadata_tag = acamera_metadata_tag(1966080);
}
impl acamera_metadata_tag {
    pub const ACAMERA_AUTOMOTIVE_END: acamera_metadata_tag = acamera_metadata_tag(1966081);
}
impl acamera_metadata_tag {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING: acamera_metadata_tag = acamera_metadata_tag(2031616);
}
impl acamera_metadata_tag {
    pub const ACAMERA_AUTOMOTIVE_LENS_END: acamera_metadata_tag = acamera_metadata_tag(2031617);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(2162688);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_MIN_FRAME_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(2162689);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STALL_DURATIONS: acamera_metadata_tag =
        acamera_metadata_tag(2162690);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(2162691);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(2162692);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STALL_DURATIONS_MAXIMUM_RESOLUTION:
        acamera_metadata_tag = acamera_metadata_tag(2162693);
}
impl acamera_metadata_tag {
    pub const ACAMERA_JPEGR_END: acamera_metadata_tag = acamera_metadata_tag(2162694);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_tag(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_tag as acamera_metadata_tag_t;
impl acamera_metadata_enum_acamera_color_correction_mode {
    pub const ACAMERA_COLOR_CORRECTION_MODE_TRANSFORM_MATRIX:
        acamera_metadata_enum_acamera_color_correction_mode =
        acamera_metadata_enum_acamera_color_correction_mode(0);
}
impl acamera_metadata_enum_acamera_color_correction_mode {
    pub const ACAMERA_COLOR_CORRECTION_MODE_FAST:
        acamera_metadata_enum_acamera_color_correction_mode =
        acamera_metadata_enum_acamera_color_correction_mode(1);
}
impl acamera_metadata_enum_acamera_color_correction_mode {
    pub const ACAMERA_COLOR_CORRECTION_MODE_HIGH_QUALITY:
        acamera_metadata_enum_acamera_color_correction_mode =
        acamera_metadata_enum_acamera_color_correction_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_color_correction_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_color_correction_mode as acamera_metadata_enum_android_color_correction_mode_t;
impl acamera_metadata_enum_acamera_color_correction_aberration_mode {
    pub const ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_OFF:
        acamera_metadata_enum_acamera_color_correction_aberration_mode =
        acamera_metadata_enum_acamera_color_correction_aberration_mode(0);
}
impl acamera_metadata_enum_acamera_color_correction_aberration_mode {
    pub const ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_FAST:
        acamera_metadata_enum_acamera_color_correction_aberration_mode =
        acamera_metadata_enum_acamera_color_correction_aberration_mode(1);
}
impl acamera_metadata_enum_acamera_color_correction_aberration_mode {
    pub const ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY:
        acamera_metadata_enum_acamera_color_correction_aberration_mode =
        acamera_metadata_enum_acamera_color_correction_aberration_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_color_correction_aberration_mode(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_color_correction_aberration_mode as acamera_metadata_enum_android_color_correction_aberration_mode_t;
impl acamera_metadata_enum_acamera_control_ae_antibanding_mode {
    pub const ACAMERA_CONTROL_AE_ANTIBANDING_MODE_OFF:
        acamera_metadata_enum_acamera_control_ae_antibanding_mode =
        acamera_metadata_enum_acamera_control_ae_antibanding_mode(0);
}
impl acamera_metadata_enum_acamera_control_ae_antibanding_mode {
    pub const ACAMERA_CONTROL_AE_ANTIBANDING_MODE_50HZ:
        acamera_metadata_enum_acamera_control_ae_antibanding_mode =
        acamera_metadata_enum_acamera_control_ae_antibanding_mode(1);
}
impl acamera_metadata_enum_acamera_control_ae_antibanding_mode {
    pub const ACAMERA_CONTROL_AE_ANTIBANDING_MODE_60HZ:
        acamera_metadata_enum_acamera_control_ae_antibanding_mode =
        acamera_metadata_enum_acamera_control_ae_antibanding_mode(2);
}
impl acamera_metadata_enum_acamera_control_ae_antibanding_mode {
    pub const ACAMERA_CONTROL_AE_ANTIBANDING_MODE_AUTO:
        acamera_metadata_enum_acamera_control_ae_antibanding_mode =
        acamera_metadata_enum_acamera_control_ae_antibanding_mode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_antibanding_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_antibanding_mode as acamera_metadata_enum_android_control_ae_antibanding_mode_t;
impl acamera_metadata_enum_acamera_control_ae_lock {
    pub const ACAMERA_CONTROL_AE_LOCK_OFF: acamera_metadata_enum_acamera_control_ae_lock =
        acamera_metadata_enum_acamera_control_ae_lock(0);
}
impl acamera_metadata_enum_acamera_control_ae_lock {
    pub const ACAMERA_CONTROL_AE_LOCK_ON: acamera_metadata_enum_acamera_control_ae_lock =
        acamera_metadata_enum_acamera_control_ae_lock(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_lock(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_lock as acamera_metadata_enum_android_control_ae_lock_t;
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_OFF: acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(0);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON: acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(1);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH: acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(2);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON_ALWAYS_FLASH:
        acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(3);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE:
        acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(4);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON_EXTERNAL_FLASH:
        acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(5);
}
impl acamera_metadata_enum_acamera_control_ae_mode {
    pub const ACAMERA_CONTROL_AE_MODE_ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY:
        acamera_metadata_enum_acamera_control_ae_mode =
        acamera_metadata_enum_acamera_control_ae_mode(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_mode as acamera_metadata_enum_android_control_ae_mode_t;
impl acamera_metadata_enum_acamera_control_ae_precapture_trigger {
    pub const ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_IDLE:
        acamera_metadata_enum_acamera_control_ae_precapture_trigger =
        acamera_metadata_enum_acamera_control_ae_precapture_trigger(0);
}
impl acamera_metadata_enum_acamera_control_ae_precapture_trigger {
    pub const ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_START:
        acamera_metadata_enum_acamera_control_ae_precapture_trigger =
        acamera_metadata_enum_acamera_control_ae_precapture_trigger(1);
}
impl acamera_metadata_enum_acamera_control_ae_precapture_trigger {
    pub const ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL:
        acamera_metadata_enum_acamera_control_ae_precapture_trigger =
        acamera_metadata_enum_acamera_control_ae_precapture_trigger(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_precapture_trigger(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_precapture_trigger as acamera_metadata_enum_android_control_ae_precapture_trigger_t;
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_OFF: acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(0);
}
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_AUTO: acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(1);
}
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_MACRO: acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(2);
}
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_CONTINUOUS_VIDEO:
        acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(3);
}
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_CONTINUOUS_PICTURE:
        acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(4);
}
impl acamera_metadata_enum_acamera_control_af_mode {
    pub const ACAMERA_CONTROL_AF_MODE_EDOF: acamera_metadata_enum_acamera_control_af_mode =
        acamera_metadata_enum_acamera_control_af_mode(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_af_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_af_mode as acamera_metadata_enum_android_control_af_mode_t;
impl acamera_metadata_enum_acamera_control_af_trigger {
    pub const ACAMERA_CONTROL_AF_TRIGGER_IDLE: acamera_metadata_enum_acamera_control_af_trigger =
        acamera_metadata_enum_acamera_control_af_trigger(0);
}
impl acamera_metadata_enum_acamera_control_af_trigger {
    pub const ACAMERA_CONTROL_AF_TRIGGER_START: acamera_metadata_enum_acamera_control_af_trigger =
        acamera_metadata_enum_acamera_control_af_trigger(1);
}
impl acamera_metadata_enum_acamera_control_af_trigger {
    pub const ACAMERA_CONTROL_AF_TRIGGER_CANCEL: acamera_metadata_enum_acamera_control_af_trigger =
        acamera_metadata_enum_acamera_control_af_trigger(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_af_trigger(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_af_trigger as acamera_metadata_enum_android_control_af_trigger_t;
impl acamera_metadata_enum_acamera_control_awb_lock {
    pub const ACAMERA_CONTROL_AWB_LOCK_OFF: acamera_metadata_enum_acamera_control_awb_lock =
        acamera_metadata_enum_acamera_control_awb_lock(0);
}
impl acamera_metadata_enum_acamera_control_awb_lock {
    pub const ACAMERA_CONTROL_AWB_LOCK_ON: acamera_metadata_enum_acamera_control_awb_lock =
        acamera_metadata_enum_acamera_control_awb_lock(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_awb_lock(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_awb_lock as acamera_metadata_enum_android_control_awb_lock_t;
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_OFF: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(0);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_AUTO: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(1);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_INCANDESCENT:
        acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(2);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_FLUORESCENT: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(3);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_WARM_FLUORESCENT:
        acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(4);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_DAYLIGHT: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(5);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT:
        acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(6);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_TWILIGHT: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(7);
}
impl acamera_metadata_enum_acamera_control_awb_mode {
    pub const ACAMERA_CONTROL_AWB_MODE_SHADE: acamera_metadata_enum_acamera_control_awb_mode =
        acamera_metadata_enum_acamera_control_awb_mode(8);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_awb_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_awb_mode as acamera_metadata_enum_android_control_awb_mode_t;
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_CUSTOM:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(0);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_PREVIEW:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(1);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_STILL_CAPTURE:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(2);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_RECORD:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(3);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(4);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(5);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_MANUAL:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(6);
}
impl acamera_metadata_enum_acamera_control_capture_intent {
    pub const ACAMERA_CONTROL_CAPTURE_INTENT_MOTION_TRACKING:
        acamera_metadata_enum_acamera_control_capture_intent =
        acamera_metadata_enum_acamera_control_capture_intent(7);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_capture_intent(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_capture_intent as acamera_metadata_enum_android_control_capture_intent_t;
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_OFF: acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(0);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_MONO: acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(1);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_NEGATIVE:
        acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(2);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_SOLARIZE:
        acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(3);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_SEPIA: acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(4);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_POSTERIZE:
        acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(5);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_WHITEBOARD:
        acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(6);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_BLACKBOARD:
        acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(7);
}
impl acamera_metadata_enum_acamera_control_effect_mode {
    pub const ACAMERA_CONTROL_EFFECT_MODE_AQUA: acamera_metadata_enum_acamera_control_effect_mode =
        acamera_metadata_enum_acamera_control_effect_mode(8);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_effect_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_effect_mode as acamera_metadata_enum_android_control_effect_mode_t;
impl acamera_metadata_enum_acamera_control_mode {
    pub const ACAMERA_CONTROL_MODE_OFF: acamera_metadata_enum_acamera_control_mode =
        acamera_metadata_enum_acamera_control_mode(0);
}
impl acamera_metadata_enum_acamera_control_mode {
    pub const ACAMERA_CONTROL_MODE_AUTO: acamera_metadata_enum_acamera_control_mode =
        acamera_metadata_enum_acamera_control_mode(1);
}
impl acamera_metadata_enum_acamera_control_mode {
    pub const ACAMERA_CONTROL_MODE_USE_SCENE_MODE: acamera_metadata_enum_acamera_control_mode =
        acamera_metadata_enum_acamera_control_mode(2);
}
impl acamera_metadata_enum_acamera_control_mode {
    pub const ACAMERA_CONTROL_MODE_OFF_KEEP_STATE: acamera_metadata_enum_acamera_control_mode =
        acamera_metadata_enum_acamera_control_mode(3);
}
impl acamera_metadata_enum_acamera_control_mode {
    pub const ACAMERA_CONTROL_MODE_USE_EXTENDED_SCENE_MODE:
        acamera_metadata_enum_acamera_control_mode = acamera_metadata_enum_acamera_control_mode(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_mode as acamera_metadata_enum_android_control_mode_t;
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_DISABLED:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(0);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_FACE_PRIORITY:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(1);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_ACTION: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(2);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_PORTRAIT:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(3);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_LANDSCAPE:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(4);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_NIGHT: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(5);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_NIGHT_PORTRAIT:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(6);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_THEATRE: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(7);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_BEACH: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(8);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_SNOW: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(9);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_SUNSET: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(10);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_STEADYPHOTO:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(11);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_FIREWORKS:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(12);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_SPORTS: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(13);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_PARTY: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(14);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_CANDLELIGHT:
        acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(15);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_BARCODE: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(16);
}
impl acamera_metadata_enum_acamera_control_scene_mode {
    pub const ACAMERA_CONTROL_SCENE_MODE_HDR: acamera_metadata_enum_acamera_control_scene_mode =
        acamera_metadata_enum_acamera_control_scene_mode(18);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_scene_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_scene_mode as acamera_metadata_enum_android_control_scene_mode_t;
impl acamera_metadata_enum_acamera_control_video_stabilization_mode {
    pub const ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_OFF:
        acamera_metadata_enum_acamera_control_video_stabilization_mode =
        acamera_metadata_enum_acamera_control_video_stabilization_mode(0);
}
impl acamera_metadata_enum_acamera_control_video_stabilization_mode {
    pub const ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_ON:
        acamera_metadata_enum_acamera_control_video_stabilization_mode =
        acamera_metadata_enum_acamera_control_video_stabilization_mode(1);
}
impl acamera_metadata_enum_acamera_control_video_stabilization_mode {
    pub const ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION:
        acamera_metadata_enum_acamera_control_video_stabilization_mode =
        acamera_metadata_enum_acamera_control_video_stabilization_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_video_stabilization_mode(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_control_video_stabilization_mode as acamera_metadata_enum_android_control_video_stabilization_mode_t;
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_INACTIVE: acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(0);
}
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_SEARCHING: acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(1);
}
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_CONVERGED: acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(2);
}
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_LOCKED: acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(3);
}
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_FLASH_REQUIRED:
        acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(4);
}
impl acamera_metadata_enum_acamera_control_ae_state {
    pub const ACAMERA_CONTROL_AE_STATE_PRECAPTURE: acamera_metadata_enum_acamera_control_ae_state =
        acamera_metadata_enum_acamera_control_ae_state(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_state as acamera_metadata_enum_android_control_ae_state_t;
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_INACTIVE: acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(0);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_PASSIVE_SCAN:
        acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(1);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_PASSIVE_FOCUSED:
        acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(2);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_ACTIVE_SCAN: acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(3);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_FOCUSED_LOCKED:
        acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(4);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED:
        acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(5);
}
impl acamera_metadata_enum_acamera_control_af_state {
    pub const ACAMERA_CONTROL_AF_STATE_PASSIVE_UNFOCUSED:
        acamera_metadata_enum_acamera_control_af_state =
        acamera_metadata_enum_acamera_control_af_state(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_af_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_af_state as acamera_metadata_enum_android_control_af_state_t;
impl acamera_metadata_enum_acamera_control_awb_state {
    pub const ACAMERA_CONTROL_AWB_STATE_INACTIVE: acamera_metadata_enum_acamera_control_awb_state =
        acamera_metadata_enum_acamera_control_awb_state(0);
}
impl acamera_metadata_enum_acamera_control_awb_state {
    pub const ACAMERA_CONTROL_AWB_STATE_SEARCHING: acamera_metadata_enum_acamera_control_awb_state =
        acamera_metadata_enum_acamera_control_awb_state(1);
}
impl acamera_metadata_enum_acamera_control_awb_state {
    pub const ACAMERA_CONTROL_AWB_STATE_CONVERGED: acamera_metadata_enum_acamera_control_awb_state =
        acamera_metadata_enum_acamera_control_awb_state(2);
}
impl acamera_metadata_enum_acamera_control_awb_state {
    pub const ACAMERA_CONTROL_AWB_STATE_LOCKED: acamera_metadata_enum_acamera_control_awb_state =
        acamera_metadata_enum_acamera_control_awb_state(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_awb_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_awb_state as acamera_metadata_enum_android_control_awb_state_t;
impl acamera_metadata_enum_acamera_control_ae_lock_available {
    pub const ACAMERA_CONTROL_AE_LOCK_AVAILABLE_FALSE:
        acamera_metadata_enum_acamera_control_ae_lock_available =
        acamera_metadata_enum_acamera_control_ae_lock_available(0);
}
impl acamera_metadata_enum_acamera_control_ae_lock_available {
    pub const ACAMERA_CONTROL_AE_LOCK_AVAILABLE_TRUE:
        acamera_metadata_enum_acamera_control_ae_lock_available =
        acamera_metadata_enum_acamera_control_ae_lock_available(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_ae_lock_available(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_ae_lock_available as acamera_metadata_enum_android_control_ae_lock_available_t;
impl acamera_metadata_enum_acamera_control_awb_lock_available {
    pub const ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_FALSE:
        acamera_metadata_enum_acamera_control_awb_lock_available =
        acamera_metadata_enum_acamera_control_awb_lock_available(0);
}
impl acamera_metadata_enum_acamera_control_awb_lock_available {
    pub const ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_TRUE:
        acamera_metadata_enum_acamera_control_awb_lock_available =
        acamera_metadata_enum_acamera_control_awb_lock_available(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_awb_lock_available(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_awb_lock_available as acamera_metadata_enum_android_control_awb_lock_available_t;
impl acamera_metadata_enum_acamera_control_enable_zsl {
    pub const ACAMERA_CONTROL_ENABLE_ZSL_FALSE: acamera_metadata_enum_acamera_control_enable_zsl =
        acamera_metadata_enum_acamera_control_enable_zsl(0);
}
impl acamera_metadata_enum_acamera_control_enable_zsl {
    pub const ACAMERA_CONTROL_ENABLE_ZSL_TRUE: acamera_metadata_enum_acamera_control_enable_zsl =
        acamera_metadata_enum_acamera_control_enable_zsl(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_enable_zsl(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_enable_zsl as acamera_metadata_enum_android_control_enable_zsl_t;
impl acamera_metadata_enum_acamera_control_af_scene_change {
    pub const ACAMERA_CONTROL_AF_SCENE_CHANGE_NOT_DETECTED:
        acamera_metadata_enum_acamera_control_af_scene_change =
        acamera_metadata_enum_acamera_control_af_scene_change(0);
}
impl acamera_metadata_enum_acamera_control_af_scene_change {
    pub const ACAMERA_CONTROL_AF_SCENE_CHANGE_DETECTED:
        acamera_metadata_enum_acamera_control_af_scene_change =
        acamera_metadata_enum_acamera_control_af_scene_change(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_af_scene_change(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_af_scene_change as acamera_metadata_enum_android_control_af_scene_change_t;
impl acamera_metadata_enum_acamera_control_extended_scene_mode {
    pub const ACAMERA_CONTROL_EXTENDED_SCENE_MODE_DISABLED:
        acamera_metadata_enum_acamera_control_extended_scene_mode =
        acamera_metadata_enum_acamera_control_extended_scene_mode(0);
}
impl acamera_metadata_enum_acamera_control_extended_scene_mode {
    pub const ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE:
        acamera_metadata_enum_acamera_control_extended_scene_mode =
        acamera_metadata_enum_acamera_control_extended_scene_mode(1);
}
impl acamera_metadata_enum_acamera_control_extended_scene_mode {
    pub const ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS:
        acamera_metadata_enum_acamera_control_extended_scene_mode =
        acamera_metadata_enum_acamera_control_extended_scene_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_extended_scene_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_extended_scene_mode as acamera_metadata_enum_android_control_extended_scene_mode_t;
impl acamera_metadata_enum_acamera_control_settings_override {
    pub const ACAMERA_CONTROL_SETTINGS_OVERRIDE_OFF:
        acamera_metadata_enum_acamera_control_settings_override =
        acamera_metadata_enum_acamera_control_settings_override(0);
}
impl acamera_metadata_enum_acamera_control_settings_override {
    pub const ACAMERA_CONTROL_SETTINGS_OVERRIDE_ZOOM:
        acamera_metadata_enum_acamera_control_settings_override =
        acamera_metadata_enum_acamera_control_settings_override(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_settings_override(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_settings_override as acamera_metadata_enum_android_control_settings_override_t;
impl acamera_metadata_enum_acamera_control_autoframing {
    pub const ACAMERA_CONTROL_AUTOFRAMING_OFF: acamera_metadata_enum_acamera_control_autoframing =
        acamera_metadata_enum_acamera_control_autoframing(0);
}
impl acamera_metadata_enum_acamera_control_autoframing {
    pub const ACAMERA_CONTROL_AUTOFRAMING_ON: acamera_metadata_enum_acamera_control_autoframing =
        acamera_metadata_enum_acamera_control_autoframing(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_autoframing(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_autoframing as acamera_metadata_enum_android_control_autoframing_t;
impl acamera_metadata_enum_acamera_control_autoframing_available {
    pub const ACAMERA_CONTROL_AUTOFRAMING_AVAILABLE_FALSE:
        acamera_metadata_enum_acamera_control_autoframing_available =
        acamera_metadata_enum_acamera_control_autoframing_available(0);
}
impl acamera_metadata_enum_acamera_control_autoframing_available {
    pub const ACAMERA_CONTROL_AUTOFRAMING_AVAILABLE_TRUE:
        acamera_metadata_enum_acamera_control_autoframing_available =
        acamera_metadata_enum_acamera_control_autoframing_available(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_autoframing_available(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_autoframing_available as acamera_metadata_enum_android_control_autoframing_available_t;
impl acamera_metadata_enum_acamera_control_autoframing_state {
    pub const ACAMERA_CONTROL_AUTOFRAMING_STATE_INACTIVE:
        acamera_metadata_enum_acamera_control_autoframing_state =
        acamera_metadata_enum_acamera_control_autoframing_state(0);
}
impl acamera_metadata_enum_acamera_control_autoframing_state {
    pub const ACAMERA_CONTROL_AUTOFRAMING_STATE_FRAMING:
        acamera_metadata_enum_acamera_control_autoframing_state =
        acamera_metadata_enum_acamera_control_autoframing_state(1);
}
impl acamera_metadata_enum_acamera_control_autoframing_state {
    pub const ACAMERA_CONTROL_AUTOFRAMING_STATE_CONVERGED:
        acamera_metadata_enum_acamera_control_autoframing_state =
        acamera_metadata_enum_acamera_control_autoframing_state(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_autoframing_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_autoframing_state as acamera_metadata_enum_android_control_autoframing_state_t;
impl acamera_metadata_enum_acamera_control_low_light_boost_state {
    pub const ACAMERA_CONTROL_LOW_LIGHT_BOOST_STATE_INACTIVE:
        acamera_metadata_enum_acamera_control_low_light_boost_state =
        acamera_metadata_enum_acamera_control_low_light_boost_state(0);
}
impl acamera_metadata_enum_acamera_control_low_light_boost_state {
    pub const ACAMERA_CONTROL_LOW_LIGHT_BOOST_STATE_ACTIVE:
        acamera_metadata_enum_acamera_control_low_light_boost_state =
        acamera_metadata_enum_acamera_control_low_light_boost_state(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_control_low_light_boost_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_control_low_light_boost_state as acamera_metadata_enum_android_control_low_light_boost_state_t;
impl acamera_metadata_enum_acamera_edge_mode {
    pub const ACAMERA_EDGE_MODE_OFF: acamera_metadata_enum_acamera_edge_mode =
        acamera_metadata_enum_acamera_edge_mode(0);
}
impl acamera_metadata_enum_acamera_edge_mode {
    pub const ACAMERA_EDGE_MODE_FAST: acamera_metadata_enum_acamera_edge_mode =
        acamera_metadata_enum_acamera_edge_mode(1);
}
impl acamera_metadata_enum_acamera_edge_mode {
    pub const ACAMERA_EDGE_MODE_HIGH_QUALITY: acamera_metadata_enum_acamera_edge_mode =
        acamera_metadata_enum_acamera_edge_mode(2);
}
impl acamera_metadata_enum_acamera_edge_mode {
    pub const ACAMERA_EDGE_MODE_ZERO_SHUTTER_LAG: acamera_metadata_enum_acamera_edge_mode =
        acamera_metadata_enum_acamera_edge_mode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_edge_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_edge_mode as acamera_metadata_enum_android_edge_mode_t;
impl acamera_metadata_enum_acamera_flash_mode {
    pub const ACAMERA_FLASH_MODE_OFF: acamera_metadata_enum_acamera_flash_mode =
        acamera_metadata_enum_acamera_flash_mode(0);
}
impl acamera_metadata_enum_acamera_flash_mode {
    pub const ACAMERA_FLASH_MODE_SINGLE: acamera_metadata_enum_acamera_flash_mode =
        acamera_metadata_enum_acamera_flash_mode(1);
}
impl acamera_metadata_enum_acamera_flash_mode {
    pub const ACAMERA_FLASH_MODE_TORCH: acamera_metadata_enum_acamera_flash_mode =
        acamera_metadata_enum_acamera_flash_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_flash_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_flash_mode as acamera_metadata_enum_android_flash_mode_t;
impl acamera_metadata_enum_acamera_flash_state {
    pub const ACAMERA_FLASH_STATE_UNAVAILABLE: acamera_metadata_enum_acamera_flash_state =
        acamera_metadata_enum_acamera_flash_state(0);
}
impl acamera_metadata_enum_acamera_flash_state {
    pub const ACAMERA_FLASH_STATE_CHARGING: acamera_metadata_enum_acamera_flash_state =
        acamera_metadata_enum_acamera_flash_state(1);
}
impl acamera_metadata_enum_acamera_flash_state {
    pub const ACAMERA_FLASH_STATE_READY: acamera_metadata_enum_acamera_flash_state =
        acamera_metadata_enum_acamera_flash_state(2);
}
impl acamera_metadata_enum_acamera_flash_state {
    pub const ACAMERA_FLASH_STATE_FIRED: acamera_metadata_enum_acamera_flash_state =
        acamera_metadata_enum_acamera_flash_state(3);
}
impl acamera_metadata_enum_acamera_flash_state {
    pub const ACAMERA_FLASH_STATE_PARTIAL: acamera_metadata_enum_acamera_flash_state =
        acamera_metadata_enum_acamera_flash_state(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_flash_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_flash_state as acamera_metadata_enum_android_flash_state_t;
impl acamera_metadata_enum_acamera_flash_info_available {
    pub const ACAMERA_FLASH_INFO_AVAILABLE_FALSE:
        acamera_metadata_enum_acamera_flash_info_available =
        acamera_metadata_enum_acamera_flash_info_available(0);
}
impl acamera_metadata_enum_acamera_flash_info_available {
    pub const ACAMERA_FLASH_INFO_AVAILABLE_TRUE:
        acamera_metadata_enum_acamera_flash_info_available =
        acamera_metadata_enum_acamera_flash_info_available(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_flash_info_available(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_flash_info_available as acamera_metadata_enum_android_flash_info_available_t;
impl acamera_metadata_enum_acamera_hot_pixel_mode {
    pub const ACAMERA_HOT_PIXEL_MODE_OFF: acamera_metadata_enum_acamera_hot_pixel_mode =
        acamera_metadata_enum_acamera_hot_pixel_mode(0);
}
impl acamera_metadata_enum_acamera_hot_pixel_mode {
    pub const ACAMERA_HOT_PIXEL_MODE_FAST: acamera_metadata_enum_acamera_hot_pixel_mode =
        acamera_metadata_enum_acamera_hot_pixel_mode(1);
}
impl acamera_metadata_enum_acamera_hot_pixel_mode {
    pub const ACAMERA_HOT_PIXEL_MODE_HIGH_QUALITY: acamera_metadata_enum_acamera_hot_pixel_mode =
        acamera_metadata_enum_acamera_hot_pixel_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_hot_pixel_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_hot_pixel_mode as acamera_metadata_enum_android_hot_pixel_mode_t;
impl acamera_metadata_enum_acamera_lens_optical_stabilization_mode {
    pub const ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_OFF:
        acamera_metadata_enum_acamera_lens_optical_stabilization_mode =
        acamera_metadata_enum_acamera_lens_optical_stabilization_mode(0);
}
impl acamera_metadata_enum_acamera_lens_optical_stabilization_mode {
    pub const ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_ON:
        acamera_metadata_enum_acamera_lens_optical_stabilization_mode =
        acamera_metadata_enum_acamera_lens_optical_stabilization_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_lens_optical_stabilization_mode(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_lens_optical_stabilization_mode as acamera_metadata_enum_android_lens_optical_stabilization_mode_t;
impl acamera_metadata_enum_acamera_lens_facing {
    pub const ACAMERA_LENS_FACING_FRONT: acamera_metadata_enum_acamera_lens_facing =
        acamera_metadata_enum_acamera_lens_facing(0);
}
impl acamera_metadata_enum_acamera_lens_facing {
    pub const ACAMERA_LENS_FACING_BACK: acamera_metadata_enum_acamera_lens_facing =
        acamera_metadata_enum_acamera_lens_facing(1);
}
impl acamera_metadata_enum_acamera_lens_facing {
    pub const ACAMERA_LENS_FACING_EXTERNAL: acamera_metadata_enum_acamera_lens_facing =
        acamera_metadata_enum_acamera_lens_facing(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_lens_facing(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_lens_facing as acamera_metadata_enum_android_lens_facing_t;
impl acamera_metadata_enum_acamera_lens_state {
    pub const ACAMERA_LENS_STATE_STATIONARY: acamera_metadata_enum_acamera_lens_state =
        acamera_metadata_enum_acamera_lens_state(0);
}
impl acamera_metadata_enum_acamera_lens_state {
    pub const ACAMERA_LENS_STATE_MOVING: acamera_metadata_enum_acamera_lens_state =
        acamera_metadata_enum_acamera_lens_state(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_lens_state(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_lens_state as acamera_metadata_enum_android_lens_state_t;
impl acamera_metadata_enum_acamera_lens_pose_reference {
    pub const ACAMERA_LENS_POSE_REFERENCE_PRIMARY_CAMERA:
        acamera_metadata_enum_acamera_lens_pose_reference =
        acamera_metadata_enum_acamera_lens_pose_reference(0);
}
impl acamera_metadata_enum_acamera_lens_pose_reference {
    pub const ACAMERA_LENS_POSE_REFERENCE_GYROSCOPE:
        acamera_metadata_enum_acamera_lens_pose_reference =
        acamera_metadata_enum_acamera_lens_pose_reference(1);
}
impl acamera_metadata_enum_acamera_lens_pose_reference {
    pub const ACAMERA_LENS_POSE_REFERENCE_UNDEFINED:
        acamera_metadata_enum_acamera_lens_pose_reference =
        acamera_metadata_enum_acamera_lens_pose_reference(2);
}
impl acamera_metadata_enum_acamera_lens_pose_reference {
    pub const ACAMERA_LENS_POSE_REFERENCE_AUTOMOTIVE:
        acamera_metadata_enum_acamera_lens_pose_reference =
        acamera_metadata_enum_acamera_lens_pose_reference(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_lens_pose_reference(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_lens_pose_reference as acamera_metadata_enum_android_lens_pose_reference_t;
impl acamera_metadata_enum_acamera_lens_info_focus_distance_calibration {
    pub const ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED:
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration =
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration(0);
}
impl acamera_metadata_enum_acamera_lens_info_focus_distance_calibration {
    pub const ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE:
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration =
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration(1);
}
impl acamera_metadata_enum_acamera_lens_info_focus_distance_calibration {
    pub const ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED:
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration =
        acamera_metadata_enum_acamera_lens_info_focus_distance_calibration(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_lens_info_focus_distance_calibration(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_lens_info_focus_distance_calibration as acamera_metadata_enum_android_lens_info_focus_distance_calibration_t;
impl acamera_metadata_enum_acamera_noise_reduction_mode {
    pub const ACAMERA_NOISE_REDUCTION_MODE_OFF: acamera_metadata_enum_acamera_noise_reduction_mode =
        acamera_metadata_enum_acamera_noise_reduction_mode(0);
}
impl acamera_metadata_enum_acamera_noise_reduction_mode {
    pub const ACAMERA_NOISE_REDUCTION_MODE_FAST:
        acamera_metadata_enum_acamera_noise_reduction_mode =
        acamera_metadata_enum_acamera_noise_reduction_mode(1);
}
impl acamera_metadata_enum_acamera_noise_reduction_mode {
    pub const ACAMERA_NOISE_REDUCTION_MODE_HIGH_QUALITY:
        acamera_metadata_enum_acamera_noise_reduction_mode =
        acamera_metadata_enum_acamera_noise_reduction_mode(2);
}
impl acamera_metadata_enum_acamera_noise_reduction_mode {
    pub const ACAMERA_NOISE_REDUCTION_MODE_MINIMAL:
        acamera_metadata_enum_acamera_noise_reduction_mode =
        acamera_metadata_enum_acamera_noise_reduction_mode(3);
}
impl acamera_metadata_enum_acamera_noise_reduction_mode {
    pub const ACAMERA_NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG:
        acamera_metadata_enum_acamera_noise_reduction_mode =
        acamera_metadata_enum_acamera_noise_reduction_mode(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_noise_reduction_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_noise_reduction_mode as acamera_metadata_enum_android_noise_reduction_mode_t;
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(0);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(1);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(2);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_RAW:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(3);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(5);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(6);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(8);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(10);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(11);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(12);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SECURE_IMAGE_DATA:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(13);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(14);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(16);
}
impl acamera_metadata_enum_acamera_request_available_capabilities {
    pub const ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE:
        acamera_metadata_enum_acamera_request_available_capabilities =
        acamera_metadata_enum_acamera_request_available_capabilities(19);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_request_available_capabilities(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_request_available_capabilities as acamera_metadata_enum_android_request_available_capabilities_t;
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(1);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(2);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(4);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(8);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(16);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(32);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(64);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(128);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(256);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(512);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(1024);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(2048);
}
impl acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX:
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map =
        acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(4096);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map as acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t;
impl acamera_metadata_enum_acamera_request_available_color_space_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_UNSPECIFIED:
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map =
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map(-1);
}
impl acamera_metadata_enum_acamera_request_available_color_space_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_SRGB:
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map =
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map(0);
}
impl acamera_metadata_enum_acamera_request_available_color_space_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_DISPLAY_P3:
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map =
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map(7);
}
impl acamera_metadata_enum_acamera_request_available_color_space_profiles_map {
    pub const ACAMERA_REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_BT2020_HLG:
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map =
        acamera_metadata_enum_acamera_request_available_color_space_profiles_map(16);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_request_available_color_space_profiles_map(
    pub ::std::os::raw::c_int,
);
pub use self::acamera_metadata_enum_acamera_request_available_color_space_profiles_map as acamera_metadata_enum_android_request_available_color_space_profiles_map_t;
impl acamera_metadata_enum_acamera_scaler_available_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_scaler_available_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_scaler_available_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_stream_configurations(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_available_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_available_stream_configurations as acamera_metadata_enum_android_scaler_available_stream_configurations_t;
impl acamera_metadata_enum_acamera_scaler_cropping_type {
    pub const ACAMERA_SCALER_CROPPING_TYPE_CENTER_ONLY:
        acamera_metadata_enum_acamera_scaler_cropping_type =
        acamera_metadata_enum_acamera_scaler_cropping_type(0);
}
impl acamera_metadata_enum_acamera_scaler_cropping_type {
    pub const ACAMERA_SCALER_CROPPING_TYPE_FREEFORM:
        acamera_metadata_enum_acamera_scaler_cropping_type =
        acamera_metadata_enum_acamera_scaler_cropping_type(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_cropping_type(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_scaler_cropping_type as acamera_metadata_enum_android_scaler_cropping_type_t;
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PREVIEW:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RECORD:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(1);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VIDEO_SNAPSHOT:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(2);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_SNAPSHOT:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(3);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_ZSL:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(4);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RAW:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(5);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_LOW_LATENCY_SNAPSHOT:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(6);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(7);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_10BIT_OUTPUT:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(8);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END_3_8:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(9);
}
impl acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations {
    pub const ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VENDOR_START:
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations =
        acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(24);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations as acamera_metadata_enum_android_scaler_available_recommended_stream_configurations_t;
impl acamera_metadata_enum_acamera_scaler_rotate_and_crop {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP_NONE:
        acamera_metadata_enum_acamera_scaler_rotate_and_crop =
        acamera_metadata_enum_acamera_scaler_rotate_and_crop(0);
}
impl acamera_metadata_enum_acamera_scaler_rotate_and_crop {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP_90:
        acamera_metadata_enum_acamera_scaler_rotate_and_crop =
        acamera_metadata_enum_acamera_scaler_rotate_and_crop(1);
}
impl acamera_metadata_enum_acamera_scaler_rotate_and_crop {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP_180:
        acamera_metadata_enum_acamera_scaler_rotate_and_crop =
        acamera_metadata_enum_acamera_scaler_rotate_and_crop(2);
}
impl acamera_metadata_enum_acamera_scaler_rotate_and_crop {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP_270:
        acamera_metadata_enum_acamera_scaler_rotate_and_crop =
        acamera_metadata_enum_acamera_scaler_rotate_and_crop(3);
}
impl acamera_metadata_enum_acamera_scaler_rotate_and_crop {
    pub const ACAMERA_SCALER_ROTATE_AND_CROP_AUTO:
        acamera_metadata_enum_acamera_scaler_rotate_and_crop =
        acamera_metadata_enum_acamera_scaler_rotate_and_crop(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_rotate_and_crop(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_scaler_rotate_and_crop as acamera_metadata_enum_android_scaler_rotate_and_crop_t;
impl acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations {
    pub const ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations =
        acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations(
            0,
        );
}
impl acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations {
    pub const ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations =
        acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations(
            1,
        );
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations as acamera_metadata_enum_android_scaler_physical_camera_multi_resolution_stream_configurations_t;
impl acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT:
        acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution(0);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT:
        acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution as acamera_metadata_enum_android_scaler_available_stream_configurations_maximum_resolution_t;
impl acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported {
    pub const ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_FALSE:
        acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported =
        acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported(0);
}
impl acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported {
    pub const ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_TRUE:
        acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported =
        acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported as acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t;
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(0);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(1);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(2);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(3);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(4);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(5);
}
impl acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
    pub const ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_CROPPED_RAW:
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases =
        acamera_metadata_enum_acamera_scaler_available_stream_use_cases(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_scaler_available_stream_use_cases(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_scaler_available_stream_use_cases as acamera_metadata_enum_android_scaler_available_stream_use_cases_t;
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(1);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(2);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(3);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLASH:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(4);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(9);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(10);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_SHADE:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(11);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(12);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(13);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(14);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(15);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(17);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(18);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(19);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D55:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(20);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D65:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(21);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D75:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(22);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D50:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(23);
}
impl acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
    pub const ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN:
        acamera_metadata_enum_acamera_sensor_reference_illuminant1 =
        acamera_metadata_enum_acamera_sensor_reference_illuminant1(24);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_reference_illuminant1(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_sensor_reference_illuminant1 as acamera_metadata_enum_android_sensor_reference_illuminant1_t;
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_OFF:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(0);
}
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_SOLID_COLOR:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(1);
}
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(2);
}
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(3);
}
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_PN9:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(4);
}
impl acamera_metadata_enum_acamera_sensor_test_pattern_mode {
    pub const ACAMERA_SENSOR_TEST_PATTERN_MODE_CUSTOM1:
        acamera_metadata_enum_acamera_sensor_test_pattern_mode =
        acamera_metadata_enum_acamera_sensor_test_pattern_mode(256);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_test_pattern_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_sensor_test_pattern_mode as acamera_metadata_enum_android_sensor_test_pattern_mode_t;
impl acamera_metadata_enum_acamera_sensor_pixel_mode {
    pub const ACAMERA_SENSOR_PIXEL_MODE_DEFAULT: acamera_metadata_enum_acamera_sensor_pixel_mode =
        acamera_metadata_enum_acamera_sensor_pixel_mode(0);
}
impl acamera_metadata_enum_acamera_sensor_pixel_mode {
    pub const ACAMERA_SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION:
        acamera_metadata_enum_acamera_sensor_pixel_mode =
        acamera_metadata_enum_acamera_sensor_pixel_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_pixel_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_sensor_pixel_mode as acamera_metadata_enum_android_sensor_pixel_mode_t;
impl acamera_metadata_enum_acamera_sensor_raw_binning_factor_used {
    pub const ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_TRUE:
        acamera_metadata_enum_acamera_sensor_raw_binning_factor_used =
        acamera_metadata_enum_acamera_sensor_raw_binning_factor_used(0);
}
impl acamera_metadata_enum_acamera_sensor_raw_binning_factor_used {
    pub const ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_FALSE:
        acamera_metadata_enum_acamera_sensor_raw_binning_factor_used =
        acamera_metadata_enum_acamera_sensor_raw_binning_factor_used(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_raw_binning_factor_used(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_sensor_raw_binning_factor_used as acamera_metadata_enum_android_sensor_raw_binning_factor_used_t;
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(0);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(1);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(2);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(3);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(4);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(5);
}
impl acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement {
    pub const ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR:
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement =
        acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement as acamera_metadata_enum_android_sensor_info_color_filter_arrangement_t;
impl acamera_metadata_enum_acamera_sensor_info_timestamp_source {
    pub const ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN:
        acamera_metadata_enum_acamera_sensor_info_timestamp_source =
        acamera_metadata_enum_acamera_sensor_info_timestamp_source(0);
}
impl acamera_metadata_enum_acamera_sensor_info_timestamp_source {
    pub const ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME:
        acamera_metadata_enum_acamera_sensor_info_timestamp_source =
        acamera_metadata_enum_acamera_sensor_info_timestamp_source(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_info_timestamp_source(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_sensor_info_timestamp_source as acamera_metadata_enum_android_sensor_info_timestamp_source_t;
impl acamera_metadata_enum_acamera_sensor_info_lens_shading_applied {
    pub const ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_FALSE:
        acamera_metadata_enum_acamera_sensor_info_lens_shading_applied =
        acamera_metadata_enum_acamera_sensor_info_lens_shading_applied(0);
}
impl acamera_metadata_enum_acamera_sensor_info_lens_shading_applied {
    pub const ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_TRUE:
        acamera_metadata_enum_acamera_sensor_info_lens_shading_applied =
        acamera_metadata_enum_acamera_sensor_info_lens_shading_applied(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sensor_info_lens_shading_applied(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_sensor_info_lens_shading_applied as acamera_metadata_enum_android_sensor_info_lens_shading_applied_t;
impl acamera_metadata_enum_acamera_shading_mode {
    pub const ACAMERA_SHADING_MODE_OFF: acamera_metadata_enum_acamera_shading_mode =
        acamera_metadata_enum_acamera_shading_mode(0);
}
impl acamera_metadata_enum_acamera_shading_mode {
    pub const ACAMERA_SHADING_MODE_FAST: acamera_metadata_enum_acamera_shading_mode =
        acamera_metadata_enum_acamera_shading_mode(1);
}
impl acamera_metadata_enum_acamera_shading_mode {
    pub const ACAMERA_SHADING_MODE_HIGH_QUALITY: acamera_metadata_enum_acamera_shading_mode =
        acamera_metadata_enum_acamera_shading_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_shading_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_shading_mode as acamera_metadata_enum_android_shading_mode_t;
impl acamera_metadata_enum_acamera_statistics_face_detect_mode {
    pub const ACAMERA_STATISTICS_FACE_DETECT_MODE_OFF:
        acamera_metadata_enum_acamera_statistics_face_detect_mode =
        acamera_metadata_enum_acamera_statistics_face_detect_mode(0);
}
impl acamera_metadata_enum_acamera_statistics_face_detect_mode {
    pub const ACAMERA_STATISTICS_FACE_DETECT_MODE_SIMPLE:
        acamera_metadata_enum_acamera_statistics_face_detect_mode =
        acamera_metadata_enum_acamera_statistics_face_detect_mode(1);
}
impl acamera_metadata_enum_acamera_statistics_face_detect_mode {
    pub const ACAMERA_STATISTICS_FACE_DETECT_MODE_FULL:
        acamera_metadata_enum_acamera_statistics_face_detect_mode =
        acamera_metadata_enum_acamera_statistics_face_detect_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_statistics_face_detect_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_statistics_face_detect_mode as acamera_metadata_enum_android_statistics_face_detect_mode_t;
impl acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode {
    pub const ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_OFF:
        acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode =
        acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode(0);
}
impl acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode {
    pub const ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_ON:
        acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode =
        acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode as acamera_metadata_enum_android_statistics_hot_pixel_map_mode_t;
impl acamera_metadata_enum_acamera_statistics_scene_flicker {
    pub const ACAMERA_STATISTICS_SCENE_FLICKER_NONE:
        acamera_metadata_enum_acamera_statistics_scene_flicker =
        acamera_metadata_enum_acamera_statistics_scene_flicker(0);
}
impl acamera_metadata_enum_acamera_statistics_scene_flicker {
    pub const ACAMERA_STATISTICS_SCENE_FLICKER_50HZ:
        acamera_metadata_enum_acamera_statistics_scene_flicker =
        acamera_metadata_enum_acamera_statistics_scene_flicker(1);
}
impl acamera_metadata_enum_acamera_statistics_scene_flicker {
    pub const ACAMERA_STATISTICS_SCENE_FLICKER_60HZ:
        acamera_metadata_enum_acamera_statistics_scene_flicker =
        acamera_metadata_enum_acamera_statistics_scene_flicker(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_statistics_scene_flicker(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_statistics_scene_flicker as acamera_metadata_enum_android_statistics_scene_flicker_t;
impl acamera_metadata_enum_acamera_statistics_lens_shading_map_mode {
    pub const ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_OFF:
        acamera_metadata_enum_acamera_statistics_lens_shading_map_mode =
        acamera_metadata_enum_acamera_statistics_lens_shading_map_mode(0);
}
impl acamera_metadata_enum_acamera_statistics_lens_shading_map_mode {
    pub const ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_ON:
        acamera_metadata_enum_acamera_statistics_lens_shading_map_mode =
        acamera_metadata_enum_acamera_statistics_lens_shading_map_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_statistics_lens_shading_map_mode(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_statistics_lens_shading_map_mode as acamera_metadata_enum_android_statistics_lens_shading_map_mode_t;
impl acamera_metadata_enum_acamera_statistics_ois_data_mode {
    pub const ACAMERA_STATISTICS_OIS_DATA_MODE_OFF:
        acamera_metadata_enum_acamera_statistics_ois_data_mode =
        acamera_metadata_enum_acamera_statistics_ois_data_mode(0);
}
impl acamera_metadata_enum_acamera_statistics_ois_data_mode {
    pub const ACAMERA_STATISTICS_OIS_DATA_MODE_ON:
        acamera_metadata_enum_acamera_statistics_ois_data_mode =
        acamera_metadata_enum_acamera_statistics_ois_data_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_statistics_ois_data_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_statistics_ois_data_mode as acamera_metadata_enum_android_statistics_ois_data_mode_t;
impl acamera_metadata_enum_acamera_tonemap_mode {
    pub const ACAMERA_TONEMAP_MODE_CONTRAST_CURVE: acamera_metadata_enum_acamera_tonemap_mode =
        acamera_metadata_enum_acamera_tonemap_mode(0);
}
impl acamera_metadata_enum_acamera_tonemap_mode {
    pub const ACAMERA_TONEMAP_MODE_FAST: acamera_metadata_enum_acamera_tonemap_mode =
        acamera_metadata_enum_acamera_tonemap_mode(1);
}
impl acamera_metadata_enum_acamera_tonemap_mode {
    pub const ACAMERA_TONEMAP_MODE_HIGH_QUALITY: acamera_metadata_enum_acamera_tonemap_mode =
        acamera_metadata_enum_acamera_tonemap_mode(2);
}
impl acamera_metadata_enum_acamera_tonemap_mode {
    pub const ACAMERA_TONEMAP_MODE_GAMMA_VALUE: acamera_metadata_enum_acamera_tonemap_mode =
        acamera_metadata_enum_acamera_tonemap_mode(3);
}
impl acamera_metadata_enum_acamera_tonemap_mode {
    pub const ACAMERA_TONEMAP_MODE_PRESET_CURVE: acamera_metadata_enum_acamera_tonemap_mode =
        acamera_metadata_enum_acamera_tonemap_mode(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_tonemap_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_tonemap_mode as acamera_metadata_enum_android_tonemap_mode_t;
impl acamera_metadata_enum_acamera_tonemap_preset_curve {
    pub const ACAMERA_TONEMAP_PRESET_CURVE_SRGB:
        acamera_metadata_enum_acamera_tonemap_preset_curve =
        acamera_metadata_enum_acamera_tonemap_preset_curve(0);
}
impl acamera_metadata_enum_acamera_tonemap_preset_curve {
    pub const ACAMERA_TONEMAP_PRESET_CURVE_REC709:
        acamera_metadata_enum_acamera_tonemap_preset_curve =
        acamera_metadata_enum_acamera_tonemap_preset_curve(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_tonemap_preset_curve(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_tonemap_preset_curve as acamera_metadata_enum_android_tonemap_preset_curve_t;
impl acamera_metadata_enum_acamera_info_supported_hardware_level {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED:
        acamera_metadata_enum_acamera_info_supported_hardware_level =
        acamera_metadata_enum_acamera_info_supported_hardware_level(0);
}
impl acamera_metadata_enum_acamera_info_supported_hardware_level {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_FULL:
        acamera_metadata_enum_acamera_info_supported_hardware_level =
        acamera_metadata_enum_acamera_info_supported_hardware_level(1);
}
impl acamera_metadata_enum_acamera_info_supported_hardware_level {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY:
        acamera_metadata_enum_acamera_info_supported_hardware_level =
        acamera_metadata_enum_acamera_info_supported_hardware_level(2);
}
impl acamera_metadata_enum_acamera_info_supported_hardware_level {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_3:
        acamera_metadata_enum_acamera_info_supported_hardware_level =
        acamera_metadata_enum_acamera_info_supported_hardware_level(3);
}
impl acamera_metadata_enum_acamera_info_supported_hardware_level {
    pub const ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL:
        acamera_metadata_enum_acamera_info_supported_hardware_level =
        acamera_metadata_enum_acamera_info_supported_hardware_level(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_info_supported_hardware_level(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_info_supported_hardware_level as acamera_metadata_enum_android_info_supported_hardware_level_t;
impl acamera_metadata_enum_acamera_black_level_lock {
    pub const ACAMERA_BLACK_LEVEL_LOCK_OFF: acamera_metadata_enum_acamera_black_level_lock =
        acamera_metadata_enum_acamera_black_level_lock(0);
}
impl acamera_metadata_enum_acamera_black_level_lock {
    pub const ACAMERA_BLACK_LEVEL_LOCK_ON: acamera_metadata_enum_acamera_black_level_lock =
        acamera_metadata_enum_acamera_black_level_lock(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_black_level_lock(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_black_level_lock as acamera_metadata_enum_android_black_level_lock_t;
impl acamera_metadata_enum_acamera_sync_frame_number {
    pub const ACAMERA_SYNC_FRAME_NUMBER_CONVERGING:
        acamera_metadata_enum_acamera_sync_frame_number =
        acamera_metadata_enum_acamera_sync_frame_number(-1);
}
impl acamera_metadata_enum_acamera_sync_frame_number {
    pub const ACAMERA_SYNC_FRAME_NUMBER_UNKNOWN: acamera_metadata_enum_acamera_sync_frame_number =
        acamera_metadata_enum_acamera_sync_frame_number(-2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sync_frame_number(pub ::std::os::raw::c_int);
pub use self::acamera_metadata_enum_acamera_sync_frame_number as acamera_metadata_enum_android_sync_frame_number_t;
impl acamera_metadata_enum_acamera_sync_max_latency {
    pub const ACAMERA_SYNC_MAX_LATENCY_PER_FRAME_CONTROL:
        acamera_metadata_enum_acamera_sync_max_latency =
        acamera_metadata_enum_acamera_sync_max_latency(0);
}
impl acamera_metadata_enum_acamera_sync_max_latency {
    pub const ACAMERA_SYNC_MAX_LATENCY_UNKNOWN: acamera_metadata_enum_acamera_sync_max_latency =
        acamera_metadata_enum_acamera_sync_max_latency(-1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_sync_max_latency(pub ::std::os::raw::c_int);
pub use self::acamera_metadata_enum_acamera_sync_max_latency as acamera_metadata_enum_android_sync_max_latency_t;
impl acamera_metadata_enum_acamera_depth_available_depth_stream_configurations {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations =
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_depth_available_depth_stream_configurations {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations =
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_depth_available_depth_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_depth_available_depth_stream_configurations as acamera_metadata_enum_android_depth_available_depth_stream_configurations_t;
impl acamera_metadata_enum_acamera_depth_depth_is_exclusive {
    pub const ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_FALSE:
        acamera_metadata_enum_acamera_depth_depth_is_exclusive =
        acamera_metadata_enum_acamera_depth_depth_is_exclusive(0);
}
impl acamera_metadata_enum_acamera_depth_depth_is_exclusive {
    pub const ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_TRUE:
        acamera_metadata_enum_acamera_depth_depth_is_exclusive =
        acamera_metadata_enum_acamera_depth_depth_is_exclusive(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_depth_depth_is_exclusive(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_depth_depth_is_exclusive as acamera_metadata_enum_android_depth_depth_is_exclusive_t;
impl acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations =
        acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations {
    pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations =
        acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations as acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_t;
impl acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT:
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution(
            0,
        );
}
impl acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution {
    pub const ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT:
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution(
            1,
        );
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution as acamera_metadata_enum_android_depth_available_depth_stream_configurations_maximum_resolution_t;
impl acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution { pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT : acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution = acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution (0) ; }
impl acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution { pub const ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT : acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution = acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution (1) ; }
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution as acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_maximum_resolution_t;
impl acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE:
        acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type =
        acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type(0);
}
impl acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type {
    pub const ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED:
        acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type =
        acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type as acamera_metadata_enum_android_logical_multi_camera_sensor_sync_type_t;
impl acamera_metadata_enum_acamera_distortion_correction_mode {
    pub const ACAMERA_DISTORTION_CORRECTION_MODE_OFF:
        acamera_metadata_enum_acamera_distortion_correction_mode =
        acamera_metadata_enum_acamera_distortion_correction_mode(0);
}
impl acamera_metadata_enum_acamera_distortion_correction_mode {
    pub const ACAMERA_DISTORTION_CORRECTION_MODE_FAST:
        acamera_metadata_enum_acamera_distortion_correction_mode =
        acamera_metadata_enum_acamera_distortion_correction_mode(1);
}
impl acamera_metadata_enum_acamera_distortion_correction_mode {
    pub const ACAMERA_DISTORTION_CORRECTION_MODE_HIGH_QUALITY:
        acamera_metadata_enum_acamera_distortion_correction_mode =
        acamera_metadata_enum_acamera_distortion_correction_mode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_distortion_correction_mode(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_distortion_correction_mode as acamera_metadata_enum_android_distortion_correction_mode_t;
impl acamera_metadata_enum_acamera_heic_available_heic_stream_configurations {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations =
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_heic_available_heic_stream_configurations {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations =
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_heic_available_heic_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_heic_available_heic_stream_configurations as acamera_metadata_enum_android_heic_available_heic_stream_configurations_t;
impl acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT:
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution(
            0,
        );
}
impl acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution {
    pub const ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT:
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution =
        acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution(
            1,
        );
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution as acamera_metadata_enum_android_heic_available_heic_stream_configurations_maximum_resolution_t;
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_INTERIOR:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(0);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_OTHER:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(1);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_FRONT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(2);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_REAR:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(3);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_LEFT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(4);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(5);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_OTHER:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(6);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_FRONT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(7);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_REAR:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(8);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_LEFT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(9);
}
impl acamera_metadata_enum_acamera_automotive_location {
    pub const ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_RIGHT:
        acamera_metadata_enum_acamera_automotive_location =
        acamera_metadata_enum_acamera_automotive_location(10);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_automotive_location(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_automotive_location as acamera_metadata_enum_android_automotive_location_t;
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(0);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(1);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(2);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(3);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(4);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(5);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(6);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(7);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(8);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(9);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(10);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(11);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(12);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(13);
}
impl acamera_metadata_enum_acamera_automotive_lens_facing {
    pub const ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT:
        acamera_metadata_enum_acamera_automotive_lens_facing =
        acamera_metadata_enum_acamera_automotive_lens_facing(14);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_automotive_lens_facing(pub ::std::os::raw::c_uint);
pub use self::acamera_metadata_enum_acamera_automotive_lens_facing as acamera_metadata_enum_android_automotive_lens_facing_t;
impl acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS_OUTPUT:
        acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations =
        acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations(0);
}
impl acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS_INPUT:
        acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations =
        acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations as acamera_metadata_enum_android_jpegr_available_jpeg_r_stream_configurations_t;
impl acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT : acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution = acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution (0) ;
}
impl acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution {
    pub const ACAMERA_JPEGR_AVAILABLE_JPEG_R_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT : acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution = acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution (1) ;
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution(
    pub ::std::os::raw::c_uint,
);
pub use self::acamera_metadata_enum_acamera_jpegr_available_jpeg_r_stream_configurations_maximum_resolution as acamera_metadata_enum_android_jpegr_available_jpeg_r_stream_configurations_maximum_resolution_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraMetadata {
    _unused: [u8; 0],
}
pub const ACAMERA_TYPE_BYTE: _bindgen_ty_64 = 0;
pub const ACAMERA_TYPE_INT32: _bindgen_ty_64 = 1;
pub const ACAMERA_TYPE_FLOAT: _bindgen_ty_64 = 2;
pub const ACAMERA_TYPE_INT64: _bindgen_ty_64 = 3;
pub const ACAMERA_TYPE_DOUBLE: _bindgen_ty_64 = 4;
pub const ACAMERA_TYPE_RATIONAL: _bindgen_ty_64 = 5;
pub const ACAMERA_NUM_TYPES: _bindgen_ty_64 = 6;
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraMetadata_rational {
    pub numerator: i32,
    pub denominator: i32,
}
#[test]
fn bindgen_test_layout_ACameraMetadata_rational() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraMetadata_rational> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraMetadata_rational>(),
        8usize,
        concat!("Size of: ", stringify!(ACameraMetadata_rational))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraMetadata_rational>(),
        4usize,
        concat!("Alignment of ", stringify!(ACameraMetadata_rational))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_rational),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_rational),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ACameraMetadata_entry {
    pub tag: u32,
    pub type_: u8,
    pub count: u32,
    pub data: ACameraMetadata_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ACameraMetadata_entry__bindgen_ty_1 {
    pub u8_: *mut u8,
    pub i32_: *mut i32,
    pub f: *mut f32,
    pub i64_: *mut i64,
    pub d: *mut f64,
    pub r: *mut ACameraMetadata_rational,
}
#[test]
fn bindgen_test_layout_ACameraMetadata_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraMetadata_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraMetadata_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ACameraMetadata_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraMetadata_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
}
#[test]
fn bindgen_test_layout_ACameraMetadata_entry() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraMetadata_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraMetadata_entry>(),
        24usize,
        concat!("Size of: ", stringify!(ACameraMetadata_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraMetadata_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ACameraMetadata_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_entry),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ACameraMetadata_const_entry {
    pub tag: u32,
    pub type_: u8,
    pub count: u32,
    pub data: ACameraMetadata_const_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ACameraMetadata_const_entry__bindgen_ty_1 {
    pub u8_: *const u8,
    pub i32_: *const i32,
    pub f: *const f32,
    pub i64_: *const i64,
    pub d: *const f64,
    pub r: *const ACameraMetadata_rational,
}
#[test]
fn bindgen_test_layout_ACameraMetadata_const_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraMetadata_const_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraMetadata_const_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraMetadata_const_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
}
#[test]
fn bindgen_test_layout_ACameraMetadata_const_entry() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraMetadata_const_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraMetadata_const_entry>(),
        24usize,
        concat!("Size of: ", stringify!(ACameraMetadata_const_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraMetadata_const_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ACameraMetadata_const_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraMetadata_const_entry),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn ACameraMetadata_getConstEntry(
        metadata: *const ACameraMetadata,
        tag: u32,
        entry: *mut ACameraMetadata_const_entry,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraMetadata_getAllTags(
        metadata: *const ACameraMetadata,
        numEntries: *mut i32,
        tags: *mut *const u32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraMetadata_copy(src: *const ACameraMetadata) -> *mut ACameraMetadata;
}
extern "C" {
    pub fn ACameraMetadata_free(metadata: *mut ACameraMetadata);
}
extern "C" {
    pub fn ACameraMetadata_isLogicalMultiCamera(
        staticMetadata: *const ACameraMetadata,
        numPhysicalCameras: *mut usize,
        physicalCameraIds: *mut *const *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ACameraMetadata_fromCameraMetadata(
        env: *mut JNIEnv,
        cameraMetadata: jobject,
    ) -> *mut ACameraMetadata;
}
pub type ACameraWindowType = ANativeWindow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraOutputTargets {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraOutputTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACaptureRequest {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ACameraOutputTarget_create(
        window: *mut ACameraWindowType,
        output: *mut *mut ACameraOutputTarget,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraOutputTarget_free(output: *mut ACameraOutputTarget);
}
extern "C" {
    pub fn ACaptureRequest_addTarget(
        request: *mut ACaptureRequest,
        output: *const ACameraOutputTarget,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_removeTarget(
        request: *mut ACaptureRequest,
        output: *const ACameraOutputTarget,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_getConstEntry(
        request: *const ACaptureRequest,
        tag: u32,
        entry: *mut ACameraMetadata_const_entry,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_getAllTags(
        request: *const ACaptureRequest,
        numTags: *mut i32,
        tags: *mut *const u32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_u8(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const u8,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_i32(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const i32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_float(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const f32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_i64(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const i64,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_double(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const f64,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_rational(
        request: *mut ACaptureRequest,
        tag: u32,
        count: u32,
        data: *const ACameraMetadata_rational,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_free(request: *mut ACaptureRequest);
}
extern "C" {
    pub fn ACaptureRequest_setUserContext(
        request: *mut ACaptureRequest,
        context: *mut ::std::os::raw::c_void,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_getUserContext(
        request: *const ACaptureRequest,
        context: *mut *mut ::std::os::raw::c_void,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_copy(src: *const ACaptureRequest) -> *mut ACaptureRequest;
}
extern "C" {
    pub fn ACaptureRequest_getConstEntry_physicalCamera(
        request: *const ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        entry: *mut ACameraMetadata_const_entry,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_u8(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const u8,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_i32(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const i32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_float(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const f32,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_i64(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const i64,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_double(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const f64,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureRequest_setEntry_physicalCamera_rational(
        request: *mut ACaptureRequest,
        physicalId: *const ::std::os::raw::c_char,
        tag: u32,
        count: u32,
        data: *const ACameraMetadata_rational,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession {
    _unused: [u8; 0],
}
pub type ACameraCaptureSession_stateCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, session: *mut ACameraCaptureSession),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession_stateCallbacks {
    pub context: *mut ::std::os::raw::c_void,
    pub onClosed: ACameraCaptureSession_stateCallback,
    pub onReady: ACameraCaptureSession_stateCallback,
    pub onActive: ACameraCaptureSession_stateCallback,
}
#[test]
fn bindgen_test_layout_ACameraCaptureSession_stateCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureSession_stateCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureSession_stateCallbacks>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ACameraCaptureSession_stateCallbacks)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureSession_stateCallbacks>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraCaptureSession_stateCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_stateCallbacks),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onClosed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_stateCallbacks),
            "::",
            stringify!(onClosed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onReady) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_stateCallbacks),
            "::",
            stringify!(onReady)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onActive) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_stateCallbacks),
            "::",
            stringify!(onActive)
        )
    );
}
pub type ACameraCaptureSession_prepareCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        window: *mut ACameraWindowType,
        session: *mut ACameraCaptureSession,
    ),
>;
pub const CAPTURE_FAILURE_REASON_FLUSHED: _bindgen_ty_65 = 0;
pub const CAPTURE_FAILURE_REASON_ERROR: _bindgen_ty_65 = 1;
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureFailure {
    pub frameNumber: i64,
    pub reason: ::std::os::raw::c_int,
    pub sequenceId: ::std::os::raw::c_int,
    pub wasImageCaptured: bool,
}
#[test]
fn bindgen_test_layout_ACameraCaptureFailure() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureFailure> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureFailure>(),
        24usize,
        concat!("Size of: ", stringify!(ACameraCaptureFailure))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureFailure>(),
        8usize,
        concat!("Alignment of ", stringify!(ACameraCaptureFailure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureFailure),
            "::",
            stringify!(frameNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureFailure),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequenceId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureFailure),
            "::",
            stringify!(sequenceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wasImageCaptured) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureFailure),
            "::",
            stringify!(wasImageCaptured)
        )
    );
}
pub type ACameraCaptureSession_captureCallback_start = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *const ACaptureRequest,
        timestamp: i64,
    ),
>;
pub type ACameraCaptureSession_captureCallback_result = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *mut ACaptureRequest,
        result: *const ACameraMetadata,
    ),
>;
pub type ACameraCaptureSession_captureCallback_failed = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *mut ACaptureRequest,
        failure: *mut ACameraCaptureFailure,
    ),
>;
pub type ACameraCaptureSession_captureCallback_sequenceEnd = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        sequenceId: ::std::os::raw::c_int,
        frameNumber: i64,
    ),
>;
pub type ACameraCaptureSession_captureCallback_sequenceAbort = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        sequenceId: ::std::os::raw::c_int,
    ),
>;
pub type ACameraCaptureSession_captureCallback_bufferLost = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *mut ACaptureRequest,
        window: *mut ACameraWindowType,
        frameNumber: i64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession_captureCallbacks {
    pub context: *mut ::std::os::raw::c_void,
    pub onCaptureStarted: ACameraCaptureSession_captureCallback_start,
    pub onCaptureProgressed: ACameraCaptureSession_captureCallback_result,
    pub onCaptureCompleted: ACameraCaptureSession_captureCallback_result,
    pub onCaptureFailed: ACameraCaptureSession_captureCallback_failed,
    pub onCaptureSequenceCompleted: ACameraCaptureSession_captureCallback_sequenceEnd,
    pub onCaptureSequenceAborted: ACameraCaptureSession_captureCallback_sequenceAbort,
    pub onCaptureBufferLost: ACameraCaptureSession_captureCallback_bufferLost,
}
#[test]
fn bindgen_test_layout_ACameraCaptureSession_captureCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureSession_captureCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureSession_captureCallbacks>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ACameraCaptureSession_captureCallbacks)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureSession_captureCallbacks>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraCaptureSession_captureCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureStarted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureStarted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureProgressed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureProgressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureCompleted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureFailed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceCompleted) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureSequenceCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceAborted) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureSequenceAborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureBufferLost) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacks),
            "::",
            stringify!(onCaptureBufferLost)
        )
    );
}
pub const CAPTURE_SEQUENCE_ID_NONE: _bindgen_ty_66 = -1;
pub type _bindgen_ty_66 = ::std::os::raw::c_int;
extern "C" {
    pub fn ACameraCaptureSession_close(session: *mut ACameraCaptureSession);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraDevice {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ACameraCaptureSession_getDevice(
        session: *mut ACameraCaptureSession,
        device: *mut *mut ACameraDevice,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_capture(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_captureCallbacks,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_setRepeatingRequest(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_captureCallbacks,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_stopRepeating(
        session: *mut ACameraCaptureSession,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_abortCaptures(
        session: *mut ACameraCaptureSession,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACaptureSessionOutput {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ACameraCaptureSession_updateSharedOutput(
        session: *mut ACameraCaptureSession,
        output: *mut ACaptureSessionOutput,
    ) -> camera_status_t;
}
pub type ACameraCaptureSession_logicalCamera_captureCallback_result = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *mut ACaptureRequest,
        result: *const ACameraMetadata,
        physicalResultCount: usize,
        physicalCameraIds: *mut *const ::std::os::raw::c_char,
        physicalResults: *mut *const ACameraMetadata,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALogicalCameraCaptureFailure {
    pub captureFailure: ACameraCaptureFailure,
    pub physicalCameraId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ALogicalCameraCaptureFailure() {
    const UNINIT: ::std::mem::MaybeUninit<ALogicalCameraCaptureFailure> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ALogicalCameraCaptureFailure>(),
        32usize,
        concat!("Size of: ", stringify!(ALogicalCameraCaptureFailure))
    );
    assert_eq!(
        ::std::mem::align_of::<ALogicalCameraCaptureFailure>(),
        8usize,
        concat!("Alignment of ", stringify!(ALogicalCameraCaptureFailure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).captureFailure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ALogicalCameraCaptureFailure),
            "::",
            stringify!(captureFailure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalCameraId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ALogicalCameraCaptureFailure),
            "::",
            stringify!(physicalCameraId)
        )
    );
}
pub type ACameraCaptureSession_logicalCamera_captureCallback_failed = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *mut ACaptureRequest,
        failure: *mut ALogicalCameraCaptureFailure,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession_logicalCamera_captureCallbacks {
    pub context: *mut ::std::os::raw::c_void,
    pub onCaptureStarted: ACameraCaptureSession_captureCallback_start,
    pub onCaptureProgressed: ACameraCaptureSession_captureCallback_result,
    pub onLogicalCameraCaptureCompleted: ACameraCaptureSession_logicalCamera_captureCallback_result,
    pub onLogicalCameraCaptureFailed: ACameraCaptureSession_logicalCamera_captureCallback_failed,
    pub onCaptureSequenceCompleted: ACameraCaptureSession_captureCallback_sequenceEnd,
    pub onCaptureSequenceAborted: ACameraCaptureSession_captureCallback_sequenceAbort,
    pub onCaptureBufferLost: ACameraCaptureSession_captureCallback_bufferLost,
}
#[test]
fn bindgen_test_layout_ACameraCaptureSession_logicalCamera_captureCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureSession_logicalCamera_captureCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureSession_logicalCamera_captureCallbacks>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureSession_logicalCamera_captureCallbacks>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureStarted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onCaptureStarted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureProgressed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onCaptureProgressed)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).onLogicalCameraCaptureCompleted) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onLogicalCameraCaptureCompleted)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).onLogicalCameraCaptureFailed) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onLogicalCameraCaptureFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceCompleted) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onCaptureSequenceCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceAborted) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onCaptureSequenceAborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureBufferLost) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacks),
            "::",
            stringify!(onCaptureBufferLost)
        )
    );
}
extern "C" {
    pub fn ACameraCaptureSession_logicalCamera_capture(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_logicalCamera_captureCallbacks,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_logicalCamera_setRepeatingRequest(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_logicalCamera_captureCallbacks,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
pub type ACameraCaptureSession_captureCallback_startV2 = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        session: *mut ACameraCaptureSession,
        request: *const ACaptureRequest,
        timestamp: i64,
        frameNumber: i64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession_captureCallbacksV2 {
    pub context: *mut ::std::os::raw::c_void,
    pub onCaptureStarted: ACameraCaptureSession_captureCallback_startV2,
    pub onCaptureProgressed: ACameraCaptureSession_captureCallback_result,
    pub onCaptureCompleted: ACameraCaptureSession_captureCallback_result,
    pub onCaptureFailed: ACameraCaptureSession_captureCallback_failed,
    pub onCaptureSequenceCompleted: ACameraCaptureSession_captureCallback_sequenceEnd,
    pub onCaptureSequenceAborted: ACameraCaptureSession_captureCallback_sequenceAbort,
    pub onCaptureBufferLost: ACameraCaptureSession_captureCallback_bufferLost,
}
#[test]
fn bindgen_test_layout_ACameraCaptureSession_captureCallbacksV2() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureSession_captureCallbacksV2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureSession_captureCallbacksV2>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureSession_captureCallbacksV2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraCaptureSession_captureCallbacksV2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureStarted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureStarted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureProgressed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureProgressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureCompleted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureFailed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceCompleted) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureSequenceCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceAborted) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureSequenceAborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureBufferLost) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_captureCallbacksV2),
            "::",
            stringify!(onCaptureBufferLost)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraCaptureSession_logicalCamera_captureCallbacksV2 {
    pub context: *mut ::std::os::raw::c_void,
    pub onCaptureStarted: ACameraCaptureSession_captureCallback_startV2,
    pub onCaptureProgressed: ACameraCaptureSession_captureCallback_result,
    pub onLogicalCameraCaptureCompleted: ACameraCaptureSession_logicalCamera_captureCallback_result,
    pub onLogicalCameraCaptureFailed: ACameraCaptureSession_logicalCamera_captureCallback_failed,
    pub onCaptureSequenceCompleted: ACameraCaptureSession_captureCallback_sequenceEnd,
    pub onCaptureSequenceAborted: ACameraCaptureSession_captureCallback_sequenceAbort,
    pub onCaptureBufferLost: ACameraCaptureSession_captureCallback_bufferLost,
}
#[test]
fn bindgen_test_layout_ACameraCaptureSession_logicalCamera_captureCallbacksV2() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraCaptureSession_logicalCamera_captureCallbacksV2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraCaptureSession_logicalCamera_captureCallbacksV2>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraCaptureSession_logicalCamera_captureCallbacksV2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureStarted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onCaptureStarted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureProgressed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onCaptureProgressed)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).onLogicalCameraCaptureCompleted) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onLogicalCameraCaptureCompleted)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).onLogicalCameraCaptureFailed) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onLogicalCameraCaptureFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceCompleted) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onCaptureSequenceCompleted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureSequenceAborted) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onCaptureSequenceAborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCaptureBufferLost) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraCaptureSession_logicalCamera_captureCallbacksV2),
            "::",
            stringify!(onCaptureBufferLost)
        )
    );
}
extern "C" {
    pub fn ACameraCaptureSession_captureV2(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_captureCallbacksV2,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_setRepeatingRequestV2(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_captureCallbacksV2,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_logicalCamera_captureV2(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_logicalCamera_captureCallbacksV2,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_logicalCamera_setRepeatingRequestV2(
        session: *mut ACameraCaptureSession,
        callbacks: *mut ACameraCaptureSession_logicalCamera_captureCallbacksV2,
        numRequests: ::std::os::raw::c_int,
        requests: *mut *mut ACaptureRequest,
        captureSequenceId: *mut ::std::os::raw::c_int,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_setWindowPreparedCallback(
        session: *mut ACameraCaptureSession,
        context: *mut ::std::os::raw::c_void,
        callback: ACameraCaptureSession_prepareCallback,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraCaptureSession_prepareWindow(
        session: *mut ACameraCaptureSession,
        window: *mut ACameraWindowType,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraIdList {
    pub numCameras: ::std::os::raw::c_int,
    pub cameraIds: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ACameraIdList() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraIdList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraIdList>(),
        16usize,
        concat!("Size of: ", stringify!(ACameraIdList))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraIdList>(),
        8usize,
        concat!("Alignment of ", stringify!(ACameraIdList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCameras) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraIdList),
            "::",
            stringify!(numCameras)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cameraIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraIdList),
            "::",
            stringify!(cameraIds)
        )
    );
}
pub const ERROR_CAMERA_IN_USE: _bindgen_ty_67 = 1;
pub const ERROR_MAX_CAMERAS_IN_USE: _bindgen_ty_67 = 2;
pub const ERROR_CAMERA_DISABLED: _bindgen_ty_67 = 3;
pub const ERROR_CAMERA_DEVICE: _bindgen_ty_67 = 4;
pub const ERROR_CAMERA_SERVICE: _bindgen_ty_67 = 5;
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub type ACameraDevice_StateCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, device: *mut ACameraDevice),
>;
pub type ACameraDevice_ErrorStateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        device: *mut ACameraDevice,
        error: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraDevice_StateCallbacks {
    pub context: *mut ::std::os::raw::c_void,
    pub onDisconnected: ACameraDevice_StateCallback,
    pub onError: ACameraDevice_ErrorStateCallback,
}
#[test]
fn bindgen_test_layout_ACameraDevice_StateCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraDevice_StateCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraDevice_StateCallbacks>(),
        24usize,
        concat!("Size of: ", stringify!(ACameraDevice_StateCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraDevice_StateCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(ACameraDevice_StateCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraDevice_StateCallbacks),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onDisconnected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraDevice_StateCallbacks),
            "::",
            stringify!(onDisconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onError) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraDevice_StateCallbacks),
            "::",
            stringify!(onError)
        )
    );
}
pub type ACameraDevice_stateCallbacks = ACameraDevice_StateCallbacks;
extern "C" {
    pub fn ACameraDevice_close(device: *mut ACameraDevice) -> camera_status_t;
}
extern "C" {
    pub fn ACameraDevice_getId(device: *const ACameraDevice) -> *const ::std::os::raw::c_char;
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_PREVIEW: ACameraDevice_request_template = ACameraDevice_request_template(1);
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_STILL_CAPTURE: ACameraDevice_request_template =
        ACameraDevice_request_template(2);
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_RECORD: ACameraDevice_request_template = ACameraDevice_request_template(3);
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_VIDEO_SNAPSHOT: ACameraDevice_request_template =
        ACameraDevice_request_template(4);
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_ZERO_SHUTTER_LAG: ACameraDevice_request_template =
        ACameraDevice_request_template(5);
}
impl ACameraDevice_request_template {
    pub const TEMPLATE_MANUAL: ACameraDevice_request_template = ACameraDevice_request_template(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ACameraDevice_request_template(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn ACameraDevice_createCaptureRequest(
        device: *const ACameraDevice,
        templateId: ACameraDevice_request_template,
        request: *mut *mut ACaptureRequest,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACaptureSessionOutputContainer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ACaptureSessionOutputContainer_create(
        container: *mut *mut ACaptureSessionOutputContainer,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionOutputContainer_free(container: *mut ACaptureSessionOutputContainer);
}
extern "C" {
    pub fn ACaptureSessionOutput_create(
        anw: *mut ACameraWindowType,
        output: *mut *mut ACaptureSessionOutput,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionOutput_free(output: *mut ACaptureSessionOutput);
}
extern "C" {
    pub fn ACaptureSessionOutputContainer_add(
        container: *mut ACaptureSessionOutputContainer,
        output: *const ACaptureSessionOutput,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionOutputContainer_remove(
        container: *mut ACaptureSessionOutputContainer,
        output: *const ACaptureSessionOutput,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraDevice_createCaptureSession(
        device: *mut ACameraDevice,
        outputs: *const ACaptureSessionOutputContainer,
        callbacks: *const ACameraCaptureSession_stateCallbacks,
        session: *mut *mut ACameraCaptureSession,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionSharedOutput_create(
        anw: *mut ACameraWindowType,
        output: *mut *mut ACaptureSessionOutput,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionSharedOutput_add(
        output: *mut ACaptureSessionOutput,
        anw: *mut ACameraWindowType,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionSharedOutput_remove(
        output: *mut ACaptureSessionOutput,
        anw: *mut ACameraWindowType,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraDevice_createCaptureSessionWithSessionParameters(
        device: *mut ACameraDevice,
        outputs: *const ACaptureSessionOutputContainer,
        sessionParameters: *const ACaptureRequest,
        callbacks: *const ACameraCaptureSession_stateCallbacks,
        session: *mut *mut ACameraCaptureSession,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACaptureSessionPhysicalOutput_create(
        anw: *mut ACameraWindowType,
        physicalId: *const ::std::os::raw::c_char,
        output: *mut *mut ACaptureSessionOutput,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraDevice_createCaptureRequest_withPhysicalIds(
        device: *const ACameraDevice,
        templateId: ACameraDevice_request_template,
        physicalIdList: *const ACameraIdList,
        request: *mut *mut ACaptureRequest,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraDevice_isSessionConfigurationSupported(
        device: *const ACameraDevice,
        sessionOutputContainer: *const ACaptureSessionOutputContainer,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraManager {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ACameraManager_create() -> *mut ACameraManager;
}
extern "C" {
    pub fn ACameraManager_delete(manager: *mut ACameraManager);
}
extern "C" {
    pub fn ACameraManager_getCameraIdList(
        manager: *mut ACameraManager,
        cameraIdList: *mut *mut ACameraIdList,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraManager_deleteCameraIdList(cameraIdList: *mut ACameraIdList);
}
pub type ACameraManager_AvailabilityCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        cameraId: *const ::std::os::raw::c_char,
    ),
>;
pub type ACameraManager_PhysicalCameraAvailabilityCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        cameraId: *const ::std::os::raw::c_char,
        physicalCameraId: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraManager_AvailabilityListener {
    pub context: *mut ::std::os::raw::c_void,
    pub onCameraAvailable: ACameraManager_AvailabilityCallback,
    pub onCameraUnavailable: ACameraManager_AvailabilityCallback,
}
#[test]
fn bindgen_test_layout_ACameraManager_AvailabilityListener() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraManager_AvailabilityListener> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraManager_AvailabilityListener>(),
        24usize,
        concat!("Size of: ", stringify!(ACameraManager_AvailabilityListener))
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraManager_AvailabilityListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraManager_AvailabilityListener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_AvailabilityListener),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCameraAvailable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_AvailabilityListener),
            "::",
            stringify!(onCameraAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCameraUnavailable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_AvailabilityListener),
            "::",
            stringify!(onCameraUnavailable)
        )
    );
}
pub type ACameraManager_AvailabilityCallbacks = ACameraManager_AvailabilityListener;
extern "C" {
    pub fn ACameraManager_registerAvailabilityCallback(
        manager: *mut ACameraManager,
        callback: *const ACameraManager_AvailabilityCallbacks,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraManager_unregisterAvailabilityCallback(
        manager: *mut ACameraManager,
        callback: *const ACameraManager_AvailabilityCallbacks,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraManager_getCameraCharacteristics(
        manager: *mut ACameraManager,
        cameraId: *const ::std::os::raw::c_char,
        characteristics: *mut *mut ACameraMetadata,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraManager_openCamera(
        manager: *mut ACameraManager,
        cameraId: *const ::std::os::raw::c_char,
        callback: *mut ACameraDevice_StateCallbacks,
        device: *mut *mut ACameraDevice,
    ) -> camera_status_t;
}
pub type ACameraManager_AccessPrioritiesChangedCallback =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACameraManager_ExtendedAvailabilityListener {
    pub availabilityCallbacks: ACameraManager_AvailabilityCallbacks,
    pub onCameraAccessPrioritiesChanged: ACameraManager_AccessPrioritiesChangedCallback,
    pub onPhysicalCameraAvailable: ACameraManager_PhysicalCameraAvailabilityCallback,
    pub onPhysicalCameraUnavailable: ACameraManager_PhysicalCameraAvailabilityCallback,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_ACameraManager_ExtendedAvailabilityListener() {
    const UNINIT: ::std::mem::MaybeUninit<ACameraManager_ExtendedAvailabilityListener> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACameraManager_ExtendedAvailabilityListener>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ACameraManager_ExtendedAvailabilityListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ACameraManager_ExtendedAvailabilityListener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).availabilityCallbacks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener),
            "::",
            stringify!(availabilityCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).onCameraAccessPrioritiesChanged) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener),
            "::",
            stringify!(onCameraAccessPrioritiesChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onPhysicalCameraAvailable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener),
            "::",
            stringify!(onPhysicalCameraAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onPhysicalCameraUnavailable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener),
            "::",
            stringify!(onPhysicalCameraUnavailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACameraManager_ExtendedAvailabilityListener),
            "::",
            stringify!(reserved)
        )
    );
}
pub type ACameraManager_ExtendedAvailabilityCallbacks = ACameraManager_ExtendedAvailabilityListener;
extern "C" {
    pub fn ACameraManager_registerExtendedAvailabilityCallback(
        manager: *mut ACameraManager,
        callback: *const ACameraManager_ExtendedAvailabilityCallbacks,
    ) -> camera_status_t;
}
extern "C" {
    pub fn ACameraManager_unregisterExtendedAvailabilityCallback(
        manager: *mut ACameraManager,
        callback: *const ACameraManager_ExtendedAvailabilityCallbacks,
    ) -> camera_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImage {
    _unused: [u8; 0],
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RGBA_8888: AIMAGE_FORMATS = AIMAGE_FORMATS(1);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RGBX_8888: AIMAGE_FORMATS = AIMAGE_FORMATS(2);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RGB_888: AIMAGE_FORMATS = AIMAGE_FORMATS(3);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RGB_565: AIMAGE_FORMATS = AIMAGE_FORMATS(4);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RGBA_FP16: AIMAGE_FORMATS = AIMAGE_FORMATS(22);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_YUV_420_888: AIMAGE_FORMATS = AIMAGE_FORMATS(35);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_JPEG: AIMAGE_FORMATS = AIMAGE_FORMATS(256);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RAW16: AIMAGE_FORMATS = AIMAGE_FORMATS(32);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RAW_PRIVATE: AIMAGE_FORMATS = AIMAGE_FORMATS(36);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RAW10: AIMAGE_FORMATS = AIMAGE_FORMATS(37);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_RAW12: AIMAGE_FORMATS = AIMAGE_FORMATS(38);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_DEPTH16: AIMAGE_FORMATS = AIMAGE_FORMATS(1144402265);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_DEPTH_POINT_CLOUD: AIMAGE_FORMATS = AIMAGE_FORMATS(257);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_PRIVATE: AIMAGE_FORMATS = AIMAGE_FORMATS(34);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_Y8: AIMAGE_FORMATS = AIMAGE_FORMATS(538982489);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_HEIC: AIMAGE_FORMATS = AIMAGE_FORMATS(1212500294);
}
impl AIMAGE_FORMATS {
    pub const AIMAGE_FORMAT_DEPTH_JPEG: AIMAGE_FORMATS = AIMAGE_FORMATS(1768253795);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AIMAGE_FORMATS(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageCropRect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_AImageCropRect() {
    const UNINIT: ::std::mem::MaybeUninit<AImageCropRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AImageCropRect>(),
        16usize,
        concat!("Size of: ", stringify!(AImageCropRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AImageCropRect>(),
        4usize,
        concat!("Alignment of ", stringify!(AImageCropRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageCropRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageCropRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageCropRect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageCropRect),
            "::",
            stringify!(bottom)
        )
    );
}
extern "C" {
    pub fn AImage_delete(image: *mut AImage);
}
extern "C" {
    pub fn AImage_getWidth(image: *const AImage, width: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImage_getHeight(image: *const AImage, height: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImage_getFormat(image: *const AImage, format: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImage_getCropRect(image: *const AImage, rect: *mut AImageCropRect) -> media_status_t;
}
extern "C" {
    pub fn AImage_getTimestamp(image: *const AImage, timestampNs: *mut i64) -> media_status_t;
}
extern "C" {
    pub fn AImage_getNumberOfPlanes(image: *const AImage, numPlanes: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImage_getPlanePixelStride(
        image: *const AImage,
        planeIdx: ::std::os::raw::c_int,
        pixelStride: *mut i32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImage_getPlaneRowStride(
        image: *const AImage,
        planeIdx: ::std::os::raw::c_int,
        rowStride: *mut i32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImage_getPlaneData(
        image: *const AImage,
        planeIdx: ::std::os::raw::c_int,
        data: *mut *mut u8,
        dataLength: *mut ::std::os::raw::c_int,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImage_deleteAsync(image: *mut AImage, releaseFenceFd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AImage_getHardwareBuffer(
        image: *const AImage,
        buffer: *mut *mut AHardwareBuffer,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImage_getDataSpace(image: *const AImage, dataSpace: *mut i32) -> media_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageReader {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AImageReader_new(
        width: i32,
        height: i32,
        format: i32,
        maxImages: i32,
        reader: *mut *mut AImageReader,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_delete(reader: *mut AImageReader);
}
extern "C" {
    pub fn AImageReader_getWindow(
        reader: *mut AImageReader,
        window: *mut *mut ANativeWindow,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_getWidth(reader: *const AImageReader, width: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_getHeight(reader: *const AImageReader, height: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_getFormat(reader: *const AImageReader, format: *mut i32) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_getMaxImages(
        reader: *const AImageReader,
        maxImages: *mut i32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_acquireNextImage(
        reader: *mut AImageReader,
        image: *mut *mut AImage,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_acquireLatestImage(
        reader: *mut AImageReader,
        image: *mut *mut AImage,
    ) -> media_status_t;
}
pub type AImageReader_ImageCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, reader: *mut AImageReader),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageReader_ImageListener {
    pub context: *mut ::std::os::raw::c_void,
    pub onImageAvailable: AImageReader_ImageCallback,
}
#[test]
fn bindgen_test_layout_AImageReader_ImageListener() {
    const UNINIT: ::std::mem::MaybeUninit<AImageReader_ImageListener> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AImageReader_ImageListener>(),
        16usize,
        concat!("Size of: ", stringify!(AImageReader_ImageListener))
    );
    assert_eq!(
        ::std::mem::align_of::<AImageReader_ImageListener>(),
        8usize,
        concat!("Alignment of ", stringify!(AImageReader_ImageListener))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageReader_ImageListener),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onImageAvailable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageReader_ImageListener),
            "::",
            stringify!(onImageAvailable)
        )
    );
}
extern "C" {
    pub fn AImageReader_setImageListener(
        reader: *mut AImageReader,
        listener: *mut AImageReader_ImageListener,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_newWithUsage(
        width: i32,
        height: i32,
        format: i32,
        usage: u64,
        maxImages: i32,
        reader: *mut *mut AImageReader,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_newWithDataSpace(
        width: i32,
        height: i32,
        usage: u64,
        maxImages: i32,
        hardwareBufferFormat: u32,
        dataSpace: i32,
        reader: *mut *mut AImageReader,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_acquireNextImageAsync(
        reader: *mut AImageReader,
        image: *mut *mut AImage,
        acquireFenceFd: *mut ::std::os::raw::c_int,
    ) -> media_status_t;
}
extern "C" {
    pub fn AImageReader_acquireLatestImageAsync(
        reader: *mut AImageReader,
        image: *mut *mut AImage,
        acquireFenceFd: *mut ::std::os::raw::c_int,
    ) -> media_status_t;
}
pub type AImageReader_BufferRemovedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        reader: *mut AImageReader,
        buffer: *mut AHardwareBuffer,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AImageReader_BufferRemovedListener {
    pub context: *mut ::std::os::raw::c_void,
    pub onBufferRemoved: AImageReader_BufferRemovedCallback,
}
#[test]
fn bindgen_test_layout_AImageReader_BufferRemovedListener() {
    const UNINIT: ::std::mem::MaybeUninit<AImageReader_BufferRemovedListener> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AImageReader_BufferRemovedListener>(),
        16usize,
        concat!("Size of: ", stringify!(AImageReader_BufferRemovedListener))
    );
    assert_eq!(
        ::std::mem::align_of::<AImageReader_BufferRemovedListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AImageReader_BufferRemovedListener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageReader_BufferRemovedListener),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onBufferRemoved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AImageReader_BufferRemovedListener),
            "::",
            stringify!(onBufferRemoved)
        )
    );
}
extern "C" {
    pub fn AImageReader_setBufferRemovedListener(
        reader: *mut AImageReader,
        listener: *mut AImageReader_BufferRemovedListener,
    ) -> media_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaCrypto {
    _unused: [u8; 0],
}
pub type AMediaUUID = [u8; 16usize];
extern "C" {
    pub fn AMediaCrypto_isCryptoSchemeSupported(uuid: *mut u8) -> bool;
}
extern "C" {
    pub fn AMediaCrypto_requiresSecureDecoderComponent(mime: *const ::std::os::raw::c_char)
        -> bool;
}
extern "C" {
    pub fn AMediaCrypto_new(
        uuid: *mut u8,
        initData: *const ::std::os::raw::c_void,
        initDataSize: usize,
    ) -> *mut AMediaCrypto;
}
extern "C" {
    pub fn AMediaCrypto_delete(crypto: *mut AMediaCrypto);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaFormat {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AMediaFormat_new() -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaFormat_delete(arg1: *mut AMediaFormat) -> media_status_t;
}
extern "C" {
    pub fn AMediaFormat_toString(arg1: *mut AMediaFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AMediaFormat_getInt32(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut i32,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getInt64(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut i64,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getFloat(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getSize(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getBuffer(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getString(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_setInt32(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: i32,
    );
}
extern "C" {
    pub fn AMediaFormat_setInt64(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: i64,
    );
}
extern "C" {
    pub fn AMediaFormat_setFloat(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "C" {
    pub fn AMediaFormat_setString(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn AMediaFormat_setBuffer(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_DRC_ATTENUATION_FACTOR: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_DRC_BOOST_FACTOR: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_DRC_HEAVY_COMPRESSION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_DRC_TARGET_REFERENCE_LEVEL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_ENCODED_TARGET_LEVEL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_PROFILE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AAC_SBR_MODE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ALLOW_FRAME_DROP: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AUDIO_SESSION_ID: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_BITRATE_MODE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_BIT_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CAPTURE_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CHANNEL_COUNT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CHANNEL_MASK: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COLOR_FORMAT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COLOR_RANGE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COLOR_STANDARD: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COLOR_TRANSFER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COMPLEXITY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD_0: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD_1: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD_2: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DISPLAY_CROP: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DISPLAY_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DISPLAY_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DURATION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_FLAC_COMPRESSION_LEVEL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_FRAME_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_GRID_COLUMNS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_GRID_ROWS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_HDR_STATIC_INFO: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IMPORTANCE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_INTRA_REFRESH_PERIOD: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IS_ADTS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IS_AUTOSELECT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IS_DEFAULT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IS_FORCED_SUBTITLE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_I_FRAME_INTERVAL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LANGUAGE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LATENCY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LEVEL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_B_FRAMES: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_INPUT_SIZE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_BUFFER_BATCH_MAX_OUTPUT_SIZE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_BUFFER_BATCH_THRESHOLD_OUTPUT_SIZE:
        *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MIME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MPEG_USER_DATA: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_OPERATING_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PCM_ENCODING: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PRIORITY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PROFILE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PUSH_BLANK_BUFFERS_ON_STOP: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_REPEAT_PREVIOUS_FRAME_AFTER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ROTATION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SAMPLE_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SEI: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SLICE_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_STRIDE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TEMPORAL_LAYER_ID: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TEMPORAL_LAYERING: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TILE_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TILE_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TIME_US: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TRACK_ID: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TRACK_INDEX: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AMediaFormat_getDouble(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_getRect(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        left: *mut i32,
        top: *mut i32,
        right: *mut i32,
        bottom: *mut i32,
    ) -> bool;
}
extern "C" {
    pub fn AMediaFormat_setDouble(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: f64,
    );
}
extern "C" {
    pub fn AMediaFormat_setSize(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        value: usize,
    );
}
extern "C" {
    pub fn AMediaFormat_setRect(
        arg1: *mut AMediaFormat,
        name: *const ::std::os::raw::c_char,
        left: i32,
        top: i32,
        right: i32,
        bottom: i32,
    );
}
extern "C" {
    pub fn AMediaFormat_clear(arg1: *mut AMediaFormat);
}
extern "C" {
    pub fn AMediaFormat_copy(to: *mut AMediaFormat, from: *mut AMediaFormat) -> media_status_t;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ALBUM: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ALBUMART: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ALBUMARTIST: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ARTIST: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AUDIO_PRESENTATION_INFO: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AUDIO_PRESENTATION_PRESENTATION_ID:
        *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AUDIO_PRESENTATION_PROGRAM_ID: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_AUTHOR: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_BITS_PER_SAMPLE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CDTRACKNUMBER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COMPILATION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_COMPOSER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CREATE_INPUT_SURFACE_SUSPENDED: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_DEFAULT_IV_SIZE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_BYTE_BLOCK: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_SIZES: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_IV: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_KEY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_MODE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_PLAIN_SIZES: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CRYPTO_SKIP_BYTE_BLOCK: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD_AVC: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_CSD_HEVC: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_D263: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_DISCNUMBER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ENCODER_DELAY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ENCODER_PADDING: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ESDS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_EXIF_OFFSET: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_EXIF_SIZE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_FRAME_COUNT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_GENRE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_HAPTIC_CHANNEL_COUNT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_ICC_PROFILE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_IS_SYNC_FRAME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LOCATION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LOOP: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LYRICIST: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MANUFACTURER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_BIT_RATE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_FPS_TO_ENCODER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MAX_PTS_GAP_TO_ENCODER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MPEG2_STREAM_HEADER: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PCM_BIG_ENDIAN: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PSSH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SAR_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SAR_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TARGET_TIME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TEMPORAL_LAYER_COUNT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TEXT_FORMAT_DATA: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_THUMBNAIL_CSD_HEVC: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_THUMBNAIL_HEIGHT: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_THUMBNAIL_TIME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_THUMBNAIL_WIDTH: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_TITLE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_VALID_SAMPLES: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_YEAR: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LOW_LATENCY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_HDR10_PLUS_INFO: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SLOW_MOTION_MARKERS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_THUMBNAIL_CSD_AV1C: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_XMP_OFFSET: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_XMP_SIZE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SAMPLE_FILE_OFFSET: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_LAST_SAMPLE_INDEX_IN_CHUNK: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_SAMPLE_TIME_BEFORE_APPEND: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_PICTURE_TYPE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_VIDEO_ENCODING_STATISTICS_LEVEL: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_VIDEO_QP_AVERAGE: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_B_MAX: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_B_MIN: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_I_MAX: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_I_MIN: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_MAX: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_MIN: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_P_MAX: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_VIDEO_QP_P_MIN: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MPEGH_COMPATIBLE_SETS: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MPEGH_PROFILE_LEVEL_INDICATION: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIAFORMAT_KEY_MPEGH_REFERENCE_CHANNEL_LAYOUT: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaCodec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaCodecBufferInfo {
    pub offset: i32,
    pub size: i32,
    pub presentationTimeUs: i64,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_AMediaCodecBufferInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AMediaCodecBufferInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMediaCodecBufferInfo>(),
        24usize,
        concat!("Size of: ", stringify!(AMediaCodecBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AMediaCodecBufferInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AMediaCodecBufferInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecBufferInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecBufferInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presentationTimeUs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecBufferInfo),
            "::",
            stringify!(presentationTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecBufferInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaCodecCryptoInfo {
    _unused: [u8; 0],
}
pub const AMEDIACODEC_BUFFER_FLAG_KEY_FRAME: _bindgen_ty_68 = 1;
pub const AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG: _bindgen_ty_68 = 2;
pub const AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM: _bindgen_ty_68 = 4;
pub const AMEDIACODEC_BUFFER_FLAG_PARTIAL_FRAME: _bindgen_ty_68 = 8;
pub const AMEDIACODEC_BUFFER_FLAG_MUXER_DATA: _bindgen_ty_68 = 16;
pub const AMEDIACODEC_BUFFER_FLAG_DECODE_ONLY: _bindgen_ty_68 = 32;
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const AMEDIACODEC_CONFIGURE_FLAG_ENCODE: _bindgen_ty_69 = 1;
pub const AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED: _bindgen_ty_69 = -3;
pub const AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED: _bindgen_ty_69 = -2;
pub const AMEDIACODEC_INFO_TRY_AGAIN_LATER: _bindgen_ty_69 = -1;
pub type _bindgen_ty_69 = ::std::os::raw::c_int;
pub type AMediaCodecOnAsyncInputAvailable = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut AMediaCodec,
        userdata: *mut ::std::os::raw::c_void,
        index: i32,
    ),
>;
pub type AMediaCodecOnAsyncOutputAvailable = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut AMediaCodec,
        userdata: *mut ::std::os::raw::c_void,
        index: i32,
        bufferInfo: *mut AMediaCodecBufferInfo,
    ),
>;
pub type AMediaCodecOnAsyncFormatChanged = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut AMediaCodec,
        userdata: *mut ::std::os::raw::c_void,
        format: *mut AMediaFormat,
    ),
>;
pub type AMediaCodecOnAsyncError = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut AMediaCodec,
        userdata: *mut ::std::os::raw::c_void,
        error: media_status_t,
        actionCode: i32,
        detail: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaCodecOnAsyncNotifyCallback {
    pub onAsyncInputAvailable: AMediaCodecOnAsyncInputAvailable,
    pub onAsyncOutputAvailable: AMediaCodecOnAsyncOutputAvailable,
    pub onAsyncFormatChanged: AMediaCodecOnAsyncFormatChanged,
    pub onAsyncError: AMediaCodecOnAsyncError,
}
#[test]
fn bindgen_test_layout_AMediaCodecOnAsyncNotifyCallback() {
    const UNINIT: ::std::mem::MaybeUninit<AMediaCodecOnAsyncNotifyCallback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMediaCodecOnAsyncNotifyCallback>(),
        32usize,
        concat!("Size of: ", stringify!(AMediaCodecOnAsyncNotifyCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<AMediaCodecOnAsyncNotifyCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AMediaCodecOnAsyncNotifyCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onAsyncInputAvailable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecOnAsyncNotifyCallback),
            "::",
            stringify!(onAsyncInputAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onAsyncOutputAvailable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecOnAsyncNotifyCallback),
            "::",
            stringify!(onAsyncOutputAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onAsyncFormatChanged) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecOnAsyncNotifyCallback),
            "::",
            stringify!(onAsyncFormatChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onAsyncError) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaCodecOnAsyncNotifyCallback),
            "::",
            stringify!(onAsyncError)
        )
    );
}
pub type AMediaCodecOnFrameRendered = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut AMediaCodec,
        userdata: *mut ::std::os::raw::c_void,
        mediaTimeUs: i64,
        systemNano: i64,
    ),
>;
extern "C" {
    pub fn AMediaCodec_createCodecByName(name: *const ::std::os::raw::c_char) -> *mut AMediaCodec;
}
extern "C" {
    pub fn AMediaCodec_createDecoderByType(
        mime_type: *const ::std::os::raw::c_char,
    ) -> *mut AMediaCodec;
}
extern "C" {
    pub fn AMediaCodec_createEncoderByType(
        mime_type: *const ::std::os::raw::c_char,
    ) -> *mut AMediaCodec;
}
extern "C" {
    pub fn AMediaCodec_delete(arg1: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_configure(
        arg1: *mut AMediaCodec,
        format: *const AMediaFormat,
        surface: *mut ANativeWindow,
        crypto: *mut AMediaCrypto,
        flags: u32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_start(arg1: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_stop(arg1: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_flush(arg1: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_getInputBuffer(
        arg1: *mut AMediaCodec,
        idx: usize,
        out_size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn AMediaCodec_getOutputBuffer(
        arg1: *mut AMediaCodec,
        idx: usize,
        out_size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn AMediaCodec_dequeueInputBuffer(arg1: *mut AMediaCodec, timeoutUs: i64) -> isize;
}
extern "C" {
    pub fn __assert(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert2(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __function: *const ::std::os::raw::c_char,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn AMediaCodec_queueInputBuffer(
        arg1: *mut AMediaCodec,
        idx: usize,
        offset: off_t,
        size: usize,
        time: u64,
        flags: u32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_queueSecureInputBuffer(
        arg1: *mut AMediaCodec,
        idx: usize,
        offset: off_t,
        arg2: *mut AMediaCodecCryptoInfo,
        time: u64,
        flags: u32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_dequeueOutputBuffer(
        arg1: *mut AMediaCodec,
        info: *mut AMediaCodecBufferInfo,
        timeoutUs: i64,
    ) -> isize;
}
extern "C" {
    pub fn AMediaCodec_getOutputFormat(arg1: *mut AMediaCodec) -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaCodec_releaseOutputBuffer(
        arg1: *mut AMediaCodec,
        idx: usize,
        render: bool,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_setOutputSurface(
        arg1: *mut AMediaCodec,
        surface: *mut ANativeWindow,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_releaseOutputBufferAtTime(
        mData: *mut AMediaCodec,
        idx: usize,
        timestampNs: i64,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_createInputSurface(
        mData: *mut AMediaCodec,
        surface: *mut *mut ANativeWindow,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_createPersistentInputSurface(
        surface: *mut *mut ANativeWindow,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_setInputSurface(
        mData: *mut AMediaCodec,
        surface: *mut ANativeWindow,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_setParameters(
        mData: *mut AMediaCodec,
        params: *const AMediaFormat,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_signalEndOfInputStream(mData: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_getBufferFormat(arg1: *mut AMediaCodec, index: usize) -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaCodec_getName(
        arg1: *mut AMediaCodec,
        out_name: *mut *mut ::std::os::raw::c_char,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_releaseName(arg1: *mut AMediaCodec, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn AMediaCodec_setAsyncNotifyCallback(
        arg1: *mut AMediaCodec,
        callback: AMediaCodecOnAsyncNotifyCallback,
        userdata: *mut ::std::os::raw::c_void,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_setOnFrameRenderedCallback(
        arg1: *mut AMediaCodec,
        callback: AMediaCodecOnFrameRendered,
        userdata: *mut ::std::os::raw::c_void,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_releaseCrypto(arg1: *mut AMediaCodec) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodec_getInputFormat(arg1: *mut AMediaCodec) -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaCodecActionCode_isRecoverable(actionCode: i32) -> bool;
}
extern "C" {
    pub fn AMediaCodecActionCode_isTransient(actionCode: i32) -> bool;
}
impl cryptoinfo_mode_t {
    pub const AMEDIACODECRYPTOINFO_MODE_CLEAR: cryptoinfo_mode_t = cryptoinfo_mode_t(0);
}
impl cryptoinfo_mode_t {
    pub const AMEDIACODECRYPTOINFO_MODE_AES_CTR: cryptoinfo_mode_t = cryptoinfo_mode_t(1);
}
impl cryptoinfo_mode_t {
    pub const AMEDIACODECRYPTOINFO_MODE_AES_WV: cryptoinfo_mode_t = cryptoinfo_mode_t(2);
}
impl cryptoinfo_mode_t {
    pub const AMEDIACODECRYPTOINFO_MODE_AES_CBC: cryptoinfo_mode_t = cryptoinfo_mode_t(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cryptoinfo_mode_t(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cryptoinfo_pattern_t {
    pub encryptBlocks: i32,
    pub skipBlocks: i32,
}
#[test]
fn bindgen_test_layout_cryptoinfo_pattern_t() {
    const UNINIT: ::std::mem::MaybeUninit<cryptoinfo_pattern_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cryptoinfo_pattern_t>(),
        8usize,
        concat!("Size of: ", stringify!(cryptoinfo_pattern_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cryptoinfo_pattern_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cryptoinfo_pattern_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encryptBlocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cryptoinfo_pattern_t),
            "::",
            stringify!(encryptBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipBlocks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cryptoinfo_pattern_t),
            "::",
            stringify!(skipBlocks)
        )
    );
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_new(
        numsubsamples: ::std::os::raw::c_int,
        key: *mut u8,
        iv: *mut u8,
        mode: cryptoinfo_mode_t,
        clearbytes: *mut usize,
        encryptedbytes: *mut usize,
    ) -> *mut AMediaCodecCryptoInfo;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_delete(arg1: *mut AMediaCodecCryptoInfo) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_setPattern(
        info: *mut AMediaCodecCryptoInfo,
        pattern: *mut cryptoinfo_pattern_t,
    );
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getNumSubSamples(arg1: *mut AMediaCodecCryptoInfo) -> usize;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getKey(
        arg1: *mut AMediaCodecCryptoInfo,
        dst: *mut u8,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getIV(
        arg1: *mut AMediaCodecCryptoInfo,
        dst: *mut u8,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getMode(arg1: *mut AMediaCodecCryptoInfo) -> cryptoinfo_mode_t;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getClearBytes(
        arg1: *mut AMediaCodecCryptoInfo,
        dst: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaCodecCryptoInfo_getEncryptedBytes(
        arg1: *mut AMediaCodecCryptoInfo,
        dst: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_HDR10_PLUS_INFO: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_LOW_LATENCY: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_OFFSET_TIME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_REQUEST_SYNC_FRAME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_SUSPEND: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_SUSPEND_TIME: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut AMEDIACODEC_KEY_VIDEO_BITRATE: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaDataSource {
    _unused: [u8; 0],
}
pub type AMediaDataSourceReadAt = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        offset: off64_t,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type AMediaDataSourceGetSize =
    ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void) -> isize>;
pub type AMediaDataSourceClose =
    ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn AMediaDataSource_new() -> *mut AMediaDataSource;
}
pub type AMediaDataSourceGetAvailableSize = ::std::option::Option<
    unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, offset: off64_t) -> isize,
>;
extern "C" {
    pub fn AMediaDataSource_newUri(
        uri: *const ::std::os::raw::c_char,
        numheaders: ::std::os::raw::c_int,
        key_values: *const *const ::std::os::raw::c_char,
    ) -> *mut AMediaDataSource;
}
extern "C" {
    pub fn AMediaDataSource_delete(arg1: *mut AMediaDataSource);
}
extern "C" {
    pub fn AMediaDataSource_setUserdata(
        arg1: *mut AMediaDataSource,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AMediaDataSource_setReadAt(arg1: *mut AMediaDataSource, arg2: AMediaDataSourceReadAt);
}
extern "C" {
    pub fn AMediaDataSource_setGetSize(arg1: *mut AMediaDataSource, arg2: AMediaDataSourceGetSize);
}
extern "C" {
    pub fn AMediaDataSource_setClose(arg1: *mut AMediaDataSource, arg2: AMediaDataSourceClose);
}
extern "C" {
    pub fn AMediaDataSource_close(arg1: *mut AMediaDataSource);
}
extern "C" {
    pub fn AMediaDataSource_setGetAvailableSize(
        arg1: *mut AMediaDataSource,
        arg2: AMediaDataSourceGetAvailableSize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaDrm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaDrmByteArray {
    pub ptr: *const u8,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_AMediaDrmByteArray() {
    const UNINIT: ::std::mem::MaybeUninit<AMediaDrmByteArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMediaDrmByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(AMediaDrmByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<AMediaDrmByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(AMediaDrmByteArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmByteArray),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmByteArray),
            "::",
            stringify!(length)
        )
    );
}
pub type AMediaDrmSessionId = AMediaDrmByteArray;
pub type AMediaDrmScope = AMediaDrmByteArray;
pub type AMediaDrmKeySetId = AMediaDrmByteArray;
pub type AMediaDrmSecureStop = AMediaDrmByteArray;
pub type AMediaDrmKeyId = AMediaDrmByteArray;
impl AMediaDrmEventType {
    pub const EVENT_PROVISION_REQUIRED: AMediaDrmEventType = AMediaDrmEventType(1);
}
impl AMediaDrmEventType {
    pub const EVENT_KEY_REQUIRED: AMediaDrmEventType = AMediaDrmEventType(2);
}
impl AMediaDrmEventType {
    pub const EVENT_KEY_EXPIRED: AMediaDrmEventType = AMediaDrmEventType(3);
}
impl AMediaDrmEventType {
    pub const EVENT_VENDOR_DEFINED: AMediaDrmEventType = AMediaDrmEventType(4);
}
impl AMediaDrmEventType {
    pub const EVENT_SESSION_RECLAIMED: AMediaDrmEventType = AMediaDrmEventType(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMediaDrmEventType(pub ::std::os::raw::c_uint);
impl AMediaDrmKeyType {
    pub const KEY_TYPE_STREAMING: AMediaDrmKeyType = AMediaDrmKeyType(1);
}
impl AMediaDrmKeyType {
    pub const KEY_TYPE_OFFLINE: AMediaDrmKeyType = AMediaDrmKeyType(2);
}
impl AMediaDrmKeyType {
    pub const KEY_TYPE_RELEASE: AMediaDrmKeyType = AMediaDrmKeyType(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMediaDrmKeyType(pub ::std::os::raw::c_uint);
impl AMediaDrmKeyRequestType {
    pub const KEY_REQUEST_TYPE_INITIAL: AMediaDrmKeyRequestType = AMediaDrmKeyRequestType(0);
}
impl AMediaDrmKeyRequestType {
    pub const KEY_REQUEST_TYPE_RENEWAL: AMediaDrmKeyRequestType = AMediaDrmKeyRequestType(1);
}
impl AMediaDrmKeyRequestType {
    pub const KEY_REQUEST_TYPE_RELEASE: AMediaDrmKeyRequestType = AMediaDrmKeyRequestType(2);
}
impl AMediaDrmKeyRequestType {
    pub const KEY_REQUEST_TYPE_NONE: AMediaDrmKeyRequestType = AMediaDrmKeyRequestType(3);
}
impl AMediaDrmKeyRequestType {
    pub const KEY_REQUEST_TYPE_UPDATE: AMediaDrmKeyRequestType = AMediaDrmKeyRequestType(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMediaDrmKeyRequestType(pub i32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaDrmKeyValuePair {
    pub mKey: *const ::std::os::raw::c_char,
    pub mValue: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AMediaDrmKeyValuePair() {
    const UNINIT: ::std::mem::MaybeUninit<AMediaDrmKeyValuePair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMediaDrmKeyValuePair>(),
        16usize,
        concat!("Size of: ", stringify!(AMediaDrmKeyValuePair))
    );
    assert_eq!(
        ::std::mem::align_of::<AMediaDrmKeyValuePair>(),
        8usize,
        concat!("Alignment of ", stringify!(AMediaDrmKeyValuePair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmKeyValuePair),
            "::",
            stringify!(mKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmKeyValuePair),
            "::",
            stringify!(mValue)
        )
    );
}
pub type AMediaDrmKeyValue = AMediaDrmKeyValuePair;
impl AMediaKeyStatusType {
    pub const KEY_STATUS_TYPE_USABLE: AMediaKeyStatusType = AMediaKeyStatusType(0);
}
impl AMediaKeyStatusType {
    pub const KEY_STATUS_TYPE_EXPIRED: AMediaKeyStatusType = AMediaKeyStatusType(1);
}
impl AMediaKeyStatusType {
    pub const KEY_STATUS_TYPE_OUTPUTNOTALLOWED: AMediaKeyStatusType = AMediaKeyStatusType(2);
}
impl AMediaKeyStatusType {
    pub const KEY_STATUS_TYPE_STATUSPENDING: AMediaKeyStatusType = AMediaKeyStatusType(3);
}
impl AMediaKeyStatusType {
    pub const KEY_STATUS_TYPE_INTERNALERROR: AMediaKeyStatusType = AMediaKeyStatusType(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AMediaKeyStatusType(pub ::std::os::raw::c_uint);
pub use self::AMediaKeyStatusType as AMediaDrmKeyStatusType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaDrmKeyStatus {
    pub keyId: AMediaDrmKeyId,
    pub keyType: AMediaDrmKeyStatusType,
}
#[test]
fn bindgen_test_layout_AMediaDrmKeyStatus() {
    const UNINIT: ::std::mem::MaybeUninit<AMediaDrmKeyStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AMediaDrmKeyStatus>(),
        24usize,
        concat!("Size of: ", stringify!(AMediaDrmKeyStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<AMediaDrmKeyStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(AMediaDrmKeyStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmKeyStatus),
            "::",
            stringify!(keyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AMediaDrmKeyStatus),
            "::",
            stringify!(keyType)
        )
    );
}
pub type AMediaDrmEventListener = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        eventType: AMediaDrmEventType,
        extra: ::std::os::raw::c_int,
        data: *const u8,
        dataSize: usize,
    ),
>;
pub type AMediaDrmExpirationUpdateListener = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        expiryTimeInMS: i64,
    ),
>;
pub type AMediaDrmKeysChangeListener = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        keyStatus: *const AMediaDrmKeyStatus,
        numKeys: usize,
        hasNewUsableKey: bool,
    ),
>;
extern "C" {
    pub fn AMediaDrm_isCryptoSchemeSupported(
        uuid: *const u8,
        mimeType: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn AMediaDrm_createByUUID(uuid: *const u8) -> *mut AMediaDrm;
}
extern "C" {
    pub fn AMediaDrm_release(arg1: *mut AMediaDrm);
}
extern "C" {
    pub fn AMediaDrm_setOnEventListener(
        arg1: *mut AMediaDrm,
        listener: AMediaDrmEventListener,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_setOnExpirationUpdateListener(
        arg1: *mut AMediaDrm,
        listener: AMediaDrmExpirationUpdateListener,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_setOnKeysChangeListener(
        arg1: *mut AMediaDrm,
        listener: AMediaDrmKeysChangeListener,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_openSession(
        arg1: *mut AMediaDrm,
        sessionId: *mut AMediaDrmSessionId,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_closeSession(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getKeyRequest(
        arg1: *mut AMediaDrm,
        scope: *const AMediaDrmScope,
        init: *const u8,
        initSize: usize,
        mimeType: *const ::std::os::raw::c_char,
        keyType: AMediaDrmKeyType,
        optionalParameters: *const AMediaDrmKeyValue,
        numOptionalParameters: usize,
        keyRequest: *mut *const u8,
        keyRequestSize: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getKeyRequestWithDefaultUrlAndType(
        arg1: *mut AMediaDrm,
        scope: *const AMediaDrmScope,
        init: *const u8,
        initSize: usize,
        mimeType: *const ::std::os::raw::c_char,
        keyType: AMediaDrmKeyType,
        optionalParameters: *const AMediaDrmKeyValue,
        numOptionalParameters: usize,
        keyRequest: *mut *const u8,
        keyRequestSize: *mut usize,
        defaultUrl: *mut *const ::std::os::raw::c_char,
        keyRequestType: *mut AMediaDrmKeyRequestType,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_provideKeyResponse(
        arg1: *mut AMediaDrm,
        scope: *const AMediaDrmScope,
        response: *const u8,
        responseSize: usize,
        keySetId: *mut AMediaDrmKeySetId,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_restoreKeys(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        keySetId: *const AMediaDrmKeySetId,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_removeKeys(
        arg1: *mut AMediaDrm,
        keySetId: *const AMediaDrmSessionId,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_queryKeyStatus(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        keyValuePairs: *mut AMediaDrmKeyValue,
        numPairs: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getProvisionRequest(
        arg1: *mut AMediaDrm,
        provisionRequest: *mut *const u8,
        provisionRequestSize: *mut usize,
        serverUrl: *mut *const ::std::os::raw::c_char,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_provideProvisionResponse(
        arg1: *mut AMediaDrm,
        response: *const u8,
        responseSize: usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getSecureStops(
        arg1: *mut AMediaDrm,
        secureStops: *mut AMediaDrmSecureStop,
        numSecureStops: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_releaseSecureStops(
        arg1: *mut AMediaDrm,
        ssRelease: *const AMediaDrmSecureStop,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getPropertyString(
        arg1: *mut AMediaDrm,
        propertyName: *const ::std::os::raw::c_char,
        propertyValue: *mut *const ::std::os::raw::c_char,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_getPropertyByteArray(
        arg1: *mut AMediaDrm,
        propertyName: *const ::std::os::raw::c_char,
        propertyValue: *mut AMediaDrmByteArray,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_setPropertyString(
        arg1: *mut AMediaDrm,
        propertyName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_setPropertyByteArray(
        arg1: *mut AMediaDrm,
        propertyName: *const ::std::os::raw::c_char,
        value: *const u8,
        valueSize: usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_encrypt(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        cipherAlgorithm: *const ::std::os::raw::c_char,
        keyId: *mut u8,
        iv: *mut u8,
        input: *const u8,
        output: *mut u8,
        dataSize: usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_decrypt(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        cipherAlgorithm: *const ::std::os::raw::c_char,
        keyId: *mut u8,
        iv: *mut u8,
        input: *const u8,
        output: *mut u8,
        dataSize: usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_sign(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        macAlgorithm: *const ::std::os::raw::c_char,
        keyId: *mut u8,
        message: *mut u8,
        messageSize: usize,
        signature: *mut u8,
        signatureSize: *mut usize,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaDrm_verify(
        arg1: *mut AMediaDrm,
        sessionId: *const AMediaDrmSessionId,
        macAlgorithm: *const ::std::os::raw::c_char,
        keyId: *mut u8,
        message: *const u8,
        messageSize: usize,
        signature: *const u8,
        signatureSize: usize,
    ) -> media_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaExtractor {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AMediaExtractor_new() -> *mut AMediaExtractor;
}
extern "C" {
    pub fn AMediaExtractor_delete(arg1: *mut AMediaExtractor) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_setDataSourceFd(
        arg1: *mut AMediaExtractor,
        fd: ::std::os::raw::c_int,
        offset: off64_t,
        length: off64_t,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_setDataSource(
        arg1: *mut AMediaExtractor,
        location: *const ::std::os::raw::c_char,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_setDataSourceCustom(
        arg1: *mut AMediaExtractor,
        src: *mut AMediaDataSource,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_getTrackCount(arg1: *mut AMediaExtractor) -> usize;
}
extern "C" {
    pub fn AMediaExtractor_getTrackFormat(
        arg1: *mut AMediaExtractor,
        idx: usize,
    ) -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaExtractor_selectTrack(arg1: *mut AMediaExtractor, idx: usize) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_unselectTrack(arg1: *mut AMediaExtractor, idx: usize) -> media_status_t;
}
extern "C" {
    pub fn AMediaExtractor_readSampleData(
        arg1: *mut AMediaExtractor,
        buffer: *mut u8,
        capacity: usize,
    ) -> isize;
}
extern "C" {
    pub fn AMediaExtractor_getSampleFlags(arg1: *mut AMediaExtractor) -> u32;
}
extern "C" {
    pub fn AMediaExtractor_getSampleTrackIndex(arg1: *mut AMediaExtractor)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AMediaExtractor_getSampleTime(arg1: *mut AMediaExtractor) -> i64;
}
extern "C" {
    pub fn AMediaExtractor_advance(arg1: *mut AMediaExtractor) -> bool;
}
impl SeekMode {
    pub const AMEDIAEXTRACTOR_SEEK_PREVIOUS_SYNC: SeekMode = SeekMode(0);
}
impl SeekMode {
    pub const AMEDIAEXTRACTOR_SEEK_NEXT_SYNC: SeekMode = SeekMode(1);
}
impl SeekMode {
    pub const AMEDIAEXTRACTOR_SEEK_CLOSEST_SYNC: SeekMode = SeekMode(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SeekMode(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn AMediaExtractor_seekTo(
        arg1: *mut AMediaExtractor,
        seekPosUs: i64,
        mode: SeekMode,
    ) -> media_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PsshEntry {
    pub uuid: AMediaUUID,
    pub datalen: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PsshEntry() {
    const UNINIT: ::std::mem::MaybeUninit<PsshEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PsshEntry>(),
        32usize,
        concat!("Size of: ", stringify!(PsshEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<PsshEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(PsshEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PsshEntry),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PsshEntry),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PsshEntry),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct PsshInfo {
    pub numentries: usize,
    pub entries: __IncompleteArrayField<PsshEntry>,
}
#[test]
fn bindgen_test_layout_PsshInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PsshInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PsshInfo>(),
        8usize,
        concat!("Size of: ", stringify!(PsshInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PsshInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PsshInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numentries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PsshInfo),
            "::",
            stringify!(numentries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PsshInfo),
            "::",
            stringify!(entries)
        )
    );
}
extern "C" {
    pub fn AMediaExtractor_getPsshInfo(arg1: *mut AMediaExtractor) -> *mut PsshInfo;
}
extern "C" {
    pub fn AMediaExtractor_getSampleCryptoInfo(
        arg1: *mut AMediaExtractor,
    ) -> *mut AMediaCodecCryptoInfo;
}
pub const AMEDIAEXTRACTOR_SAMPLE_FLAG_SYNC: _bindgen_ty_70 = 1;
pub const AMEDIAEXTRACTOR_SAMPLE_FLAG_ENCRYPTED: _bindgen_ty_70 = 2;
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AMediaExtractor_getFileFormat(arg1: *mut AMediaExtractor) -> *mut AMediaFormat;
}
extern "C" {
    pub fn AMediaExtractor_getSampleSize(arg1: *mut AMediaExtractor) -> isize;
}
extern "C" {
    pub fn AMediaExtractor_getCachedDuration(arg1: *mut AMediaExtractor) -> i64;
}
extern "C" {
    pub fn AMediaExtractor_getSampleFormat(
        ex: *mut AMediaExtractor,
        fmt: *mut AMediaFormat,
    ) -> media_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMediaMuxer {
    _unused: [u8; 0],
}
impl OutputFormat {
    pub const AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4: OutputFormat = OutputFormat(0);
}
impl OutputFormat {
    pub const AMEDIAMUXER_OUTPUT_FORMAT_WEBM: OutputFormat = OutputFormat(1);
}
impl OutputFormat {
    pub const AMEDIAMUXER_OUTPUT_FORMAT_THREE_GPP: OutputFormat = OutputFormat(2);
}
impl OutputFormat {
    pub const AMEDIAMUXER_OUTPUT_FORMAT_HEIF: OutputFormat = OutputFormat(3);
}
impl OutputFormat {
    pub const AMEDIAMUXER_OUTPUT_FORMAT_OGG: OutputFormat = OutputFormat(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OutputFormat(pub ::std::os::raw::c_uint);
impl AppendMode {
    pub const AMEDIAMUXER_APPEND_IGNORE_LAST_VIDEO_GOP: AppendMode = AppendMode(0);
}
impl AppendMode {
    pub const AMEDIAMUXER_APPEND_TO_EXISTING_DATA: AppendMode = AppendMode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AppendMode(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn AMediaMuxer_new(fd: ::std::os::raw::c_int, format: OutputFormat) -> *mut AMediaMuxer;
}
extern "C" {
    pub fn AMediaMuxer_delete(arg1: *mut AMediaMuxer) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_setLocation(
        arg1: *mut AMediaMuxer,
        latitude: f32,
        longitude: f32,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_setOrientationHint(
        arg1: *mut AMediaMuxer,
        degrees: ::std::os::raw::c_int,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_addTrack(arg1: *mut AMediaMuxer, format: *const AMediaFormat) -> isize;
}
extern "C" {
    pub fn AMediaMuxer_start(arg1: *mut AMediaMuxer) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_stop(arg1: *mut AMediaMuxer) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_writeSampleData(
        muxer: *mut AMediaMuxer,
        trackIdx: usize,
        data: *const u8,
        info: *const AMediaCodecBufferInfo,
    ) -> media_status_t;
}
extern "C" {
    pub fn AMediaMuxer_append(fd: ::std::os::raw::c_int, mode: AppendMode) -> *mut AMediaMuxer;
}
extern "C" {
    pub fn AMediaMuxer_getTrackCount(arg1: *mut AMediaMuxer) -> isize;
}
extern "C" {
    pub fn AMediaMuxer_getTrackFormat(muxer: *mut AMediaMuxer, idx: usize) -> *mut AMediaFormat;
}
pub type __uint128_t = u128;
