diff -ruN whispercpp-org/CMakeLists.txt whispercpp-patched/CMakeLists.txt
--- whispercpp-org/CMakeLists.txt	2023-04-15 13:21:58.000000000 +0200
+++ whispercpp-patched/CMakeLists.txt	2023-05-25 15:51:18.164431043 +0200
@@ -286,7 +286,7 @@
 
 install(TARGETS ${TARGET}
     LIBRARY DESTINATION lib
-    ARCHIVE DESTINATION lib/static
+    ARCHIVE DESTINATION lib
     RUNTIME DESTINATION bin
     PUBLIC_HEADER DESTINATION include
     )
diff -ruN whispercpp-org/ggml.c whispercpp-patched/ggml.c
--- whispercpp-org/ggml.c	2023-04-15 13:21:58.000000000 +0200
+++ whispercpp-patched/ggml.c	2023-05-25 15:46:32.332520354 +0200
@@ -2788,6 +2788,7 @@
     void * mem_buffer;
     bool   mem_buffer_owned;
     bool   no_alloc;
+    bool   stop;
 
     int    n_objects;
 
@@ -3094,6 +3095,14 @@
     return ctx;
 }
 
+void ggml_cancel(struct ggml_context * ctx) {
+    ctx->stop = true;
+}
+
+void ggml_cancel_clear(struct ggml_context * ctx) {
+    ctx->stop = false;
+}
+
 void ggml_free(struct ggml_context * ctx) {
     // make this function thread safe
     ggml_critical_section_start();
@@ -10027,7 +10036,7 @@
     const int64_t perf_start_cycles  = ggml_perf_cycles();
     const int64_t perf_start_time_us = ggml_perf_time_us();
 
-    for (int i = 0; i < cgraph->n_nodes; i++) {
+    for (int i = 0; i < cgraph->n_nodes && !ctx->stop; i++) {
         GGML_PRINT_DEBUG_5("%s: %d/%d\n", __func__, i, cgraph->n_nodes);
 
         struct ggml_tensor * node = cgraph->nodes[i];
@@ -10057,7 +10066,7 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -10076,7 +10085,7 @@
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) > 0) {
+            while (atomic_load(&state_shared.n_ready) > 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -10093,14 +10102,14 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) != 0) {
+            while (atomic_load(&state_shared.n_ready) != 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -10112,7 +10121,7 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -10131,7 +10140,7 @@
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) > 0) {
+            while (atomic_load(&state_shared.n_ready) > 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -10148,14 +10157,14 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) != 0) {
+            while (atomic_load(&state_shared.n_ready) != 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
diff -ruN whispercpp-org/ggml.h whispercpp-patched/ggml.h
--- whispercpp-org/ggml.h	2023-04-15 13:21:58.000000000 +0200
+++ whispercpp-patched/ggml.h	2023-05-25 15:46:32.332520354 +0200
@@ -358,6 +358,8 @@
 
 struct ggml_context * ggml_init(struct ggml_init_params params);
 void ggml_free(struct ggml_context * ctx);
+void ggml_cancel(struct ggml_context * ctx);
+void ggml_cancel_clear(struct ggml_context * ctx);
 
 size_t ggml_used_mem(const struct ggml_context * ctx);
 
diff -ruN whispercpp-org/whisper.cpp whispercpp-patched/whisper.cpp
--- whispercpp-org/whisper.cpp	2023-04-15 13:21:58.000000000 +0200
+++ whispercpp-patched/whisper.cpp	2023-05-25 15:46:32.332520354 +0200
@@ -603,6 +603,9 @@
     // [EXPERIMENTAL] speed-up techniques
     int32_t exp_n_audio_ctx = 0; // 0 - use default
 
+    bool stop = false;
+    ggml_context * gctx = nullptr;
+
     void use_buf(struct ggml_context * ctx, int i) {
 #if defined(WHISPER_USE_SCRATCH)
         size_t last_size = 0;
@@ -1365,6 +1368,8 @@
     };
 
     struct ggml_context * ctx0 = ggml_init(params);
+    wctx.state->gctx = ctx0;
+    if (wctx.state->stop) ggml_cancel(ctx0);
 
     wstate.use_buf(ctx0, 0);
 
@@ -1763,16 +1768,17 @@
         ggml_graph_compute(ctx0, &gf);
         //ggml_graph_print(&gf);
     }
-
+    
     ////////////////////////////////////////////////////////////////////////////
 
-    //printf("%s: used_mem = %f MB, %f MB, %f MB %f MB %f MB\n", __func__,
-    //        ggml_used_mem(ctx0)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(0)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(1)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(2)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(3)/1024.0/1024.0);
+    // printf("%s: used_mem = %f MB, %f MB, %f MB %f MB %f MB\n", __func__,
+    //         ggml_used_mem(ctx0)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(0)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(1)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(2)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(3)/1024.0/1024.0);
 
+    wctx.state->gctx = nullptr;
     ggml_free(ctx0);
 
     wstate.t_encode_us += ggml_time_us() - t_start_us;
@@ -3984,6 +3990,8 @@
             return -6;
         }
 
+        if (ctx->state->stop) return -100;
+
         // if there is a very short audio segment left to process, we remove any past prompt since it tends
         // to confuse the decoder and often make it repeat or hallucinate stuff
         if (seek > seek_start && seek + 500 >= seek_end) {
@@ -4067,6 +4075,8 @@
                     return -7;
                 }
 
+                if (ctx->state->stop) return -100;
+
                 {
                     const int64_t t_start_sample_us = ggml_time_us();
 
@@ -4305,6 +4315,8 @@
                         return -8;
                     }
 
+                    if (ctx->state->stop) return -100;
+
                     {
                         const int64_t t_start_sample_us = ggml_time_us();
 
@@ -4504,9 +4516,19 @@
         }
     }
 
+    if (ctx->state->stop) return -100;
+
     return 0;
 }
 
+void whisper_cancel(struct whisper_context * ctx) {
+    ctx->state->stop = true;
+    if (ctx->state->gctx) ggml_cancel(ctx->state->gctx);
+}
+
+void whisper_cancel_clear(struct whisper_context * ctx) {
+    ctx->state->stop = false;
+}
 
 int whisper_full(
         struct whisper_context * ctx,
@@ -5138,7 +5160,7 @@
             }
         }
     }
-
+    
     // fixed token expand (optional)
     //{
     //    const int t_expand = 0;
diff -ruN whispercpp-org/whisper.h whispercpp-patched/whisper.h
--- whispercpp-org/whisper.h	2023-04-15 13:21:58.000000000 +0200
+++ whispercpp-patched/whisper.h	2023-05-25 15:46:32.332520354 +0200
@@ -114,6 +114,10 @@
     WHISPER_API void whisper_free      (struct whisper_context * ctx);
     WHISPER_API void whisper_free_state(struct whisper_state * state);
 
+    // Cancel any ongoing operation
+    WHISPER_API void whisper_cancel(struct whisper_context * ctx);
+    WHISPER_API void whisper_cancel_clear(struct whisper_context * ctx);
+
     // Convert RAW PCM audio to log mel spectrogram.
     // The resulting spectrogram is stored inside the default state of the provided whisper context.
     // Returns 0 on success
