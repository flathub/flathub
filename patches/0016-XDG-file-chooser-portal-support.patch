From 29e63bc853817348641a45f51fe79359058885d4 Mon Sep 17 00:00:00 2001
From: Ryan Gonzalez <rymg19@gmail.com>
Date: Mon, 31 Aug 2020 15:26:52 -0500
Subject: [PATCH 16/18] XDG file chooser portal support

---
 chrome/browser/about_flags.cc             |   7 +
 chrome/browser/flag_descriptions.cc       |  11 +
 chrome/browser/flag_descriptions.h        |   9 +
 content/public/common/content_features.cc |  10 +-
 content/public/common/content_features.h  |   4 +
 ui/gtk/BUILD.gn                           |   6 +
 ui/gtk/gtk_ui.cc                          |   4 +
 ui/gtk/select_file_dialog_impl.cc         |  68 +-
 ui/gtk/select_file_dialog_impl.h          |   9 +
 ui/gtk/select_file_dialog_impl_portal.cc  | 727 ++++++++++++++++++++++
 ui/gtk/select_file_dialog_impl_portal.h   | 134 ++++
 11 files changed, 970 insertions(+), 19 deletions(-)
 create mode 100644 ui/gtk/select_file_dialog_impl_portal.cc
 create mode 100644 ui/gtk/select_file_dialog_impl_portal.h

diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 1794b098518f5..84a803fbf38c1 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -4702,6 +4702,13 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(features::kVaapiWebPImageDecodeAcceleration)},
 #endif
 
+#if defined(OS_LINUX)
+    {"enable-xdg-file-chooser-portal",
+     flag_descriptions::kXdgFileChooserPortalName,
+     flag_descriptions::kXdgFileChooserPortalDescription, kOsLinux,
+     FEATURE_VALUE_TYPE(features::kXdgFileChooserPortal)},
+#endif  // OS_LINUX
+
 #if defined(OS_WIN)
     {"calculate-native-win-occlusion",
      flag_descriptions::kCalculateNativeWinOcclusionName,
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 7014b7deb3ab9..1765e023d8d96 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -3376,6 +3376,17 @@ const char kSyncSetupFriendlySettingsDescription[] =
 
 #endif  // !defined(OS_ANDROID)
 
+// Linux -----------------------------------------------------------------------
+
+#if defined(OS_LINUX)
+
+const char kXdgFileChooserPortalName[] = "Use the XDG file chooser portal";
+const char kXdgFileChooserPortalDescription[] =
+    "File selection will use the XDG portal rather than GTK/KDE-specific "
+    "dialogs";
+
+#endif
+
 // Windows ---------------------------------------------------------------------
 
 #if defined(OS_WIN)
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 82c3abd03cf3e..6536d257bcdae 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1932,6 +1932,15 @@ extern const char kSyncSetupFriendlySettingsDescription[];
 
 #endif  // defined(OS_ANDROID)
 
+// Linux ----------------------------------------------------------------------
+
+#if defined(OS_LINUX)
+
+extern const char kXdgFileChooserPortalName[];
+extern const char kXdgFileChooserPortalDescription[];
+
+#endif  // defined(OS_LINUX)
+
 // Windows --------------------------------------------------------------------
 
 #if defined(OS_WIN)
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index 99d8f1bcedd28..4084195b6ee53 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -191,7 +191,7 @@ const base::Feature kEnableNewCanvas2DAPI{"EnableNewCanvas2DAPI",
 // media-device enumeration will provide at most one device per type and the
 // device IDs will not be available.
 // TODO(crbug.com/1019176): remove the feature in M89.
-const base::Feature kEnumerateDevicesHideDeviceIDs{
+const base::Feature kEnumerateDevicesHideDeviceIDs {
   "EnumerateDevicesHideDeviceIDs",
 #if defined(OS_ANDROID)
       base::FEATURE_DISABLED_BY_DEFAULT
@@ -896,7 +896,13 @@ const base::Feature kForce60HzRefreshRate{"Force60HzRefreshRate",
 const base::Feature kWebNfc{"WebNFC", base::FEATURE_ENABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_MAC)
+#if defined(OS_LINUX)
+// Enables use of the XDG file chooser portal for file selection.
+const base::Feature kXdgFileChooserPortal{"XdgFileChooserPortal",
+                                          base::FEATURE_ENABLED_BY_DEFAULT};
+#endif  // defined(OS_LINUX)
+
+#if defined(OS_MACOS)
 // Enables caching of media devices for the purpose of enumerating them.
 const base::Feature kDeviceMonitorMac{"DeviceMonitorMac",
                                       base::FEATURE_ENABLED_BY_DEFAULT};
diff --git a/content/public/common/content_features.h b/content/public/common/content_features.h
index 902522421aa9c..c4e2222902656 100644
--- a/content/public/common/content_features.h
+++ b/content/public/common/content_features.h
@@ -189,6 +189,10 @@ CONTENT_EXPORT extern const base::Feature kWarmUpNetworkProcess;
 CONTENT_EXPORT extern const base::Feature kWebNfc;
 #endif  // defined(OS_ANDROID)
 
+#if defined(OS_LINUX)
+CONTENT_EXPORT extern const base::Feature kXdgFileChooserPortal;
+#endif
+
 #if defined(OS_MAC)
 CONTENT_EXPORT extern const base::Feature kDeviceMonitorMac;
 CONTENT_EXPORT extern const base::Feature kIOSurfaceCapturer;
diff --git a/ui/gtk/BUILD.gn b/ui/gtk/BUILD.gn
index 3759400373b77..14762a75f5cad 100644
--- a/ui/gtk/BUILD.gn
+++ b/ui/gtk/BUILD.gn
@@ -43,6 +43,8 @@ component("gtk") {
     "select_file_dialog_impl_gtk.cc",
     "select_file_dialog_impl_gtk.h",
     "select_file_dialog_impl_kde.cc",
+    "select_file_dialog_impl_portal.cc",
+    "select_file_dialog_impl_portal.h",
     "settings_provider.h",
     "settings_provider_gtk.cc",
     "settings_provider_gtk.h",
@@ -71,6 +73,9 @@ component("gtk") {
     # our own HarfBuzz avoid mixing symbols from system HarfBuzz and
     # our own through the indirect dependency to harfbuzz-ng here.
     "//build/config/linux/gtk",
+    "//components/dbus/thread_linux",
+    "//content/public/common",
+    "//dbus",
     "//third_party:freetype_harfbuzz",
     "//ui/aura",
     "//ui/base",
@@ -89,6 +94,7 @@ component("gtk") {
     "//ui/shell_dialogs",
     "//ui/strings",
     "//ui/views",
+    "//url",
   ]
 
   if (use_cups) {
diff --git a/ui/gtk/gtk_ui.cc b/ui/gtk/gtk_ui.cc
index 9905c4f0b355f..d41673b38da87 100644
--- a/ui/gtk/gtk_ui.cc
+++ b/ui/gtk/gtk_ui.cc
@@ -392,6 +392,8 @@ GtkUi::GtkUi(ui::GtkUiDelegate* delegate) : delegate_(delegate) {
 GtkUi::~GtkUi() {
   gtk_widget_destroy(fake_window_);
   g_gtk_ui = nullptr;
+
+  SelectFileDialogImpl::DestroyFactory();
 }
 
 ui::GtkUiDelegate* GtkUi::GetDelegate() {
@@ -445,6 +447,8 @@ void GtkUi::Initialize() {
       &GetPdfPaperSizeDeviceUnitsGtk);
 #endif
 
+  SelectFileDialogImpl::InitializeFactory();
+
   // We must build this after GTK gets initialized.
   settings_provider_ = CreateSettingsProvider(this);
 
diff --git a/ui/gtk/select_file_dialog_impl.cc b/ui/gtk/select_file_dialog_impl.cc
index 8dfc91f918e42..41889aa2426c5 100644
--- a/ui/gtk/select_file_dialog_impl.cc
+++ b/ui/gtk/select_file_dialog_impl.cc
@@ -7,21 +7,26 @@
 #include "ui/gtk/select_file_dialog_impl.h"
 
 #include "base/environment.h"
+#include "base/feature_list.h"
 #include "base/files/file_util.h"
 #include "base/nix/xdg_util.h"
 #include "base/no_destructor.h"
+#include "base/notreached.h"
 #include "base/threading/thread_restrictions.h"
+#include "content/public/common/content_features.h"
+#include "ui/gtk/select_file_dialog_impl_portal.h"
 
 namespace {
 
-enum UseKdeFileDialogStatus { UNKNOWN, NO_KDE, YES_KDE };
+enum FileDialogChoiceStatus { kUnknown, kGtk, kKde, kPortal };
 
-UseKdeFileDialogStatus use_kde_ = UNKNOWN;
 std::string& KDialogVersion() {
   static base::NoDestructor<std::string> version;
   return *version;
 }
 
+FileDialogChoiceStatus dialog_status_ = kUnknown;
+
 }  // namespace
 
 namespace gtk {
@@ -30,12 +35,21 @@ base::FilePath* SelectFileDialogImpl::last_saved_path_ = nullptr;
 base::FilePath* SelectFileDialogImpl::last_opened_path_ = nullptr;
 
 // static
-ui::SelectFileDialog* SelectFileDialogImpl::Create(
-    ui::SelectFileDialog::Listener* listener,
-    std::unique_ptr<ui::SelectFilePolicy> policy) {
-  if (use_kde_ == UNKNOWN) {
-    // Start out assumimg we are not going to use KDE.
-    use_kde_ = NO_KDE;
+void SelectFileDialogImpl::InitializeFactory() {
+  if (dialog_status_ != kUnknown) {
+    return;
+  }
+
+  // Start out assumimg we are going to use GTK.
+  dialog_status_ = kGtk;
+
+  // Check to see if the portal is available.
+  if (base::FeatureList::IsEnabled(features::kXdgFileChooserPortal) &&
+      SelectFileDialogImplPortal::IsPortalAvailable()) {
+    dialog_status_ = kPortal;
+  } else {
+    // Make sure to kill the portal connection.
+    SelectFileDialogImplPortal::DestroyPortalConnection();
 
     // Check to see if KDE is the desktop environment.
     std::unique_ptr<base::Environment> env(base::Environment::Create());
@@ -49,22 +63,42 @@ ui::SelectFileDialog* SelectFileDialogImpl::Create(
         // Check to see if the KDE dialog works.
         if (SelectFileDialogImpl::CheckKDEDialogWorksOnUIThread(
                 KDialogVersion())) {
-          use_kde_ = YES_KDE;
+          dialog_status_ = kKde;
         }
       }
     }
   }
+}
 
-  if (use_kde_ == NO_KDE) {
-    return SelectFileDialogImpl::NewSelectFileDialogImplGTK(listener,
-                                                            std::move(policy));
+// static
+void SelectFileDialogImpl::DestroyFactory() {
+  if (dialog_status_ == kPortal) {
+    SelectFileDialogImplPortal::DestroyPortalConnection();
   }
+}
 
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  base::nix::DesktopEnvironment desktop =
-      base::nix::GetDesktopEnvironment(env.get());
-  return SelectFileDialogImpl::NewSelectFileDialogImplKDE(
-      listener, std::move(policy), desktop, KDialogVersion());
+// static
+ui::SelectFileDialog* SelectFileDialogImpl::Create(
+    ui::SelectFileDialog::Listener* listener,
+    std::unique_ptr<ui::SelectFilePolicy> policy) {
+  switch (dialog_status_) {
+    case kGtk:
+      return SelectFileDialogImpl::NewSelectFileDialogImplGTK(
+          listener, std::move(policy));
+    case kPortal:
+      return SelectFileDialogImpl::NewSelectFileDialogImplPortal(
+          listener, std::move(policy));
+    case kKde: {
+      std::unique_ptr<base::Environment> env(base::Environment::Create());
+      base::nix::DesktopEnvironment desktop =
+          base::nix::GetDesktopEnvironment(env.get());
+      return SelectFileDialogImpl::NewSelectFileDialogImplKDE(
+          listener, std::move(policy), desktop, KDialogVersion());
+    }
+    case kUnknown:
+      CHECK(false) << "InitializeFactory was never called";
+      return nullptr;
+  }
 }
 
 SelectFileDialogImpl::SelectFileDialogImpl(
diff --git a/ui/gtk/select_file_dialog_impl.h b/ui/gtk/select_file_dialog_impl.h
index 3cb8ee5d6a972..412a4394a8d65 100644
--- a/ui/gtk/select_file_dialog_impl.h
+++ b/ui/gtk/select_file_dialog_impl.h
@@ -24,6 +24,11 @@ namespace gtk {
 // Shared implementation SelectFileDialog used by SelectFileDialogImplGTK
 class SelectFileDialogImpl : public ui::SelectFileDialog {
  public:
+  // Called to set which dialog factory method to use.
+  static void InitializeFactory();
+
+  static void DestroyFactory();
+
   // Main factory method which returns correct type.
   static ui::SelectFileDialog* Create(
       Listener* listener,
@@ -39,6 +44,10 @@ class SelectFileDialogImpl : public ui::SelectFileDialog {
       std::unique_ptr<ui::SelectFilePolicy> policy,
       base::nix::DesktopEnvironment desktop,
       const std::string& kdialog_version);
+  // Factory method for creating an XDG portal-backed SelectFileDialogImpl
+  static SelectFileDialogImpl* NewSelectFileDialogImplPortal(
+      Listener* listener,
+      std::unique_ptr<ui::SelectFilePolicy> policy);
 
   // Returns true if the SelectFileDialog class returned by
   // NewSelectFileDialogImplKDE will actually work.
diff --git a/ui/gtk/select_file_dialog_impl_portal.cc b/ui/gtk/select_file_dialog_impl_portal.cc
new file mode 100644
index 0000000000000..f7a6004b86219
--- /dev/null
+++ b/ui/gtk/select_file_dialog_impl_portal.cc
@@ -0,0 +1,727 @@
+#include "ui/gtk/select_file_dialog_impl_portal.h"
+#include "base/bind.h"
+#include "base/logging.h"
+#include "base/nix/mime_util_xdg.h"
+#include "base/no_destructor.h"
+#include "base/notreached.h"
+#include "base/sequenced_task_runner.h"
+#include "base/strings/string_piece_forward.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/synchronization/waitable_event.h"
+#include "components/dbus/thread_linux/dbus_thread_linux.h"
+#include "dbus/message.h"
+#include "dbus/object_path.h"
+#include "dbus/object_proxy.h"
+#include "dbus/property.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gtk/select_file_dialog_impl.h"
+#include "ui/strings/grit/ui_strings.h"
+#include "url/url_util.h"
+
+namespace gtk {
+
+namespace {
+
+constexpr char kDBusMethodNameHasOwner[] = "NameHasOwner";
+constexpr char kDBusMethodListActivatableNames[] = "ListActivatableNames";
+
+constexpr char kXdgPortalService[] = "org.freedesktop.portal.Desktop";
+const dbus::ObjectPath kXdgPortalObject("/org/freedesktop/portal/desktop");
+
+constexpr int kXdgPortalRequiredVersion = 3;
+
+constexpr char kXdgPortalRequestInterfaceName[] =
+    "org.freedesktop.portal.Request";
+constexpr char kXdgPortalResponseSignal[] = "Response";
+
+constexpr char kFileChooserInterfaceName[] =
+    "org.freedesktop.portal.FileChooser";
+
+constexpr char kFileChooserMethodOpenFile[] = "OpenFile";
+constexpr char kFileChooserMethodSaveFile[] = "SaveFile";
+
+constexpr char kFileChooserOptionHandleToken[] = "handle_token";
+constexpr char kFileChooserOptionAcceptLabel[] = "accept_label";
+constexpr char kFileChooserOptionMultiple[] = "multiple";
+constexpr char kFileChooserOptionDirectory[] = "directory";
+constexpr char kFileChooserOptionFilters[] = "filters";
+constexpr char kFileChooserOptionCurrentFilter[] = "current_filter";
+constexpr char kFileChooserOptionCurrentFolder[] = "current_folder";
+constexpr char kFileChooserOptionCurrentFile[] = "current_file";
+
+constexpr int kFileChooserFilterKindGlob = 0;
+
+constexpr char kOpenLabel[] = "_Open";
+constexpr char kSaveLabel[] = "_Save";
+
+constexpr char kFileUriPrefix[] = "file://";
+
+struct FileChooserProperties : dbus::PropertySet {
+  dbus::Property<uint32_t> version;
+
+  explicit FileChooserProperties(dbus::ObjectProxy* object_proxy)
+      : dbus::PropertySet(object_proxy, kFileChooserInterfaceName, {}) {
+    RegisterProperty("version", &version);
+  }
+
+  ~FileChooserProperties() override = default;
+};
+
+}  // namespace
+
+SelectFileDialogImpl* SelectFileDialogImpl::NewSelectFileDialogImplPortal(
+    Listener* listener,
+    std::unique_ptr<ui::SelectFilePolicy> policy) {
+  return new SelectFileDialogImplPortal(listener, std::move(policy));
+}
+
+SelectFileDialogImplPortal::SelectFileDialogImplPortal(
+    Listener* listener,
+    std::unique_ptr<ui::SelectFilePolicy> policy)
+    : SelectFileDialogImpl(listener, std::move(policy)) {}
+
+SelectFileDialogImplPortal::~SelectFileDialogImplPortal() = default;
+
+// static
+bool SelectFileDialogImplPortal::IsPortalAvailable() {
+  // TODO: make this work
+  // base::WaitableEvent event;
+
+  // dbus_thread_linux::GetTaskRunner()->PostTask(
+  //     FROM_HERE,
+  //     base::BindOnce(&IsPortalAvailableOnTaskRunner,
+  //                    base::Unretained(&available),
+  //                    base::Unretained(&event)));
+
+  // LOG(INFO) << "Waiting for bus thread!";
+  // event.Wait();
+
+  // VLOG(1) << "File chooser portal available: " << (available ? "yes" : "no");
+  // return available;
+  return true;
+}
+
+// static
+void SelectFileDialogImplPortal::DestroyPortalConnection() {
+  dbus_thread_linux::GetTaskRunner()->PostTask(
+      FROM_HERE,
+      base::BindOnce([]() { AcquireBusOnTaskRunner()->ShutdownAndBlock(); }));
+}
+
+// static
+void SelectFileDialogImplPortal::IsPortalAvailableOnTaskRunner(
+    bool* out_available,
+    base::WaitableEvent* event) {
+  dbus::Bus* bus = AcquireBusOnTaskRunner();
+
+  dbus::ObjectProxy* dbus_proxy =
+      bus->GetObjectProxy(DBUS_SERVICE_DBUS, dbus::ObjectPath(DBUS_PATH_DBUS));
+
+  if (IsPortalRunningOnTaskRunner(dbus_proxy) ||
+      IsPortalActivatableOnTaskRunner(dbus_proxy)) {
+    dbus::ObjectProxy* portal =
+        bus->GetObjectProxy(kXdgPortalService, kXdgPortalObject);
+
+    FileChooserProperties properties(portal);
+    if (!properties.GetAndBlock(&properties.version)) {
+      LOG(ERROR) << "Failed to read portal version property";
+    } else if (properties.version.value() >= kXdgPortalRequiredVersion) {
+      *out_available = true;
+    }
+  }
+
+  event->Signal();
+}
+
+// static
+bool SelectFileDialogImplPortal::IsPortalRunningOnTaskRunner(
+    dbus::ObjectProxy* dbus_proxy) {
+  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS, kDBusMethodNameHasOwner);
+  dbus::MessageWriter writer(&method_call);
+  writer.AppendString(kXdgPortalService);
+
+  std::unique_ptr<dbus::Response> response = dbus_proxy->CallMethodAndBlock(
+      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT);
+  if (!response) {
+    return false;
+  }
+
+  dbus::MessageReader reader(response.get());
+  bool owned = false;
+  if (!reader.PopBool(&owned)) {
+    LOG(ERROR) << "Failed to read response";
+    return false;
+  }
+
+  return owned;
+}
+
+// static
+bool SelectFileDialogImplPortal::IsPortalActivatableOnTaskRunner(
+    dbus::ObjectProxy* dbus_proxy) {
+  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS,
+                               kDBusMethodListActivatableNames);
+
+  std::unique_ptr<dbus::Response> response = dbus_proxy->CallMethodAndBlock(
+      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT);
+  if (!response) {
+    return false;
+  }
+
+  dbus::MessageReader reader(response.get());
+  std::vector<std::string> names;
+  if (!reader.PopArrayOfStrings(&names)) {
+    LOG(ERROR) << "Failed to read response";
+    return false;
+  }
+
+  return base::Contains(names, kXdgPortalService);
+}
+
+bool SelectFileDialogImplPortal::IsRunning(
+    gfx::NativeWindow parent_window) const {
+  if (parent_window && parent_window->GetHost()) {
+    auto window = parent_window->GetHost()->GetAcceleratedWidget();
+
+    base::AutoLock locker(parents_lock_);
+    return parents_.find(window) != parents_.end();
+  }
+
+  return false;
+}
+
+void SelectFileDialogImplPortal::SelectFileImpl(
+    Type type,
+    const base::string16& title,
+    const base::FilePath& default_path,
+    const FileTypeInfo* file_types,
+    int file_type_index,
+    const base::FilePath::StringType& default_extension,
+    gfx::NativeWindow owning_window,
+    void* params) {
+  auto info = std::make_unique<CallInfo>();
+  info->type = type;
+  info->listener_task_runner = base::SequencedTaskRunnerHandle::Get();
+  info->params = params;
+
+  if (owning_window && owning_window->GetHost()) {
+    info->parent = owning_window->GetHost()->GetAcceleratedWidget();
+
+    base::AutoLock locker(parents_lock_);
+    parents_.insert(*info->parent);
+  }
+
+  if (file_types) {
+    file_types_ = *file_types;
+  }
+
+  file_type_index_ = file_type_index;
+
+  PortalFilterSet filter_set = BuildFilterSet();
+  dbus_thread_linux::GetTaskRunner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&SelectFileDialogImplPortal::SelectFileImplOnTaskRunner,
+                     base::Unretained(this), base::Unretained(info.release()),
+                     std::move(title), std::move(default_path),
+                     std::move(filter_set), std::move(default_extension)));
+}
+
+bool SelectFileDialogImplPortal::HasMultipleFileTypeChoicesImpl() {
+  return file_types_.extensions.size() > 1;
+}
+
+SelectFileDialogImplPortal::AutoCancel::AutoCancel(
+    SelectFileDialogImplPortal* portal,
+    CallInfo* info)
+    : portal_(portal), info_(info) {}
+
+SelectFileDialogImplPortal::AutoCancel::~AutoCancel() {
+  if (info_ && portal_->listener_) {
+    info_->listener_task_runner->PostTask(
+        FROM_HERE, base::BindOnce(
+                       [](Listener* listener, void* params) {
+                         listener->FileSelectionCanceled(params);
+                       },
+                       base::Unretained(portal_->listener_),
+                       base::Unretained(info_->params)));
+  }
+}
+
+void SelectFileDialogImplPortal::AutoCancel::Release() {
+  info_.release();
+}
+
+SelectFileDialogImplPortal::PortalFilterSet
+SelectFileDialogImplPortal::BuildFilterSet() {
+  PortalFilterSet filter_set;
+
+  for (size_t i = 0; i < file_types_.extensions.size(); ++i) {
+    PortalFilter filter;
+
+    for (const std::string& extension : file_types_.extensions[i]) {
+      if (extension.empty()) {
+        continue;
+      }
+
+      filter.patterns.insert(base::StringPrintf("*.%s", extension.c_str()));
+    }
+
+    if (filter.patterns.empty()) {
+      continue;
+    }
+
+    // The description vector may be blank, in which case we are supposed to
+    // use some sort of default description based on the filter.
+    if (i < file_types_.extension_description_overrides.size()) {
+      filter.name =
+          base::UTF16ToUTF8(file_types_.extension_description_overrides[i]);
+    } else {
+      std::vector<std::string> patterns_vector(filter.patterns.begin(),
+                                               filter.patterns.end());
+      filter.name = base::JoinString(patterns_vector, ",");
+    }
+
+    if (i == file_type_index_) {
+      filter_set.default_filter = filter;
+    }
+
+    filter_set.filters.push_back(std::move(filter));
+  }
+
+  if (file_types_.include_all_files && !filter_set.filters.empty()) {
+    // Add the *.* filter, but only if we have added other filters (otherwise it
+    // is implied).
+    PortalFilter filter;
+    filter.name = l10n_util::GetStringUTF8(IDS_SAVEAS_ALL_FILES);
+    filter.patterns.insert("*.*");
+
+    filter_set.filters.push_back(std::move(filter));
+  }
+
+  return filter_set;
+}
+
+// static
+dbus::Bus* SelectFileDialogImplPortal::AcquireBusOnTaskRunner() {
+  static base::NoDestructor<dbus::Bus*> bus([] {
+    dbus::Bus::Options options;
+    options.bus_type = dbus::Bus::SESSION;
+    options.connection_type = dbus::Bus::PRIVATE;
+    options.dbus_task_runner = dbus_thread_linux::GetTaskRunner();
+
+    return new dbus::Bus(options);
+  }());
+
+  return *bus;
+}
+
+void SelectFileDialogImplPortal::SelectFileImplOnTaskRunner(
+    CallInfo* info,
+    base::string16 title,
+    base::FilePath default_path,
+    PortalFilterSet filter_set,
+    base::FilePath::StringType default_extension) {
+  dbus::Bus* bus = AcquireBusOnTaskRunner();
+
+  std::string method;
+
+  switch (info->type) {
+    case SELECT_FOLDER:
+    case SELECT_UPLOAD_FOLDER:
+    case SELECT_EXISTING_FOLDER:
+    case SELECT_OPEN_FILE:
+    case SELECT_OPEN_MULTI_FILE:
+      method = kFileChooserMethodOpenFile;
+      break;
+    case SELECT_SAVEAS_FILE:
+      method = kFileChooserMethodSaveFile;
+      break;
+    case SELECT_NONE:
+      NOTREACHED();
+      break;
+  }
+
+  dbus::MethodCall method_call(kFileChooserInterfaceName, method);
+  dbus::MessageWriter writer(&method_call);
+
+  if (info->parent) {
+    // XXX: Assumes X11.
+    std::string parent_window =
+        base::StringPrintf("x11:%u", static_cast<std::uint32_t>(*info->parent));
+    writer.AppendString(parent_window);
+  } else {
+    writer.AppendString("");
+  }
+
+  if (!title.empty()) {
+    writer.AppendString(base::UTF16ToUTF8(title));
+  } else {
+    int message_id;
+    if (info->type == SELECT_SAVEAS_FILE) {
+      message_id = IDS_SAVEAS_ALL_FILES;
+    } else if (info->type == SELECT_OPEN_MULTI_FILE) {
+      message_id = IDS_OPEN_FILES_DIALOG_TITLE;
+    } else {
+      message_id = IDS_OPEN_FILE_DIALOG_TITLE;
+    }
+    writer.AppendString(l10n_util::GetStringUTF8(message_id));
+  }
+
+  dbus::MessageWriter options_writer(nullptr);
+  writer.OpenArray("{sv}", &options_writer);
+
+  std::string handle_token =
+      base::StringPrintf("handle_%d", handle_token_counter_++);
+  AppendStringOption(&options_writer, kFileChooserOptionHandleToken,
+                     handle_token);
+
+  switch (info->type) {
+    case SELECT_SAVEAS_FILE:
+      AppendStringOption(&options_writer, kFileChooserOptionAcceptLabel,
+                         kSaveLabel);
+      break;
+    case SELECT_UPLOAD_FOLDER:
+      AppendStringOption(&options_writer, kFileChooserOptionAcceptLabel,
+                         l10n_util::GetStringUTF8(
+                             IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON));
+      break;
+    default:
+      AppendStringOption(&options_writer, kFileChooserOptionAcceptLabel,
+                         kOpenLabel);
+      break;
+  }
+
+  if (info->type == SELECT_UPLOAD_FOLDER ||
+      info->type == SELECT_EXISTING_FOLDER) {
+    AppendBoolOption(&options_writer, kFileChooserOptionDirectory, true);
+  } else if (info->type == SELECT_OPEN_MULTI_FILE) {
+    AppendBoolOption(&options_writer, kFileChooserOptionMultiple, true);
+  }
+
+  AppendFiltersOption(&options_writer, filter_set.filters);
+  if (filter_set.default_filter) {
+    dbus::MessageWriter option_writer(nullptr);
+    options_writer.OpenDictEntry(&option_writer);
+
+    option_writer.AppendString(kFileChooserOptionCurrentFilter);
+
+    dbus::MessageWriter value_writer(nullptr);
+    option_writer.OpenVariant("(sa(us))", &value_writer);
+
+    AppendFilterStruct(&value_writer, *filter_set.default_filter);
+
+    option_writer.CloseContainer(&value_writer);
+    options_writer.CloseContainer(&option_writer);
+  }
+
+  if (info->type == SELECT_SAVEAS_FILE) {
+    if (CallDirectoryExistsOnUIThread(default_path)) {
+      AppendByteStringOption(&options_writer, kFileChooserOptionCurrentFolder,
+                             default_path.value());
+    } else {
+      AppendByteStringOption(&options_writer, kFileChooserOptionCurrentFile,
+                             default_path.value());
+    }
+  }
+
+  writer.CloseContainer(&options_writer);
+
+  // The sender part of the handle object contains the D-Bus connection name
+  // without the prefix colon and with all dots replaced with underscores.
+  std::string sender_part;
+  base::ReplaceChars(bus->GetConnectionName().substr(1), ".", "_",
+                     &sender_part);
+
+  dbus::ObjectPath expected_handle_path(
+      base::StringPrintf("/org/freedesktop/portal/desktop/request/%s/%s",
+                         sender_part.c_str(), handle_token.c_str()));
+
+  info->handle = bus->GetObjectProxy(kXdgPortalService, expected_handle_path);
+  ConnectToHandle(info);
+
+  dbus::ObjectProxy* portal =
+      bus->GetObjectProxy(kXdgPortalService, kXdgPortalObject);
+  portal->CallMethodWithErrorResponse(
+      &method_call, dbus::ObjectProxy::TIMEOUT_INFINITE,
+      base::BindOnce(&SelectFileDialogImplPortal::OnCallResponse,
+                     base::Unretained(this), base::Unretained(bus),
+                     base::Unretained(info)));
+}
+
+void SelectFileDialogImplPortal::AppendStringOption(dbus::MessageWriter* writer,
+                                                    const std::string& name,
+                                                    const std::string& value) {
+  dbus::MessageWriter option_writer(nullptr);
+  writer->OpenDictEntry(&option_writer);
+
+  option_writer.AppendString(name);
+  option_writer.AppendVariantOfString(value);
+
+  writer->CloseContainer(&option_writer);
+}
+
+void SelectFileDialogImplPortal::AppendByteStringOption(
+    dbus::MessageWriter* writer,
+    const std::string& name,
+    const std::string& value) {
+  dbus::MessageWriter option_writer(nullptr);
+  writer->OpenDictEntry(&option_writer);
+
+  option_writer.AppendString(name);
+
+  dbus::MessageWriter value_writer(nullptr);
+  option_writer.OpenVariant("ay", &value_writer);
+
+  value_writer.AppendArrayOfBytes(
+      reinterpret_cast<const std::uint8_t*>(value.c_str()),
+      // size + 1 will include the null terminator.
+      value.size() + 1);
+
+  option_writer.CloseContainer(&value_writer);
+  writer->CloseContainer(&option_writer);
+}
+
+void SelectFileDialogImplPortal::AppendBoolOption(dbus::MessageWriter* writer,
+                                                  const std::string& name,
+                                                  bool value) {
+  dbus::MessageWriter option_writer(nullptr);
+  writer->OpenDictEntry(&option_writer);
+
+  option_writer.AppendString(name);
+  option_writer.AppendVariantOfBool(value);
+
+  writer->CloseContainer(&option_writer);
+}
+
+void SelectFileDialogImplPortal::AppendFiltersOption(
+    dbus::MessageWriter* writer,
+    const std::vector<PortalFilter>& filters) {
+  dbus::MessageWriter option_writer(nullptr);
+  writer->OpenDictEntry(&option_writer);
+
+  option_writer.AppendString(kFileChooserOptionFilters);
+
+  dbus::MessageWriter variant_writer(nullptr);
+  option_writer.OpenVariant("a(sa(us))", &variant_writer);
+
+  dbus::MessageWriter filters_writer(nullptr);
+  variant_writer.OpenArray("(sa(us))", &filters_writer);
+
+  for (const PortalFilter& filter : filters) {
+    AppendFilterStruct(&filters_writer, filter);
+  }
+
+  variant_writer.CloseContainer(&filters_writer);
+  option_writer.CloseContainer(&variant_writer);
+  writer->CloseContainer(&option_writer);
+}
+
+void SelectFileDialogImplPortal::AppendFilterStruct(
+    dbus::MessageWriter* writer,
+    const PortalFilter& filter) {
+  dbus::MessageWriter filter_writer(nullptr);
+  writer->OpenStruct(&filter_writer);
+
+  filter_writer.AppendString(filter.name);
+
+  dbus::MessageWriter patterns_writer(nullptr);
+  filter_writer.OpenArray("(us)", &patterns_writer);
+
+  for (const std::string& pattern : filter.patterns) {
+    dbus::MessageWriter pattern_writer(nullptr);
+    patterns_writer.OpenStruct(&pattern_writer);
+
+    pattern_writer.AppendUint32(kFileChooserFilterKindGlob);
+    pattern_writer.AppendString(pattern);
+
+    patterns_writer.CloseContainer(&pattern_writer);
+  }
+
+  filter_writer.CloseContainer(&patterns_writer);
+  writer->CloseContainer(&filter_writer);
+}
+
+void SelectFileDialogImplPortal::ConnectToHandle(CallInfo* info) {
+  info->handle->ConnectToSignal(
+      kXdgPortalRequestInterfaceName, kXdgPortalResponseSignal,
+      base::BindRepeating(&SelectFileDialogImplPortal::OnResponseSignalEmitted,
+                          base::Unretained(this), base::Unretained(info)),
+      base::BindOnce(&SelectFileDialogImplPortal::OnResponseSignalConnected,
+                     base::Unretained(this), base::Unretained(info)));
+}
+
+void SelectFileDialogImplPortal::DetachAndUnparent(CallInfo* info) {
+  if (info->handle) {
+    info->handle->Detach();
+    info->handle = nullptr;
+  }
+
+  if (info->parent) {
+    base::AutoLock locker(parents_lock_);
+    parents_.erase(*info->parent);
+    info->parent.reset();
+  }
+}
+
+void SelectFileDialogImplPortal::OnCallResponse(
+    dbus::Bus* bus,
+    CallInfo* info,
+    dbus::Response* response,
+    dbus::ErrorResponse* error_response) {
+  AutoCancel canceller(this, info);
+
+  if (response) {
+    dbus::MessageReader reader(response);
+    dbus::ObjectPath actual_handle_path;
+    if (!reader.PopObjectPath(&actual_handle_path)) {
+      LOG(ERROR) << "Invalid portal response";
+    } else {
+      if (info->handle->object_path() != actual_handle_path) {
+        info->handle->Detach();
+        info->handle =
+            bus->GetObjectProxy(kXdgPortalService, actual_handle_path);
+        ConnectToHandle(info);
+      }
+
+      canceller.Release();
+      // Return before the detach calls are performed.
+      return;
+    }
+  } else if (error_response) {
+    std::string error_name = error_response->GetErrorName();
+    std::string error_message;
+    dbus::MessageReader reader(error_response);
+    reader.PopString(&error_message);
+
+    LOG(ERROR) << "Portal returned error: " << error_name << ": "
+               << error_message;
+  } else {
+    NOTREACHED();
+  }
+
+  // All error paths end up here.
+  DetachAndUnparent(info);
+}
+
+void SelectFileDialogImplPortal::OnResponseSignalEmitted(CallInfo* info,
+                                                         dbus::Signal* signal) {
+  DetachAndUnparent(info);
+  AutoCancel canceller(this, info);
+
+  dbus::MessageReader reader(signal);
+
+  std::uint32_t response;
+  if (!reader.PopUint32(&response)) {
+    LOG(ERROR) << "Failed to read response ID";
+    return;
+  }
+
+  if (response != 0) {
+    return;
+  }
+
+  dbus::MessageReader results_reader(nullptr);
+  if (!reader.PopArray(&results_reader)) {
+    LOG(ERROR) << "Failed to read file chooser variant";
+    return;
+  }
+
+  while (results_reader.HasMoreData()) {
+    dbus::MessageReader entry_reader(nullptr);
+    std::string key;
+    if (!results_reader.PopDictEntry(&entry_reader) ||
+        !entry_reader.PopString(&key)) {
+      LOG(ERROR) << "Failed to read response entry";
+      return;
+    }
+
+    if (key == "uris") {
+      dbus::MessageReader uris_reader(nullptr);
+      std::vector<std::string> uris;
+      if (!entry_reader.PopVariant(&uris_reader) ||
+          !uris_reader.PopArrayOfStrings(&uris)) {
+        LOG(ERROR) << "Failed to read response entry value";
+        return;
+      }
+
+      std::vector<base::FilePath> paths;
+      for (const std::string& uri : uris) {
+        // GURL url(uri);
+        // if (!url.is_valid() || !url.SchemeIsFile()) {
+        //   LOG(ERROR) << "Ignoring unknown/invalid file chooser URI: " << uri;
+        //   continue;
+        // }
+
+        if (!base::StartsWith(uri, kFileUriPrefix,
+                              base::CompareCase::SENSITIVE)) {
+          LOG(ERROR) << "Ignoring unknown file chooser URI: " << uri;
+          continue;
+        }
+
+        base::StringPiece encoded_path(uri);
+        encoded_path.remove_prefix(strlen(kFileUriPrefix));
+
+        url::RawCanonOutputT<base::char16> decoded_uri;
+        url::DecodeURLEscapeSequences(encoded_path.data(), encoded_path.size(),
+                                      url::DecodeURLMode::kUTF8OrIsomorphic,
+                                      &decoded_uri);
+        paths.emplace_back(base::UTF16ToUTF8(
+            base::StringPiece16(decoded_uri.data(), decoded_uri.length())));
+        // paths.emplace_back(url.path());
+      }
+
+      // All the URIs failed, do nothing, then AutoCancel will cancel as usual.
+      if (!paths.empty()) {
+        canceller.Release();
+        // Because AutoCancel has now lost ownership of the CallInfo, we wrap it
+        // in a unique_ptr to ensure it still is deleted.
+        std::unique_ptr<CallInfo> info_ownership(info);
+
+        if (listener_) {
+          info->listener_task_runner->PostTask(
+              FROM_HERE,
+              base::BindOnce(
+                  [](Type type, Listener* listener,
+                     std::vector<base::FilePath> paths, void* params) {
+                    if (type == SELECT_OPEN_MULTI_FILE) {
+                      listener->MultiFilesSelected(paths, params);
+                    } else if (paths.size() > 1) {
+                      LOG(ERROR)
+                          << "Got >1 file URI from a single-file chooser";
+                    } else {
+                      // The meaning of the index isn't clear, see
+                      // select_file_dialog_impl_kde.cc.
+                      listener->FileSelected(paths.front(), 1, params);
+                    }
+                  },
+                  info->type, base::Unretained(listener_), std::move(paths),
+                  base::Unretained(info->params)));
+        }
+      }
+    }
+  }
+}
+
+void SelectFileDialogImplPortal::OnResponseSignalConnected(
+    CallInfo* info,
+    const std::string& interface,
+    const std::string& signal,
+    bool connected) {
+  AutoCancel canceller(this, info);
+
+  if (!connected) {
+    LOG(ERROR) << "Could not connect to Response signal";
+    DetachAndUnparent(info);
+  } else {
+    canceller.Release();
+  }
+}
+
+int SelectFileDialogImplPortal::handle_token_counter_ = 0;
+
+}  // namespace gtk
diff --git a/ui/gtk/select_file_dialog_impl_portal.h b/ui/gtk/select_file_dialog_impl_portal.h
new file mode 100644
index 0000000000000..fd838bcd3a1ed
--- /dev/null
+++ b/ui/gtk/select_file_dialog_impl_portal.h
@@ -0,0 +1,134 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GTK_SELECT_FILE_DIALOG_IMPL_PORTAL_H_
+#define UI_GTK_SELECT_FILE_DIALOG_IMPL_PORTAL_H_
+
+#include "base/memory/scoped_refptr.h"
+#include "base/optional.h"
+#include "base/sequenced_task_runner.h"
+#include "dbus/bus.h"
+#include "dbus/message.h"
+#include "dbus/object_proxy.h"
+#include "ui/gtk/select_file_dialog_impl.h"
+
+namespace gtk {
+
+// Implementation of SelectFileDialog that shows a KDE common dialog for
+// choosing a file or folder. This acts as a modal dialog.
+class SelectFileDialogImplPortal : public SelectFileDialogImpl {
+ public:
+  SelectFileDialogImplPortal(Listener* listener,
+                             std::unique_ptr<ui::SelectFilePolicy> policy);
+
+  static bool IsPortalAvailable();
+  static void DestroyPortalConnection();
+
+ protected:
+  ~SelectFileDialogImplPortal() override;
+
+  // BaseShellDialog implementation:
+  bool IsRunning(gfx::NativeWindow parent_window) const override;
+
+  // SelectFileDialog implementation.
+  // |params| is user data we pass back via the Listener interface.
+  void SelectFileImpl(Type type,
+                      const base::string16& title,
+                      const base::FilePath& default_path,
+                      const FileTypeInfo* file_types,
+                      int file_type_index,
+                      const base::FilePath::StringType& default_extension,
+                      gfx::NativeWindow owning_window,
+                      void* params) override;
+
+  bool HasMultipleFileTypeChoicesImpl() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(SelectFileDialogImplPortal);
+
+  struct PortalFilter {
+    std::string name;
+    std::set<std::string> patterns;
+  };
+
+  struct PortalFilterSet {
+    std::vector<PortalFilter> filters;
+    base::Optional<PortalFilter> default_filter;
+  };
+
+  struct CallInfo {
+    dbus::ObjectProxy* handle = nullptr;
+    base::Optional<gfx::AcceleratedWidget> parent;
+    Type type;
+    scoped_refptr<base::SequencedTaskRunner> listener_task_runner;
+    void* params = nullptr;
+  };
+
+  class AutoCancel {
+   public:
+    AutoCancel(SelectFileDialogImplPortal* portal, CallInfo* info);
+    ~AutoCancel();
+
+    void Release();
+
+   private:
+    SelectFileDialogImplPortal* portal_;
+    std::unique_ptr<CallInfo> info_;
+  };
+
+  PortalFilterSet BuildFilterSet();
+
+  static dbus::Bus* AcquireBusOnTaskRunner();
+
+  static void IsPortalAvailableOnTaskRunner(bool* out_available,
+                                            base::WaitableEvent* event);
+
+  static bool IsPortalRunningOnTaskRunner(dbus::ObjectProxy* dbus_proxy);
+  static bool IsPortalActivatableOnTaskRunner(dbus::ObjectProxy* dbus_proxy);
+
+  void SelectFileImplOnTaskRunner(CallInfo* info,
+                                  base::string16 title,
+                                  base::FilePath default_path,
+                                  PortalFilterSet filter_set,
+                                  base::FilePath::StringType default_extension);
+
+  void AppendStringOption(dbus::MessageWriter* writer,
+                          const std::string& name,
+                          const std::string& value);
+  void AppendByteStringOption(dbus::MessageWriter* writer,
+                              const std::string& name,
+                              const std::string& value);
+  void AppendBoolOption(dbus::MessageWriter* writer,
+                        const std::string& name,
+                        bool value);
+
+  void AppendFiltersOption(dbus::MessageWriter* writer,
+                           const std::vector<PortalFilter>& filters);
+  void AppendFilterStruct(dbus::MessageWriter* writer,
+                          const PortalFilter& filter);
+
+  void ConnectToHandle(CallInfo* info);
+  void DetachAndUnparent(CallInfo* info);
+
+  void OnCallResponse(dbus::Bus* bus,
+                      CallInfo* info,
+                      dbus::Response* response,
+                      dbus::ErrorResponse* error_response);
+
+  void OnResponseSignalEmitted(CallInfo* info, dbus::Signal* signal);
+
+  void OnResponseSignalConnected(CallInfo* info,
+                                 const std::string& interface,
+                                 const std::string& signal,
+                                 bool connected);
+
+  mutable base::Lock parents_lock_;
+  std::set<gfx::AcceleratedWidget> parents_;
+
+  static int handle_token_counter_;
+};
+
+}  // namespace gtk
+
+#endif  // UI_GTK_SELECT_FILE_DIALOG_IMPL_PORTAL_H_
-- 
2.26.2

